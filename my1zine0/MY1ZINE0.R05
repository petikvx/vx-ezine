                            (моя первая е-зина) BKNY0NNX // SBVC (c) 27.10.2001
-------------------------------------------------------------------------------

		Создание демок
		~~~~~~~~~~~~~~
 Хехе :) Вы решили написать демку. Хорошее желание :)
 Начнём с начала. Для того, чтобы написать крутую демку, надо знать, как делать
эффекты, из которых, как из кубиков, будут создаваться всё новые и новые демки.
Я буду рассматривать только видео-эффекты. Видео-эффекты - это преобразование
изображений по каким-либо математическим формулам.
 Один из простейших эффектов - это БЛЮР(BLUR). Блюр - это размывание растра
(изображения). В БЛЮРЕ ТОЧКА РАСТРА ЕСТЬ СРЕДНЕЕ АРИФМЕТИЧЕСКОЕ ЦВЕТОВ СОСЕДНИХ
К НЕЙ ТОЧЕК. Т.Е. РИСУЕТЕ КАРТИНКУ И ДЛЯ КАЖДОЙ ТОЧКИ СЧИТАЕТЕ СРЕДНЕЕ
АРИФМЕТИЧЕСКОЕ ЦВЕТОВ СОСЕДНИХ К НЕЙ ТОЧЕК.
 И тут-то начинается САМОЕ интересное :) Ну нарисовали вы картину (Малевича :))
и принялись считать ср.арифм. ... Тут одни начнут писать получаемые точки в
дополнительный буфер, а другие - прямо в растр. В первом случае изменения растра
блюру параллельны - он их не видит, т.к. не меняет исходный растр. Во втором
случае растр изменяется сразу же, и алгоритм очень даже видит и использует
изменения. Первый случай - это КЛАССИЧЕСКИЙ (TRUE) БЛЮР, у него есть один
недостаток - появление "решётки". У второго, ИЗМЕНЁННОГО БЛЮРА, этого недостатка
нет, и изображение размывается "мягко".
 А по скольки точкам вы считаете ср.арифм. ?! По четырём вы получите Евклида с
его треугольниками, квадратами, по восьми - Гефеста с его лавой :) Чем больше
точек вы используете для ср.арифм., тем более "мягкое" изображение вы получите.
 Чуть не забыл - полученное ср.арифм. можно изменять - прибавлять к нему
что-либо, вычитать, умножать, делить, изменять по математическим законам ...
Ограничения - ваша фантазия и коэффициент интеллекта :)

 Надеюсь, вы поняли теорию. А теперь практика - кодинг.
 Кодить будем в 0x13 режиме --- 320 * 200 * 8 bits
 Да, я не использую BGI - слишком медленно. Кроме того, для ускорения показа
растра и чтобы не мучать зрителя показом нутрей изменения растра, все изменения
проходят в виртуальном экране(обычный массив), а затем данные из него копируются
напрямую в видеопамять(для нас - тоже обычный массив). Но из-за того, что это
массивы, в координате точки первой идёт Y, а затем - X.
 Использование виртуального экрана называется "DoubleBuffering".
 Кроме того, я использую ассемблерные вставки(между ASM и END), не понимаете -
ничего страшного, скоро поймёте.

=====[CUT HERE]=====
(* Начало исходника. *)
Program Blur1;
(* Описание констант. MaxX - это максимальное разрешение растра по горизонтали,
а MaxY - по вертикали. FlameConst - та самая прибавляемая величина. *)
Const
	MaxX		=	320;
	MaxY		=	200;
	FlameConst	=	1;

(* Описание переменных. *)
Var
	(* S - это область памяти видеоадаптера *)
	S		: Array [1..MaxY, 1..MaxX] of Byte Absolute $A000:0000;
	(* VS - это Виртуальный Экран [ВЭ], используется для ускорения работы *)
	VS		: Array [1..MaxY, 1..MaxX] of Byte;
	(* Переменные-счетчики циклов *)
	x, y		: Integer;

(* Процедура проверки нажатия клавиши. Аналог содержащейся в модуле CRT,
но я её написал, чтобы не подключать этот модуль. *)
Function KeyPressed : Boolean;
Var	rFlags	: Boolean;
Label	_Ok, _End;
begin
	asm
		mov	ah, 1
		int	16h
		jz	_Ok
		mov	rFlags, True
		jmp	_End
	_Ok:	mov	rFlags, False
	_End:
	end;
	KeyPressed := rFlags;
end;

(* Начало основной проги *)
BEGIN
	(* Инициализируем генератор случайных чисел *)
	Randomize;

	(* Переключаем монитор в 0x13-ый режим *)
	asm
		mov	ax, 13h
		int	10h
	end;

	(* Заполнаем ВЭ случайными цветами *)
	for x := 1 to MaxX do for y := 1 to MaxY do
		VS[y,x] := Random(255);

	(* Повторяем цикл ... *)
	Repeat

		(* Проходим все ДОПУСТИМЫЕ для изменения точки. Поэтому такие
		начальные и конечные значения счетчиков *)
		for y := 2 to MaxY-1 do for x := 2 to MaxX-1 do

			(* Самый важный момент - БЛЮР. Так просто, но ... *)
			VS[y,x] := (VS[y-1,x-1] + VS[y-1,x-0] + VS[y-1,x+1] +
				VS[y-0,x-1] + VS[y-0,x+1] +
				VS[y+1,x-1] + VS[y+1,x-0] + VS[y+1,x+1])
					div 8 + FlameConst;

		(* Выше мы, для ускорения работы, работали с ВЭ, а теперь из
		него копируем растр в видеопамять *)
		for y := 1 to MaxY do for x := 1 to MaxX do S[y,x] := VS[y,x];

	(* Повторяем цикл, пока не нажмут клавишу *)
	Until KeyPressed;

	(* Переключаем монитор в текстовой режим *)
	asm
		mov	ax, 3
		int	10h
	end;

	(* Отваливаем! *)
END.
=====[END CUT]======

					Желаю успеха!
