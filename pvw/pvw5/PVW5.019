ฤฤฤฤฤฤฤ[PVW5.019]ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
Written for the : Pinoy Virus Writers E-Zine #5

                                % % % % %

                               - = %|% = -

 ษอออ  Tutorials!!!  ออออออออออออออออออออออออออออออออออออออออออป
 ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ

Polymorphism in C++

        Polymorphism has always been a good anti-heuristic technique. It gives
confusion to such AV scanners in scanning of signatures. But polymorphism was
always written Assembly language like SMEG & Mte. I made this tutorial in
discussing polymorphism in C++ language. The discussion is not based on the
polymorphism of virus but this tutorial just speaks of polymorphism which can
be applied to viruses. Readers must already have knowledge on C++.
       Polymorphism describes the capability of C++ code of behaving differently
on runtime situations. This behavior is often beyond the direct control of the
programmer, who must rely on C++ objects to keep track of themselves. In real
programs, the possible ways in which objects can interact with one another is
combinatorial, reaching astronomical numbers with even small class hierarchies.
        Polymorphism is not as much a characteristic of objects as it is a
characteristic of member functions for a class. Polymorphism is implemented
through the class architecture; however, only the member functions of the class
can be polymorphic, rather than the entire class.

******************************************************************************
Early And Late Binding

        In C++, a polymorphic function can be associated with one of many
possible functions only when an actual object is passed to the polymorphic
function. In C++, a function call is only indicated in the source code, without
specifying the exact function to call. This is known as late binding. In most
traditional programming languages, such as C and Pascal, the compiler calls
fixed function identifiers, based on the source code. The linker then takes
these identifiers and replaces them with a physical address. This process is
known as early binding, because function identifiers area associated with
physical addresses before runtime, during the process of compilation and
linkage.
        The problem with early binding is that the programmer must predict
what objects will be used in all function calls in every situation. This is
not only limiting but it's sometimes impossible. Moving the binding process
further downstream forces the runtime code to sort out the binding of
identifiers and addresses. The best thing about early binding is that it's fast.
The only runtime overhead incurred is in passing arguments, performing function
call, and cleaning up the stack. Early binding is tremendously limiting.
        The problem with late binding is obviously its runtime efficiency. The
code itself must deduce at runtime which function to invoke, and then invoke
it. Exclusive use of late bonding results in an extremely powerful language,
but one suffers from certain speed penalties.

******************************************************************************
Virtual Functions

        In C++, you specify late binding for a function declaring it virtual.
Declaring a function virtual for a class that is not used as a base class is
syntactically correct, but results in unnecessary runtime overhead.
                        __________________________
                       |                          |
                       | A                        |
                       | public:                  |
                       |  virtual void Display(); |
                       |__________________________|
                                    |
                        ____________|_____________
                       |                          |
                       | B                        |
                       | public:                  |
                       |  virtual void Display(); |
                       |__________________________|


                   Virtual Functions in a simple hierarchy.

#include <stdio.h>

class A {
public:
      virtual void Display() {puts("\nClass A");}
};

class B: public A {
      virtual void Display() {puts("\nClass B");}
};

void Show(A* a)
{
     a->Display();       // find out at runtime which function to use
}

void main()
{
     A* a = new A;
     B* b = new B;
     a->Display();       // Use A::Display()
     b->Display();       // Use B::Display()
     Show(a);            // Use A::Display()
     Show(b);            // Use B::Display()
}

        The polymorphic behavior of the member function Display() in classes A
and B is not obvious when you look solely at function main(). The polymorphic
behavior does show up in function Show(), in which it is impossible to predict
solely examining its source code - whetehr A::Display() or B::Display() will be
invoked. 


void main()
{
     // behavior with non-virtual functions

     Show(a);            // Use A::Display()
     Show(b);            // Use B::Display()
}

        The second function causes A::Display() to be called because the
argument B* is converted to A*, and then passed to the function Show(A*). The
call a->Display() is bound early to the function A::Display(), resulting in
the fixed behavior.
        Declaring a function virtual doesn't mean that it is overridden in a
derived class, merely that it can be. To propagate the polymorphic behavior
of a function down an inheritance tree, each derived class must declare the
same function to be virtual.

******************************************************************************
Function Overriding

        Function B::Display() is said to virtually overrode function A::Display().
A function declared in a derived class overrides a virtual base class function
only if it has the same name and uses the same number and type of arguments as
the virtual base class function. If even one argument is different, it is
considered an enttirely new function, and no overriding occurs.

                     ___________________________________
                    |                                   |
                    | A                                 |
                    | public:                           |
                    |  virtual void Print(int, int);    |
                    |___________________________________|
                                   |
                     ______________|____________________
                    |                                   |
                    | B                                 |
                    | public:                           |
                    |  virtual void Print(int, double); |
                    |___________________________________|

                  A class hierarchy containing no overriding

#include <stdio.h>

class A {
public:
      virtual void Print(int, int);

};

class B: public A {
public:
      virtual void Print(int, double);
};

void A::Print(int a, int b)
{
      printf("\na = %d, b = %d", a, b);
}

void B::Print(int a, double d)
{
      printf("\na = %d, d = %lf", a ,d);
}

void Show(A* a)
{
      a->Print(3, 5);    // always invoke A::Print(int, int)
}
void main()
{
      A* a = new A;
      B* b = new B;
      Show(a);           // use A::Print(int, int)
      Show(b);           // use A::Print(int, int)
}

        The function Show(A*) always invokes the same function, because the
function B::Print(int, double) is declared differently from A::Print(int, int),
thus the former doesn't override the latter. A function in a derived class does
not have to be declared virtual to override a virtual base class function.
Declaring a function virtual allows it to be overridden in subsequent derived
classes, but doesn't guarantee that this will occur.

******************************************************************************
Null Virtual Functions

        A derived class doesn't necessarily have to implement a function that
is declared virtual in a base class. However, if a virtual function is to be
accessible in a derived class through the virtual mechanism, a path of virtual
functions has to lead from the base class down to the derived class. All
intermediate classes that have no se for that virtual function are still
required to declare it for the benefit of the derived class. Defining a null
virtual function serves this purpose.

#include <stdio.h>

class A {
public:
      virtual void printOn() {puts("\nClass A");}
};

class B: public A {
public:
      virtual void printOn() {}
};

class C: public B {
public:
      virtual void printOn() {puts("\nClass C");}
};

void Show(A* a)
{
      a->printOn();
}

void main()
{
      A* a = new A;
      B* b = new B;
      C* c = new C;
      Show(a);           // use A::printOn()
      Show(b);           // do nothing
      Show(c);           // use C::printOn()
}


                        __________________________
                       |                          |
                       | A                        |
                       | public:                  |
                       |  virtual void printOn(); |
                       |__________________________|
                                    |
                        ____________|_____________
                       |                          |
                       | B                        |
                       | public:                  |
                       |  virtual void printOn(); |
                       |__________________________|
                                    |
                        ____________|_____________
                       |                          |
                       | C                        |
                       | public:                  |
                       |  virtual void printOn(); |
                       |__________________________|


    The use of a null virtual function for the benefit of derived classes.

        The virtual function B::printOn() is declared null because class B
doesn't require such function. The reason is to allow classes derived from B
to use the virtual function interface of class A, allowing the function call
Show(c); to correctly access virtual function C::printOn() following the path
of virtual functions starting from an A type object.

******************************************************************************
Improved Interfaces for Classes

        Virtual Funcions are used with class hierarchies. Unless you arrange
classes in some kind of inheritance hierarhy, virtual functions don't really
make much sense. Often, you have many classes to which a conceptually similar
function can be applied. This implies that many classes have a virtual function
in common.


                              ___________
                             |           |
                             | A         |
                             |  Virus(); |
                             |___________|
                                   |
                  _________________|__________________
                  |                 |                 |
             _____|_____      _____|______      _____|_____
            |           |    |            |    |           |
            | B         |    | C          |    | D         |
            |  Virus(); |    |  Virus();  |    |  Virus(); |
            |___________|    |____________|    |___________|
                  |
             _____|_____
            |           |
            | E         |
            |  Virus(); |
            |___________|

            Multiple null virtual functions in a class hierarchy

        In the tree, not all the classes need a Virus() function. To access
function E::Virus() through a reference to class A, both classes A and B
must declare the function Virus() to be virtual. Because these classes
presumably don't have the need for such a function, the functions implemented
are null virtual functions. In practical class hierarchies, members at the top
tend to have mnay (possibly nothing but) null virtual functions, or even pure
virtual functions, for the sole purpose of providing a clean interface to
classes that are lower in the tree. 

******************************************************************************
Abstract Classes

        Classes appearing at or near the top of a hierarchy often have one or
more null virtual functions. These functions make for a consistent user interface
when dealing with the hierarchy. In turn, the consistent interface allows the
late binding process to be used extensively and relives the programmer from
keeping track of objects at runtime. Classes at the top have all the common
functions declared in them, allowing C++ polymorphism to distinguish individual
class functions through the virtual function mechanism.
        C++ makes it possible to restrict the use of such classes by declaring
them abstract. Attempts to instantiate an abstract class then trapped by the
compiler as an error. Before a class can be made abstract, it must have at
least one virtual function. To declare an abstract class, at least one of its
virtual functions must be declared tp be pure virtual, which requires the special
C++ notation

virtual void printOn() = 0;   // a pure virtual function

which is not be confused with the declaration of a null virtual function

virtual void pritnOn() {}     // a null virtual function

        The notation for declaring a pure virtual function is easier to remember
if you consider the assignment-to-zero notation to indicate that there is no
definition for the function. Although it is illegal to instantiate an abstract
class. This opens the door to the indirect manipulation of an abstract class,
which can lead to problems. Attempts to invoke a pure virtual functrion causes
a runtime error.

class A {
public:
      virtual void printOn() = 0;       // a pure virtual function
};

void main()
{
      A* a;
      a->printOn();                     // big trouble here...
}

                    Code invoking a pure virtual function

        The function call in main() is trapped by the system at runtime, producing
the error message

Abnormal program termination

        The message is rather generic, but other C++ compilers are even less
elegant in handling this kind of runtime error and can crash altogether.
        In effect, invoking a pure virtual function is an attempt to use an
uninitialized pointer to indirectly invoke a function. However, Borland C++
preinitializes the pointer, with a reference to a handler of its own, to print
the error message.
        Abstract classes are set up for the benefit of derived classes. This
suggests classes occur at or near the root of a hierarchy. There can be several
abstract classes in the same hierarchy.
                       _______________________________
                      |                               |
                      | A                             |
                      | public:                       |
                      |  virtual void printOn(); = 0; |
                      |_______________________________|
                                      |
                       _______________|_______________
                      |                               |
                      | B                             |
                      | public:                       |
                      |  virtual void printOn();      |
                      |_______________________________|
                                      |
                       _______________|_______________
                      |                               |
                      | C                             |
                      | public:                       |
                      |  virtual void printOn();      |
                      |_______________________________|

                 The use of an abstract class in a hierarchy.

#include <stdio.h>

class A {
public:
      virtual void printOn() = 0;        // a pure virtual function,
                                         // making class A abstract
};

class B: public A {
public:
      virtual void printOn() {puts("\nClass B");}
};

class C: public B {
public:
      virtual void printOn() {puts("\nClass C");}

void Show(A* a)
{
      a->printOn();
}

void main()
{
      B* b = new B;
      C* c = new C;
      Show(b);                           // use B::printOn()
      Show(c);                           // use C::printOn()
}

        Class A is used exclusively as rhe base for other classes. The function
::Show(A*) determines at runtime the function to be used, based on the type of
object passed to ::Show(A*).
        Deriving a class from an abstract class doesn't necessarily yield a
class that can be instantiated. If a class overrides any of the virtual functions
in its base class with new pure virtuals, the new class is also abstract. By the
way, C++ requires you to override all pure virtual functions in derived classes.
Failure to do so necessarily causes a compiler error, because if you were able to
not override a pure virtual function, the virtual mechanism would not be
propagated to further derived classes. If a class derived from an abstract one
is itself abstract, one or more of its virtual functions must be pure. This implies
that you can override a pure virtual with a new pure virtual.
        Failure to override a pure virtual function leads to compiler errors.

                       _______________________________
                      |                               |
                      | A                             |
                      | public:                       |
                      |  virtual void printOn(); = 0; |
                      |_______________________________|
                                      |
                       _______________|_______________
                      |                               |
                      | B                             |
                      | public:                       |
                      |  void g(int);                 |
                      |_______________________________|

A derived class that fails to override a pure virtual function of its base class.

        The tree shows a class B derived form A without the pure virtual function
A::f().

class A {
public:
      virtual void f() = 0;
};

class B: public A {
      // add a variable
      int value;
public:
      // add a member function
      void g(int i) {value = i;}
};

        If pure virtuals behaved like regular virtual functions, class B would
inherit A::f(), because B doesn't override A::f(). Assume a new class, called C,
is derived from B. If C declared a virtual function f(), this function would
not be accessible trough an A* or B* pointer, because the chain of virtual
functions is interrupted in class B. Invoking C::f() through an A* pointer
would cause the pure virtual function A::f() to be invoked, triggering a runtime
error. Pure virtual functions must be overridden in derived classes to avoid
this problem.

******************************************************************************
Limitations of virtual Functions

**Virtual friends

        The idea of a virtual function being a friend to another class may sound
a bit perplexing. A virtual friend is required to be a member function of some
class, because the virtual friend requires the use vptr and vtab to be invoked.
            __________________________
           |                          |
           | A                        |
           | public:                  |
           |  virtual void printOn(); |       
           |__________________________|
                        |                  ________________________
                        |                 |                        |
                        |                 | C                      |
                        |                 | friend A::printOn(C&); |
                        |                 | friend B::printOn(C&); |
                        |                 |________________________|
            ____________|_____________
           |                          |
           | B                        |
           | public:                  |
           |  virtual void printOn(); |
           |__________________________|

                         Virtual Functions as friends

#include <stdio.h>

class C;                        // introduce into scope

class A {
public:
      int a;
      A(int i) {a = i;}
      virtual void printOn(C&);
};

class B: public A {
public:
      int b;
      A(int i, int j) : A(i) {b = j;}
      virtual void printOn(C&);
};

class C {
      friend void A::printOn(C&);
      friend void B::printOn(C&);
      int a, b, c;
public:
      C(int i, int j, int k) {a =i; b = j; c = k;}
};

void A::printOn(C& t)
{
      printf("\nClass A member a = %d", a);
      printf("\nClass C member c = %d", t.c);
}

void B::printOn(C& t)
{
      printf("\nClass B member b = %d", b);
      printf("\nClass C member c = %d", t.c);
2}
1
void main()
{
      A a(10);
      B b(10, 20);
      C c(10, 20, 30);
      a.printOn(c);
      b.printOn(c);
}

        In effect, the friend relationship is a compile-time attribute, whereas
the virtual function mechanism is a runtime sequence. Although the same function
can be declared both virtual and friend, the two attributes trigger completely
processing by the compiler. In particular, the friend attribute causes absolutely
no runtime overhead.

**Virtual Operators

        Because operators are implemened as member functions or friend functions,
it is possible to declare virtual operators.

                        _________________________
                       |                         |
                       | A                       |
                       | public:                 |
                       |  virtual operator+(A&); |
                       |  virtual operator=(A&); |
                       |_________________________|
                                     |
                        _____________|___________
                       |                         |
                       | B                       |
                       | public:                 |
                       |  virtual operator+(A&); |
                       |  virtual operator=(A&); |
                       |_________________________|
                                     |
                        _____________|___________
                       |                         |
                       | C                       |
                       | public:                 |
                       |  virtual operator+(A&); |
                       |  virtual operator=(A&); |
                       |_________________________|
                                     
                  Virtual Operators in a class hierarchy.

class A {
public:
      int value_a;
      A(int i) {value_a = i;}
      virtual A& operator+(A&);
      virtual A& operator=(A&);
      virtual int a() {return value_a;}
      virtual int b() {return 0;};
      virtual int c() {return 0;};
};

class B: public A {
public:
      int value_b;    
      B(int i, int j) : A(i) {value_b = j;}
      virtual A& operator+(A&);
      virtual A& operator=(A&);
      virtual int b() {return value_b;}
};

class C: public B {
public:
      int value_c;
      C(int i, int j, int k) : B(i, j) {value_c = k;}
      virtual A& operator+(A&);
      virtual A& operator=(A&);
      virtual int c() {return value_c;}
};

A& A::operator+(A& t)
{
      value_a += t.a();
      return *this;
}

A& A::operator+(A& t)
{
      value_a += t.a();
      value_a += t.a();
}

A& B::operator+(A& t)
{
     value_a += t.a();
     value_b += t.b();
     return *this;
}

A& B::operator+(A& t)
{
     value_a += t.a();
     value_b += t.b();
     return *this;
}

A& C::operator+(A& t)
{
     value_a += t.a();
     value_b += t.b();
     value_c += t.c();
     return *this;
}

A& C::operator+(A& t)
{
     value_a += t.a();
     value_b += t.b();
     value_c += t.c();
     return *this;
}

void AddObjects(A& object1, A& object2)
{
     object1 = object1 + object2;
}

void main()
{
     A a(10);
     B b(10, 20);
     C c(10, 20, 30);

     AddObjects(a, b);
     AddObjects(b, c);
     AddObjects(c, b);

     a = b + c;
     c = c + a;
}

        The preceding code shows some interesting points. First, the overloaded
operators for all classes are declared to accept an argument of type A&. This is
necessary, even though the actual argument types might be derived from class A.
The virtual mechanism is utilized only when a virtual function in a derived class
has the same number and type of parameters as a virtual base class function. The
code in main() shows how you can pass object around as function arguments, applying
the polymorphic operators inside function AddObjects(A&, A&). An explicit use
of virtual operators is shown in the last two lines of main(). Of significance
is that by solely looking at the code in main(), you can't deduce that virtual
operators are used inside the classes.

**Virtual Constructors

        The current proposed C++ standard does not allow constructors to be virtual.
The limitation is dictated more by technical difficulties of implementation than
by conceptual difficulties. The problem is this: The invocation of a virtual
function requires vectoring through a vptr into the table of virtual pointers
vtab. Before an object is constructed in memory, however no such table exists.
The idea of virtual constructors is intriguing, but somebody needs to figure
out how to implement them in a reasonable manner.

**Virtual Destructors

        C++ allows you to declare a destructor virtual. Because a destructor
is invoked just before an object's memory is released, the vptr is still
available for use. Note that the storage for vtabs is not allocated to each
individual object, but once per class. Because no arguments can be declared for
destructors, it follows that there can only be one virtual destructor for a
class.

******************************************************************************
Scope Resolution Disables Polymorphism

        There is considerable freedom in calling a virtual function. A virtual
function can be invoked by practically any function that has proper access
privileges. A virtual function in a derived class is even allowed to invoke a
virtual function in its base class with the same name, without causing infinite
loops or crashing the system. To invoke a virtual function in the base class of
a derived class, you have to use the scope resolution operator to indicate
explicitly which base class to use. This operator tells the compiler that you
whish to bypass deliberately the virtual function mechanism.

******************************************************************************
Virtual Functions with Non-Virtual Functions

        Using virtuals and non-virtuals together in a class hierarchy might
cause confusion initially for the novice.

                            ____________________
                           |                    |
                           | A                  |
                           | public:            |
                           |  void f();         |
                           |  virtual void g(); |
                           |____________________|
                                       |
                            ___________|________
                           |                    |
                           | B                  |
                           | public:            |
                           |  void f();         |
                           |  virtual void g(); |
                           |____________________|

   A class hierarchy using both virtual and non-virtual functions together.


#include <stdio.h>

class A {
      int a;
public:
      void f()         {puts("Function A::f()");}
      virtual void g() {puts("Function A::g()");}
};

class B: public A {
      int b;
public:
      void f()         {puts("Function B::f()");}
      void g()         {puts("Function B::g()");}
};

void Do(A& a)
{
      a.f();
      a.g();
}

void main()
{
      A a;
      B b;

      Do(a);
      Do(b);
}

    The following output is attained:

    Function A::f()
    Function A::g()
    Function B::f()
    Function B::g()

******************************************************************************
Memory Layout of vptr and vtab Structures

        It is easier to understand how the compiler locates virtual functions
at runtime by considering the data structures involved and the memory lyout used
with class objects using virtual functions.
        Calling Do(A&) with a B object results in the functions A::f() and
B::g() being called. This happens in the function call

Do(b);

the B& reference is implitly converted to an A& reference. The compiler sees that
A::f() is not a virtual function, so code is generated to call A::f() directly.
The function call a.g() in Do(A&) is handled differently, because the compiler
sees that g() is declared virtual in class A. This provokes the generation of
code to use the virtual function mechanism.

                  ___________________
                 |          |        |
                 | variable | offset |
                 |__________|________|                _______
                 |          |        |               |       |
  a ---> A::     |     a    |    0   |  ---> A::vtab | &A::g |
                 |   vptr   |    2   |               |_______|
                 |__________|________|


                  ___________________
                 |          |        |
                 | variable | offset |
                 |__________|________|                _______
                 |          |        |               |       |
  b ---> A::     |     a    |    0   |  ---> B::vtab | &B::g |
                 |   vptr   |    2   |               |_______|
         B::     |     b    |    4   |
                 |__________|________|

                 Layout of two objects in memory.

        At runtime, the code vectors through class B's vptr to find which function
to call for g() and finds B::g(). The vptr of class B is stored in the same
offset as the vptr in class A, so Do(A&). Note, however, that the vprts for A
and B objects reference different vtab tables.

******************************************************************************
Virtual Functions Don't Have to be Overridden

        Declaring a function virtual forces the compiler to generate runtime
vectoring through a vptr pointer to invoke functions. The virtual keyword tells
the compiler that the function may be overridden in a base class.
        In the previous class hierarchy, class B was laid out in memory so that
class B included a complete A object in it. The vptr for the two classes was
different. In any case, class A was completely "oblivious" to the fact that it
was used as a base class for other classes. A virtual function does not have
to be overrridden in a derived class.In fact, a virtual function declared in a
class doesn't even have to be defined, in which case, it is a pure virtual
function. Of course, pure virtual functions can't be invoked directly, unless
you want to force a runtime error.
        The classes in commercial class libraries often have many of their
member functions declared virtual in order to allow users the option of overriding
them. This improves the flexibility of classes at the expense of runtime performance.

                            ____________________
                           |                    |
                           | A                  |
                           | public:            |
                           |  virtual void f(); |
                           |  virtual void g(); |
                           |  virtual void h(); |
                           |____________________|
                                      |
                            __________|_________
                           |                    |
                           | B                  |
                           | public:            |
                           |  virtual void f(); |
                           |  virtual void h(); |
                           |____________________|

A class hierarchy in which not all base class virtual functions are overridden.

#include <stdio.h>

class A {
      int a;

public:
      virtual void f() {puts("Function A::f()");}
      virtual void g() {puts("Function A::g()");}
      virtual void h() {puts("Function A::h()");}
};

class B: public A {
      int b;
public:
      virtual void f() {puts("Function B::f()");}
      virtual void h() {puts("Function B::h()");}
};

void Do(A& a)
{
      a.f();
      a.g();
      a.h();
}

void main()
{
      A a;
      B b;

      Do(a);
      Do(b);
}

        Class B does not override all its base class virtuals, which causes
the compiler to create an unusual vtab for class B to guarantee correctness in
polymorphic behavior.

                  ___________________
                 |          |        |
                 | variable | offset |
                 |__________|________|                _______
                 |          |        |               |       |
  a ---> A::     |     a    |    0   |  ---> A::vtab | &A::f |
                 |   vptr   |    2   |               | &A::g |
                 |__________|________|               | &A::h |
                                                     |_______|
                  ___________________
                 |          |        |
                 | variable | offset |
                 |__________|________|                _______
                 |          |        |               |       |
  b ---> A::     |     a    |    0   |  ---> B::vtab | &B::f |
                 |   vptr   |    2   |               | &B::g |
         B::     |     b    |    4   |               | &B::h |
                 |__________|________|               |_______|


    The vptr and vtab structures used with classes when not all base class
                   class virtual functions are overridden.

******************************************************************************
To Be or Not to Be Virtual

        You can declare any member function to be a virtual function, with the
following restrictions.

1. Constructors
2. Static member functions

        The two restrictions leave the door open to most of the functions in a
typical program, but the overhead associated with virtual functions makes it
advisable to use virtuals only when needed. Whether a polymorphic function is
needed is not always immediately obvious. For instance, you can immediately
rule out virtual functions in classes that aren't designed to be derived from.
Consider virtual functions at least in these cases:

1. In class designed to be at the top or near the top of a class hierarchy.
2. For functions that describe class attributes that depend on the structure
   or type of a class.
3. For functions that implement input or output for a class.
4. For functions that have actions defined only for specific classes.

******************************************************************************
Virtual Functions can also be Private

        The fact that a virtual function is normally used to create a consistent
and polymorphic interface to the class users doesn't mean tha the virtual function
has to be accessible to users. If you have a class in which a virtual function
is designed to be invoked exclusively form another member function, the virtual
function can be declared private.

                            ________________________
                           |                        |
                           | A                      |
                           | public:                |
                           |  virtual void print(); |
                           | public:                |
                           |  void f();             |
                           |  virtual void g();     |
                           |________________________|
                                       |
                            ___________|____________
                           |                        |
                           | B                      |
                           | private:               |
                           |  virtual void print(); |
                           | public:                |
                           |  void f();             |
                           |  virtual void g();     |
                           |________________________|

              A class hierarchy using private virtual functions.

#include <stdio.h>

class A {
      int a;
      virtual void print() {puts("Called via A::g()");}

public:
      void f()              {puts("Function A::f()");}
      virtual void g()      {print();}
};

class B: public A {
      int b;
      virtual void print() {puts("Called via B::g()");}

public:
      void f()              {puts("Function B::f()");}
      virtual void g()      {print();}
};

void Do(A& a)
{
      a.g();
}

void main()
{
      A a;
      B b;

      Do(a);
      Do(b);
}

        Both classes A and B have a private virtual called print(), which is not
meant to be called directly by class users. Although it is rather unusual,
nothing is wrong with declaring a virtual function private.

******************************************************************************
Polymorphism with Single Inheritance
 
        Single Inheritance carries no memory overhead in objects unless virtual
functions are used. Even so, the implementation of virtual functions with single
inheritance is straightforward. The best way to study the runtime characteristics
of a compiler is to look at the code generated.

                               _____ 
                              |     |  
                              |  A  |
                              |_____|
                                 |
                               __|__
                              |     |
                              |  B  |
                              |_____|
                                 |
                               __|__
                              |     |
                              |  C  |
                              |_____|
                                 |
                               __|__
                              |     |
                              |  D  |
                              |_____|


class A {
public:
      int v1, v2, v3, v4;
      void V1() {v1 = 1;}
      void V2() {v2 = 2;}
      void V3() {v3 = 3;}
      void V4() {v4 = 4;}

      virtual void VV1() {v1 = 1;}
      virtual void VV2() {v2 = 2;}
      virtual void VV3() {v3 = 3;}
      virtual void VV4() {v4 = 4;}

};

class B: public A {
public:
      int v1, v2, v3, v4;
      void V1() {v1 = 1;}
      void V2() {v2 = 2;}
      void V3() {v3 = 3;}
      void V4() {v4 = 4;}
      
      virtual void VV1() {v1 = 1;}
      virtual void VV2() {v2 = 2;}
      virtual void VV3() {v3 = 3;}
      virtual void VV4() {v4 = 4;}

};

class C: public B {
public:
      int v1, v2, v3, v4;
      void V1() {v1 = 1;}
      void V2() {v2 = 2;}
      void V3() {v3 = 3;}
      void V4() {v4 = 4;}

      virtual void VV1() {v1 = 1;}
      virtual void VV2() {v2 = 2;}
      virtual void VV3() {v3 = 3;}
      virtual void VV4() {v4 = 4;}

};

class D: public C {
public:
      int v1, v2, v3, v4;
      void V1() {v1 = 1;}
      void V2() {v2 = 2;}
      void V3() {v3 = 3;}
      void V4() {v4 = 4;}

      virtual void VV1() {v1 = 1;}
      virtual void VV2() {v2 = 2;}
      virtual void VV3() {v3 = 3;}
      virtual void VV4() {v4 = 4;}

};

void Show(A* a)
{
      a->v1 = 1;  
      a->v2 = 2;
      a->v3 = 3;
      a->v4 = 4;

      a->VV1();
      a->VV2();
      a->VV3();
      a->VV4();
}

A* a = new A;
B* a = new B;
C* a = new C;
D* a = new D;

void main()
{
      Show(a);
      Show(b);
      Show(c);
      Show(d);
}


        By studying the compiled code with Turbo Debugger, you can determine
the structure of each class and the invocation sequences for each function
call.
                           ___________________
                          |          |        |
                          | variable | offset |
                          |__________|________|
                          |          |        |
           a ---> A::     |    v1    |    0   |
                          |    v2    |    2   |
                          |    v3    |    4   |
                          |    v4    |    6   |
                          |   vptr   |    8   |
                          |__________|________|
                      
        The resulting memory layout for a class A object pointed at by a.

        Everythng looks pretty normal, except for the field called vptr at
offset 8. It is a pointer to a table of pointers through which the compiler
vectors the code at runtime when invoking a virtual function. The table of
pointers referenced by vptr is called the virtual function table, or vtab for
short.

                           __________________
                          |         |        |
                          | pointer | offset |
                          |_________|________|
                          |         |        |
           vptr ---> vtab | &A::VV1 |   0    |
                          | &A::VV2 |   2    |
                          | &A::VV3 |   4    |
                          | &A::VV4 |   6    |
                          |_________|________|

                     The vtab for object of class A.

        Any object of a class with virtual functions is allocated the necessary
extra storage for the vptr and the vtab. Calling a virtual function involves
using the offset of a virtual table pointer in vtab. This offset is added to
vtab at runtime to determine the address of the virtual function to call.
                  ___________________
                 |          |        |
                 | variable | offset |
                 |__________|________|
                 |          |        |
  b ---> A::     |    v1    |    0   |
                 |    v2    |    2   |             __________________
                 |    v3    |    4   |            |         |        |
                 |    v4    |    6   |            | pointer | offset |
                 |   vptr   |    8   |  ---> vtab |_________|________|
         B::     |    v1    |   10   |            |         |        |
                 |    v2    |   12   |            | &B::VV1 |   0    |
                 |    v3    |   14   |            | &B::VV2 |   2    |
                 |    v4    |   16   |            | &B::VV3 |   4    |
                 |__________|________|            | &B::VV4 |   6    |
                                                  |_________|________|

                 The memory layout of an object of class B.
                  ___________________
                 |          |        |
                 | variable | offset |
                 |__________|________|
                 |          |        |
  c ---> A::     |    v1    |    0   |
                 |    v2    |    2   |             __________________
                 |    v3    |    4   |            |         |        |
                 |    v4    |    6   |            | pointer | offset |
                 |   vptr   |    8   |  ---> vtab |_________|________|
         B::     |    v1    |   10   |            |         |        |
                 |    v2    |   12   |            | &C::VV1 |   0    |
                 |    v3    |   14   |            | &C::VV2 |   2    |
                 |    v4    |   16   |            | &C::VV3 |   4    |
         C::     |    v1    |   18   |            | &C::VV4 |   6    |
                 |    v2    |   20   |            |_________|________|
                 |    v3    |   22   |
                 |    v4    |   24   |
                 |__________|________|

                 The memory layout of an object of class C.
                  ___________________
                 |          |        |
                 | variable | offset |
                 |__________|________|
                 |          |        |
  d ---> A::     |    v1    |    0   |
                 |    v2    |    2   |             __________________
                 |    v3    |    4   |            |         |        |
                 |    v4    |    6   |            | pointer | offset |
                 |   vptr   |    8   |  ---> vtab |_________|________|
         B::     |    v1    |   10   |            |         |        |
                 |    v2    |   12   |            | &D::VV1 |   0    |
                 |    v3    |   14   |            | &D::VV2 |   2    |
                 |    v4    |   16   |            | &D::VV3 |   4    |
         C::     |    v1    |   18   |            | &D::VV4 |   6    |
                 |    v2    |   20   |            |_________|________|
                 |    v3    |   22   |
                 |    v4    |   24   |
         D::     |    v1    |   26   |
                 |    v2    |   28   |
                 |    v3    |   30   |
                 |    v4    |   32   |
                 |__________|________|

                 The memory layout of an object of class D.

        The vptr is always placed at the end of the variables of the first base
class. Each class has a vptr, but its value is different for each class. The
vptr references the vtab to use for each class. Thus, by changing only the vptr
different vtabs are accessible, and different virtual functions can be invoked.
        The vtab for a derived class is different from the vtab of its base
classes. This includes class D, which includes integral A, B, and C objects in
itself. If a D object is converted to an A objetc, the D object continues to
have a different vtab from A objects. Understand also that a class such as D,
which has three levels of base classes, still has only one vptr.

       The assembly language generated for the simple inheritance example.

Show:
        push    bp                      ;save old frame
        mov     bp,sp                   ;set up new frame
        push    si
        mov     si,word ptr [bp+4]      ;get this pointer for the object passed
     ;
     ;  {
        a->VV4();
     ;
        push    si                      ;push this pointer
        mov     bx,word ptr [si+8]      ;get vptr
        call    word ptr [bx+6]         ;call (vptr+6)
        pop     cx
     ;
     ;  }
     ;
        pop     si
        pop     bp
        ret

main:
        push    bp                      ;save old frame
        mov     bp,sp                   ;set up new frame
     ;
     ;{
        Show(a);
     ;
        push    word ptr DROUP:_a       ;push argument 'a'
        call    near ptr Show           ;invoke Show(A&)
        pop     cx                      ;clean up stack
     ;
        Show(d);
     ;
        push    word ptr DROUP:_d       ;push argument 'd'
        call    near ptr Show           ;invoke Show(A&)
        pop     cx                      ;clean up stack
     ;
     ;}
     ;
        pop     bp                      ;restore old frame
        ret

        The same functionShow(A&) invokes different functions when it passed
pointers to different objects, even though it is declared to accept an argument
of type A&. The difference in vptr for each class makes this possible.

******************************************************************************
Polymorphism with Multiple Inheritance

        Multiple Inheritance is obviously more involved than single inheritance.
Classes that have multiple base classes employing virtual functions utilize
multiple vptr pointers and vtab tables, so he mechanics of polymorphism are
similar to the single inheritance case.
                      _____               _____
                     |     |             |     |
                     |  A  |             |  C  |
                     |_____|             |_____|
                        |                   |
                      __|__               __|__
                     |     |             |     |
                     |  B  |             |  D  |
                     |_____|             |_____|
                        |                   |
                        |___________________|
                                  |
                                __|__
                               |     |
                               |  E  |
                               |_____|


class A {
public:
      int ab1, ab2;
      void AB1() {ab1 = 1;}
      void AB2() {ab2 = 2;}

      virtual void VAB1() {ab1 = 1;}
      virtual void VAB2() {ab2 = 2;}
};

class B: public A {
public:
      int ab1, ab2;
      void AB1() {ab1 = 1;}
      void AB2() {ab2 = 2;}

      virtual void VAB1() {ab1 = 1;}
      virtual void VAB2() {ab2 = 2;}
};

class C {
public:
      int cd1, cd2;
      void CD1() {cd1 = 1;}
      void CD2() {cd2 = 2;}

      virtual void VCD1() {cd1 = 1;}
      virtual void VCD2() {cd2 = 2;}
};

class D: public C {
public:
      int cd1, cd2;
      void CD1() {cd1 = 1;}
      void CD2() {cd2 = 2;}

      virtual void VCD1() {cd1 = 1;}
      virtual void VCD2() {cd2 = 2;}
};

class E: public B, public D {
public:
      int ab1, ab2, cd1, cd2;
      virtual void VAB1() {ab1 = 1;}
      virtual void VAB2() {ab2 = 2;}
      virtual void VCD1() {cd1 = 1;}
      virtual void VCD2() {cd1 = 1;}
};

void ABShow(A* a) {a->VAB2();}
void CDShow(C* c) {c->VCD2();}

B* b = new B;
D* d = new D;
E* e = new E;

void main()
{
      ABShow(e);
      CDShow(e);
}


        By using Turbo Debugger to look at the code that is generated, you can
see that the objects are laid out in memory.

                 ___________________
                |          |        |
                | variable | offset |
                |__________|________|
                |          |        |            ___________________
 b ---> A::     |   ab1    |    0   |           |          |        |
                |   ab2    |    2   |           | pointer  | offset |
                |   vptr   |    4   | ---> vtab |__________|________|
        B::     |   ab1    |    6   |           |          |        |
                |   ab2    |    8   |           | &B::VAB1 |    0   |
                |__________|________|           | &B::VAB2 |    2   |
                                                |__________|________|

                       The layout of objects of class B.


                 ___________________
                |          |        |
                | variable | offset |
                |__________|________|
                |          |        |            ___________________
 d ---> C::     |   cd1    |    0   |           |          |        |
                |   cd2    |    2   |           | pointer  | offset |
                |   vptr   |    4   | ---> vtab |__________|________|
        D::     |   cd1    |    6   |           |          |        |
                |   cd2    |    8   |           | &B::VCD1 |    0   |
                |__________|________|           | &B::VCD2 |    2   |
                                                |__________|________|

                       The layout of objects of class D.

                 ___________________
                |          |        |
                | variable | offset |
                |__________|________|
                |          |        |            ___________________
 e ---> A::     |   ab1    |    0   |           |          |        |
                |   ab2    |    2   |           | pointer  | offset |
                |   vptr   |    4   | ---> vtab |__________|________|
        B::     |   ab1    |    6   |           |          |        |
                |   ab2    |    8   |           | &B::VAB1 |    0   |
                |__________|________|           | &B::VAB2 |    2   |
                |          |        |           |__________|________|
        C::     |   cd1    |   10   |           |          |        |
                |   cd2    |   12   |           | pointer  | offset |
                |   vptr   |   14   | ---> vtab |__________|________|
        D::     |   cd1    |   16   |           |          |        |
                |   cd2    |   18   |           | &B::VCD1 |    0   |
                |__________|________|           | &B::VCD2 |    2   |
                                                |__________|________|

    The layout of objects of class E, derived using multiple inheritance.

        Objects of class B and D have their own vptrs. Class E contains two
vptrs. The allocation order of the subobjects inside E is determined by the
declaration order of the base classes in E. The preceding code shows two
essential parts in the polymorphic behavior of class E.

ABShow(e);
CDShow(e);

        In both cases, implicit conversions are performed. If the conversions
were made explicit, they would look like this:

ABShow( (A*) e);
CDShow( (C*) e);

        The first conversion is trivial, because the beginning of an E object
is an A object, so there is no change on the pointer e. The fact that an E
object passed uses the vptr field defined in the A subobject for virtual
function calls. The second conversion is more complicated. To convert a pointer
to E into a pointer to C, an offset must be added to the E pointer to get to
the C subobject.
        When a derived class has multiple base classes, it may also have multiple
vptrs. For each base class that uses virtual functions, there is one vptr, so a
class can have any number of virtual table pointers. Obviously all these vptrs
represent memory overhead in objects, but the good news is that the overhead is
under your direct control. If none of the base classes has virtual functions,
there is no overhead. The amount of overhead is a function of the complexity of
the inheritance tree and the use of virtual functions.

******************************************************************************
Inline Virtual Functions

        Inline function calls are replaced with straight code, it seems that
inline functions would not be declared virtusl. This is not the case. C++
compilers are designed to help simplify coding, which they do by being "smart".
Borland C++ is much more powerful than the earlier Turbo C, a fact that is evidenced
by its implementation of virtual functions. The compiler doesn't treat all
virtual function calls the same way, just as it doesn't treat all inline
declarations equally. The code generated depends on the most reasonable way to
handle each case.

class A {
      int a, b, c;

public:
      inline virtual int f() {return a;}
      inline virtual int g() {return b;}
      inline virtual int h() {return c;}
};

class B: public A {
      int a, b, c;

public:
      inline virtual int f() {return a;}
      inline virtual int h() {return c;}
};


A program using inline virtual functions.

void Do(A& a)
{
      a.f();
      a.g();
      a.h();
}

int i;
A a;
B b;

void main()
{
      i = a.f();
      i = a.g();
      i = a.h();

      i = b.f();
      i = b.g();
      i = b.h();
}

                 ___________________
                |          |        |
                | variable | offset |
                |__________|________|
                |          |        |            ___________________
 b ---> A::     |    a     |    0   |           |          |        |
                |    b     |    2   |           | pointer  | offset |
                |    c     |    4   | ---> vtab |__________|________|
                |   vptr   |    6   |           |          |        |
                |__________|________|           |   &A::f  |    0   |
                                                |   &A::g  |    2   |
                                                |   &A::h  |    4   |
                                                |__________|________|

                        Layout of class A objects.

                 ___________________
                |          |        |
                | variable | offset |
                |__________|________|
                |          |        |            ___________________
 b ---> A::     |    a     |    0   |           |          |        |
                |    b     |    2   |           | pointer  | offset |
                |    c     |    4   | ---> vtab |__________|________|
                |  vptr    |    6   |           |          |        |
        B::     |    a     |    8   |           |   &B::f  |    0   |
                |    b     |   10   |           |   &B::g  |    2   |
                |    c     |   12   |           |   &B::h  |    4   |
                |__________|________|           |__________|________|

                        Layout of class B objects.

       The assembly language generated when inline functions are used.

      ;
      ;   void Do(A& a)
      ;

Do:
        push    bp                      ;save old frame
        mov     bp,sp                   ;create new frame
        push    si
        mov     si,word ptr [bp+4]      ;get 'this' pointer of argument a

      ;
      ;  {
      ;    a.f();
      ;
        push    si
        mov     bx,word ptr [si+6]      ;get A::vptr
        call    word ptr [bx]           ;call f() virtual function of
                                        ;whatever object was passed
        pop     cx
      ;
      ;    a.g();
      ;
        push    si                      ;get A:: vptr
        mov     bx,word ptr [si+6]      ;get A::vptr
        call    word ptr [bx+2]         ;call g() virtual function of
                                        ;whatever object was passed
        pop     cx
      ;
      ;    a.g();
      ;
        push    si                      ;get A:: vptr
        mov     bx,word ptr [si+6]      ;get A::vptr
        call    word ptr [bx+4]         ;call h() virtual function of
                                        ;whatever object was passed
        pop     cx
      ;
      ;  }
      ;
        pop     si
        pop     bp                      ;restore old frame
        ret
      ;
      ;  void main()
      ;
_main:
        push    bp
        mov     bp,sp
      ;
      ;  {
      ;    i = a.f()_;
      ;
        mov     ax,word ptr _a          ;use inline code, rather than virtual
                                        ;function mechanism
        mov     word ptr _i,ax
      ;
      ;    i = a.g();
      ;
        mov     ax,word ptr _a+2        ;use inline code
        mov     word ptr _i,ax
      ;
      ;    i = a.h();
      ;
        mov     ax,offset _b            ;this time the inline
        push    ax                      ;code is ignored, and a
        mov     bx,word ptr _b+6        ;full fledged virtual
        call    word ptr [bx+2]         ;function call is used
        pop     cx
        mov     word ptr _i,ax
      ;
      ;    i = b.h();
      ;
        mov     ax,word ptr _b+12       ;use inline code
        mov     word ptr _i,ax
      ;
      ;
        pop     bp
        ret

        The compiler is smart enough to know whether it can replace an inline
function call with the inline code. This function calls in function Do(A&) use
an object reference, and thus, the compiler has no way of knowing whether the
function will be invoked later with a reference to an A object or a reference
to an object derived form A. This forces the compiler to use the complete
virtual function-calling mechanism throughout Do(A&). The function calls in
main() are different. Here the compiler knows the exact object types that are
used in various function calls and thus exploit inline coding. There is one
exception, though. The function call   i = b.g();    is handled as a regular
virtual, because the function invoked is A::g(). Although class B does in this
case, class B may not always know how class A accesses its virtual function
A::g(). In the preceding example, the compiler had the full declarations and
definitions for both classes A and B, so it could have used inline code even
for the b.g() function call.

******************************************************************************
Invoking Polymorphic Functions in a Base Class

        When you have a library of related classes, member functions in one
class frequently need to invoke functions higher in the inheritance tree.
The problem with directly invoking a base class function is that you normally
use scope resolution to identify at compile time which base class to use.
Scope resolution operator disables late binding, so you can't get a polymorphic
fucntion call this way. Things have to be done slightly differently to get the
desired result.

                      _______________
                     |               |
                     | A             |
                     |  virtual f(); |
                     |_______________|
                             |
                             | ---------------------------|
                      _______|_______              _______|_______
                     |               |            |               |
                     | B             |            | D             |
                     |  virtual f(); |            |  virtual f(); |
                     |_______________|            |_______________|
                             |
                             |
                      _______|_______
                     |               |
                     | C             |
                     |  virtual f(); |
                     |_______________|

     An inheritance tree in which a base class virtual function is used.

class A {
public:
      virtual void f() {}
      virtual void g() {f();}
};

class B: public A {
public:
      virtual void f() {}
      virtual void g() {A::f();}
};

class C: public B {
public:
      virtual void f() {}
      virtual void g() {A::f();}
};

void Show(A& a)
{
      // invoke f() for object passed, then f() for object's parent
      a.f();
      a.g();
}

void main()
{
      A a;
      B b;
      C c;
      D d;

      Show(a);
      Show(b);
      Show(c);
      Show(d);
}
        Show(A&) needs to invoke a function f() for the object referenced and
also the funcion f() in the object's parent. Essentially, what is needed is a
way to extend polymorphism in a derived object into the object's base class.
This is easily accomplished by adding a new virtual function g() to each class
in the hierarchy. Function g() is defined to polymorphically invoke f() in its
base class. Obviously, any other base class function could be called through
g(), including functions further up the inheritance tree.

******************************************************************************
Virtual Functions and Classification Hierarchies

      Consider another more complicated case: You have an extended hierarchy,
characterized by classification nodes at random locations along the tree.
These special classes are conceptually significant because they identify major
branches in the hierarchy. The problem is that not all classes are classification
nodes.

                                ______
                               |      |
                               | Chip |
                               |______|
                                  |
                    ______________|____________________
                   |                                   |
               ____|____                             __|__
              |         |                           |     |
              |  Memory |                           | CPU |
              |_________|                           |_____|
                   |                                   |
       ____________|_______________               _____|_____
      |            |               |              |           |
  ____|____     ___|____     ______|______      __|___      __|___
 |         |   |        |   |             |    |      |    |      |
 | Dynamic |   | Static |   | NonVolatile |    | RISC |    | CISC |
 |_________|   |________|   |_____________|    |______|    |______|

        The classes memory and CPU are major classifications for the tree.
Assume you need a function that takes a generic Chip& argument, invokes a polymorphic
function for it, and then prints the classes' major classification. This requires
you somehow to obtain a polymorphic behavior in a base class, departing from a
class that is unknown at compile time.

#include <stdio.h>

class Chip {
public:
      virtual void Classification();
      virtual void f() {}
};

class Memory: public Chip {
public:
      virtual void Classification();
      virtual void f() {}
};

class CPU: public Chip {
public:
      virtual void Classification();
      virtual void f() {}
};

void Chip::Classification() { puts("Unknown classification");}
void Memory::Classification() { puts("Memory chip");}
void CPU::Classification() { puts("CPU chip");}

class Static: public Memory {
public:
      virtual void f() {}
};

class NonVolatile: public Memory {
public:
      virtual void f() {}
};

class RISC: public CPU {
public:
      virtual void f() {}
};

class M41256: public Dynamic {
public:
      virtual void f() {}
};

class M6264: public Static {
public:
      virtual void f() {}
};

class M1230: public NonVolatile {
public:
      virtual void f() {}
};

class M88000: public RISC {
public:
      virtual void f() {}
};

class M68000: public CISC {
public:
      virtual void f() {}
};

void Use(Chip& chip)
{
      // invoke f() for the passed object type
      chip.f();

      // print object's classification type
      chip.Classification();
}

void main()
{
      M41256 hitachi;
      M88000 motorola;
      Memory device;
      Chip and_gate;
      CISC microprocessor;
      NonVolatile ram;

      Use(hitachi);
      Use(motorola);
      Use(device);
      Use(and_gate);
      Use(microprocessor);
      Use(ram);
}
        Invoking the function Classification() through the Chip& reference
compels the compiler to use a polymorphic function call, resulting in late
binding. From a different perspective, the virtual function mechanism causes
the code to search the inheritance tree for a function called Classification(),
starting at the class Chip. The Classification()function that is invoked is the
one that overrides all the others, that is, the one defined in the lowest class.
        The virtual table for class M41256, for example, is such that the
function Memory::Classification() is invoked. The correct classification function
would similarly be called for a class defined at any other arbitrary level in
the hierarchy. All the details are handled transparently by the compiler. In
fact, the lower levels in the hierarchy may not even be aware that a Classification()
function exists above them.

******************************************************************************
Invoking Virtual Functions in a Constructor

        The virtual function mechanism is normally used after an object has been
constructed.

class A {
public:
      A() {f();}
      virtual void f() {}
};

void main()
{
      A* a = new A;
}

        The constructor for class A invokes a virtual function. If you try to
compile the preceding code, you'll find that not only does it compile without
errors, but it also works.
        The reason it works is that the vptr and vtab structures are set up for
a class just before the body of the constructor executes. This allows you to
use virtual functions without problems inside the constructor. Things get a
little trickier, however when a constructor invokes a base class constructor,
which in turn, invokes a virtual function. This produces different results.

class A {
public:
      A() {f();}
      virtual void f() {}
};

class B: public A {
public:
      B() : A() {}
      virtual void f() {}
};

void main()
{
      B* b = new B;
}

        The constructor for class B invokes the base class constructor A::A(),
which in turn, invokes a virtual function. The constructor for B invokes the
constructor for class A just before setting up its own virtual mechanism. When
A::A() is called, it establishes its own virtual tables, so the call f() causes
the invocation of A::f(). After the A constructor is executed, the class B
virtual mechanism is put in place. If the virtual function f() were invoked
inside the body of B::B(), the function B::f() would be executed.

-ฤ---ฤฤ-ฤ---ฤฤ-ฤ---ฤฤ-ฤ---ฤฤ-ฤ---ฤฤ-ฤ---ฤฤ-ฤ---ฤฤ-ฤ---ฤฤ-ฤ---ฤฤ-ฤ---ฤฤ-ฤ--
(C) Pinoy Virus Writers 1999
l0rz@mailcity.com

