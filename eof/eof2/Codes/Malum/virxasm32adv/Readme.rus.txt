
 ======================================================================
 ====================[ LENGTH-DISASSEMBLER ENGINE ]====================
 ====================[ VIRXASM32 ]=========[ v1.5 ]====================
 ====================[ WRITTEN BY MALUM  12.02.07 ]====================
 ======================================================================

 История версии
 v1.0 - первый бета релиз
 v1.1 - исправлена ошибка при обработке расширеных опкодов, добавлены 9A и EA
 v1.2 - добавлена поддержка 67h
 v1.3 - добавлен MOV EAX,[OFF] (релиз через день после 1.2, скюзми :) )
 v1.4 - 67h префикс bugfixed, добавлен F1 опкод
 v1.5 - добавлен f6w /1 недок. опкод

 --------
 Описание
 --------
 VirXasm - маленький дизасм длин, предназначеный, главным образом, для использования во
 всякого рода живности, хотя в принципе можно задействовать его в любых задачах. Размер
 тулзы - 333 байт, так что вирус - даже самый маленький - он не обременит (надеюсь). Еще
 одна особенность - для VirXasm'а нет неверных опкодов. Имхо все дизасмы длин грешат
 неспособностью идентифицировать большинство ошибочных команд (а зачем находить какой-то
 ud2, если его все равно никто не использует).

 В пакете сосуществуют две версии дизасма. Первая - версия A с данными отдельно от кода,
 вторая - версия B (348 байт), где все данные запушиваются в стек, т.е. чистый код,
 способный пермутировать. Само собой обе версии базонезависимы и способны исполняться
 где угодно.

 Еще замечание по поводу мутации: структура кода VirXasm'a очень глубоко завязана на
 особенностях машинных команд, поэтому изменения типа dec->sub 1, loop->dec/jnz будут
 фатальными (это следствие экстремальной оптимизации). Значит according model идет
 лесом, а пермутация и мусор рулят :)

 -------------
 Использование
 -------------
 Для юзания в асме просто подключите файл virxasm32a.inc (или virxasm32b.inc) в месте,
 в котором вы хотите видеть код дизасма. При вызове передайте указатель на код в регистре
 esi, размер опкода вернется в eax (остальные регистры неизменны, DF будет равен нулю).
 Например:

  ...
  mov	esi, [ebx+code_start]
next_opcode:
  call	VirXasm32
  cmp	byte ptr [esi], 0e8h
  lea	esi, [esi+eax]
  jne	next_opcode
  call	random
  test	al, 1
  jz	next_opcode
  ...
  include inc\virxasm32b.inc
  ...

 Для HLL языков подготовлены три типа obj-файлов - coff (для Microsoft C++), omf (для
 Borland C++/Delphi) и elf (для gcc, но не тестировалось за неимением сейчас у меня
 оного). Код также имеет два варианта: A и B. Во всех обджах экспортируется одна функция
 VirXasm32, в C конвенции. Объявление этой функции находится в хидере inc\virxasm32.h.

unsigned long __cdecl VirXasm32 (const void *pCode);

 Пример:

#include <stdio.h>
#include "VirXasm32.h"
int main(void)
{
    unsigned long code,n,i;
    for (code=0x401000;code < 0x401a00;)  {
        printf("%08X:", code);
        n = VirXasm32((void*)code);
        for (i=0; i<n; i++)
               printf(" %02X", ((unsigned long) *((char*)code++))&0xff );
        printf("\n");
    }
    return 0;
}

 Для самых ленивых в комплект входит dll (в единственном экземпляре) с одной экспортируемой
 функцией VirXasm32 в C конвенции, а также либы для неё (три либы для разных компилеров).
 Для Delphi потребуется подключить unit UVirXasm32 из UVirXasm32.pas, а для C дополнительную
 директиву #pragma comment(lib, "virxasm32.lib")

 ------------------------
 Контакты и благодарности
 ------------------------
 Особая благодарность roy g biv за предложения и вылавливание всех моих глупых багов :)
 Спасибо также Вячеславу Патькову за предложение сделать таки VirXasm презентабельным,
 а то как то не сурьёзно :)

 Ну багов вроде нет, но всё же если найдете, то сообщите, пожалуйста.
 Если будут какие вопросы - пишите, обязательно постараюсь ответить.
 (X) Malum 12.02.07 - malum@mail.ru

; =======[
; ==========================[
; ===============================================[
