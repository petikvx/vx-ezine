 ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
                                 ÜÜÜ Ü Ü ÜÜÜ
                                  Û  ÛÜÛ ÛÜ
                                  Û  Û Û ÛÜÜ

               ²²²²²²  ²²²²²²        ²²²²²²  ²²  ²²      ²²²²²²
               ²²  ²²  ²²            ²²      ²²  ²²      ²²
               ²²²²²²  ²²²²    ²²²²  ²²²²    ²²  ²²      ²²²²
               ²²      ²²            ²²      ²²  ²²      ²²
               ²²      ²²²²²²        ²²      ²²  ²²²²²²  ²²²²²²

                           Ü   ÜÜÜ Ü Ü ÜÜÜ Ü Ü ÜÜÜ
                           Û   ÛÜÛ ÛÜÛ Û Û Û Û  Û
                           ÛÜÜ Û Û  Û  ÛÜÛ ÛÜÛ  Û

 ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

 ÄÄÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ a presentation by Lord Julus (C) 1999 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÄÄ


 ÍÍÍÍÍÍÍÍ
 Briefing
 ÍÍÍÍÍÍÍÍ

        There  are  several documents around the PE file layout, more or less
 documented,  more  or less well presented, but most of them tend to corectly
 cover  all  aspects sorounding this file type layout. However, and I do hope
 no  one  will  object,  I felt like taking my share of this stuff by writing
 down my own PE file description, viewed more from the pure ASM point of view
 (as  most  of the articles are built around the .h files from the WinSDK and
 tend  to look more on the C programming style). Therefore, read carefuly all
 the notes regarding my notations and get your hands on some x86 compiler and
 linker  to  use  with. Most of the stuff in here can be used easily by using
 the include files I set up and which can be also found in this issue.

        Also,  in order to check the things as you read and understand them a
 file  dump  utility  is  absolutely necessary. Here are some names you could
 use:

        TDUMP   - Borland's File dumper (TASM 5.0)
        DUMPPE  - VCommunications PE dumper (Sourcer 7.0)
        DUMPBIN - Microsoft File dumper (Microsoft SDK)
        INFO-PE - My own PE dumper
        PESPILL - My second PE dumper written in win32 ASM

        The  first  three  might  be  more complete than mine, but in my file
 dumper  my  main  idea  was to make things easily to understand, therefore I
 made  it  dump  the  file  in  a  special  ordered  form, giving you all the
 information possible.

        Also,  please  note that at the end of this document you will find an
 Annex  which  will  guide  you  in  exploring the PE file using the Assembly
 language.

 ÍÍÍÍÍÍÍÍÍÍÍÍ
 Bibliography
 ÍÍÍÍÍÍÍÍÍÍÍÍ

        To  write  this  article  I  compiled  information gathered from many
 documents and I wish to thank all of the authors of those articles for their
 research and explanations:

        Kath Randy
        Matt Pietrek
        Michael J. O'Leary
        Luevelsmeyer

        Also, I would like to send a special greeting to a friend that helped
 me  purge   the  fog  off  some  structures and values in the PE file: Jacky
 Qwerty/29A.


 ÍÍÍÍÍÍÍÍÍÍÍ
 First notes
 ÍÍÍÍÍÍÍÍÍÍÍ

        PE  stands for "Portable Executable", and represents the new encoding
 for  the  executable  files  introduced  by Microsoft in the win32 platform.
 Meaning  that  the  PE  file  can run on Windows95/98, WindowsNT, as well as
 Win32s. The Portable Executable layout is inspired from the COFF file layout
 used  in  some  UNIX  platforms. As complicated as the PE layout looks like,
 actually  it is not complicated at all, it contains lots of useless data, as
 well  as some redundant data. Understanding the basic concepts will help you
 understand  basically  anything in the PE layout. The PE file follows the NE
 ("New Executable") file format used in the Windows 3.xx.

        The  PE  files  we  will  talk  about  in  this  document  are the PE
 executable files (extension .EXE, usually). But, you should know that a very
 important part of the PE files are also the dinamic link libraries, the .DLL
 files which share the same layout. The OBJ files (output of the compiler and
 input  for  the  linker) have also the same format in the win32 environment,
 but  they have some more information in the headers than the PE executables.
 Anyway, we will stop at the PE executable files, but some refferences may be
 done to the DLLs as well.

        In  order to get all this let me tell you what happens when a PE file
 gets  loaded  by  the  system. First, a virtual memory area is created going
 from  00000000h  up to 0FFFFFFFFh. The file is loaded into this memory area,
 actually  mapped, starting from an address until that address plus filesize,
 with  some  alignments, of course. The address where the PE file gets loaded
 is called the imagebase of the file (or base of image).

        Two  very  important  notions you need to be aware of are the virtual
 address and the relative virtual address. The formula we have is this:

        imagebase + Relative Virtual Address = Virtual Address

 or     imagebase + RVA = VA

        So,  the  relative  virtual address tells you where in memory you can
 find  a  certain data, but only adding the imagebase to it, you can actually
 have   the   real  address.  This was done in this way because even if a DLL
 file  has  a certain imagebase inside its PE header (as we will see), due to
 address  clashes (different DLLs trying to load at the same imagebase), some
 DLLs  are forced to be loaded at other free imagebases. In this way, the RVA
 simply  needs  to be added the new imagebase and all addresses are correctly
 calculated  and  all  pointers  point  to  the  right data. You will see how
 important it is to know exactly the difference between the RVA and the VA.

        Another  important  thing is that Win32 is running in protected mode.
 This means that all memory is expressed in pages, and therefore a lot of the
 information must be aligned to page boundaries as we shall see as follows.


 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Basic structure
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

        The  basic structure of the PE file is bulit around headers and data.
 There  exist a number of well defined headers one after another and a set of
 data  that  you  can  access  using  the  information  you gathered from the
 headers.

        Basically, the PE file looks like this:

       ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
       ³    Old MS-DOS header      ³
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    MS-DOS stub            ³
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    PE header              ³
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    PE Optional Header     ³
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    PE Data Directory      ³
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    Section header #1      ³
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    Section header #2      ³
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    Section header #3      ³
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       |    ...                    |
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    Section header #n      ³
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    Section body #1        ³
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    Section body #2        ³
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    Section body #3        ³
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       |    ...                    |
       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    Section body #n        ³
       ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


        So,  you see how easy is the layout. Firstly the headers and then the
 real data. Let us look each part in depth.


 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Old MS-DOS header
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

        The  Old  MS-DOS  header  looks,  as  it speaks, exactly like the old
 ms-dos  header.  The  only new adding is the PE header offset and the MS-DOS
 stub. So, the MS-DOS header is:

 IMAGE_DOS_HEADER STRUC            ; DOS .EXE header
     MZ_magic      DW ?            ; Magic number ('MZ')
     MZ_cblp       DW ?            ; Bytes on last page of file
     MZ_cp         DW ?            ; Pages in file
     MZ_crlc       DW ?            ; Relocations
     MZ_cparhdr    DW ?            ; Size of header in paragraphs
     MZ_minalloc   DW ?            ; Minimum extra paragraphs needed
     MZ_maxalloc   DW ?            ; Maximum extra paragraphs needed
     MZ_ss         DW ?            ; Initial (relative) SS value
     MZ_sp         DW ?            ; Initial SP value
     MZ_csum       DW ?            ; Checksum
     MZ_ip         DW ?            ; Initial IP value
     MZ_cs         DW ?            ; Initial (relative) CS value
     MZ_lfarlc     DW ?            ; File address of relocation table
     MZ_ovno       DW ?            ; Overlay number
     MZ_res        DW 4 DUP(?)     ; Reserved words
     MZ_oemid      DW ?            ; OEM identifier (for MZ_oeminfo)
     MZ_oeminfo    DW ?            ; OEM information; MZ_oemid specific
     MZ_res2       DW 10 DUP(?)    ; Reserved words
     MZ_lfanew     DD ?            ; File address of new exe header
 IMAGE_DOS_HEADER ENDS             ;

        The  MZ_lfanew  value is actually an offset from the beginning of the
 file which points to the next header, the PE header. Note that this value is
 a  RVA  and if you are looking inside the memory, you must add the imagebase
 to  it!  Look  at the Annex for examples. The usual values for the PE header
 offset   are   80h and 100h. It looks like the dword at MZ_lfarcl has always
 the  value 40h if the MS-DOS header is followed by a PE Header. For now, I'd
 say  that  besides the specific checks in the PE header itself, checking for
 the  dword  40h  in  the place of the address of the relocation table in the
 MS-DOS  header  is  a  safe thing to do. I guess this is a remanent from the
 NewExe header description.


 ÍÍÍÍÍÍÍÍÍÍÍ
 MS-DOS stub
 ÍÍÍÍÍÍÍÍÍÍÍ

        The  MS-DOS  stub is actually a small piece of code which is there to
 run  if  the  PE file is started under a non-win32 environment. Usually this
 stub  file  prints  a  string  on  the  screen,  like:  "This  file requires
 MS-Windows"  or  "This  file cannot run in MS-DOS mode", then quits. In this
 way  the  PE  files notify themselves as win32 only. The content of the stub
 can easily be customized using the linker's specific command line options or
 setup files.


 ÍÍÍÍÍÍÍÍÍ
 PE header
 ÍÍÍÍÍÍÍÍÍ

        The  PE  header  is  the  first  part  with useful information on the
 contents of the PE file.

 IMAGE_FILE_HEADER STRUC            ; Portable Exe File
     PE_Magic                 DD ?  ; PE signature
     Machine                  DW ?  ; Machine type
     NumberOfSections         DW ?  ; Number of sections
     TimeDateStamp            DD ?  ; Date and Time
     PointerToSymbolTable     DD ?  ; Pointer to Symbols
     NumberOfSymbols          DD ?  ; Number of Symbols
     SizeOfOptionalHeader     DW ?  ; Size of Optional Header
     Characteristics          DW ?  ; File characteristics
 IMAGE_FILE_HEADER ENDS             ;

 IMAGE_FILE_HEADER_SIZE       = SIZEOF IMAGE_FILE_HEADER

 The length given by this equate is actually 20.

 ş PE_Magic
 ßßßßßßßßßß
        This  is  the signature of the PE file and always equals "PE",0,0. In
 hexadecimal this is 00004550h.

 ş Machine
 ßßßßßßßßß
        This  tells  us  on what machine type the PE file can be executed on.
 The known values are as follows:

 IMAGE_FILE_MACHINE_UNKNOWN    = 0      ; unknown
 IMAGE_FILE_MACHINE_I386       = 014ch  ; Intel 386.
 IMAGE_FILE_MACHINE_R3000      = 0162h  ; MIPS little-endian, 160 big-endian
 IMAGE_FILE_MACHINE_R4000      = 0166h  ; MIPS little-endian
 IMAGE_FILE_MACHINE_R10000     = 0168h  ; MIPS little-endian
 IMAGE_FILE_MACHINE_WCEMIPSV2  = 0169h  ; MIPS little-endian WCE v2
 IMAGE_FILE_MACHINE_ALPHA      = 0184h  ; Alpha_AXP
 IMAGE_FILE_MACHINE_POWERPC    = 01F0h  ; IBM PowerPC Little-Endian
 IMAGE_FILE_MACHINE_SH3        = 01a2h  ; SH3 little-endian
 IMAGE_FILE_MACHINE_SH3E       = 01a4h  ; SH3E little-endian
 IMAGE_FILE_MACHINE_SH4        = 01a6h  ; SH4 little-endian
 IMAGE_FILE_MACHINE_ARM        = 01c0h  ; ARM Little-Endian
 IMAGE_FILE_MACHINE_THUMB      = 01c2h  ;
 IMAGE_FILE_MACHINE_IA64       = 0200h  ; Intel 64
 IMAGE_FILE_MACHINE_MIPS16     = 0266h  ; MIPS
 IMAGE_FILE_MACHINE_MIPSFPU    = 0366h  ; MIPS
 IMAGE_FILE_MACHINE_MIPSFPU16  = 0466h  ; MIPS
 IMAGE_FILE_MACHINE_ALPHA64    = 0284h  ; ALPHA64
 IMAGE_FILE_MACHINE_AXP64      = IMAGE_FILE_MACHINE_ALPHA64


 ş NumberOfSections
 ßßßßßßßßßßßßßßßßßß
        This  is  the  value  which  gives  us the number 'n' from the scheme
 above,  and  which  tells  how  many sections there exist in the file, right
 after the PE headers.

 ş TimeDateStamp
 ßßßßßßßßßßßßßßß
        The  time that the file was output. There are various opinions on the
 actual value of this field, but it seems to hold the number of seconds since
 December  31st,  1969,  at 4:00 P.M. It was made this way in order to have a
 unique  value  for  each version of the linked file. Even if it looks like a
 little  space to hold such a big ammount, think of it, 30 years from 1969 it
 would  mean a value of 60*60*24*365*30=946.080.000d meaning 38640900h, which
 means that in another 30 years the value will reach 70C81200h. Anyway, until
 then  we shall use teleportation and mind communication so the PE time stamp
 will not be taken seriously anymore ;-P

 ş PointerToSymbolTable
 ßßßßßßßßßßßßßßßßßßßßßß
        This  is  a pointer to the COFF symbol table. It gets used by the OBJ
 files  or  by  the PE files with COFF debug information. Not much to look at
 this anyway.

 ş NumberOfSymbols
 ßßßßßßßßßßßßßßßßß
        The  number of sysmbols in the Symbol Table. There exist descriptions
 of the Symbols in the SDK but I don't think they are useful in anyway...

 ş SizeOfOptionalHeader
 ßßßßßßßßßßßßßßßßßßßßßß
        This  is a value which gives the size of the header which follows the
 PE  header.  I  guess  Microsoft  included  this because they thought in the
 future the size of the optional header might change. When you analyze the PE
 header you should rely on this value and use it.

 ş Characteristics
 ßßßßßßßßßßßßßßßßß
        The  Characteristics  name  appears  in many structures inside the PE
 file  and,  with some exceptions, it represents a set of flags that give out
 specific information about the structure or data. In the PE header this is a
 value  that  gives important information about the way the file was compiled
 and  linked. It actually represents a set of values ORer one with another to
 give a full value. Here are the common known values for this field:

 IMAGE_FILE_RELOCS_STRIPPED         = 0001h

        We  shall discuss relocations later. If this bit is set than it means
 that  the  relocation  information was removed from this file. This differes
 from  the relocations presented in this document and this is a particularity
 for the executables. Usually this bit is set.

 IMAGE_FILE_EXECUTABLE_IMAGE        = 0002h

        If  this bit is set then the file is for sure an executable file, not
 an object or library file.

 IMAGE_FILE_LINE_NUMS_STRIPPED      = 0004h

        Line numbers stripped from file. Same idea as for the relocations and
 same meaningless for the exe files.

 IMAGE_FILE_LOCAL_SYMS_STRIPPED     = 0008h

        Local symbols stripped from file. Same stuff as above. Unused.

 IMAGE_FILE_AGGRESIVE_WS_TRIM       = 0010h

        Agressively trim working set. This makes the operating system to page
 the  application out. This is used if the application is dormant most of the
 time.

 IMAGE_FILE_LARGE_ADDRESS_AWARE     = 0020h

        App can handle >2gb addresses.

 IMAGE_FILE_BYTES_REVERSED_LO       = 0080h

        Bytes of machine word are reversed.

 IMAGE_FILE_32BIT_MACHINE           = 0100h

        32 bit word machine. As we are talking about a win32 environment this
 bit should always be set.

 IMAGE_FILE_DEBUG_STRIPPED          = 0200h

        Debugging info stripped from file. Unused in executables which have a
 special kind of debugging information in the debug section.

 IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = 0400h

        If Image is on removable media, copy and run from the swap file. This
 applies for applications which run from a floppy or from CD, and to speed up
 execution the system could load them into the swap file.

 IMAGE_FILE_NET_RUN_FROM_SWAP       = 0800h

        If  Image  is on Net, copy and run from the swap file. The same here,
 but applies for applications run over the network.

 IMAGE_FILE_SYSTEM                  = 1000h

        System File. This flag is never set for exe files. It only applies to
 drivers.

 IMAGE_FILE_DLL                     = 2000h

        File is a DLL. Pretty clear.

 IMAGE_FILE_UP_SYSTEM_ONLY          = 4000h

        File  should  only  be  run  on  a  UP  machine.  This  is set if the
 application may only run on a system equiped with only one processor.

 IMAGE_FILE_BYTES_REVERSED_HI       = 8000h

        Bytes of machine word are reversed.

        For  example  a  32bit  executable file without debugging information
 will  have  the  Characteristics  field  equal to (0002h OR 0100h OR 0200h),
 which gives 310h.


 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 PE Optional header
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

        Even  if  the name tells that this header is optional, actually it is
 not optional at all and it exists in all PE files. The information in the PE
 Optional header are very important and should be looked up very carefuly.

 IMAGE_OPTIONAL_HEADER STRUC                        ; Optional Header
     OH_Magic                        DW ?           ; Magic word
     OH_MajorLinkerVersion           DB ?           ; Major Linker version
     OH_MinorLinkerVersion           DB ?           ; Minor Linker version
     OH_SizeOfCode                   DD ?           ; Size of code section
     OH_SizeOfInitializedData        DD ?           ; Initialized Data
     OH_SizeOfUninitializedData      DD ?           ; Uninitialized Data
     OH_AddressOfEntryPoint          DD BYTE PTR ?  ; Initial EIP
     OH_BaseOfCode                   DD BYTE PTR ?  ; Code Virtual Address
     OH_BaseOfData                   DD BYTE PTR ?  ; Data Virtual Address
     OH_ImageBase                    DD BYTE PTR ?  ; Base of image
     OH_SectionAlignment             DD ?           ; Section Alignment
     OH_FileAlignment                DD ?           ; File Alignment
     OH_MajorOperatingSystemVersion  DW ?           ; Major OS
     OH_MinorOperatingSystemVersion  DW ?           ; Minor OS
     OH_MajorImageVersion            DW ?           ; Major Image version
     OH_MinorImageVersion            DW ?           ; Minor Image version
     OH_MajorSubsystemVersion        DW ?           ; Major Subsys version
     OH_MinorSubsystemVersion        DW ?           ; Minor Subsys version
     OH_Win32VersionValue            DD ?           ; win32 version
     OH_SizeOfImage                  DD ?           ; Size of image
     OH_SizeOfHeaders                DD ?           ; Size of Header
     OH_CheckSum                     DD ?           ; unused
     OH_Subsystem                    DW ?           ; Subsystem
     OH_DllCharacteristics           DW ?           ; DLL characteristic
     OH_SizeOfStackReserve           DD ?           ; Stack reserve
     OH_SizeOfStackCommit            DD ?           ; Stack commit
     OH_SizeOfHeapReserve            DD ?           ; Heap reserve
     OH_SizeOfHeapCommit             DD ?           ; Heap commit
     OH_LoaderFlags                  DD ?           ; Loader flags
     OH_NumberOfRvaAndSizes          DD ?           ; Number of directories
                                     UNION          ; directory entries
     OH_DataDirectory                IMAGE_DATA_DIRECTORY\
                                     IMAGE_NUMBEROF_DIRECTORY_ENTRIES DUP (?)
     OH_DirectoryEntries             IMAGE_DIRECTORY_ENTRIES ?
                                     ENDS           ;
     ENDS                                           ;


 ş OH_Magic
 ßßßßßßßßßß
        This  value  seems  to  equal  010Bh on all PE files I saw. Why is it
 considered  magic... I don't know! ;-) But if you think of it, in ASCII this
 is  transcribed  like  this: '', which is as far as I know the sign of the
 male and the sign of a happy face... A happy man? Bill Gates? Maybe ;-))

 ş OH_MajorLinkerVersion
 ßßßßßßßßßßßßßßßßßßßßßßß
        The major linker version.

 ş OH_MinorLinkerVersion
 ßßßßßßßßßßßßßßßßßßßßßßß
        The minor linker version.

 ş OH_SizeOfCode
 ßßßßßßßßßßßßßßß
        This  is  the  size  of  all the sections that contain code. We shall
 learn  about  the sections and the code section itself later. You should not
 rely on this value as to contain the total amount of code.

 ş OH_SizeOfInitializedData
 ßßßßßßßßßßßßßßßßßßßßßßßßßß
        This is the size of the initialized data section. Not to rely on this
 value! It's only valid for "normally" compiled and linked files.

 ş OH_SizeOfUninitializedData
 ßßßßßßßßßßßßßßßßßßßßßßßßßßßß
        This  is  the  size of the uninitialized data section. Not to rely on
 this value also!

 ş OH_AddressOfEntryPoint
 ßßßßßßßßßßßßßßßßßßßßßßßß
        This  is  a  RVA,  which  usualy  points  in  the  code  section, and
 represents  the  entrypoint  of  the  PE file, e.g. the place where the file
 starts to execute.

 ş OH_BaseOfCode
 ßßßßßßßßßßßßßßß
        The base address where the code section will be loaded.

 ş OH_BaseOfData
 ßßßßßßßßßßßßßßß
        The base address where the initialized data section will be loaded.

 ş OH_ImageBase
 ßßßßßßßßßßßßßß
        This is the imagebase we spoke about before, the address where the PE
 file  is about to be mapped in memory. The most used value is 00400000h, but
 you can find other values as 30000000h (like in MS-Office).

 ş OH_SectionAlignment
 ßßßßßßßßßßßßßßßßßßßßß
        The  alignment of the sections. This means that every section must be
 at  least  the  size  of  section alignment when mapped into memory and must
 start  from  a  multiple  of  this value. Because of protected mode specific
 paging  methods, this value is currently 1000h and it always must be a power
 of 2.

 ş OH_FileAlignment
 ßßßßßßßßßßßßßßßßßß
        This  is the alignment of the file. The file size should be divisible
 with  this value, and also the sections inside the file will always start at
 a  multiple of this value. To ensure this, the linker pads each section with
 0  until the file alignment is met. This value is usualy set to 200h. When I
 said that the filesize should be divisible with file alignment, I meant that
 it should but not necessary. There are quite a few utilities that strip some
 useless  zero  padding from the PE file in order to make it smaller, such as
 NetWalker Fat-Free.

 ş OH_MajorOperatingSystemVersion
 ş OH_MinorOperatingSystemVersion
 ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
        These  two  values  together  give  you  the minimum operating system
 needed  to run this file. The value here seems to serve no purpose since the
 subsystem value defined below looks like providing the same information, but
 more detailed. Currently set to 1.0 (Win32 1.0?)

 ş OH_MajorImageVersion
 ş OH_MinorImageVersion
 ßßßßßßßßßßßßßßßßßßßßßß
        These  serve  as  a  place  for  the user to place the version of the
 compiled  file.  It  is thus, an user defined value which is usualy not set,
 but it can be set using the linker's specific command line.

 ş OH_MajorSubsystemVersion
 ş OH_MinorSubsystemVersion
 ßßßßßßßßßßßßßßßßßßßßßßßßßß
        This  gives  the  version  of  the  subsystem  running  on  the win32
 paltform. For example 3.10 means WindowsNT 3.1.

 ş OH_Win32VersionValue
 ßßßßßßßßßßßßßßßßßßßßßß
        From  it's  name looks like the version of the win32 system. Probably
 they realised that it is already defined in the system version, so currently
 this  field  is  always  set to 0, and might contain different values in the
 future with different meanings.

 ş OH_SizeOfImage
 ßßßßßßßßßßßßßßßß
        This  represents the total size of the file image after it was mapped
 into  memory and aligned properly. It is very important for this value to be
 exact,  otherwise  the  load  of  the  file  could  fail,  especially  under
 WindowsNT.  It  seems  that the loader looks this value up, allocates memory
 and  then  maps  the  file.  If the memory is less then needed an error will
 occure.  Windows95  doesn't  seem to rely on that value; instead probably it
 looks directly at the size of the file.

 ş OH_SizeOfHeaders
 ßßßßßßßßßßßßßßßßßß
        This  is  the total size of headers. Very important value, especially
 if  Microsoft will add future extensions to the existing headers. You should
 rely on this value for future compatibility. Add this value to the imagebase
 and obtain the address in memory of the first section body.

 ş OH_CheckSum
 ßßßßßßßßßßßßß
        A  checksum  of  the  file which can be obtained with some win32 APIs
 calls,   like   ChecksumMappedFile,  MapAndChecksumA,  MapAndChecksumW,  and
 others,  and  who's  value is not necessary to be set correctly; from what I
 saw,  only if the file is created by a special service which wants to assure
 the  integracy  of  the  PE  file.  You should rearrange this value if it is
 different  from  0. Usually it is set to 0. The algorithm for computing this
 value  is  copyrighted  by  Microsoft,  but  I  guess  it  could be found by
 disassembling  the  call to the ChecksumMappedFile api. I haven't got a clue
 if  the  loader checks this value by itself, but the file could check itself
 for sure.

 ş OH_Subsystem
 ßßßßßßßßßßßßßß
        This gives furthure more guidelines on the type of application the PE
 file  is by telling if it needs a graphical interphace, if it is a text mode
 only application, etc:

 IMAGE_SUBSYSTEM_UNKNOWN        = 0

        Unknown subsystem.

 IMAGE_SUBSYSTEM_NATIVE         = 1

        Image doesn't require a subsystem. This is the case for drivers.

 IMAGE_SUBSYSTEM_WINDOWS_GUI    = 2

        Image  runs  in  the  Windows  GUI  subsystem.  It  runs  thus in the
 graphical interphace, meaning it can open a graphical console, but it is not
 assigned one from the start.

 IMAGE_SUBSYSTEM_WINDOWS_CUI    = 3

        Image  runs  in the Windows character subsystem. Automatically gets a
 console at startup.

 IMAGE_SUBSYSTEM_OS2_CUI        = 5

        Image runs in the OS/2 character subsystem.

 IMAGE_SUBSYSTEM_POSIX_CUI      = 7

        Image runs in the Posix character subsystem.

 IMAGE_SUBSYSTEM_NATIVE_WINDOWS = 8

        Image is a native Win9x driver. I think this is the same as 1.

 IMAGE_SUBSYSTEM_WINDOWS_CE_GUI = 9

        Image  runs  in  the  Windows  CE  subsystem. Special setting for the
 Windows CE operating system.

        I  guess  the  only  legal  values for the Windows95/98/NT executable
 files are 2, 3 and 9.

 ş OH_DllCharacteristics
 ßßßßßßßßßßßßßßßßßßßßßßß
        These  are some flags which are set to tell the loader wether to call
 some  initialization  routines  at  different times. The values show when to
 call  the  routine. However, they seem to be useless, as the DLL seems to be
 notified about everything:

        1  Call  when  DLL is first loaded into a process's address space, or
 when it gets attached to a process, if you want.

        2 Call when a thread terminates.

        4 Call when a thread starts up.

        8 Call when DLL exits, or when it gets dettached.


 ş OH_SizeOfStackReserve
 ßßßßßßßßßßßßßßßßßßßßßßß
        This  is the ammount of reserved stack in pages required by the first
 thread.  Only a part of this stack is actually commited, created. Usually 16
 pages are reserved.

 ş OH_SizeOfStackCommit
 ßßßßßßßßßßßßßßßßßßßßßß
        The  ammount  of  stack  which  is  actually  commited from the total
 reserved stack. This field is usually 1 or 2 pages.

 ş OH_SizeOfHeapReserve
 ş OH_SizeOfHeapCommit
 ßßßßßßßßßßßßßßßßßßßßßß
        These  fields have  the  same explanation as the stack fields.

 ş OH_LoaderFlags
 ßßßßßßßßßßßßßßßß
        These are flags that seem to be used to invoke some debugging process
 at  different  times,  but not only that it doesn't seem to work, it is also
 not specified anywhere how to set them:

        1   Invoke a breakpoint instruction before starting the process
        2   Invoke a debugger on the process after it's been loaded

        I  guess  these  are  remanants  from  the early designs of the Win32
 systems.

 ş OH_NumberOfRvaAndSizes
 ßßßßßßßßßßßßßßßßßßßßßßßß
        This  is  the  number of entries in the Data Directory, the number of
 elements  in  the array that follows the PE Optional header. It is currently
 set  to  16.  You  should rely heavily on this value as to give you the real
 size  of the DataDirectory, because you will see that it is used in order to
 reach the section headers.


        After the PE Optional header we have the PE Data directory.


 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 PE Data Directory
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

        Before  explaining  the  data directory let me explain the concept of
 section.  As  you  can  see  in  the  diagram above, right after the headers
 follows the section bodies. These actually represent the real data, the part
 where  the actual code and data exists. Each section contains different data
 and  usually  the  information  inside  is  concentrated  there  on  the use
 criteria.  For example, the resources (like menus, icons, etc.) are arranged
 into  one  section, the code is concentrated in one section, the imports are
 gathered  in one section, and so on. So, basically each section represents a
 part of the PE file which has a very well defined purpose. Of course, as you
 should  imagine,  there  exist a few sections which became largely known and
 used,  which we will discuss later. The most important thing is that most of
 these sections can be found via data directory.

        And  here we come to the data directory. The reason it is called data
 directory  is because the sections are sometimes also called directories (or
 objects).  The data directory is an array of dwords that specify the RVA and
 size of some well known sections.

        A data directory structure goes like this:

 IMAGE_DATA_DIRECTORY STRUC   ; Image data directory
     DD_VirtualAddress DD ?   ; Virtual address
     DD_Size           DD ?   ; Virtual size
 IMAGE_DATA_DIRECTORY ENDS    ;

 ş DD_VirtualAddress
 ßßßßßßßßßßßßßßßßßßß
         The DD_VirtualAddress is a RVA to the place where the section will be
 loaded  into memory.

 ş DD_Size
 ßßßßßßßßß
        While the DD_Size is the size of the section, before it was padded to
 reach the section alignment.

        For  the  moment  all  linkers  set  up  the following data directory
 structure:

 IMAGE_DIRECTORY_ENTRIES STRUC                      ; All directories
     DE_Export           IMAGE_DATA_DIRECTORY    ?  ; Export directory
     DE_Import           IMAGE_DATA_DIRECTORY    ?  ; Import directory
     DE_Resource         IMAGE_DATA_DIRECTORY    ?  ; Resource directory
     DE_Exception        IMAGE_DATA_DIRECTORY    ?  ;
     DE_Security         IMAGE_DATA_DIRECTORY    ?  ;
     DE_BaseReloc        IMAGE_DATA_DIRECTORY    ?  ; Relocations directory
     DE_Debug            IMAGE_DATA_DIRECTORY    ?  ; Debug directory
     DE_Copyright        IMAGE_DATA_DIRECTORY    ?  ;
     DE_GlobalPtr        IMAGE_DATA_DIRECTORY    ?  ;
     DE_TLS              IMAGE_DATA_DIRECTORY    ?  ;
     DE_LoadConfig       IMAGE_DATA_DIRECTORY    ?  ;
     DE_BoundImport      IMAGE_DATA_DIRECTORY    ?  ;
     DE_IAT              IMAGE_DATA_DIRECTORY    ?  ;
     DE_Reserved1        IMAGE_DATA_DIRECTORY    ?  ;
     DE_Reserved2        IMAGE_DATA_DIRECTORY    ?  ;
     DE_Reserved3        IMAGE_DATA_DIRECTORY    ?  ;
 IMAGE_DIRECTORY_ENTRIES ENDS                       ;

        So  basically,  each  data  directory  entry  points to the specified
 section  body.  If  the  values are 0 then it means that the PE file doesn't
 contain  that particular section. Check the annexes to see how to locate the
 sections using the data directory.


 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Section Header
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

        As  we  move to the section header we are coming closer and closer to
 the  actual  data  inside  the  PE  file.  The  section  headers offer basic
 information  on the section body itself and can be used to locate the actual
 place of the section body. Here it is:

 IMAGE_SECTION_HEADER STRUC                  ; Section hdr.
     SH_Name                 DB IMAGE_SIZEOF_SHORT_NAME DUP(?) ; name
                             UNION           ;
     SH_PhysicalAddress      DD BYTE PTR ?   ; Physical address (for OBJ)
     SH_VirtualSize          DD ?            ; Virtual size     (for EXE)
                             ENDS            ;
     SH_VirtualAddress       DD BYTE PTR ?   ; Virtual address
     SH_SizeOfRawData        DD ?            ; Raw data size
     SH_PointerToRawData     DD BYTE PTR ?   ; pointer to raw data
     SH_PointerToRelocations DD BYTE PTR ?   ; ...
     SH_PointerToLinenumbers DD BYTE PTR ?   ; ...... not really used
     SH_NumberOfRelocations  DW ?            ; ....
     SH_NumberOfLinenumbers  DW ?            ; ..
     SH_Characteristics      DD ?            ; flags
 IMAGE_SECTION_HEADER ENDS                   ;

 ş SH_Name
 ßßßßßßßßß
        The  name  of  the  section.  It  is an 8 byte length string which is
 thought  to  give  a  basic  information  on the section's data. Usual names
 like  .code,  .data,  .reloc give you a hint, but you should not rely on the
 names in the search for a particular section. Also note that the leading '.'
 is  not  compulsory, and that the size of the name is padded to 8 characters
 using zeros. Here are some used names for the most know sections:

        - code section               : CODE, .text, .code
        - initialized data section   : .data
        - uninitialized data section : .bss
        - import section             : .import
        - export section             : .export
        - resource section           : .rsrc
        - relocation section         : .reloc
        - debug section              : .debug

        These  are  only  informative. One should not rely on the name of the
 section  as  to  hold  the  information  as presented above. This is why the
 DataDirectory  was created, to allow the system to locate the most important
 section  headers,  like  imports,  exports,  resources,  not regarding their
 names.

 ş SH_VirtualSize
 ßßßßßßßßßßßßßßßß
        Here  we  have  an  union and the PhysicalAddress is used for the OBJ
 files,  while  the VirtualSize that we care about is used for EXE files. The
 definition  differs  from  obj files to exe files. We shall only look on the
 EXE  side.  In  EXE, this field gives you the size of the section, before it
 was  rounded  up  to  file  alignment.  I  don't know why, but it looks like
 Microsoft misnamed this value and also another one explained below.

 ş SH_VirtualAddress
 ßßßßßßßßßßßßßßßßßßß
        This  is  a  RVA  to  the  section's body. Use this value to locate a
 particular section in memory, by adding it to the value of the imagebase.

 ş SH_SizeOfRawData
 ßßßßßßßßßßßßßßßßßß
        This  is the total size of the section's data after it was rounded to
 the  file  alignment. This is the value I was talking about before and which
 seems  to  be misnamed  also.  It  looks  to me that this value shouldn't be
 rounded  (raw  data),  insted  VirtualSize should (it's virtual). Looks like
 tlink32  switches  the  values  to  obtain  the  right  representation.  The
 SizeOfRawData is, as I said rounded up to file alignment but when the loader
 maps the sections, they get rounded to the section alignment. For example if
 VirtualSize  is  555h,  file  alignment  is 200h, then SizeOfRawData will be
 600h,  but  when  loaded  into  memory  the  section will be 1000h, assuming
 section alignment is 1000h.

 ş SH_PointerToRawData
 ßßßßßßßßßßßßßßßßßßßßß
        This  points to the raw data of the section. Use this value to locate
 the section body inside the file. It is simply an offset to the real data of
 the section from the beginning of the file.

 ş SH_PointerToRelocations
 ßßßßßßßßßßßßßßßßßßßßßßßßß
        Not used in the PE Exe file, but only in OBJs.

 ş SH_PointerToLinenumbers
 ßßßßßßßßßßßßßßßßßßßßßßßßß
        This  links  the source code with the output assembly. It seems to be
 obsolete, as modern debugging sections also contain this information.

 ş SH_NumberOfRelocations
 ßßßßßßßßßßßßßßßßßßßßßßßß
        Number of relocations in file. Set to 0 for EXEs.

 ş SH_NumberOfLinenumbers
 ßßßßßßßßßßßßßßßßßßßßßßßß
        Number of line numbers. Unused.

 ş SH_Characteristics
 ßßßßßßßßßßßßßßßßßßßß
        This  field  tells  a  hole bunch of stuff about how the page for the
 section  will  be  created  and  a lot of other information. It represents a
 combination of the following values ORed. Only a few are actually used, some
 I  was  not  able  to decipher and others are very important, which I marked
 with a '*':

 IMAGE_SCN_CNT_CODE                 = 00000020h  ;*

        Section contains code. This flag is useless as the x86 machine cannot
 distinguish  between  code  and  non-code,  therefore it cannot validate the
 section using this flag.

 IMAGE_SCN_CNT_INITIALIZED_DATA     = 00000040h  ;*

        Section  contains  initialized  data. Here data which have meaning at
 startup is stored.

 IMAGE_SCN_CNT_UNINITIALIZED_DATA   = 00000080h  ;*

        Section  contains  uninitialized data. This is usually zeroed and can
 be used by the program.

 IMAGE_SCN_LNK_INFO                 = 00000200h  ;

        Section contains comments or some other type of information.

 IMAGE_SCN_LNK_REMOVE               = 00000800h  ;

        Section  contents  will not become part of image. The section will be
 removed at link time. It is used in object files.

 IMAGE_SCN_LNK_COMDAT               = 00001000h  ;

        Section  contents comdat. Comdat means "common block data". I have no
 idea what that means.

 IMAGE_SCN_NO_DEFER_SPEC_EXC        = 00004000h  ;

        Reset  speculative  exceptions  handling  bits in the TLB entries for
 this section. What?!?

 IMAGE_SCN_GPREL                    = 00008000h  ;

        Section content can be accessed relative to GP.

 IMAGE_SCN_MEM_FARDATA              = 00008000h  ;

        Sections contains far data. Hmmm...?

 IMAGE_SCN_MEM_PURGEABLE            = 00020000h  ;

        This  looks  like  to tell if the section can be discarded, but it is
 not,  as  a  special  bit  is  used  for  that. I think it's redundant and I
 wouldn't recommend it's use.

 IMAGE_SCN_MEM_16BIT                = 00020000h  ;

        ?

 IMAGE_SCN_MEM_LOCKED               = 00040000h  ;

        Looks  like  a  flag which should make the section unmovable. I think
 again it has no meaning, as you can do this using the read/write flags.

 IMAGE_SCN_MEM_PRELOAD              = 00080000h  ;

        Looks  like  the  operating  system  should  page this before all the
 others?

 IMAGE_SCN_ALIGN_1BYTES             = 00100000h  ;
 IMAGE_SCN_ALIGN_2BYTES             = 00200000h  ;
 IMAGE_SCN_ALIGN_4BYTES             = 00300000h  ;
 IMAGE_SCN_ALIGN_8BYTES             = 00400000h  ;
 IMAGE_SCN_ALIGN_16BYTES            = 00500000h  ; Default alignment if no others are specified.
 IMAGE_SCN_ALIGN_32BYTES            = 00600000h  ;
 IMAGE_SCN_ALIGN_64BYTES            = 00700000h  ;
 IMAGE_SCN_ALIGN_128BYTES           = 00800000h  ;
 IMAGE_SCN_ALIGN_256BYTES           = 00900000h  ;
 IMAGE_SCN_ALIGN_512BYTES           = 00A00000h  ;
 IMAGE_SCN_ALIGN_1024BYTES          = 00B00000h  ;
 IMAGE_SCN_ALIGN_2048BYTES          = 00C00000h  ;
 IMAGE_SCN_ALIGN_4096BYTES          = 00D00000h  ;
 IMAGE_SCN_ALIGN_8192BYTES          = 00E00000h  ;

        This  is the alignment of the objects, but it doesn't seem to be used
 in the exe files. Only the 16 bit alignment is used, which is default.

 IMAGE_SCN_ALIGN_MASK               = 00F00000h  ;

        Mask for the alignment?

 IMAGE_SCN_LNK_NRELOC_OVFL          = 01000000h  ;

        Section contains extended relocations.

 IMAGE_SCN_MEM_DISCARDABLE          = 02000000h  ;*

        Section  can  be discarded. This means that after startup the section
 is not needed anymore.

 IMAGE_SCN_MEM_NOT_CACHED           = 04000000h  ;

        Section is not cachable.

 IMAGE_SCN_MEM_NOT_PAGED            = 08000000h  ;

        Section is not pageable.

 IMAGE_SCN_MEM_SHARED               = 10000000h  ;*

        Section  is shareable. If a file runs in more instances, this section
 is shared by all.

 IMAGE_SCN_MEM_EXECUTE              = 20000000h  ;*

        Section  is executable. The right to execute is set for this section.
 The execute right is interpreted as 'read' on x86 machines.

 IMAGE_SCN_MEM_READ                 = 40000000h  ;*

        Section  is  readable. This and the next are probably the only really
 important flags. This one allows reads in the section.

 IMAGE_SCN_MEM_WRITE                = 80000000h  ;*

        Section is writeable. This one allows writes in the section.


        Basically this is the entire PE header with all the stuff you need to
 know about. This was simple, wasn't it? Well, here comes the hard part. As I
 explained  above, among all the kinds of sections that can exists, there are
 a  few which are very, very important, some of them existing in all PE files
 and  some of them having a very well defined structure. Basically I will not
 explain  anything  from  within the PE header itself. Instead we will look a
 little  over  the  most common sections inside the PE file body and we shall
 try to understand what information those sections provide to us.


 ÍÍÍÍÍÍÍÍÍÍÍÍ
 Section body
 ÍÍÍÍÍÍÍÍÍÍÍÍ

        The  section body is the place where the actual data can be found. It
 is  unlikely to speak about a section body layout, because it doesn't exist.
 Basically  one PE file may have no matter how many sections with any kind of
 layout.  We  can  only  stop and speak about the known sections which can be
 found in most of the PE files and their layout.


 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Export section
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        As  I explained at the beginning of this documents, and as well as in
 other  articles  I  wrote,  one of the main propriety of the win32 system is
 dynamic  linking.  When  the  PE  file  gets compiled, the source code makes
 refference  to different win32 apis, which are needed for the program to run
 (let's  say GlobalAlloc, for example). When the linker sees that the PE file
 is  trying to use a win32 Api which is defined inside some DLL file, it will
 create  a  special  table,  actually  more tables, in which the PE file will
 import  the  apis  from  the  dynamic  libraries.  Let's take the example of
 ExitProcess.  In  order  to  finish execution any application must call this
 API.  ExitProcess  is  an  API that belongs to the kernel32.dll library. The
 linker  understands  this  and  creates  an import section in the PE file to
 allow  it  to  call  the  functions  inside kernel32.dll. On the other hand,
 kernel32.dll  itself  must  be able to notify the PE file that this function
 belongs  to it and that it can be called. This process is called export. The
 kernel32.dll  must  export  its  functions,  so that the PE files can import
 them.

        Firstly  we  will  look  at the exporting part. Usually exports exist
 only  in  the  DLL  files.  Exe files do not export functions. The dll files
 export  their functions and whenever a PE file imports them, they get mapped
 into the process memory and a dynamic link is created between the two files.
 The  loader  checks  if  all  functions that are imported by the PE file are
 exported by the corresponding DLL. If not, an error message pops up.

        So,  we  were  talking  about  the exports. Here is the layout of the
 export section, starting right were the section body begins:


 IMAGE_EXPORT_DIRECTORY STRUC                    ; Export Directory
     ED_Characteristics        DD ?              ; Flags
     ED_TimeDateStamp          DD ?              ; Date / Time
     ED_MajorVersion           DW ?              ; Major version
     ED_MinorVersion           DW ?              ; Minor version
     ED_Name                   DD    BYTE PTR ?  ; Ptr to name of exported DLL
     ED_BaseOrdinal            DD    ?           ; base ordinal
     ED_NumberOfFunctions      DD    ?           ; number of exported funcs.
     ED_NumberOfNames          DD    ?           ; number of exported names
     ED_AddressOfFunctions     DD    DWORD PTR ? ; Ptr to array of function addresses
     ED_AddressOfNames         DD    DWORD PTR ? ; Ptr to array of (function) name addresses
     ED_AddressOfNameOrdinals  DD    WORD PTR ?  ; Ptr to array of name ordinals
 IMAGE_EXPORT_DIRECTORY ENDS                     ;

 ş ED_Characteristics
 ßßßßßßßßßßßßßßßßßßßß
        Always set to 0.

 ş ED_TimeDateStamp
 ßßßßßßßßßßßßßßßßßß
        The time when this file was created. This is used as an unique number
 which  defines  the  version of the DLL file. When the loader maps this file
 into  one  process'  memory  area  it will compare this value with the value
 defined  in  the  import  section  of the importing file to be sure that the
 dinamic  library  is  the same as it was at link time. If the version of the
 DLL  is  not  the same, the loader assumes that something might be wrong and
 takes different actions (see import section).

 ş ED_MajorVersion
 ş ED_MinorVersion
 ßßßßßßßßßßßßßßßßß
        Always set to 0.

 ş ED_Name
 ßßßßßßßßß
        This is a RVA to an ASCIIZ string which contains the name of this DLL
 (for ex. "Kernel32.DLL",0)

 ş ED_BaseOrdinal
 ßßßßßßßßßßßßßßßß
        This value holds the first ordinal for the exported functions. If the
 file  exports  the  ordinal functions 100, 101, 102, this field will contain
 100.

 ş ED_NumberOfFunctions
 ßßßßßßßßßßßßßßßßßßßßßß
        This  holds the total number of exported functions. It represents the
 length of the array pointed by AddressOfFunctions.

 ş ED_NumberOfNames
 ßßßßßßßßßßßßßßßßßß
        This  is  a  value  which is always equal to the NumberOfFunctions. I
 have  no  idea  why Microsoft thought two fields for the same thing? How can
 you export a name without an address?

 ş ED_AddressOfFunctions
 ßßßßßßßßßßßßßßßßßßßßßßß
        This  is the entry RVA into an array that holds RVAs to each exported
 function address.

 ş ED_AddressOfNames
 ßßßßßßßßßßßßßßßßßßß
        This  is the entry RVA into an array of RVAs that holds each function
 name, as an asciiz string.

 ş ED_AddressOfNameOrdinals
 ßßßßßßßßßßßßßßßßßßßßßßßßßß
        This is the entry RVA into an array that holds each exported function
 ordinal.  Microsoft  compiled  quite  a few DLLs which export functions with
 null  names,  so you can only search them by their ordinal. This array is an
 array of words!!

        Let's see it graphically:

  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
  ³  Characteristics        ³
  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
  |  other fields           |      Function Address Table
  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´    ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
  ³  NumberOfFunctions      ³ÚÄÄ>³aaaaaaaah³bbbbbbbbh³cccccccch³ddddddddh³
  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´³   ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÙ
  ³  NumberOfNames          ³³     Function Names Table
  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´³   ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
  ³  AddressOfFunctions     ÃÙ Ú>³nameptr1 ³nameptr2 ³nameptr3 ³nameptr4 ³
  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´  ³ ÀÂÄÄÄÄÄÄÄÄÁÂÄÄÄÄÄÄÄÄÁÂÄÄÄÄÄÄÄÄÁÂÄÄÄÄÄÄÄÄÙ
  ³  AddressOfNames         ÃÄÄÙ ÚvÄÄÄÄÄÄÄ¿ÚvÄÄÄÄÄÄÄ¿ÚvÄÄÄÄÄÄÄ¿ÚvÄÄÄÄÄÄÄ¿
  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´    ³"name1" ³³"name2" ³³"name3" ³³"name4" ³
  ³  AddressOfNameOrdinals  ÃÄÄ¿ ÀÄÄÄÄÄÄÄÄÙÀÄÄÄÄÄÄÄÄÙÀÄÄÄÄÄÄÄÄÙÀÄÄÄÄÄÄÄÄÙ
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  ³   Function Ordinals Table
                               ³ ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
                               À>³ 01h     ³ 02h     ³ 03h     ³ 04h     ³
                                 ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÙ


        Look  at  the  Annex  to see how you can locate a function address by
 knowing it's name.


 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Import section
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Before  starting  to  read  this section's description, please go and
 puke, so you won't have to stop while reading ;-)

        As  I  explained before, there are DLLs exporting functions (actually
 function  addresses),  and  there  are  executables and DLLs importing those
 functions  (actually  the  addresses),  in  order to call them. A call to an
 imported API is generated by the linker like this:

          call xxxxxxxx

 xxxxxxxx:
          jmp [yyyyyyyy]

        If you look in the place where the jmp is found, you will see as many
 jmps as functions are imported (imported functions are declared in asm using
 the  EXTRN  definition).  The  table  containing  the JMPs is called the IAT
 (Imported  Address  Table), and it is located right before the entrypoint in
 the code section (only if the file was normally compiled and linked, and was
 not modified). All values as our [yyyyyyyy] here is patched by the loader at
 load time, so that the jumps will jump correctly inside the correct DLL body
 (which  is mapped in the process' area). In order to be able to do this, the
 loader  must first know what DLLs must it map inside the process' memory and
 second   what   function addresses must it patch. The loader obtains this by
 scanning  the  import  table,  and this is what we are about to do ourselves
 too.

        The import section is the second entry in the data directory. You can
 check  on how to locate sections using the data directory in the examples in
 the Annex. Also note that the import section is commonly named ".idata".

        This  is  a little difficult, but I will try to explain it as well as
 possible. First let's discuss the most important structures. There are three
 of them and I will take them one by one.

        First,  the IMAGE_IMPORT_BY_NAME is actually the last place you reach
 while searching the name of the function:

 IMAGE_IMPORT_BY_NAME STRUC   ; Import by name data type
     IBN_Hint DW 0            ; Hint entry
     IBN_Name DB 1 DUP (?)    ; name
 IMAGE_IMPORT_BY_NAME ENDS    ;

 ş IBN_Hint
 ßßßßßßßßßß
        This  should represent the export ordinal for this imported function.
 I  have no idea if this is necessarily true. You should not rely too much on
 this value.

 ş IBN_Name
 ßßßßßßßßßß
        This is and ASCIIZ string with the name of the imported function.

        The  next  important  structure  is  the IMAGE_THUNK_DATA. This is an
 union with the dword length and it may have different meanings:

 IMAGE_THUNK_DATA STRUC                          ; Thunk data
                         UNION                   ;
     TD_AddressOfData    DD IMAGE_IMPORT_BY_NAME PTR ? ; Ptr to IMAGE_IMPORT_BY_NAME structure
     TD_Ordinal          DD ?                    ; Ordinal ORed with IMAGE_ORDINAL_FLAG
     TD_Function         DD BYTE PTR ?           ; Ptr to function (i.e. Function address after program load)
     TD_ForwarderString  DD BYTE PTR ?           ; Ptr to a forwarded API function.
                         ENDS                    ;
 IMAGE_THUNK_DATA ENDS                           ;

        Usually  the  dword  is  used as TD_AddressOfData, thus pointing to a
 structure  IMAGE_IMPORT_BY_NAME,  where  you  can  retrieve  the name of the
 function.  However,  it  can  be  interpreted  as  an exported ordinal (as I
 explained  functions  may  be  exported  by  their ordinals instead of their
 names;  to  check  this  check  if the high bit is set, which means it is an
 ordinal  ; kernel32.dll exports some functions by their ordinals, especially
 functions that Microsoft is trying to keep in dark).

        And  now,  the  main  structure  called  IMAGE_IMPORT_DESCRIPTOR. The
 import  section  begins with an array made up from structures like this, and
 it  has  as  many as imported DLLs exist. For example if the program imports
 functions  from  kernel32.dll, user32.dll, gdi32.dll, there will exist three
 IMAGE_IMPORT_DESCRIPTOR  structures  one  after the other, one for each DLL.
 So, the structure goes like this:

 IMAGE_IMPORT_DESCRIPTOR STRUC           ; Import descryptor
                           UNION         ;
     ID_Characteristics    DD ?          ; 0 for last null import descriptor
     ID_OriginalFirstThunk DD IMAGE_THUNK_DATA PTR ? ; RVA to original unbound IAT
                           ENDS          ;
     ID_TimeDateStamp      DD ?          ; 0 if not bound, -1 if bound
     ID_ForwarderChain     DD ?          ; -1 if no forwarders
     ID_Name               DD BYTE PTR ? ; RVA to name of imported DLL
     ID_FirstThunk         DD IMAGE_THUNK_DATA PTR ?  ; RVA to IAT (if bound this IAT has actual addresses)
 IMAGE_IMPORT_DESCRIPTOR ENDS

 ş ID_Characteristics
 ßßßßßßßßßßßßßßßßßßßß
        Again,  this  is  a  misnamed  value,  as  it  does  not  represent a
 characteristic of anykind. Instead, this is a RVA to an array of pointers to
 an  IMAGE_IMPORT_BY_NAME structure. By starting from this RVA you can easily
 locate  the  imported function names, as we shall see later. This is, as you
 can see, also called OriginalFirstThunk.

 ş ID_TimeDateStamp
 ßßßßßßßßßßßßßßßßßß
        This  is  said  to  be the time when the file was built, but it isn't
 always.  Sometimes  it  is  the  time  that  the  linked file was built, but
 sometimes  it's  value differs. The difference appears again as a difference
 between  Borland linkers and Microsoft linkers. Sometimes this value is 0 if
 the  imported addresses are bound (we shall discuss what is bound later) and
 -1  if they are unbound. If the value is -1 the actual TimeDateStam is found
 in  another  structure  called  IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT,  which I
 looks almost the same.

 ş ID_ForwarderChain
 ßßßßßßßßßßßßßßßßßßß
        This  field  is used in forwarding. Sometimes, when you are calling a
 function  exported  by  a  DLL, this DLL actually imports that function from
 another  DLL  and actually forwards your application call to the next DLL. I
 wasn't  able  to find any file that forwards functions. This field is usualy
 set to -1 (no more forwards).

 ş ID_Name
 ßßßßßßßßß
        This  is the RVA to the DLL name which exports the functions imported
 by  the  application.  The DLL name is represented as an ASCIIZ string (like
 "KERNEL32.dll",0, for example).

 ş ID_FirstThunk
 ßßßßßßßßßßßßßßß
        This  field  is  a  RVA  to  an IMAGE_THUNK_DATA, which actually is a
 pointer to a IMAGE_IMPORT_BY_NAME.

        So, basically, if you read what you read once again, you nottice that
 there  exist  two RVAs which point to an array of pointers, each pointing an
 IMAGE_IMPORT_BY_NAME,  and  these are: ID_Characteristics and ID_FirstThunk.
 The idea is kinda like this:


                    IMAGE_IMPORT_DESCRIPTOR 1
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
       ÚÄÄÄÄÄÄÄÄÄÄÄ´  Characteristics        ³
       ³           ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³           ³  TimeDateStamp          ³
       ³           ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³           ³  ForwarderChain         ³
       ³           ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´     ÚÄÄÄÄÄÄÄÄÄÄÄ¿
       ³           ³  Name                   ÃÄÄÄÄ>³ dll name  ³
       ³           ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´     ÀÄÄÄÄÄÄÄÄÄÄÄÙ
       ³           ³  FirstThunk             ÃÄÄÄÄÄÄÄÄÄÄ¿
       ³           ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ          ³
       ³            IMAGE_IMPORT_DESCRIPTOR 2           ³
       ³            ...                                 ³
       ³            IMAGE_IMPORT_DESCRIPTOR T           ³
       ³                                                ³
 ÚÄÄÄÄÄvÄÄÄÄÄÄ¿   ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ÚÄÄÄÄÄvÄÄÄÄÄÄÄ¿
 ³  Pointer11 ÃÄÄ>³ Ordinal1  ³ FunctionName1 ³<ÄÄ´  Pointer21  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄ´   ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ³  Pointer12 ÃÄÄ>³ Ordinal2  ³ FunctionName2 ³<ÄÄ´  Pointer22  ³
 ÃÄÄÄÄÄÄÄÄÄÄÄÄ´   ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 |            |   |           |               |   |             |
 ³  Pointer1N ÃÄÄ>³ OrdinalN  ³ FunctionNameN ³<ÄÄ´  Pointer2N  ³
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÙ   ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
  (Array 1)                                         (Array 2)

        Basically,  the  import  descriptor  has  two  fields  that point two
 paralel  arrays  of  pointers, each pointer targeting a function ordinal and
 name.  But why do we need two parallel arrays pointing to the same data? The
 answer is simple. At load time, the loader looks up in the second array, the
 one  pointed  by  the FirstThunk and replaces each Pointer2x with the actual
 address  of  the  function inside the imported DLL. The other array, however
 remains untouched. There is a little thing to mention here also: do not rely
 ever  on  the first array! There are linkers, like TLINK32 which do not fill
 the   first   array,  as  Borland  realised  that  two  arrays  are  somehow
 unnecessary.  The  array  1  is  also  called Hint/Name table and array 2 is
 called thunk table.

        However,  the  problems  still go on. A normal situation like the one
 above,  with  the  FirstThunk  array pointing to function names gives us the
 so  called  unbound  imports.  These are the easiest to handle for the user.
 But,  there also exist the bound imports. I already explained to you how the
 loader  searches  for  the addresses of the imported functions and fills the
 thunk  table  with them. Sometimes this operation is done at link time. This
 means  that the thunk table will contain before loading the exact address of
 the imported functions, assuming that the DLL in discussion loads at a fixed
 address  (like  kernel32  in Win95/98). However, even so, it may happen that
 the  DLL  from  which  the  function get imported has to load at a different
 address,  or  the version of the DLL is different and the function addresses
 must be recalculated. The loader follows the following algorithm:

        1.If  the field TimeDateStamp is 0 then the values in the thunk table
 are not bound, and so the thunk table is refilled.

        2.If  the  field TimeDateStamp differs from 0, then the loader checks
 if  the  TimeDateStamp  from  the  DLL's  PE  header  is equal to this value
 (remember  that the timedate is an unique value). If it is equal and the DLL
 is loaded  at  it's  imagebase (from the PE header), then no readjustment is
 made   and the addresses remain bound. If somehow the value differs (the DLL
 is  a  different  version or the imagebase differs), the loader looks in the
 first  array  (hint/name  table)  and locates the function names, repatching
 then  the  values in the thunk table. Because of this, it is not impossible,
 but  not normal to have a PE file with the addresses bound and the hint/name
 table  strip.  If  this  happens  and the exporting DLL loads at a different
 address  or it is a different version, the loader will *not* be able to find
 the  names  or  ordinals  of  the  functions.  This kind of acting is called
 old-style binding.

        3.If the field TimeDateStamp equals -1, than we are also looking at a
 bound import table, but this time we are talking about new-style binding. In
 this  case  there  is no mark in the forwarding chains (I will explain those
 in  a minute) and all addresses are bound. In order to decipher these values
 one  must  look  into  another  section,  the  section  called  bound import
 directory  (the 12th entry, called DE_BoundImport). Here, in this section we
 have  a structure called IMAGE_BOUND_IMPORT_DESCRIPTOR. Using this structure
 you  can distinguish between the normal imported functions and the forwarded
 imported functions.


        The  IMAGE_IMPORT_DESCRIPTORS  are, as you can see in the scheme, one
 after  the  other,  and the last one is filled with zeroes. In order to find
 all  functions  imported  by  a  PE  file  one  needs  to  search all import
 descriptors until the null one, and for each one find the hint/name table or
 the  thunk  table and using these tables locate the address of the import by
 name structure. There, skip the ordinal and you find the function name.

        I  know  that  maybe this is a little hard to understand, but looking
 over the examples in the Annex will clear things up.


 ÄÄÄÄÄÄÄÄÄÄÄÄ
 Code section
 ÄÄÄÄÄÄÄÄÄÄÄÄ

        Code section, also called .code, .text or CODE is the place where the
 actual  code  of  the  PE  file  should  be  placed.  Of course, there is no
 certainity that the code is really here, but in most cases it is.


 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Resource section
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        This  section  is  found in most PE files which have run in GUI mode.
 The  resource is basically a piece of data with a specific use. For example:
 menus,  icons,  bitmaps, cursors, etc, are all resources. Each PE file needs
 and  uses a certain set of resources and this set is well defined inside the
 resource section. Usually this section is called ".rsrc".

        The  layout  of  the  resoruce section is somehow tricky, but however
 easy  to understand. It is tree based, just like directories on the hdd. The
 beginning of the resource section holds the root of resources and from there
 on  start  a  small  tree  for  each type of resource. There are a couple of
 resources predefined by the win32 system:

           RT_CURSOR           EQU 1
           RT_BITMAP           EQU 2
           RT_ICON             EQU 3
           RT_MENU             EQU 4
           RT_DIALOG           EQU 5
           RT_STRING           EQU 6
           RT_FONTDIR          EQU 7
           RT_FONT             EQU 8
           RT_ACCELERATOR      EQU 9
           RT_RCDATA           EQU 10
           RT_MESSAGETABLE     EQU 11
           DIFFERENCE          EQU 11
           RT_GROUP_CURSOR     EQU RT_CURSOR + DIFFERENCE
           RT_GROUP_ICON       EQU RT_ICON + DIFFERENCE
           RT_VERSION          EQU 16
           RT_DLGINCLUDE       EQU 17
           RT_PLUGPLAY         EQU 19
           RT_VXD              EQU 20
           RT_ANICURSOR        EQU 21
           RT_ANIICON          EQU 22
           RT_HTML             EQU 23

        Any other resource number is custom defined.

        Let  us peek the structures used here. The section contains a tree of
 IMAGE_RESOURCE_DIRECTORY   and   IMAGE_RESOURCE_DIRECTORY_ENTRY  structures.
 These point one to another creating a big tree:

 IMAGE_RESOURCE_DIRECTORY STRUC            ;
     RD_Characteristics      DD ?          ; unused
     RD_TimeDateStamp        DD ?          ; time of link
     RD_MajorVersion         DW ?          ; ...
     RD_MinorVersion         DW ?          ; ...
     RD_NumberOfNamedEntries DW ?          ; number of entries with names
     RD_NumberOfIdEntries    DW ?          ; number of entries with Ids
 IMAGE_RESOURCE_DIRECTORY ENDS             ;

 ş RD_Characteristics

        This field is unused and it is null.

 ş RD_TimeDateStamp
 ßßßßßßßßßßßßßßßßßß
        This represents the date time when the resource was created

 ş RD_MinorVersion
 ş RD_MajorVersion
 ßßßßßßßßßßßßßßßßß
        Resource version.

 ş RD_NumberOfNamedEntries
 ßßßßßßßßßßßßßßßßßßßßßßßßß
        This gives the total number of resources given by their name

 ş RD_NumerOfIdEntries
 ßßßßßßßßßßßßßßßßßßßßß
        This gives the total number of resources given by their ID.

        By  adding  the  RD_NumberOfNamedEntries  and RD_NumberOfIdEntries we
 obtain  a  number  (let's  say  X).  After  this  structure  we  will have X
 structures of type IMAGE_RESOURCE_DIRECTORY_ENTRY:


 IMAGE_RESOURCE_DIRECTORY_ENTRY STRUC      ;
         UNION                             ;
         STRUC                             ;
         RDE_Offset RECORD  {              ; this record is used to mask
         RDE_NameOffset:31                 ; thi high bit
         RDE_NameIsString:1 }              ;
         ENDS                              ;
         RDE_Name DD ?                     ;  (*)
         RDE_Id   DW ?                     ;  (*)
         ENDS                              ;
         UNION                             ;
         RDE_OffsetToData DD ?             ;  (*)
         STRUC                             ;
         RDE_Directory RECORD     {        ; this record is used to mask
         RDE_OffsetToDirectory:31          ; the high bit
         RDE_DataIsDirectory:1    }        ;
         ENDS                              ;
         ENDS                              ;
 IMAGE_RESOURCE_DIRECTORY_ENTRY ENDS       ;

        I  will  explain  shortly  the  Records there, but the main important
 thing are the fields marked by (*):

 ş RDE_Name
 ş RDE_ID
 ßßßßßßßßßß
        This  value  here  can  have  the  high  bit set, in which case it is
 interpreted  as  a  name  (the  rest  31  bits  represent an offset from the
 beginning  of  the  section  to  the  resource's  name, actually pointing an
 IMAGE_RESOURCE_DIRECTORY_STRING_U). If the  high  bit is clear, the value is
 interpreted as an ID.

 IMAGE_RESOURCE_DIR_STRING_U STRUC         ;
     RDSU_Length     DW ?                  ;
     RDSU_NameString DB 1 DUP (?)          ;
 IMAGE_RESOURCE_DIR_STRING_U ENDS          ;

 ş RDSU_Length
 ßßßßßßßßßßßßß
        Length of the following string.

 ş RDSU_NameString
 ßßßßßßßßßßßßßßßßß
        A  string  in  UNICODE  (!)  not  null  terminated. You might need to
 convert this into ASCII.


 ş RDE_OffsetToData
 ßßßßßßßßßßßßßßßßßß
        This  one is either an offset to the actual data, or an offset to the
 next  resource  directory,  an  offset  relative  to  the root of resources.
 Whenever  we  have  the  high  bit  set  it represents an offset to the next
 directory;  whenever  it  is  clear it represents an offset to the data. The
 offset   to   the   next   directory   is  actually  an  offset  to  another
 IMAGE_RESOURCE_DIRECTORY,  and  the  offset  to data is an offset to another
 structure  called  IMAGE_RESOURCE_DATA_ENTRY  (here we finally find the real
 data):

 IMAGE_RESOURCE_DATA_ENTRY STRUC           ;
     REDE_OffsetToData DD ?                ;
     REDE_Size         DD ?                ;
     REDE_CodePage     DD ?                ;
     REDE_Reserved     DD ?                ;
 IMAGE_RESOURCE_DATA_ENTRY ENDS            ;

 ş REDE_OffsetToData
 ßßßßßßßßßßßßßßßßßßß
        This  is  a  RVA  to  the  resource  data  (not  relative to the root
 directory  as  all other offsets in the resource directory, but a RVA to the
 imagebase,  thus  depending on where the file is loaded). At this offset you
 can find the particular data for each type of resource.

 ş REDE_Size
 ßßßßßßßßßßß
        Size of the resource data.

 ş REDE_CodePage
 ßßßßßßßßßßßßßßß
        Code page is used to find the language used.

        Now,  after  this little story, let me explain shortly how things are
 in the real world:

        1.The  root  is  a directory and holds pointers to other directories,
 one for each of the resource type used by the PE file.

        2.All  these  directories  will  have  a pointer  to other directories
 which point to subdirectories containing the language used for that resource
 type.

        3.For  each  language  there  exist  a resource entry which point the
 resource data.

        Let's see a scheme:

 ÚÄÄÄÄÄÄ¿                                                          ³
 ³ root ³                                                          ³
 ÀÄÄÂÄÄÄÙ                                                          ³ ROOT
    ³                                                          -------------
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿      ³
 ÚÄÄÁÄÄÄ¿                               ÚÄÄÁÄÄÄ¿         ÚÄÄÁÄÄÄÄÄ¿³
 ³ menu ³                               ³ icon ³         ³ bitmap ³³ LEVEL 1
 ÀÄÄÂÄÄÄÙ                               ÀÄÄÂÄÄÄÙ         ÀÄÄÂÄÄÄÄÄÙ³
    ³                                      ³                ³      ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                 ÃÄÄÄÄÂÄÄÄÄ¿      ³  -------------
 ÚÄÄÁÄÄÄ¿             ÚÄÄÁÄÄÄ¿            ÚÁÄÄ¿ÚÁÄÄ¿ÚÁÄÄ¿ ÚÄÁÄ¿    ³
 ³"file"³             ³"edit"³            ³01h³³02h³³01h³ ³01h³    ³ LEVEL 2
 ÀÄÄÂÄÄÄÙ             ÀÄÄÂÄÄÄÙ            ÀÄÂÄÙÀÄÂÄÙÀÄÂÄÙ ÀÄÂÄÙ    ³
    ³                    ³                  ³    ³    ³     ³      ³
    ÃÄÄÄÄÄÄÄÄÄ¿          ÃÄÄÄÄÄÄÄÄÄ¿        ³    ³    ³     ³  -------------
 ÚÄÄÁÄÄÄÄÄÄ¿ÚÄÁÄÄÄÄÄÄ¿ÚÄÄÁÄÄÄÄÄÄ¿ÚÄÁÄÄÄÄÄÄ¿ÚÁÄÄ¿ÚÁÄÄ¿ÚÁÄÄ¿ÚÄÁÄ¿    ³
 ³ english ³³ french ³³ english ³³ french ³³ D ³³ D ³³ D ³³ D ³    ³ LEVEL 3
 ÀÄÄÄÄÄÄÄÄÄÙÀÄÄÄÄÄÄÄÄÙÀÄÄÄÄÄÄÄÄÄÙÀÄÄÄÄÄÄÄÄÙÀÄÄÄÙÀÄÄÄÙÀÄÄÄÙÀÄÄÄÙ    ³

        D  means default in the example above. So, in order to locate all the
 resource  RVAs and data one must locate the resource section, browse through
 each  of  the  entries  in  the ROOT until level 3. Level 1 and Level 2 will
 always point to a new subdirectory. Only Level 3 points to the real data. By
 checking the Id in the first level you can know what resource are we talking
 about.  If  the  Id  is  one  of  the default defined ones, you can take the
 specific  action.  If  the  Id is custom or the resource is named, basically
 there  is  not  much  you  can do about it. By checking the Id in the second
 level  (and  here it is *always* an Id), this will give the language for the
 specified resource. The languages are defined as follows:

        This  would  be  about resources. To find an example on how to browse
 the resources check the Annex.


 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Relocations section
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        The  relocations  section  is very important especially in DLLs. As I
 explained  before, the PE files will always be able to load at the imagebase
 given  in  the header, due to specific mapping methods. Because of this, the
 relocations  are  useless  in PE executable file, they are obsolete and they
 are  sometimes  strip.  If  they  exist, usually the name of the relocations
 section is ".reloc" and usually it is the last section in the PE header.

        Let's check the structures here:

 IMAGE_RELOCATION_DATA   RECORD {            ; relocation data
     RD_RelocType        :4                  ; type
     RD_RelocOffset      :12    }            ; address

 IMAGE_BASE_RELOCATION   STRUC               ; base relocation
     BR_VirtualAddress   DD    ?             ; Virtual address
     BR_SizeOfBlock      DD    ?             ; size of relocation block
     BR_TypeOffset       IMAGE_RELOCATION_DATA 1 DUP (?) ; relocation data
 IMAGE_BASE_RELOCATION   ENDS                ;

 ş BR_VirtualAddress
 ßßßßßßßßßßßßßßßßßßß
        This  field  is  the  base  RVA  where  you have to apply this set of
 relocations (current chunk)

 ş BR_SizeOfBlock
 ßßßßßßßßßßßßßßßß
        This is the size of the block to apply the relocations too.

 ş BR_TypeOffset
 ßßßßßßßßßßßßßßß
        This  field  comes after the other two fields and is repeted N times,
 where  N equals (BR_SizeOfBlock-8)/2. The high 4 bits of this field gives us
 the relocation type, which can be one of the following:

 IMAGE_REL_BASED_ABSOLUTE      EQU 0 ; ignore, do not align
 IMAGE_REL_BASED_HIGH          EQU 1 ; apply to the high 16 bits
 IMAGE_REL_BASED_LOW           EQU 2 ; apply to the low 16 bits
 IMAGE_REL_BASED_HIGHLOW       EQU 3 ; apply to the entire dword
 IMAGE_REL_BASED_HIGHADJ       EQU 4 ; ?
 IMAGE_REL_BASED_MIPS_JMPADDR  EQU 5 ; ?
 IMAGE_REL_BASED_SECTION       EQU 6 ; ?
 IMAGE_REL_BASED_REL32         EQU 7 ; ?

        The  lower  12  bits  give  the address where the relocation is to be
 applied.  This  value must be added with the IMAGE_BASE_RELOCATION's virtual
 address, in order to have the RVA where to apply the relocation.

 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
 Annex: How to?
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

        In  this  Annex I will try to answer some simpe "how to..." questions
 which I think are most wanted. Think about all the definitions and equates I
 use  as  the once I explained in detail above. If you have troubles, read it
 again or get a grip on my .inc win32 files.

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 How to define the entire PE header in ASM?
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        MZHeader    IMAGE_DOS_HEADER      ?
        PeHeader    IMAGE_FILE_HEADER     ?
        PeOptHeader IMAGE_OPTIONAL_HEADER ?

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 How to address the values in the PE header?
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Let's  assume  that  ESI  holds  the address of the PE Header and EBX
 holds the image base where the file is loaded. These are some common ways of
 addressing values:

        mov eax, [esi.NumberOfSections]       ; obtain number of sections
        add esi, IMAGE_SIZEOF_FILE_HEADER     ; skip file header
        mov eax, [esi.OH_AddressOfEntryPoint] ; obtain EIP

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 How to locate the PE header?
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Let's assume ESI holds the imagebase:

        mov edi, [esi.MZ_lfanew]     ; obtain PE header offset
        add edi, esi                 ; align to imagebase

        EDI holds the address of the PE header.

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 How to locate the PE optional header?
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Assume EDI holds the address of the PE header.

        add EDI, IMAGE_SIZEOF_FILE_HEADER

        EDI holds the address of PE optional header.

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 How to check if there exist a PE header?
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Let's assume ESI holds the imagebase:

        cmp word ptr [esi], 'ZM'             ; check for valid DOS header
        jne not_ok                           ;
        cmp word ptr [esi.MZ_lfarc], 40h     ; check for NewExe mark
        jne not_ok                           ;
        mov edi, [esi.MZ_lfanew]             ; get pointer to PE header
        add edi, esi                         ; align with imagebase
        cmp [edi], 'EP'                      ; check the PE signature
        jne not_ok                           ;
 ok:                                         ;
        ...                                  ;
 not_ok:                                     ;
        ...                                  ;

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 How to read the PE Data directory?
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Let's assume EDI holds the address of the PE optional header

        mov esi, [edi.OH_DirectoryEntries]

        ESI holds the address of the Data Directory.

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 How to obtain the information from the Data Directory?
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Let's  assume  EDI  holds  the  address of the PE optional header and
 let's assume we are looking for values concerning the Import section:

        mov ebx, [edi.OH_DataDirectory.DE_IMPORT.DD_VirtualAddress]
        mov edx, [edi.OH_DataDirectory.DE_IMPORT.DD_VirtualSize]

        EBX  holds  the  Virtual Address of the Import Section, and EDX holds
 the Virtual Size of the Import Section.

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 How to locate the xth section header?
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Assume  ESI holds the address of the PE header, EDX holds the address
 of  the  first  section  header;  variable  sectionnr hold the number of the
 section we search:

       xor eax, eax                    ;
       mov ax, [esi.NumberOfSections]  ;
       cmp sectionnr, eax              ;
       ja section_error                ;
       mov esi, edx                    ;
       mov ecx, SIZE IMAGE_SECTION_HEADER
       mov eax, sectionnr              ;
       mul ecx                         ;
       add esi, eax                    ;
       jmp section_quit                ;
                                       ;
section_error:                         ;
       xor esi, esi                    ;
                                       ;
section_quit:                          ;

       ESI  will hold the address of the xth section header, or 0 if an error
 occured  (like we searched for a section number bigger than the total number
 of sections).

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 How to locate the xth section body?
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

       Let's  assume ESI holds the address of the xth section header. We have
 two  situations here. One is when the file was mapped using specific mapping
 methods and the file in memory looks like the file on disk. And there is the
 situation where the file was loaded using loading methods (like LoadLibrary)
 and the file in memory is aligned properly.

        For situation 1 we have:

        mov edi, [esi.SH_PointerToRawData]
        add edi, imagebase

        For situation 2 we have:

        mov edi, [esi.SH_VirtualAddress]
        add edi, imagebase

        So, EDI will now hold a pointer to the start of the section body. The
 imagebase is the address where the file was loaded or opened.


 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 How to locate an exported function?
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Let us think of how to locate a given function knowing it's name.

        So,  basically  what do we have? We have three arrays that have the
 same  number  of  elements. One points to the function address, one to the
 function name and one to the function ordinal.

        Let  us  assume that ESI points the beginning of the export section
 and EBX holds the imagebase of the file. This example will show you how to
 find  the  address  of  the "AllocConsole" Api, assuming we are looking up
 into the Kernel32.dll export table:

 mov edi, [esi.ED_AddressOfNames]     ; take address of names
 add edi, ebx                         ; and align to imagebase
 mov ecx, [esi.ED_NumberOfFunctions]  ; take the maximum number of functions
 mov index, 0                         ; and set index to zero
 push esi                             ; save the export address
                                      ;
 loop_:                               ;
 push edi                             ; save
 push ecx                             ; save
 mov edi, [edi]                       ; take one address to a name from the
 add edi, ebx                         ; name array and align it to imagebase
 mov esi, offset our_function         ; this is the function we search
 mov ecx, our_function_length         ; and its length.
 rep cmpsb                            ; compare!
 je found                             ; if found -> go!
 pop ecx                              ; otherwise restore values
 pop edi                              ;
 add edi, 4                           ; and get next entry
 inc index                            ; increment index in array
 loop loop_                           ;
 jmp not_found                        ; if loop is finished the search is
                                      ; a failure
 found:                               ; if found...
 pop ecx                              ; restore registers
 pop edi                              ;
 pop esi                              ;
 mov ecx, index                       ; take index (*)
 mov eax, dword ptr [esi.ED_AddressOfOrdinals]; get address of ordinals
 add eax, ebx                         ; and align to imagebase
 shl ecx, 1                           ; double index as we look in a word
 add eax, ecx                         ; array. Go there...
 xor ecx, ecx                         ;
 mov cx, word ptr [eax]               ; take the ordinal
 mov eax, dword ptr [esi.ED_AddressOfFunctions]; take address of funcs.
 add eax, ebx                         ; align to imagebase
 shl ecx, 2                           ; we look in a dword array
 add eax, ecx                         ; go to the function addr
 mov eax, [eax]                       ; take it's address
 add eax, ebx                         ; and align it to imagebase

 ...

 not_found:

 ...

 our_function db 'AllocConsole', 0
 our_function_length = $-offset our_function
 index dd 0

        So,  in 40 lines we were able to retrive the address of an API from
 the  kernel32.dll  module. Using the same method you can retrive the name,
 address or ordinal of any function.

        Knowing  the  ordinal  it is even simpler. Just use the code starting
 from  (*)  and  put in the 'index' variable the value of the ordinal you are
 searching.

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 How to locate an imported function?
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Let's  assume  ESI  points  the import section and variable imagebase
 holds  the  image base where the file was loaded (assume a file loaded using
 file  open,  so that we can assume the RawData pointers are good, instead of
 the  virtual  ones). Here I will show you how too look up all imports. Check
 the places with (*) to see what we can retrieve:

       mov esi, [esi.SH_PointerToRawData]         ; get pointer to section
       add esi, imagebase                         ; data
                                                  ;
imports_loop:                                     ;
       cmp dword ptr [esi], 0                     ; is the import directory
       mov ebp, esi                               ; strip?
       je no_imports                              ;
                                                  ;
ready_import:                                     ;
       mov edi, [ebp.ID_Name]                     ; get a pointer to a DLL
       add edi, imagebase                         ; name... EDI holds it!!(*)
                                                  ;
       mov edi, [ebp.ID_OriginalFirstThunk]       ; get pointer in array#1
       mov ebp, [ebp.ID_FirstThunk]               ; get pointer in array#2
       add edi, imagebase                         ;
       add ebp, imagebase                         ;
       pushad                                     ;
                                                  ;
rep_imported_names:                               ;
       cmp dword ptr [edi], 0                     ; no more names?
       je no_more_names                           ;
                                                  ;
       push ebp                                   ;
       mov esi, [edi]                             ; get pointer to ordinal
       add esi, imagebase                         ; ESI points to function
                                                  ; ordinal!  (*)
                                                  ;
       add esi, 2                                 ; now point function name
                                                  ; ESI points to name! (*)
       mov eax, [ebp]                             ; EAX holds function
                                                  ; address!!! (*)
       pop ebp                                    ;
       add edi, 4                                 ; get next pointer
       add ebp, 4                                 ; get next pointer
       jmp rep_imported_names                     ;
                                                  ;
no_more_names:                                    ;
       popad                                      ;
                                                  ;
       jmp imports_loop                           ;
                                                  ;
no_imports:                                       ;

        So,  the  above  code  basically browses through all the modules from
 which  the  file  imports  functions,  and  all  function names. Now you can
 compare  the different strings (like module name or function names) and save
 their addresses for later use.

        Please  note  that  in  this example not all error avoiding steps are
 taken  care  of.  For  example,  a pointer to a function name could have the
 highest  bit set (TEST ..., 8000000h), which means that actually there is no
 pointer to a name, but instead there is an ordinal. To avoid this we can use
 whenever  we  have  pointers and we are not sure that they point accordingly
 the apis IsBadReadPtr and IsBadStringPtrA.

 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 How to browse the resources?
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     call parse_resource_directory                  ; parse all
     jmp go_on                                      ; go furthure...
                                                    ;
parse_resource_directory:                           ;
     xor ecx, ecx                                   ;
     mov cx, word ptr [esi.RD_NumberOfNamedEntries] ; NamedEntries+IdEntries
     add cx, word ptr [esi.RD_NumberOfIdEntries]    ; is our counter
                                                    ;
     add esi, IMAGE_RESOURCE_DIRECTORY_SIZE         ; skip resource dir
                                                    ;
parse_this_one:                                     ;
     push ecx                                       ; save counter
     push esi                                       ; save address
     call parse_resource                            ; parse the dir
     pop esi                                        ; restore address
     pop ecx                                        ; restore counter
     add esi, 8                                     ; get next entry
     loop parse_this_one                            ; loop until cx=0
     ret                                            ; return
                                                    ;
parse_resource:                                     ;
     mov eax, [esi.RDE_OffsetToData]                ; get offset to data
     mov esi, edi                                   ; get base of resorurces
     test eax, 80000000h                            ; is it a subdirectory?
     jz data_is_resource                            ;
                                                    ;
data_is_directory:                                  ;
     xor eax, 80000000h                             ; if it is a subdirectory
     add esi, eax                                   ; find it's address and
     sub esi, 10h                                   ;
     call parse_resource_directory                  ; go to parse it too...
     ret                                            ;
                                                    ;
data_is_resource:                                   ; if it is data, then
     add esi, eax                                   ; find out it's address
     sub esi, 10h                                   ;
     mov eax, dword ptr [esi.REDE_OffsetToData]     ; (!!!!)
     ret                                            ; and ret...
                                                    ;
go_on:                                              ;

        So,  at  the  (!!!!)  point  you  have the address of the data of the
 resource.  One  should know the layout of each resource to be able to use or
 alter it.


                                            ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                                            ³   Lord Julus - 1999    Û
                                            ÀÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÛ
