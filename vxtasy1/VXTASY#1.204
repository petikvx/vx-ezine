  __________________________________________________________________________
 (__________________________________________________________________________)
 { __ }   { __ }        |                            |        { __ }   { __ }
  |\\|     |\\|    .----O----------------------------O----.    |//|     |//|
  |\\|     |\\|    |        Assembling and Linking        |    |//|     |//|
  |\\|     |\\|    `--------------------------------------'    |//|     |//|
 {____}   {____}                                              {____}   {____}


        ๐ Warning ๐

        This  warning  goes  for  experienced  programmers:  skip this. It is
 designed  for  beginners. It is intended to show a better and quicker way to
 compile and link the Win32 applications.

     ฺฤฤฤฤฤฤฤฤฤฟ
     ณ  Basic  ณ
     ภฤฤฤฤฤฤฤฤฤู

        This  short  little article was written for the real beginners. Those
 people  who  didn't move from 16bit programming towards 32bit, but those who
 start  coding  Win32. For them I thought it would be a nice idea to show all
 the  insides  in  compiling and linking a Win32 file. As I am a Borland fan,
 with  all  the  NASM madness out there, I will present the TASM situation. I
 have no time for MASM now, but most of the stuff is the same.

        I  am  pretty  sure  that  nobody  had time to read the official TASM
 documentation. I know, it is pretty dull and pretty long. Here I will try to
 show  you  that  you  only  need to know about 40 lines with all to help you
 quickly compile you win32 applications.

        So,  the  basic basic is the input. The input file is your .ASM file.
 This file must be converted in the second input file, the .OBJ. This is done
 using the compiler.

        The TASM32 compiler has the following sintax:

        TASM32 [options] source [,object] [,listing] [,xref]

 /a,/s          Alphabetic or Source-code segment ordering
 /c             Generate cross-reference in listing
 /dSYM[=VAL]    Define symbol SYM = 0, or = value VAL
 /e,/r          Emulated or Real floating-point instructions
 /h,/?          Display this help screen
 /iPATH         Search PATH for include files
 /jCMD          Jam in an assembler directive CMD (eg. /jIDEAL)
 /kh#           Hash table capacity # symbols
 /l,/la         Generate listing: l=normal listing, la=expanded listing
 /ml,/mx,/mu    Case sensitivity on symbols: ml=all, mx=globals, mu=none
 /mv#           Set maximum valid length for symbols
 /m#            Allow # multiple passes to resolve forward references
 /n             Suppress symbol tables in listing
 /os,/o,/op,/oi Object code: standard, standard w/overlays, Phar Lap, or IBM
 /p             Check for code segment overrides in protected mode
 /q             Suppress OBJ records not needed for linking
 /t             Suppress messages if successful assembly
 /uxxxx         Set version emulation, version xxxx
 /w0,/w1,/w2    Set warning level: w0=none, w1=w2=warnings on
 /w-xxx,/w+xxx  Disable (-) or enable (+) warning xxx
 /x             Include false conditionals in listing
 /z             Display source line with error message
 /zi,/zd,/zn    Debug info: zi=full, zd=line numbers only, zn=none

        For our type of application, the sufficent sintax is this:

        TASM32 /ml /m <file.asm>

        The  /ml option assures that the symbols are case sensitive. In Win32
 this  is  a  rule.  The  /m  option  allows  multiple passes so that forward
 refferences can be solved.

        After  this  operation  and if it was finished without any errors, we
 will  have  a file called <file>.OBJ. This is the file which we will pass to
 the linker in order to obtain our final executable.

        The TLINK32 linker has the following sintax:

       TLINK32 objfiles, exefile, mapfile, libfiles, deffile, resfiles

   -m      Map file with publics     -x       No map
   -s      Detailed segment map      -L       Specify library search paths
   -M      Map with mangled names    -j       Specify object search paths
   -c      Case sensitive link       -v       Full symbolic debug information
   -Enn    Max number of errors      -n       No default libraries
   -P-     Disable code packing      -H:xxxx  Specify app heap reserve size
   -B:xxxx Specify image base addr   -Hc:xxxx Specify app heap commit size
   -wxxx   Warning control           -S:xxxx  Specify app stack reserve size
   -Txx    Specify output file type  -Sc:xxxx Specify app stack commit size
           -Tpx  PE image            -Af:nnnn Specify file alignment
                 (x: e=EXE, d=DLL)   -Ao:nnnn Specify object alignment
   -ax     Specify application type  -o       Import by ordinals
           -ap Windowing Compatible  -Vd.d    Specify Windows version
           -aa Uses Windowing API    -r       Verbose link

        Again, our options to use, for the moment, are these:

        TLINK32 -Tpe -aa -c -x <file.obj>,,,<path>\import32.lib

        The  -Tpe  option  assures  the output of an EXE file. The -aa option
 means an application using Windows APIs. The -c option is the case sensitive
 option.  -x  makes  the linker forget about the unneeded map file. Note that
 you  might  want  to use the -ap option instead of -aa, whenever you want to
 design  an  application  to  run in the character system (for example if you
 want to output strings to the DOS screen from the Win32 application).

        The  import32.lib  file  is  a file that ships together with the TASM
 package.  It  represents  the  file  where  from  the linker will "suck" the
 imports from various DLLs. I will explain how to create the libs later.

        Now, lets concentrate on quicker linking.

     ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
     ณ  Module-Definition file  ณ
     ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู

        As  you can see from the TLINK32 sintax, you can specify a definition
 file  by  the  name  <file>.DEF. This file has crucial information about how
 your  file  should get linked. If this file isn't mentioned TLINK32 will use
 the default settings.

        The  layout  of  the  .DEF  file  is  very  simple. You have a string
 specifying the setting you want to alter followed by a string or number that
 gives its value.

        Let's see what settings can we alter, using the official Borland
 documentation, and then we shall look at an example.


 CODE statement
 ออออออออออออออ

        CODE  defines  the default attributes of code segments. Code segments
 can  have  any  name,  but must belong to segment classes whose name ends in
 CODE (such as CODE or MYCODE). The syntax is:

 CODE            [PRELOAD|LOADONCALL]
                 [EXECUTEONLY|EXECUTEREAD]

        -'EXECUTEONLY'   means   a   code   segment  can  only  be  executed.
 'EXECUTEREAD' (the default) means the code segment can be read and executed.

        -'PRELOAD'  means  the  segment  is  loaded  when the module is first
 loaded. 'LOADONCALL' (the default) means the segment is loaded when called.


 DATA statement
 ออออออออออออออ

 DATA defines attributes of data segments. The syntax is:

         DATA [NONE | SINGLE | MULTIPLE]
              [READONLY | READWRITE]
              [PRELOAD | LOADONCALL]
              [SHARED | NONSHARED]

        -'NONE'  means  that there is no data segment created. This option is
 available  only  for  libraries.  'SINGLE'  (the  default for .DLLs) means a
 single  data segment is created and shared by all processes. 'MULTIPLE' (the
 default for .EXEs) means a data segment is created for each process.

        -'READONLY' means the data segment can be read only. 'READWRITE' (the
 default) means the data segment can be read and written to.

        -'PRELOAD'  means  the data segment is loaded when a module that uses
 it  is  first  loaded.  'LOADONCALL' (the default) means the data segment is
 loaded when it is first accessed (this is ignored for 32-bit applications).

        -'SHARED'  (the  default for 16-bit .DLLs) means one copy of the data
 segment is shared among all processes. 'NONSHARED' (the default for programs
 and  32-bit  .DLLs)  means  a  copy  of  the data segment is loaded for each
 process needing to use the data segment.


 DESCRIPTION statement
 อออออออออออออออออออออ

        DESCRIPTION  (optional)  inserts text into the application module and
 is  typically  used  to  embed  author,  date, or copyright information. The
 syntax is:

         DESCRIPTION 'Text'

 'Text' is an ASCII string delimited with single quotes.


 EXETYPE statement
 อออออออออออออออออ

        EXETYPE  defines  the  default executable file (.EXE) header type for
 16-bit application. You can leave this section in for 32-bit application for
 backward  compatibility, but if you need to change the EXETYPE, refer to the
 NAME statement. The syntax for EXETYPE is:

         EXETYPE  WINDOWS


 EXPORTS statement
 อออออออออออออออออ

        EXPORTS defines the names and attributes of functions to be exported.
 The  EXPORTS  keyword  marks  the  beginning  of  the definitions. It can be
 followed  by  any number of export definitions, each on a separate line. The
 syntax is:

         EXPORTS ExportName [Ordinal] [RESIDENTNAME] [Parameter]

        -'ExportName' specifies an ASCII string that defines the symbol to be
 exported:

         EntryName [=InternalName]

        'InternalName'  is  the  name used within the application to refer to
 this  entry.  'EntryName'  is the name listed in the executable file's entry
 table and is externally visible.

        -'Ordinal' defines the function's ordinal value as follows:

         @ordinal

        where  'ordinal'  is  an  integer value that specifies the function's
 ordinal value.

        When  an  application  or DLL module calls a function exported from a
 DLL,  the  calling  module  can  refer to the function by name or by ordinal
 value.  It's  faster  to  refer  to  the  function by ordinal because string
 comparisons  aren't  required  to  locate  the function. To use less memory,
 export a function by ordinal (from the point of view of that function's DLL)
 and import/call a function by ordinal (from the point of view of the calling
 module).

        When  a  function  is  exported  by  ordinal, the name resides in the
 nonresident  name  table.  When  a  function  is  exported by name, the name
 resides  in the resident name table. The resident name table for a module is
 in memory whenever the module is loaded; the nonresident name table isn't.

        -'RESIDENTNAME'  specifies  that the function's name must be resident
 at  all  times. This is useful only when exporting by ordinal (when the name
 wouldn't be resident by default).

        -'Parameter'  is  an optional integer value that specifies the number
 of words the function expects to be passed as parameters.


 IMPORTS statement
 อออออออออออออออออ

        IMPORTS  defines the names and attributes of functions to be imported
 from  DLLs.  Instead  of  listing  imported  DLL  functions  in  the IMPORTS
 statement, you can do the following:

        -Specify an import library for the DLL in the TLINK command line, or

        -Include the import library for the DLL in the project manager in the
 IDE.


        The  IMPORTS  keyword  marks  the beginning of the definitions; it is
 followed  by  any number of import definitions, each on a separate line. The
 syntax is:

         IMPORTS  [InternalName=]ModuleName.Entry

        -'InternalName' is an ASCII string that specifies the unique name the
 application uses to call the function.

        -'ModuleName'  specifies  one or more uppercase ASCII characters that
 define the name of the executable module containing the function. The module
 name  must  match  the  name  of  the executable file. For example, the file
 SAMPLE.DLL has the module name SAMPLE.

        -'Entry'  specifies  the  function  to  be  imported--either an ASCII
 string  that  names  the  function  or  an integer that gives the function's
 ordinal value.


 LIBRARY statement
 อออออออออออออออออ

        LIBRARY  defines  the  name of a DLL module. A module-definition file
 can  contain  either  a  LIBRARY  statement  to  indicate  a  DLL  or a NAME
 statement to indicate a program.

        A  library's  module name must match the name of the executable file.
 For example, the library MYLIB.DLL has the module name MYLIB. The syntax is:

         LIBRARY LibraryName [INITGLOBAL | INITINSTANCE]

        -'LibraryName' (optional) is an ASCII string that defines the name of
 the  library module. If you don't include a LibraryName, TLINK uses the file
 name  with  the  extension  removed.  If the module-definition file includes
 neither  a  NAME  nor  a  LIBRARY  statement, TLINK assumes a NAME statement
 without a ModuleName parameter.

        -'INITGLOBAL' means the library-initialization routine is called only
 when  the  library  module is first loaded into memory. 'INITINSTANCE' means
 the  library-initialization  routine  is called each time a new process uses
 the library.


 NAME statement
 ออออออออออออออ

        NAME  is  the name of the application's executable module. The module
 name   identifies   the   module   when   exporting  functions.  For  32-bit
 applications,  NAME  must  appear  before EXETYPE. If NAME and EXETYPE don't
 specify  the same target type, the type listed with NAME is used. The syntax
 is:

         NAME  ModuleName [WINDOWSAPI] | [WINDOWCOMPAT]

        -'ModuleName'  (optional)  specifies  one  or  more  uppercase  ASCII
 characters  that name the executable module. The name must match the name of
 the  executable  file.  For example, an application with the executable file
 SAMPLE.EXE has the module name SAMPLE.

        If  ModuleName  is missing, TLINK assumes the module name matches the
 file name of the executable file. For example, if you don't specify a module
 name  and  the  executable file is named MYAPP.EXE, TLINK assumes the module
 name is MYAPP.

        If  the  module-definition file includes neither a NAME nor a LIBRARY
 statement, TLINK assumes a NAME statement without a ModuleName parameter.

        -'WINDOWAPI'  is  a  Windows  executable,  and  is  equivalent to the
 TLINK32 option /aa.

        -'WINDOWCOMPAT'  is  a  Windows-compatible character-mode executable,
 and is equivalent to the TLINK32 option /ap.


 SEGMENTS statement
 ออออออออออออออออออ

        SEGMENTS  defines  the segment attributes of additional code and data
 segments. The syntax is:

         SEGMENTS
                 SegmentName [CLASS 'ClassName'] [MinAlloc]
                 [SHARED | NONSHARED]
                 [PRELOAD | LOADONCALL]

        -'SegmentName'  is  a character string that names the new segment. It
 can be any name, including the standard segment names _TEXT and _DATA, which
 represent the standard code and data segments.

        -'ClassName'  (optional)  is the class name of the specified segment.
 If no class name is specified, TLINK uses the class name CODE.

        -'MinAlloc'  (optional)  is  an  integer  that  specifies the minimum
 allocation size for the segment. TLINK and TLINK32 ignore this value.

        -'SHARED'  (the  default  for  16-bit  .DLLs)  means  one copy of the
 segment is shared among all processes. 'NONSHARED' (the default for programs
 and  32-bit  .DLLs)  means  a copy of the segment is loaded for each process
 needing to use the data segment.

        -'PRELOAD'   means   that   the   segment   is   loaded  immediately;
 'LOADONCALL'  means that the segment is loaded when it is accessed or called
 (this  is  ignored  by  TLINK32).  The  resource compiler might override the
 LOADONCALL option and preload segments instead.


 STACKSIZE statement
 อออออออออออออออออออ

        STACKSIZE  defines  the number of bytes needed by the application for
 its  local  stack.  An  application  uses  the local stack whenever it makes
 function   calls.   Don't  use  the  STACKSIZE  statement  for  dynamic-link
 libraries. The syntax is:

         STACKSIZE bytes

        bytes is an integer value that specifies the stack size in bytes.


 STUB statement
 ออออออออออออออ

        STUB  appends  a  DOS  executable  file  specified by FileName to the
 beginning  of the module. The executable stub displays a warning message and
 terminates  if  the  user  attempts  to run the executable stub in the wrong
 environment (running a Windows application under DOS, for example).

        Borland  C++  adds  a  built-in  stub  to  the beginning of a Windows
 application  unless  a  different stub is specified with the STUB statement.
 You  shouldn't  use  the  STUB  statement to include WINSTUB.EXE because the
 linker does this automatically. The syntax is:

         STUB 'FileName'

        'FileName'  is  the name of the DOS executable file to be appended to
 the module. The name must have the DOS file name format.

        If  the  file named by FileName isn't in the current directory, TLINK
 searches  for  the file in the directories specified by the PATH environment
 variable.


 Module-definition file defaults
 อออออออออออออออออออออออออออออออ

 If no module-definition file is specified, the following defaults are
 assumed:

         CODE            PRELOAD MOVEABLE DISCARDABLE
         DATA            PRELOAD MOVEABLE MULTIPLE (for applications)
                         PRELOAD MOVEABLE SINGLE (for DLLs)
                         HEAPSIZE        4096
                         STACKSIZE       1048576



        After this, maybe complicated description, let's see an example of a
 definition file:

 MYAPP.DEF
 ;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
 NAME         MYAPP WINDOWSAPI             ฤฤฤฤฤฤฤฤ> App. name and type

 DESCRIPTION  'Win32 Application'          ฤฤฤฤฤฤฤฤ> short description

 CODE         PRELOAD MOVEABLE DISCARDABLE ฤฤฤฤฤฤฤฤ> code section charact.
 DATA         PRELOAD MOVEABLE MULTIPLE    ฤฤฤฤฤฤฤฤ> data section charact.

 EXETYPE      WINDOWS                      ฤฤฤฤฤฤฤฤ> Windows application

 HEAPSIZE     4096                         ฤฤฤฤฤฤฤฤ> Heap size
 STACKSIZE    131072                       ฤฤฤฤฤฤฤฤ> Stacksize
 ;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ

        In order to link our application now, we must do the following:

        TLINK32 -Tpe -cc myapp.asm,,,import32.lib,myapp.def

        Note  that  we  don't  need  the  -aa  statement,  because it is also
 specified  in the module definition file (WINDOWSAPI). So, you see how using
 the  module  definition  file  you  can quickly modify the way your exe gets
 linked and obtain exactly what you want.

      ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
      ณ  Even quicker  ณ
      ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู

        Even  with  the  module  definition file, compiling and linking still
 requires  you  to  type  long  lines.  However, there exist a way you can do
 everything only by typing one single word: MAKE...

        The  MAKE  utility  is pretty complex, but easy to understand. I will
 not  present the make command line here, because we are looking for a method
 of  using make as short as posible, basically with no command line. The make
 utility  will search for a file called "makefile" (or "makefile.mak") in the
 current  directory  and will interpret it. Using the information inside, the
 compiler and the linker will perform their actions.

        The makefile will contain:

        -  Comments
        -  Explicit rules
        -  Implicit rules
        -  Macros
        -  Directives


 Symbolic targets
 ออออออออออออออออ

        A symbolic target forces MAKE to build multiple targets in a makefile
 (you  don't  need to rely on linked dependencies). The dependency line lists
 all  the  targets  you  want  to  build.  You  don't type any commands for a
 symbolic target.

        In the following makefile, the symbolic target "allFiles" builds both
 FILE1.EXE and FILE2.EXE:

  allFiles: file1.exe file2.exe     #Note this target has no commands.
  file1.exe: file1.obj
        tlink32 file1.obj
  file2.exe: file2.obj
        tlink32 file2.obj


 Rules for symbolic targets
 อออออออออออออออออออออออออออ

 Observe the following rules with symbolic targets:

        - Symbolic targets don't need a command line.

        -Give  your  symbolic target a unique name; it can't be the name of a
 file in your current directory.

        -Name  symbolic  targets  according to the operating system rules for
 naming files.


 Explicit and implicit rules
 อออออออออออออออออออออออออออ

        The  explicit  and  implicit  rules  that instruct MAKE are generally
 defined as follows:

        -Explicit rules give MAKE instructions for specific files.

        -Implicit  rules  give general instructions that MAKE follows when it
 can't find an explicit rule.

        Rules follow this general format:

        Dependency line
                   Commands

        The dependency line is different for explicit and implicit rules, but
 the commands are the same.

        MAKE  supports  multiple  rules for one target. You can add dependent
 files  after  the first explicit rule, but only one should contain a command
 line. For example:

  Target1: dependent1 dep2 dep3 dep4 dep5
  Target1: dep6 dep7 dep8
    bcc -c $**


 Explicit rule syntax
 ออออออออออออออออออออ

        Explicit  rules  are  instructions  to  MAKE  that specify exact file
 names.  The  explicit  rule names one or more targets followed by one or two
 colons.  One colon means one rule is written for the target; two colons mean
 that two or more rules are written for the target.

 Explicit rules follow this syntax:

  target [target...]:[:][{path}] [dependent[s]...]
         [commands]

 -  target      The name and extension of the file to be updated
                ("target" must be at the start of the line--no spaces or
                tabs are allowed). One or more targets must be
                separated by spaces or tabs. Don't use a target's name
                more than once in the target position of an explicit
                rule in a makefile.

 -  path        A list of directories, separated by semicolons and
                enclosed in braces, that points to the dependent files.

 -  dependent   The file (or files) whose date and time MAKE checks to
                see if it is newer than "target" (dependent must be
                preceded by a space). If a dependent file also appears
                in the makefile as a target, MAKE updates or creates
                the target file before using it as a dependent for
                another target.

 -  commands    Any operating system command. Multiple commands are
                allowed in a rule. Commands must be indented by at
                least one space or tab.

        If  the  dependency or command continues on to the next line, use the
 backslash  (\)  at  the  end  of the line after a target or a dependent file
 name. For example:

  MYSOURCE.EXE: FILE1.OBJ\
                FILE2.OBJ\
                FILE3.OBJ
                bcc file1.obj file2.obj file3.obj


 Single targets with multiple rules
 ออออออออออออออออออออออออออออออออออ

        A  single  target  can have more than one explicit rule. You must use
 the  double colon (::) after the target name to tell MAKE to expect multiple
 explicit rules. The following example shows how one target can have multiple
 rules and commands:

  .cpp.obj:
        bcc -c -ncobj $<

  .asm.obj:
        tasm  /mx $<, asmobj\\

  mylib.lib :: f1.obj f2.obj
        echo Adding C files
        tlib mylib -+cobj\f1 -+cobj\f2

  mylib.lib :: f3.obj f4.obj
        echo Adding ASM files
        tlib mylib -+asmobj\f3 -+asmobj\f4


 Implicit rule syntax
 ออออออออออออออออออออ

        An  implicit rule starts with either a path or a period and implies a
 target-dependent   file   relationship.   Its   main   components  are  file
 extensions  separated  by  periods.  The  first  extension  belongs  to  the
 dependent, the second to the target.

        If  implicit dependents are out-of-date with respect to the target or
 if  they  don't  exist, MAKE executes the commands associated with the rule.
 MAKE updates explicit dependents before it updates implicit dependents.

 Implicit rules follow this basic syntax:

  [{source_dirs}].source_ext[{target_dirs}].target_ext:
     [commands]

  -  {source_dirs}      The directory of the dependent files.
                        Separate multiple directories with a semicolon.

  -  .source_ext        The dependent file-name extension.

  -  {target_dirs}      The directory of the target (executable) files.
                        Separate multiple directories with a semicolon.

  -  .target_ext        The target file-name extension. Macros are allowed.

  -  :                  Marks the end of the dependency line.

  -  commands           Any operating system command. Multiple commands
                        are allowed. Commands must be indented by one
                        space or tab.

        If  two  implicit  rules  match  a  target extension but no dependent
 exists,  MAKE  uses  the  implicit  rule whose dependent's extension appears
 first in the .SUFFIXES list.


 Explicit rules with implicit commands
 อออออออออออออออออออออออออออออออออออออ

        A  target  in  an  explicit  rule  can  get  its command line from an
 implicit  rule. The following example shows an implicit rule and an explicit
 rule without a command line:

  .c.obj:
     bcc -c $<     #This command uses a macro $< described later.

  myprog.obj:      #This explicit rule uses the command: bcc -c myprog.c

        The  implicit  rule command tells MAKE to compile MYPROG.C (the macro
 $< replaces the name "myprog.obj" with "myprog.c").


 Commands syntax
 อออออออออออออออ

        Commands  can  be  any  operating  system  command, but they can also
 include  MAKE  macros,  directives,  and  special  operators  that operating
 systems  can't  recognize  (note that | can't be used in commands). Here are
 some sample commands:

  cd..
  bcc -c mysource.c
  COPY *.OBJ C:\PROJECTA
  bcc -c $(SOURCE)     #Macros are explained later in the chapter.

 Commands follow this general syntax:

        [prefix...] commands


 Command prefixes
 ออออออออออออออออ

        Commands  in  both implicit and explicit rules can have prefixes that
 modify  how MAKE treats the commands. The following table lists the prefixes
 you can use in makefiles:

 Option          Description
 ------          -----------
 @               Don't display command while it's being executed.

 -<num>          Stop processing commands in the makefile when the
                 exit code returned from command exceeds <num>.
                 Normally, MAKE aborts if the exit code is nonzero.
                 No white space is allowed between - and <num>.

 -               Continue processing commands in the makefile,
                 regardless of the exit code returned by them.

 &               Expand either the macro $**, which represents all
                 dependent files, or the macro $?, which represents
                 all dependent files stamped later than the target.
                 Execute the command once for each dependent file
                 in the expanded macro.


 Using @
 อออออออ

        The following command uses the modifier @, which prevents the command
 from displaying onscreen when MAKE executes it.

  diff.exe : diff.obj
            @bcc diff.obj


 Using -num and -
 ออออออออออออออออ

        The  "-num"  and  "-"  modifiers  control MAKE processing under error
 conditions.  You  can  choose  to continue with the MAKE process if an error
 occurs or only if the errors exceed a given number.

        In  the following example, MAKE continues processing if BCC isn't run
 successfully:

  target.exe : target.obj
  target.obj : target.cpp
               bcc -c target.cpp


 Using &
 อออออออ

        The  &  modifier issues a command once for each dependent file. It is
 especially  useful  for  commands  that  don't  take  a  list  of  files  as
 parameters. For example,

 copyall : file1.cpp file2.cpp
           &copy $** c:\temp

 results in COPY being invoked twice as follows:

  copy file1.cpp c:\temp
  copy file2.cpp c:\temp

        Without the & modifier, COPY would be called only once.

 Command operators
 อออออออออออออออออ

        You  can use any operating system command in a MAKE commands section.
 MAKE  uses  the  normal operators (such as +, -, and so on), but it also has
 other operators you can use.

 Operator        Description
 --------        -----------
 <               Take the input for use by "command" from
                 "file" rather than from standard input.

 >               Send the output from "command" to "file".

 >>              Append the output from "command" to "file".

 <<              Create a temporary, inline file and use
                 its contents as standard input to
                 "command".

 &&              Create a temporary file and insert its
                 name in the makefile.

 delimiter       Any character other than # and \ used
                 with << and && as a starting and ending
                 delimiter for a temporary file. Any
                 characters on the same line and
                 immediately following the starting
                 delimiter are ignored. The closing
                 "delimiter" must be written on a line by
                 itself.



 Using MAKE macros
 อออออออออออออออออ

        A  MAKE  macro is a string that is expanded (used) wherever the macro
 is  called  in a makefile. Macros let you create template makefiles that you
 can change to suit different projects. For example, to define a macro called
 LIBNAME  that represents the string "mylib.lib," type "LIBNAME = mylib.lib".
 When MAKE encounters the macro "$(LIBNAME)", it uses the string "mylib.lib".

        If  MAKE  finds  an  undefined  macro  in a makefile, it looks for an
 operating-system  environment  variable  of  that name (usually defined with
 SET)  and  uses  its  definition  as the expansion text. For example, if you
 wrote  "$(path)"  in a makefile and never defined "path", MAKE would use the
 text  you  defined  for PATH in your AUTOEXEC.BAT. (See the manuals for your
 operating system for information on defining environment variables.)


 Defining macros
 อออออออออออออออ

        The general syntax for defining a macro in a makefile is:

        MacroName = expansion_text

  -  "MacroName" is case-sensitive and is limited to 512 characters.

  -  "expansion_text" is limited to 4096 characters consisting of
     alpha-numeric characters, punc-tuation, and white space.

        Each  macro  must  be  on  a  separate line in a makefile. Macros are
 usually  put  at  the  top  of  the  makefile.  If  MAKE finds more than one
 definition for a "macroName", the new definition replaces the old one.

        Macros  can  also  be  defined using the command-line option -D. More
 than  one macro can be defined by separating them with spaces. The following
 examples show macros defined at the command line:

  make -Dsourcedir=c:\projecta
  make command="bcc -c"
  make command=bcc option=-c

        The  following  differences in syntax exist between macros entered on
 the command line and macros written in a makefile.

                        Makefile    ณ   Command line
                        ฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
 Spaces allowed before              ณ
 and after =             Yes        ณ    No
                                    ณ
 Space allowed before               ณ
 macroName               No         ณ    Yes


 Using a macro
 อออออออออออออ

        To  use a macro in a makefile, type "$(MacroName)" where MacroName is
 the name of a defined macro. You can use braces {} and parentheses () to

        MAKE  expands  macros at various times depending on where they appear
 in the makefile:

  -  Nested macros are expanded when the outer macro is invoked.

  -  Macros in rules and directives are expanded when MAKE first looks at
     the makefile.

  -  Macros in commands are expanded when the command is executed.


 String substitutions in macros
 ออออออออออออออออออออออออออออออ

        MAKE  lets  you  temporarily  substitute  characters  in a previously
 defined  macro.  For  example,  if  you  defined  a  macro  called SOURCE as
 "SOURCE  =  f1.cpp  f2.cpp f3.cpp", you could substitute the characters .OBJ
 for  the  characters  .CPP  by using "$(SOURCE:.CPP=.OBJ)". The substitution
 doesn't redefine the macro.

 Rules for macro substitution:

  -  Syntax: $(MacroName:original_text=new_text)

  -  No whitespace before or after the colon.

  -  Characters in "original_text" must exactly match the characters in the
     macro definition; this text is case-sensitive.

        MAKE now lets you use macros within substitution macros. For example:

  MYEXT=.C
  SOURCE=f1.cpp f2.cpp f3.cpp
  $(SOURCE:.cpp=$(MYEXT))         #Changes f1.cpp to f1.C, etc.


 Default MAKE macros
 อออออออออออออออออออ

        MAKE  contains  several default macros you can use in your makefiles.
 The  following  table  lists  the macro definition and what it expands to in
 explicit and implicit rules.

 Macro ณ Expands in implicit:    Expands in explicit:    Example
 ฤฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
 $*    ณ path\dependent file     path\target file        C:\PROJ\MYTARGET
       ณ
 $<    ณ path\dependent file+ext path\target file+ext    C:\PROJ\MYTARGET.OBJ
       ณ
 $:    ณ path for dependents     path for target         C:\PROJ
       ณ
 $.    ณ dependent file+ext      target file + ext       MYSOURCE.C
       ณ
 $&    ณ dependent file          target file             MYSOURCE
       ณ
 $@    ณ path\target file+ext    path\target file+ext    C:\PROJ\MYSOURCE.C
       ณ
 $**   ณ path\dependent file+ext all dependents file+ext F1.CPP F2.CPP F3.CPP
       ณ
 $?    ณ path\dependent file+ext old dependents          FILE1.CPP
       ณ

 Macro      ณ    Expands to:     Comment
 ฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
 __MSDOS__  ณ    1               If running under DOS.
            ณ
 __MAKE__   ณ    0x0370          MAKE's hex version number.
            ณ
 MAKE       ณ    make            MAKE's executable file name.
            ณ
 MAKEFLAGS  ณ    options         The options typed at the
            ณ                    command line.
            ณ
 MAKEDIR    ณ    directory       Directory where MAKE.EXE is
            ณ                    located.


 Modifying default macros
 ออออออออออออออออออออออออ

        When  the  default  macros listed in the preceding table doesn't give
 you  the  exact  string  you  want, macro modifiers let you extract parts of
 the string to suit your purpose.

        To modify a default macro, use this syntax:

        $(MacroName [modifier])

        The  following  table  lists macro modifiers and provides examples of
 their use.

 Modifier        Part of file name expanded      Example Result
 ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
 D               Drive and directory             $(<D)   C:\PROJECTA\

 F               Base and extension              $(<F)   MYSOURCE.C

 B               Base only                       $(<B)   MYSOURCE

 R               Drive, directory, and base      $(<R)   C:\PROJECTA\MYSOURCE


 Using MAKE directives
 อออออออออออออออออออออ

        MAKE  directives  resemble  directives  in  languages  such  as C and
 Pascal,  and  perform various control functions, such as displaying commands
 onscreen  before  executing  them.  MAKE  directives  begin  either  with an
 exclamation  point  or  a  period. The following table lists MAKE directives
 and   their   corresponding   command-line   options   (directives  override
 command-line   options).   Each   directive  is  described  in  more  detail
 following the table.

 Directive       Option          Description
 ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
 .autodepend     -a              Turns on autodependency checking.

 !elif                           Acts like a C "else if".

 !else                           Acts like a C "else".

 !endif                          Ends an "!if", "!ifdef", or "!ifndef"
                                 statement.

 !error                          Stops MAKE and prints an error message.

 !if                             Begins a conditional statement.

 !ifdef                          If defined that acts like a C "ifdef", but
                                 with macros rather than "#define" directives.

 !ifndef                         If not defined.

 .ignore         -i              MAKE ignores the return value of a command.

 !include                        Specifies a file to include in the makefile.

 !message                        Lets you print a message from a makefile.

 .noautodepend   -a-             Turns off autodependency checking.

 .noIgnore       -i-             Turns off ".Ignore".

 .nosilent       -s-             Displays commands before MAKE executes them.

 .noswap         -S-             Tells MAKE not to swap itself out of memory
                                 before executing a command.

 .path.ext                       Tells MAKE to search for files with the
                                 extension .ext in path directories.

 .precious                       Saves the target or targets even if the
                                 build fails.

 .silent         -s              Executes without printing the commands.

 .suffixes                       Determines the implicit rule for ambiguous
                                 dependencies.

 .swap           -S              Tells MAKE to swap itself out of memory
                                 before executing a command.

 !undef                          Clears the definition of a macro.


 Using macros in directives
 ออออออออออออออออออออออออออ

        The  macro  $d  is used with the !if conditional directive to perform
 some  processing  if  a  specific  macro is defined. The $d is followed by a
 macro  name,  enclosed  in  parentheses or braces, as shown in the following
 example.

  !if $d(DEBUG)                #If DEBUG is defined,
  bcc -v f1.cpp f2.cpp         #compile with debug information;
  !else                        #otherwise (else)
  bcc -v- f1.cpp f2.cpp        #don't include debug information.
  !endif


        Now,  after  looking  at the official make documentation, let's see a
 makefile for our example:

 ;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
 #       make -B                 Will build wap32.exe
 #       make -B -DDEBUG         Will build the debug version of wap32.exe

 NAME = MYAPP                        # application name
 OBJS = $(NAME).obj                  # define the OBJ (myapp.obj)
 DEF  = $(NAME).def                  # define de def file (myapp.def)
                                     #
 !if $d(DEBUG)                       # for DEBUG mode
 TASMDEBUG=/zi /m /l                 #     TASM options
 LINKDEBUG=/v                        #     TLINK options
 !else                               # for NON-DEBUG mode
 TASMDEBUG=/m /l                     #     TASM options
 LINKDEBUG=                          #     TLINK options
 !endif                              #
                                     #
 !if $d(MAKEDIR)                     # the import library
 IMPORT=$(MAKEDIR)import32.lib       #
 !else                               #
 IMPORT=import32.lib                 #
 !endif                              #
                                     #
                                     #
 $(NAME).EXE: $(OBJS) $(DEF)         # We get our exes from OBJ and DEF
   tlink32 /Tpe /aa /c $(LINKDEBUG) $(OBJS),$(NAME),, $(IMPORT), $(DEF)
                                     # the TLINK32 command line
                                     #
 .asm.obj:                           #
    tasm32 $(TASMDEBUG) /ml $&.asm   # the TASM32 command line
 ;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ

        This was it!! Easy...

        Shortly,  one  must specify the definitions for the filenames, insert
 them in the command line for the compiler and the linker and that's it...

        Note  that my examples for the .DEF and MAKEFILE files can be applied
 to  almost  all  of  your  win32  applications. One should create a separate
 directory  for  each  Win32  application  and  have  this  sort of directory
 structure:

        -myapp.asm
        -myapp.def
        -makefile
        -<different include files>

        Now, just type MAKE and... Voila!!!

        Check the utilities directories for live examples!

        Have fun and enjoy your Win32...

        NB:  I  promised  something  and  I forgot to tell... About the 32bit
 libraries...  The  default TASM import32.lib file is actually a library that
 contains  names  and  ordinals for the functions exported by different dlls.
 Sometimes  it  may  contain  useless  exports  or  it could miss some... For
 example,  in  my  utilities  you  need  to  have import32.lib to contain the
 exports  from  IMAGEHLP.DLL,  which is not included by default. To make your
 own library use the IMPLIB.EXE utility that ships with TASM, like this:

  IMPLIB [options] libname[.lib] [@respfile | srcname] [srcname ...]

  Options:
     -c     Case sensitive symbols
     -f     Force imports by name (with hints)
     -i     Ignore WEP
     -o     Remove module extensions (16bit Windows)
     -w     No Warnings

        A good example is this:

 implib -c -w -f import32.lib kernel32.dll user32.dll shell32.dll gdi32.dll /
                              advapi32.dll imagehlp.dll

        Of  course,  you  must  issue  this  command  in  the  windows\system
 directory,  so  the  utility  is  able to find the dlls. You may include any
 other dlls for your own use.

                                            ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
                                            ณ   Lord Julus - 1999    
                                            ภ
