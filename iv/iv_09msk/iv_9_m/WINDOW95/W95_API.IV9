▄▄                   ▄
▀▀▀ STEALTH GROUP WW █ Mail:   BOX 15, 125080 MOSCOW   ████████ █████████ █▀▀█
▀██ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀ ▀▀▀▀▐▀▀▀   ┌─┐┬ ┬┌─┤┬ ┬ ╥ ┬┐┌ █▄▄█
 ▐█ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▄█▄ ▄▀▀ █▀█   ▌ █ ▄▀█ █ ▄▀▀ █▄▄    ├┬┘│ │└─┐├─┤   │└┤ ▄  █
  █ █ █ █▀  █▀  █    █  █▀  █ █   █ █ █ █ █ █   █      ┴└─└─┘└─┘┴ ┴   ┴ ┴ ▀▀▀▀
  █ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀    ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄▄   ████  WINTER ' 96  ████
  ▐ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄   ███████████████████████

°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°° ФОРТОЧКИ '95 - ОКНО В ... ?


                  Infection of Portable Executables
                                by
                      Qark and Quantum [VLAD]


  Формат portable executable используется Win32, Windows NT и Win95, что
  делает его очень популярным и возможно, в будущем, доминирующим форматом
  exe. NE header в Windows 3.11 полностью отличается от PE header и the two
  should not be  confused.

  Ни одна из нижеперечисленных технологий не была опробована на Windows NT,
  потому что мы не нашли человека, имеющего доступ к NT.

  В конце документа находится копия PE формата, являющегося доступным для
  всех. Turbo Debugger 32 (TD32) использовался при работе, а также часть
  работы была сделана с помощью SoftIce'95.

  Вызов Windows 95 API
  ────────────────────

  Обычные приложения вызывают win 95 api, используя import table.
  Имя API, необходимое для вызова, заносится в import table.
  Когда приложение загружено, данные, необходимые для вызова API, заносятся
  в import table. Как обьяснялось в Win 95 introduction (см. статью), мы
  не можем модифицировать эту таблицу благодаря предусмотрительности Микрософта.

  Эта проблема решается непосредственным вызовом kernel.
  Нам необходимо полностью игнорировать структуру вызова  и переходить
  непосредственно на dll entrypoint.

  Чтобы получить handle dll/exe (названный module), можно использовать
  вызов API GetModuleHandle, другие функции для получения entrypoint 
  модуля - включая функцию получения адреса API, GetProcAddress.

  Но тут встает вопрос "курицы или яйца". Как я вызываю API, имея возможность
  вызывать его, и в то же время такой возможности не имея ? Ответ прост :
  вызывать api, известный нам в памяти - API в файле KERNEL32.DLL - по 
  постоянным адресам.

  Немного кода
  ─────────

  Вызов API законными приложениями выглядит примерно так:

        call APIFUNCTIONNAME
eg.     call CreateFileA

  Этот вызов ассемблируется в:

        db 9ah          ; инструкция call
        dd ????         ; смещение в jump table

  Код в jump table похож на:

        jmp far [offset into import table]

  Смещение в import table содержит адрес диспетчера для данной функции API.
  Этот адрес можно получить с помощью GetProcAddress API.
  Диспетчер функций выглядит так:

        push function value
        call Module Entrypoint

  Здесь находятся функции API получения точки входа для каждого именованного
  модуля, но функция нам недоступна. Если мы вызываем функции KERNEL32.DLL
  ( там находятся все функции, необходимые для заражения executables), нам
  нужно взглянуть не далее, чем на этот call. Мы просто push'им значение
  функции и вызываем entrypoint модуля.
  
  Snags
  ─────

  На последних этапах создания Bizatch мы провели бета-тестинг на многих
  системах. После долгого процесса тестирования выяснилось, что модуль 
  KERNEL32 располагается в памяти статически - точно, как мы предполагали,
  но местоположение в "June Test Release" отличается от "Full August Release".
  Мы поставили проверку на это. Более того, одна функция (получение времени/
  даты) отличалась номером. Для компенсации этих различий я добавил проверку
  на 2 различных местоположения KERNEL32, но если kernel не найден, вирус
  возвращает управление программе-носителю.

  Адреса и номера функций.
  ──────────────────────────────

  Для June Test Release kernel найден по адресу 0BFF93B95h;
  для August Release                       -    0BFF93C1Dh

  Function              June            August
  ──────────────────────────────────────────────────
  GetCurrentDir       BFF77744         BFF77744
  SetCurrentDir       BFF7771D         BFF7771D
  GetTime             BFF9D0B6         BFF9D14E
  MessageBox          BFF638D9         BFF638D9
  FindFile            BFF77893         BFF77893
  FindNext            BFF778CB         BFF778CB
  CreateFile          BFF77817         BFF77817
  SetFilePointer      BFF76FA0         BFF76FA0
  ReadFile            BFF75806         BFF75806
  WriteFile           BFF7580D         BFF7580D
  CloseFile           BFF7BC72         BFF7BC72


  Можно найти другие значения функции, используя Turbo Debugger 32bit из
  комплекта Tasm v4.0.

  Соглашения о вызовах (Calling Conventions)
  ───────────────────

  Windows 95 написан на C++ и Assembler, в основном на C++. И, хотя 
  соглашения о вызовах просты для применения, Microsoft их не использует.
  Все API под Win95 используют Pascal Calling Convention. 
  Например, API, описанный в Visual C++ help files:

        FARPROC GetProcAddress(
                HMODULE  hModule,   		// handle to DLL module
                        LPCSTR  lpszProc        // имя функции
        );

  На первый взгляд кажется, что все, что вам нужно - это заPush'ить 
  handle, стоящий перед ( followed by) указателем на имя функции и вызвать
  API - не тут-то было. Параметры, согласно Pascal Calling Convention, должны
  быть заPush'ены в обратном порядке"

          push offset lpszProc
          push dword ptr [hModule]
          call GetProcAddress

  Используя TD 32bit мы можем оттрассировать call и найти вызов kernel,
  такой, какой был указан выше. Это позволит нам получить номер функции
  and we can do away with the need for an entry in the import table.


  Заражение файлов формата PE
  ──────────────────────────

  Нахождение начала PE header'а происходит аналогично нахождению начала NE,
  проверкой DOS relocations на 40h или больше, и поиском dword указателя по
  смещению 3ch. 'NE' - для Windows 3.11, 'PE' - для Win32/WinNT/Win95.

  Внутри PE header находится Таблица Обьектов, ее формат наиболее важен 
  нам из всех форматов. Для добавления своего кода в носитель и перехвата
  управления нас ебя (на себя :) необходимо добавить элемент в Таблицу
  Обьектов. К счастью, Мелкомягкие "поехали" на округлении до 32 битной
  границы, так что для нас всегда найдется место, и не потребуется сдвигать
  эти двинутые таблицы.
  
  Основные понятия заражения PE:

        Найти смещение заголовка PE в файле
        Считать достаточное количество заголовка для вычисления его полного
		размера
	Считать весь PE header и Таблицу Обьектов
        Добавить новый обьект в Таблицу Обьектов
        Установить точку входа RVA на новый обьект
        Дописать вирус к файлу по вычисленному физическому смещению
        Записать измененный PE header в файл

  Для нахождения таблицы обьектов:
   Переменная 'Header Size' (не путать с 'NT headersize') - рамер заголовков
   DOS, PE и Таблицы Обьектов вместе.
   Для считывания таблицы обьектов необходимо считать HeaderSize байт от
   начала файла.

   Таблица обьектов следует непосредственно за NT Header'ом.
   Значение 'NTheadersize' показывает количество байт, следующих за полем
   'flags'. Итак, для нахождения смещения Таблицы обьектов получите 
   NTheaderSize и добавьте размер поля флагов (24).

  Добавление обьекта:
   ПолучИте 'number of objects' (количество обьектов) и помножьте это на 5*8
   (размер элемента таблицы обьектов). Таким образом, вы узнаете смещение,
   по которому будет помещен обьект вируса.
   
   Данные для элемента таблицы обьектов должны быть вычислены с использованием
   информации в предыдущем элементе (элементе носителя).

   RVA             = ((prev RVA + prev Virtual Size)/OBJ Alignment+1)
                                                               *OBJ Alignment
   Virtual Size    = ((size of virus+buffer any space)/OBJ Alignment+1)
                                                               *OBJ Alignment
   Physical Size   = (size of virus/File Alignment+1)*File Alignment
   Physical Offset = prev Physical Offset + prev Physical Size
   Object Flags    = db 40h,0,0,c0h
   Entrypoint RVA  = RVA
   
   Увеличьте на 1 поле 'количества обьектов'.

   Запишите код вируса по вычисленному 'физическому смещению', в размере
  'physical size' байт.

  Замечания
  ─────────

  Microsoft больше не включает информацию о заголовке PE в своих developers
  CDROM'ах.  Они думают, что это сделает написание вирусов под Win95 менее
  интересным. Информация, содержащаяся в следующей статье, взята из Beta
  CDROM Win32 SDK.


  Инструменты
  ───────────

  Существует много неплохих книг, дающих представление о низкоуровневом
  программировании под Windows 95.
  "Unauthorized Windows 95", хотя и не особенно полезная (в ней больше
  рассказывается о взаимодействии DOS/Windows), обеспечивает нас утилитами
  на диске и на своих WWW, что весьма превосходно для тех, кто исследует
  вирусы под Win95.