┌────────────────┬──┬────────┬─────────────────────────────┬─────────────────┐
│INFECTED MOSCOW │#1│ JAN'97 │(C)STEALTH Group MoscoW & Co │ one@redline.ru  │
└────────────────┴──┴────────┴─────────────────────────────┴─────────────────┘
┌──────────────────────────────────────────────────┬────────────────────────┐
│ ШИФРОВАНИЕ МЕТОДОМ КУБА                          │ (C) Zipper             │
└──────────────────────────────────────────────────┴────────────────────────┘

" - Ой, @#$, щас ведь с нового года закон выйдет, вот @#$$#@ будет, надо все
шифровать у себя на винте.
  - А чем ?
  - DiskReet'ом или PGP.
  - Раскроют ...
  - Как ?
  - Так !
  - ???"

     Вот такой базар был,  когда мы очередной раз возвращались со сходки, тог-
да я подумал, почему бы не написать про метод, который я давно  обдумывал,  но
никак не хотел открывать. Но, так как, встал вопрос о новом алгоритме, я поду-
мал, а почему бы и не поделиться соображениями по данной теме. Так вот, я  из-
ложу здесь алгоритм, а Вы уж решите каков  он, совсем дохлый  или  всетаки  им
можно зашифровать хоть что-нибудь. =)
     Итак,  все  по-порядку,  назовем этот метод ну хотя бы "Метод криптования
кубом". Почему, "кубом", потому что мы будем криптовать его в трехмерной  сис-
теме координат, что очень необычно для криптования файлов. Для начала предста-
вим что наш файл поток данных, который не является одним  целым, а  просто  он
нечто такое, чем мы можем оперировать разбивая его на  части  по  определенным
правилам. Тоесть для начала нам нужно определить полную длину файла, потом  по
таблице или по формуле вычислить оптимальный куб для нашего файла.  Ниже  дана
краткая таблица, тут кажется все просто: X*Y*Z=1_куб

                            ╔══════╦══════════╗
                            ║ 1    ║ 1*1*1    ║
                            ║ 8    ║ 2*2*2    ║
                            ║ 27   ║ 3*3*3    ║
                            ║ 64   ║ 4*4*4    ║
                            ║ 125  ║ 5*5*5    ║
                            ║ 216  ║ 6*6*6    ║
                            ║ 343  ║ 7*7*7    ║
                            ║ 512  ║ 8*8*8    ║
                            ║ 729  ║ 9*9*9    ║
                            ║ 1000 ║ 10*10*10 ║
                            ╚══════╩══════════╝

     Формула проста как пень, ну так вот, а теперь самое интересное, наш  файл
мы разделяем на кубы различных размеров, первый куб самый  большой,  далее  мы
получаем остаток и извлекаем из него куб, и так до тех пор пока у нас останет-
ся совсем маленький остаток, из которого уже сложно извлечь куб, его то мы бу-
дем шифровать отдельно. Далее в 1_куб мы помещаем наши "крипторы", точнее ука-
затели на байт, который мы хотим криптовать. Наши  указатели  должны  иметь  2
свойства:
     - трехмерный размер;
     - направление движение;

     Под "трехмерным размером"  подразумевается  количество  байт  которое  мы
криптуем  за один шаг, т.е. чисто визуально метод криптования выглядит  так:
в одном большом кубе двигаются несколько маленьких кубиков,  различных  разме-
ров, которые могут проходить через соседние подвижные кубики, но через  стенки
куба они не имеют возможности проскочить. Стенки являются для  них  преградой,
от которой они отталкиваются.
     Под "направлением движения" подразумевается  диагональные  оси  движения,
так как выбор у нас небольшой, то таких осей у нас 4, остальные не несут в се-
бе существенной пользы, так как по правилам физики, кубик по такой  оси  будет
ползать от стенки до стенки, что нам не очень то поможет.
     Так вот, когда мы разобрались чем криптовать, нужно посмотреть как  крип-
товать. Как было сказано выше, кубики двигаются по кубу, за один шаг мы выпол-
няем любую операцию, sub, xor, add. В общем  такую,  которую  можно  выполнить
второй раз и получить преждний результат. Задав расположение кубиков и их  оси
движения мы начинаем перемещать их по кубу, при этом криптуя при  каждом  шаге
тот "объем", где находится кубик. Передвигая несколько тысяч  раз  кубики,  по
нашему кубу мы добиваемся полного уничтожения "линейной  структуры"  криптова-
ния, т.е. если к нам полезут плохие дядки, они долго будут ломать головы  "ка-
кая тут последовательность".
     Итак, прогоняв кубики по кубу, мы запоминаем их состояние и по нему выво-
дим пароль. Без знания этого пароля, хрен кто расставит кубики в  нужных  мес-
тах, ведь количество трехмерных позиций и вариантов огромно, очень огромно ...
     Для устрашения можно еще поставить в  генерацию  пароля  привязку  к  на-
чальным положениям кубиков, чем еще усложним задачу плохим дядкам.
     После того, как мы решили что прогоняли наши кубики по первому кубу  дос-
таточно, мы запоминаем часть пароля в укромном месте, и переходим  ко  второму
кубу, т.е. остатку файла. Итак проделываем дальше со всеми кубами, после  того
как мы затрэшели всю информацию, мы вспоминаем про наш самый  маленький  оста-
ток, и подвергаем его криптованию в произвольной форме.
     В конце нам выдается пароль, который содержит:
 - размер файла;
 - количество кубов;
 - размер остатка;
 - количество кубиков;
 - свойства кубиков;
 - количество шагов для каждого куба (а можно и не делать, а вычислять по фор-
муле для кубов различных величин)

     Получив этот пароль мы запоминаем его и храним в тайне,  для  того  чтобы
потом ввести его и получить наш файл обратно.
     Вот такие у меня соображения по теме криптования, если вдруг найдется че-
ловек, который захочет написать сей заумный метод, пусть пишет его скорей, так
как закон уже ...

                                                         ╔═════════╗
                                                         ║Mr.Zipper║█
                                                         ╚═════════╝█
                                                           ▀▀▀▀▀▀▀▀▀▀