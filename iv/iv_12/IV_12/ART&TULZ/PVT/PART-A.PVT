
      ▄▄                  █
     ▀▀▀  Virus Magazine  █ Box 176, Kiev 210, Ukraine      IV   1998
     ▀██ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀ ▀▀▀▀▐▀▀▀  █▀▀▀▀▀▀▀█
      ▐█ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▄█▄ ▄▀▀ █▀█    ▌ █ ▄▀█ █ ▄▀▀ █▄▄   █ █ ▀▀█ █
       █ █ █ █▀  █▀  █    █  █▀  █ █    █ █ █ █ █ █   █     █ █ ▄▄█ █
       █ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀     ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄▄  █ █ █▄▄ █
       ▐ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄  █▄▄▄▄▄▄▄█
          (C) Copyright, 1994-98, by STEALTH group WorldWide, unLtd.

                      HLL (High Level Language) virii.
             Вирусы, написанные на ЯВУ (Языках Высокого Уровня).


                      "Не догонишь - не поймаешь, не догнал - не воровали,
                       Без труда не выбьешь зубы, не продашь, не наебешь.
                       Эту песню не задушишь, не убьешь"

                                          Янка Дягилева, "Гори, гори ясно"


1. HLL-вирусы. Разделение на классы.

        Вирусы, написанные на языках высокого  уровня  (High Level
Language) подразделяются на 3 вида, 1 и 3 вид подразделяются на
два подвида:

1. HLLC - вирусы-спутники (Companion).
1.1. Вирусы, не производящие никаких операций с инфицируемой программой.
1.2. Вирусы, в той или иной мере изменяющие инфицируемую программу.

2. HLLO - вирусы, записывающиеся поверх кода программ (Overwrite).

3. HLLP - вирусы, внедряющиеся в программу (Parasitic).
3.1. Вирусы, заражающие программы методом сдвига.
3.2. Вирусы, заражающие программы методом переноса.

        Первый вид вирусов получил свое название "спутники" из-за алгоритма
размножения.
        Первый подвид данного вида размножается следующим образом:
для каждого инфицируемого .EXE файла в каталоге, где находится .EXE файл,
создается файл с вирусным кодом, имеющий такое же имя, что и .EXE файл,
но расширение .COM. Если в командной строке указано только имя исполняемого
файла, его выполнение в среде DOS происходит следующим образом: сначала
DOS ищет в текущем каталоге файл с указанным именем и расширением .COM,
затем, если .COM файл с таким именем не найден, ищется .EXE файл, если
не найдет .EXE файл, ищется .BAT (пакетный) файл. Если в текущем каталоге
DOS не находит исполняемого файла с указанным именем, поиск производится
во всех каталогах, доступных по переменной PATH. То есть когда пользователь
хочет запустить программу и набирает в командной строке только ее имя
(из-за лени, и в основном так поступают все пользователи ПК), первым
управление получает вирусный код, находящийся в .COM файле, создает
.COM файл еще к одному или нескольким .EXE файлам, а затем исполняет
.EXE файл с таким же именем. Пользователь же думает, что исполняется
только запущенная .EXE программа. Вирус-спутник первого подвида вылечить
довольно просто, достаточно удалить .COM файл.
        Второй подвид данного вида несколько продвинут и размножается
так: инфицируемый .EXE файл переименовывается в файл с таким же именем,
но с любым другим расширением, отличным от явно исполняемых (.COM, .EXE и
.BAT). Например, .DAT (файл данных) или .OVL (программный оверлей). Затем
на место .EXE файла копируется вирусный код. При запуске такой инфицирован-
ной программы получает управление вирусный код, находящийся в .EXE файле,
инфицирует еще один или несколько .EXE файлов таким же образом, затем
возвращает оригинальному файлу исполняемое расширение (но не .EXE, а
.COM, поскольку .EXE файл с таким именем занят вирусом), и исполняет его.
После исполнения файлу возвращается расширение неисполняемого файла.
Лечение данного подвида может быть затруднено, если вирус-спутник
зашифрует часть или все тело инфицируемого файла, а перед исполнением
будет его расшифровывать. Тут уж без поллитры не обойдешься... ;)

        Второй вид вирусов является давно забытым раритетом, так как
имеет один огромный недостаток - инфицированные программы не исполняются,
поскольку вирус записывается поверх программного кода, не сохраняя его.
При запуске вирус ищет очередную жертву (или жертвы), открывает их
на запись и записывает свое тело в начало программы, не сохраняя
оригинальный код. После этого вирус возвращает управление в ДОС.
Инфицированные программы лечению не подлежат. Больше сказать об
этом виде вирусов нечего.

        Третий вид вирусов (parasitic) является самым продвинутым, так
как код вируса вписывается в инфицируемую программу, что существенно
затрудняет его лечение по сравнению с лечением первых двух типов.
        Первый подвид данного вида (вирус, заражающий методом сдвига)
инфицирует программы следующим образом: тело инфицируемой программы
считывается в память, затем на место инфицируемой программы записывается
вирусный код, а после кода вируса записывается код инфицируемой программы.
Таким образом, код программы как бы "сдвигается" в файле на длину кода
вируса. Отсюда и название метода - "метод сдвига". При запуске
инфицированного файла вирус инфицирует еще один или несколько файлов,
затем считывает в память код программы, создает на диске временный файл
с расширением исполняемого файла (.COM или .EXE), вписывает в него код
программы и затем исполняет созданный файл. Когда программа выполнилась,
вирус удаляет временный файл. Если не применять дополнительных приемов
защиты от излечения в вирусе, то вылечить инфицированный файл очень
просто - достаточно удалить код вируса в начале файла, и программа снова
окажется работоспособной. Мне данный метод не нравится тем, что приходится
считывать в память весь код инфицируемой программы (а ведь бывают монстры
размером больше 1Мб, например, foxpro.exe, тут у нас наступит облом),
да и у "метода переноса" больше приколов и возможностей.
        Второй подвид parasitic вирусов (вирус, заражающий методом
переноса) является, на мой взгляд, самым продвинутым видом из всех
перечисленных. Вирус второго подвида размножается следующим способом:
при запуске инфицированной программы вирусный код считывает в память
тело вируса из программы, с которой вирус стартовал, затем находит
неинфицированную программу, считывает в память ее начало, по длине
равное телу вируса, на место считанного в память начала программы (в
начало файла) вписывается тело вируса, считанное начало программы
дописывается к концу файла. Отсюда название метода - "метод переноса".
После того, как вирус инфицировал один или несколько файлов, он
приступает к исполнению программы, с которой он запустился. Для
этого он считывает начало инфицированной программы, сохраненное в
конце файла, и вписывает его в начало файла, восстанавливая таким
образом работоспособность программы. Затем вирус удаляет код начала
программы из конца файла, восстанавливая оригинальную длину файла
и исполняет программу. После завершения программы вирус вновь
записывает свой код в начало файла, а оригинальное начало
программы - в конец. Этим методом можно инфицировать даже антивирусы,
которые проверяют свой код на целостность, потому что запускаемая
вирусом программа имеет в точности такой же код, как и до инфицирования.
Применив некоторые приемы, описанные в этом руководстве, можно существен-
но затруднить лечение вирусов, использующих данный метод.


2. Базовые знания, необходимые для написания простейшего вируса на
     Паскале.

     Из стандартного пакета модулей Турбо Паскаля (находящихся в
файле turbo.tpl) для написания вируса необходимы только два
модуля - модуль System, из которого нам необходимы процедуры
работы с файлами и каталогами (модуль System автоматически подклю-
чается в любую программу при компиляции) и модуль DOS - в нем нам
нужны функции "Выполнить программу (Exec)", "Получить/установить
вектор прерывания (Get/SetIntVec)" и пр. Также необходимо помнить
некоторые переменные и константы этих модулей.

                            Модуль System

procedure Assign(var f; name : string);

Присваивает имя внешнего файла файловой пeременной. (Не путать с
открытием файла, для этого существует отдельная процедура!)
Для открытия файла на Паскале необходимо выполнить две процедуры:

     Assign(_F , 'PROGRAM.EXE');
     Reset(_F);

     Только тогда будет открыт.

procedure Reset(var f [ : file;
                recsize : Word ] );

Открывает существующий файл. Для текстового файла параметр recsize
не нужен, для открытия бинарного recsize указывает размер записи
для процедур BlockRead (Чтение из файла) и BlockWrite (Запись в
файл). Если recsize для бинарного файла указан не будет, то берется
значение по умолчанию - 255 (0ffh). Результат открытия файла возвраща-
ется функцией IOResult, если после открытия файла она равна нулю - при
открытии не было ошибок, иначе в IOResult содержится номер ошибки.

function IOResult : Word;

 Возвращает целое значение - состояние послед-
 ней операции ввода-вывода.

Пример:
        ......

        Assign(_F , 'PROGRAM.EXE');
        Reset(_F , 1);
        If IOResult <> 0 Then GoTo Error; { если не получилось
        открыть файл, переходим к дальнейшим действиям, иначе }
        InfectFile; { заражаем открытый файл }
Error:
        ......

procedure BlockRead(var f: file; var buf;
                     count : Word
                     [; var result: Word])

  Считывает одну или более записей в массив или
  переменную. f - файловая переменная, buf (буфер)
  любая переменная, count (счетчик) выражение
  типа Word и result (результат) - переменая
  типа Word.

То есть, для применения в вирусе, f - это открытый файл, buf - это
массив типа char (символьный тип), count - сколько recsize нужно считать
из файла (если файл открывается с recsize = 1 (Reset(_F , 1), то count
указывает количество байт, которые нужно считать из файла). Параметр
result после выполнения процедуры содержит реальное количество считанных
байт, и может применятся для проверки, не произошла ли ошибка при чтении.

        Var
           VirBuf : Array [1..VirLen] Of Char; { VirLen - константа,
           содержащая длину вируса }
           ......
           Res : Word; { Переменная, подставляемая в параметр result }

        ......

        BlockRead(_F , VirBuf , VirLen , Res);
        If VirLen <> Res Then WriteLn('Ошибка чтения!');

procedure BlockWrite(var f: file;
                      var buf; count: Word
                      [; var result: Word])

  Записывает одну или более записей из массива или перемен-
  ной, где f это файловая переменная, buf
  (буфер) - переменная любого типа, count
  (счетчик) - выражение типа Word, и result
  (результат) переменная типа Word.

То же, что и для BlockRead, только этой процедурой мы будем записывать
тело вируса из буфера в файл.

procedure Close(var f);

  Закрывает открытый файл. Нет комметаpиев ;)

procedure ChDir(s : string);

Выполняет смену текущего каталога.
В переменной S указывается путь.

procedure Exit;

Осуществляет немедленный выход из текущего
блока. (прооцедуры или функции). Если текущий
блок это основная программа, вызывает окончание
программы.

procedure Halt [ ( exitcode : Word ) ];

  Останавливает выполнение программы и
  возвращает в операционную систему.
  Можно использовать при критической ошибке.

Например:

function IsThisDriveWriteProtected : Boolean;
 begin
        { функция проверяет, защищен ли диск от записи }

        ......
 end;

        ......

 If IsThisDriveWriteProtected = True Then
   begin
        WriteLn('Abnormal program termination.');
        Halt;
   end;

function ParamCount : Word;

Возвращает количество параметров вызова в командной строке.

Используется для сохранения параметров коммандной строки.
Параметры, указанные в коммандной строке, нумеруются с единицы слева
направо, нулевым параметром является полное имя программы.

function ParamStr(index) : string;

 Возвращает требуемый параметр командной
 строки.

Пример:

 Var
    _Parms : String;

        ......

Procedure SaveParms;
 Var
    _I : Byte;
 begin
     _Parms:='';
     If ParamCount <> 0 Then { если в командной строке есть
                               параметры }
     begin
       For _I:=1 To ParamCount Do
        _Parms:=_Parms + ParamStr(_I);
     end;
 end;

После выполнения процедуры SaveParms переменная _Parms будет содержать
все параметры командной строки.

procedure Seek(var f; n : Longint);

Перемещает указатель текущей позиции файла в требуемое место.

Используется для перемещения по файлу. При открытии файла
указатель устанавливается на нулевую позицию, то есть на первый
байт файла. f - открытый файл, n - позиция, на которую
необходимо переместить указатель.

procedure Truncate(var f);

Усекает размер файла до места, на котором находится
указатель текущей позиции.

Используется для удаления тела вируса из программы перед ее
исполнением.

  ......
Seek(_F , FileSize - VirLen);
Truncate(_F);
  ......

                               Модуль DOS

procedure SwapVectors;

Используется перед и после процедуры Exec. Компилятор Борланда
автоматом вставляет в любую программу код, который при выполнении
программы сохраняет адреса некоторых векторов (Int 00h (деление на
ноль), Int 23h (адрес передачи управления по нажатию клавиш Ctrl-Break),
Int 24h (обработка критической ошибки)) и еще несколько других
в переменных SaveIntXX, где XX - шестнадцатеричный номер вектора
прерывания, и заменяет адресами собственных процедур для обработки
ошибок. Процедура SwapVectors переставляет SaveIntXX указатель с
текущим вектором, поэтому для запуска на выполнение программы из
нашей программы перед процедурой Exec необходимо выполнить
процедуру SwapVectors для восстановления оригинальных адресов, а
после выполнения процедуры Exec выполнить процедуру SwapVectors
еще раз, дабы опять установить паскалевские процедуры обработки
ошибок.

procedure Exec(Path, CmdLine : string);

Выполняет требуемую программу с необходимой
командной строкой.

Path - имя программы, которую необходимо выполнить, CmdLine -
параметры командной строки для этой программы. Обычно для
запуска используется командный процессор, доступный через
переменную COMSPEC, а в CmdLine указывается сразу имя программы,
которую необходимо запустить и параметры для ее запуска, если
таковые существуют. Для получения значения переменной COMSPEC
используют функцию GetEnv, которая возвращает значение указанной
переменной окружения.

        ......
        ProgramToRun:='PROGRAM.EXE ' + '/A /B /C';
        SwapVectors;
          Exec(GetEnv('COMSPEC') , '/C ' + ProgramToRun);
        SwapVectors;
        ......

/C - параметр, указывающий командному процессору, что после выполнения
указанной программы необходимо вернуть управление вызвавшему его
процессу, то есть нашей программе.

procedure FindFirst(Path : string;
                    Attr : Word;
                    var S : SearchRec);

Ищет в описанном (или текущем) каталоге
первое вхождение, соответствующее заданному
имени файла и набору аттрибутов.
Path - маска файлов, которые необходимо искать (*.EXE, например).
Attr - атрибуты файлов, которые необходимо искать.
Эти константы используются для проверки, установки и очистки битов
атрибута файлов при использовании процедур GetFAttr, SetFAttr,
FindFirst и FindNext:

const
  ReadOnly  = $01;
  Hidden    = $02;
  SysFile   = $04;
  VolumeID  = $08;
  Directory = $10;
  Archive   = $20;
  AnyFile   = $3F;

S - переменная типа SearchRec:

Переменные типа SearchRес используются в процедурах FindFirst
и Findnext для просмотра каталогов файлов.

type
  { Запись Search, используемая FindFirst }
  { и FindNext }
  SearchRec = record
                Fill: array[1..21] of Byte;
                Attr: Byte;
                Time: Longint;
                Size: Longint;
                Name: string[12];
              end;

Таким образом, при нахождении файла по маске процедурой FindFirst или
FindNext мы автоматически получаем: атрибуты файла в переменной Attr,
дату и время последней модификации файла в переменной Time, размер
файла в переменной Size и имя файла с расширением в переменной Name.
Нет нужды вызывать процедуру GetFAttr (получить атрибуты файла),
GetFTime (получить дату и время последней модификации файла) и
функцию FileSize (получить размер файла в байтах).

procedure FindNext(var S : SearchRec);

Продолжает поиск, начатый FindFirst с
прежним именем и аттрибутами.

Для отслеживания ошибок операций модуля DOS существует переменная
DosError. Если операция выполнилась успешно, DosError равна нулю,
иначе переменная содержит код ошибки. Возможные коды ошибок включают
в себя:

     2 - файл не найден;
     3 - путь доступа не найден;
     5 - доступ отвергнут;
     6 - недопустимая обработка;
     8 - недостаточно памяти;
     10 - недопустимая программная среда;
     11 - неверный формат;
     18 - файлы отсутствуют.

Если файлы по указанной маске не найдены (или закончились), переменная
DosError приобетает ненулевое значение - это служит нам сигналом к окон-
чанию поиска.

        Var
           _Sr : SearchRec;
           Attr : Word;
           Time : LongInt;
        ......

        FindFirst('*.EXE' , Archive , _Sr);
        While DosError = 0 Do { пока переменная DosError равна 0 }
          begin
              Attr:=_Sr.Attr; { запоминаем атрибуты }
              Time:=_Sr.Time; { и дату/время найденого файла }
                InfectFile; { вызываем процедуру заражения }
              FindNext(_Sr); { ищем следующий файл по маске }
          end;

        ......

procedure SetFAttr(var F; Attr : Word);

Устанавливает аттрибуты файла.

procedure SetFTime(var F; Time : Longint);

Устанавливает дату и время создания файла.

Если Вы в своих целях собираетесь модифицировать дату инфицируемого
файла (я, например, пользовался полем даты/времени файла как индикатором
зараженности), необходимо "распаковать" переменную Time типа LongInt
процедурой UnpackTime в переменную типа DateTime, затем сделать
необходимые изменения и "упаковать" обратно в LongInt процедурой
PackTime.

Переменные типа DateTiме (даты и времени) ис-
  пользуются в процедурах UnраскТiме и РаскТiме
  для анализа, упаковки и построения четырех-
  байтового значения, содержащего дату и время,
  которое используется затем в процедурах
  GetFTiме, SetTiме, FindFirst и FindNехt.

  type
    { Date & time запись, используемая
      PackTime и UnpackTime }
    DateTime = record
                 Year,Month,Day,Hour,
                 Min,Sec: Word;

procedure UnpackTime(Time : Longint;
                     var T : DateTime);

Преобразует 4-байтовое, упакованное в Longint
время и дату, возвращаемое GetFTime,
FindFirst или FindNext в распакованную запись
типа DateTime.

procedure PackTime(var T : DateTime;
                     var Time : Longint);

Преобразует  запись типа DateTime в
4-х байтную упакованную дату-и-время типа
Longint, используемую SetFTime.

Пример приведу из паскалевского хэлпа:

 uses Dos;
 var
   f: text;
   h, m, s, hund : Word; {Для GetTime}
   ftime : Longint; {Для Get/SetFTime}
   dt : DateTime; {Для Pack/UnpackTime}
 function LeadingZero(w : Word) : String;
 var
   s : String;
 begin
   Str(w:0,s);
   if Length(s) = 1 then
      s := '0' + s;
    LeadingZero := s;
  end;
  begin
    Assign(f, 'TEST.TXT');
    GetTime(h,m,s,hund);
    Rewrite(f); { Создать новый файл }
    GetFTime(f,ftime); { Опр. время создания }
    WriteLn('файл создан в ',LeadingZero(h),
            ':',LeadingZero(m),':',
            LeadingZero(s));
    UnpackTime(ftime,dt);
   with dt do
     begin
     WriteLn('Время файла ',
             LeadingZero(hour),':',
             LeadingZero(min),':',
             LeadingZero(sec));
     hour := 0;
     min := 1;
     sec := 0;
     PackTime(dt,ftime);
     WriteLn('Установка времени файла ',
          'на одну минуту после полуночи');
     Reset(f); { Переоткрыть файл для чтения }
     { (Иначе Close изменит время) }
    SetFTime(f,ftime);
    end;
  Close(f);   { Закрыть файл }
end.

procedure GetIntVec(IntNo : Byte;
               var Vector : pointer);

Возвращает адрес требуемого вектора
прерывания. IntNo - номер вектора в десятичной или шестнадцатеричной
системе счисления, Vector - переменная типа Pointer (указатель)

 Переменная типа указатель содержит адрес в
 памяти динамической переменной определенного
 базового типа.

 Вы можете присвоить значение переменной типа
 указатель при помощи процедур New или GetMem,
 оператора @ или функции Ptr. Зарезервиро-
 ванное слово nil определяет константу-ука-
 затель, которая ни на что не указывает.

 Предопределенный тип "pointer" служит для
 объявления безтиповых указателей, т.е. указа-
 телей, которые не указывают ни на какой опре-
 деленный тип.

То есть, после выполнения процедуры GetIntVec в переменной
Vector будет находится адрес вектора интересующего Вас прерывания.

procedure SetIntVec(IntNo : Byte;
                    Vector : pointer);

Устанавливает требуемый вектор прерывания на требуемый адрес,
то бишь процедурой SetIntVec мы устанавливаем свой обработчик
прерывания.

procedure SetCBreak(Break: Boolean);

Устанавливает проверку Ctrl-Break в DOS. SetCBreak(False) отключает
проверку нажатия клавиш Ctrl-C, но, блин, Ctrl-Break все равно
приходится закрывать, вешая свою процедуру обработки на int 1Bh
или отрубая клавиатуру на время работы вира.

На этом с Частью A покончено, переходим к водным процедурам. ;)