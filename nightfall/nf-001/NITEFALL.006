 Грядущему поколению: Ip spoofing                                by lord matrix

  Да, да... Та самая подделка ip-адреса. Естественно без обратной связи и т.п.,
 но подделка исходного ip. Применений подделки исходящего адреса - море. Тайно
 послать комманду уже установленому где-то backdoor daemon-у и не засветиться в
 логах, атака land denial of service (мы ставим одинаковые source и dest адреса
 в ip-заголовке пакета и система зависает). Примеры в этой статье я даю для BSD
 архитектуры, однако тот же код (с небольшими изменениями) можно использовать и
 под linux.
  Т.к. основная масса U*X машин работает с сетью по принципу сокетов (да, еще я
 видел десяток разных методов, однако идеология практически та же), то и мы не
 откажемся от этого удобства. Для начала нужно выбрать тип сокета, необходимого
 нам. Учитывая, что мы будем работать с ip-заголовком, нам необходим "сырой со-
 кет", т.е. сокет, для которого машина исполняет только транспортные функции. И
 вот как выглядит открывание сокета:

  int sockfd;
  sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);

  Теперь мы можем делать с нашими пакетами что захочем. Для других видов сокета
 система сама заполняет многие поля и исправляет некоторые поля, по ее мнению
 составленные неправильно. Однако в "сыром" режиме мы сможем вытворять кучу ин-
 тересных штучек, не особо волнуясь за действия системы. Теперь мы должны уста-
 новить опции сокета:

  int xxx = 1;
  setsockopt (sockfd, IPPROTO_IP, IPPROTO_RAW, (char *)&one, sizeof(one));

  Отлично. Теперь можно приступать непосредственно к редактированию пакета. Сам
 пакет - структура, строго определенная где-то в /usr/include/netinet. А теперь
 мы возьмем определение пакета, выкинем все лишнее и рассмотрим наиболее важные
 поля.

  struct iphdr {

   u_int32_t    saddr;     /* исходный адрес                                 */
   u_int32_t    daddr;     /* конечный адрес                                 */
   u_int8_t     protocol;  /* протокол (tcp/udp)                             */
   u_int16_t    check;     /* контрольная сумма                              */
   u_int8_t     ttl;       /* максимальное количество хопов (time to live)   */
   u_int8_t     tos;       /* тип сервиса, абсолютно левая хрень             */
   u_int16_t    id;        /* идентефикатор пакета                           */
   u_int16_t    tot_len;   /* длинна пакета                                  */
   u_int16_t    frag_off;  /* смещение содержимого, если это фрагмент        */

  };

  Нас волнуют только saddr, daddr, protocol, check. Протоколы определены в /etc
 /protocols, мы выбираем tcp (6). И теперь:

  char *packet = (char *)malloc(400);
  struct *iphdr fakeip = (struct iphdr *)(packet + sizeof(struct iphdr));
  fakeip->protocol = 6;

  А теперь мы же должны подставить левый ip-адрес? Voila! :

  char *address = "127.0.0.1";           // ;) пакет пришел с localhost ;)))
    struct in_addr addr;
     if ((addr.s_addr = inet_addr(address)) == -1) {
            puts("error resolving hostname");
            exit(0);
        }
    bcopy((char *)&addr.s_addr, (char *)&fakeip->saddr, 4);

  После проверки адреса на нормальность мы его заносим в заголовок пакета. Ура.
 Теперь у нас есть спуфнутый пакет. Теперь доделаем остальной кусок пакета, что- бы был нормальный, готовый к отсылке пакет.

  fakeip->version = 4;
  fakeip->ihl = 20;
  fakeip->tot_len = htons(IpData + IcmpData + 8);
  fakeip->tos = 3;
  fakeip->ttl = 30;
  fakeip->id = htons(getpid() & 255);
  fakeip->frag_off = 0;
  fakeip->check = checksm((u_short *)ip, IpData);
  fakeip->daddr = dstip;

  Я использовал функцию checksm, которой не найдешь в include-ах. Я также злосно глючил в некоторых параметрах пакета. Эта статья писалась не для script kiddie, а для человека, любящего читать документацию. Т.е. rtfm! С небольшим колличест- вом знаний мо
жно легко из всего вышеприведенного собрать спуфер. Единственное,
 чего мы еще не рассмотрели, так это отсылки пакета. Но я думаю, что если вы не
 доросли до того, как прицепить к пакету содержимое и отослать его - rtfm again.