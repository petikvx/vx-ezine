 Новые методы троянизации ядра                                   by lord matrix

 Возвращаясь к seltorn-овским сапогам я вдогонку решил чиркнуть статейку о новых
 методах заражения ядра linux. Самые первые модули научились ловить с помощью
 lsmod. Подом появились перехватчики системных вызовов - их тоже научились ло-
 вить. Вот просто недавно я сталкивался с программой, которая успешно находила
 w00w00-шные kernel-трояны, которые садились на sys_call_table.

 Ну и что же мы можем сделать теперь? Научиться перехватывать системные вызовы,
 при этом не садясь на sct. Как это сделать? Давайте посмотрим на любой вызов:
  maytrickz# id sys_execve
   sys_execve:       pushl  %ebp
   sys_execve+0x1:   movl   %esp,%ebp
   sys_execve+0x3:   subl   $0x10,%esp
   sys_execve+0x6:   pushl  %esi
   sys_execve+0x7:   pushl  %ebx
   sys_execve+0x8:   addl   $0xfffffff4,%esp
   sys_execve+0xb:   movl   0x8(%ebp),%eax
   sys_execve+0xe:   pushl  %eax
   sys_execve+0xf:   call   getname

 А теперь посмотрим. Инструкция, получаемая из 6-го бита занимает именно один
 бит. Что же мы можем сделать? Вирьмейкерская "прыжковая" идеология заползает
 на машины под Linux. Мы меняем первые шесть байт на:

   movl trojan, %eax
   jmp *%eax

 При этом мы затираем как раз первые 7 байт. Теперь мы выполняем сначала эти
 семь байт, потом троянский код и потом возвращаемся. Т.е. мы записываем в
 маcсив семь байт в виде shellcode-а, выполняем его и делаем наше дело:

 char original[7];
 void hook( void )
 {
         asm volatile( "jmp original" );
         printf ("yo bitch. we've trojanized you");
 }

 *hint* Для тех, кто уже размечтался использовать - вышеописанный код работать
 не будет. Хех =)

 Кстати, credit за обнаружение такой возможности уходит к riq, он собственно и
 написал первого трояна.
