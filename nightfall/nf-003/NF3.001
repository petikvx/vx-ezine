
  gggggggg   ........  n i g h t f a l l   m a g a z i n e   ......   gggggggg
  $$$$$$$$   ::                                                  ::   $$$$$$$$
  $$7'````                   програмирование сокетов                  ''''`7$$
  $[ ·∙xxmmmmgg                   by napalmed                    ggmmmmxx∙· ]$
  $$┌,....   $$                                                  $$   ....,┐$$
  $$$$$$$$   $$mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm$$   $$$$$$$$
  ¤¤¤¤¤¤¤¤                                                            ¤¤¤¤¤¤¤¤

 ты уже поставил себе unix. наверное даже научился писать простенькие sh-скрип-
 ты и перловые  мульки. но хочеться мосчи. уже и С немного выучил,  но с сетями
 пока что плохо. ну, ничего. тут имеет смысл почитать мой туториал. золотых гор
 я вам не обещаю,  но немного полезной инфы для использования и размышления по-
 лучите...

 по сути для програмиста работа с сокетами  чем-то похожа на работу с файловыми
 указателями: почти идентичный синтаксис, очень похожая логика. можно использо-
 вать read() и write().

 для основной массы сокетов нам необходим клиент и сервер, где сервер - "слуша-
 ющая" часть, а клиент -  "вызывающая" :) ну вобщем-то несложно догадаться, что
 мы будем обсуждать построение и первого, и второго. сокет фактически и есть та
 связующая нить  между сервером и клиентом, через которую они и общаются. в от-
 личии от файловой  системы в сокетах куда важнее установка связи, уже сам про-
 цесс невероятно прост. ну да ладно, хватит распинательств, приступим к делу. а
 именно, к генерации нового сокета.

 вот что должно присутствовать в заголовке, дабы сокет можно было создать:

 #include <sys/types.h>
 #include <sys/socket.h>

 ну и естественно мы должны определить сокет:

 int socket(int af, int type, int protocol)

 что же за параметры к socket? вот они:

  int af : т.н. "семья адресов", т.е. тип адресации. может быть:

               AF_UNIX: внутримашинная одноранговая адресация.
               AF_INET: стандартная адресация семейства DARPA.

  int type : тип соединения. два основных типа:

               SOCK_STREAM: сокеты, ориентированные на полный контроль за сое-
                            динением, гарантированная доставка etc.
               SOCK_DGRAM: сокеты, рассчитанные на отсылку датаграмм (т.е. па-
                           кетов). больше  возможностей  раскрутить содержимое
                           пакета etc.

  int protocol : протокол. проще  всего  ставить 0, тогда система сама выберет
                 первый протокол из тех, что подходят по предыдущим двум пара-
                 метрам.

 если сокет успешно открыт,  то в результате  функция возвращает файловый деск-
 риптор. если нет, то -1.

 т.е. вот как выглядит инициализация сокета:

 sockfd = socket(AF_INET, SOCK_STREAM, 0)

 теперь мы имеем сокет, использующий сетевую адресацию, рассчитанный на поддер-
 жку соединений и с дефолтовым протоколом.

 поехали дальше.  можно прицепить нашему сокету имя и всякие регалии. для этого
 есть на свете функция bind():

 int bind(int sockfd, struct sockaddr *name, int namelen)

 где *name имеет структуру sockaddr:

 struct sockaddr {
                 u_short sa_family;
                 char    sa_data[14];
         };

 name.sa_family должно быть AF_UNIX, name.na_data - имя файла, прибитое к соке-
 ту. namelen - собственно длинна этого добра. вот как все это функционирует all
 togetha:

 #include <sys/types.h>
 #include <sys.socket.h>

 struct sockaddr name;
 int sockfd;

    name.sa_family = AF_UNIX;
    strcpy(name.sa_data, "/var/bullshit");

    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    bind(s, &name, strlen(name.sa_data) + sizeof(name.sa_family);

 как всегда, если  все успешно,  то возврат 0, если нет, то -1... если мы хотим
 bind-ить с семейством  адресов AF_INET,  то все выглядит немного сложнее.  вот
 как будет выглядеть структура sockaddr:

 struct sockaddr_in {
         short int          sin_family;
         unsigned short int sin_port;
         struct in_addr     sin_addr;
         unsigned char      sin_zero[8];
     };

 тут я думаю все доступно на лету, вот яркий рабочий пример использоваиня:

 #include <stdio.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <errno.h>

 int sockfd, port = 23;
 struct sockaddr_in my_addr;

   if((sockfd=socket(AF_INET, SOCK_STREAM, 0)) == -1)
   {
      printf("Socket Error, %d\n", errno);
      exit(1);
   }

    my_addr.sin_family = AF_INET;
    my_addr.sin_port = htons(port);
    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    bzero(&(my_addr.sin_zero), 8);

   if((bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr)) == -1)
   {
      printf("Bind Error, %d\n", errno);
      close(sockfd);
      exit(1);
   }

 вот и все.  все, что мы сделали - создали сокет и "прибили" к нему рабочую ин-
 формацию.  едем  дальше... установим соединение... эт функция connect(), рабо-
 чий прототип у нее такой:

 int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);

 sockfd - наш файловый  дескриптор... serv_addr -  структура sockaddr с инфой о
 сервере. вот примерно как мы это юзаем:

 #include <string.h>
 #include <sys/types.h>
 #include <sys/socket.h>

 #define DEST_IP   "132.241.5.10"
 #define DEST_PORT 23

 main()
 {
 int sockfd;
 struct sockaddr_in dest_addr;

    sockfd = socket(AF_INET, SOCK_STREAM, 0);

    dest_addr.sin_family = AF_INET;
    dest_addr.sin_port = htons(DEST_PORT);
    dest_addr.sin_addr.s_addr = inet_addr(DEST_IP);
    bzero(&(dest_addr.sin_zero), 8);

    connect(sockfd, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr));
 }

 вот  примерно так мы  устанавливаем связь с сервером, а  дальше уже собственно
 начинаем обмен  пакетами. но до основной части мы обсудим еще одну важную фун-
 кцию:   listen(). собственно  это серверная функция, которая  сидит на порту и
 ждет входяшие запросы. прототип выглядит так:

 int listen(int sockfd, int backlog);

 вот тут нам уже полюбому нужно прибайндить к сокету выбранный порт, чтобы люди
 вообще знали, куда  коннектиться. но это еще ничего... дальше будет хуже. если
 кто-кто коннектиться, то нам нужно использовать функцию accept(), чтобы вобщем
 то принять соединение... вот прототип:

 int accept(int sockfd, void *addr, int *addrlen);

 кстати backlog -  колличество соединений, которые одновременно можно поддержи-
 вать.

 так вот. как же вся эта фигня работает вместе... это несложно:

 #include <string.h>
 #include <sys/types.h>
 #include <sys/socket.h>

 #define MYPORT 1500
 #define BACKLOG 5

 main()
 {
 int sockfd, new_fd;
 struct sockaddr_in my_addr;
 struct sockaddr_in their_addr;
 int sin_size;

    sockfd = socket(AF_INET, SOCK_STREAM, 0);

    my_addr.sin_family = AF_INET;
    my_addr.sin_port = htons(MYPORT);
    my_addr.sin_addr.s_addr = INADDR_ANY;
    bzero(&(my_addr.sin_zero), 8);

    bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr));

    listen(sockfd, BACKLOG);

    sin_size = sizeof(struct sockaddr_in);
    new_fd = accept(sockfd, &their_addr, &sin_size);

 ура. вот у нас  есть установленное  соединение, как client-side, так и server-
 side.  теперь  поговорим о главном. send() и recv().  самая  несложная и самая
 нужная часть. прототипы функций выглядят так:

 int send(int sockfd, const void *msg, int len, int flags);
 int recv(int sockfd, void *buf, int len, unsigned int flags);

 параметры:

  sockfd - понятно

  msg - типа "послание" :))) по сути содержимое, которое придет на заданый порт
  len - длинна
  flags - держим на 0, man send за объяснением :)

  buf - указатель на переменную или переменная, в которую получать
  len - длинна
  flags - то же самое...

 теперь я покажу двумя обрывками, как посылать и получать:

 char *msg = "is there anybody at home?";
 int len, send_msg;

 /* time to send..... */

 len = strlen(msg);
 bytes_sent = send(sockfd, msg, len, 0);

 ну и:

 char *buf;
 int len, recv_msg;

 /* time to receive.... */

 len = strlen(buf);
 recv_msg = recv(sockfd, buf, len, 0);

 ну и теперь вот такая фигня, как close() и shutdown(). с close все понятно:

 close(sockfd);

 ну а вот shutdown дает несколько очень полезных фишек, которыми можно восполь-
 зоваться к своему вящему удовольствию:

 int shutdown(int sockfd, int how)

 how - метод выключения, бывает трех типов:

             how        метод выключения
              1     :   recv() отключается
              2     :   send() отключается
              3     :   и recv(), и send() отключается

 вот скока  дофига мы уже умеем. теперь поехали уже по сервисным функциям. что,
 если мы  хотим получить информацию о том, кто открывает с нами соединение? тут
 есть такая мулька, как getpeerbyname():

 int getpeername(int sockfd, struct sockaddr *addr, int *addrlen);

 где sockfd - вполне понятно
     addr - структура, в которую писать
     addrlen - длинна вышеуказанной структуры

 есть аналогичная структура для получения инфы о самом себе:

 int gethostname(char *hostname, size_t size);

 тут параметры понятны. следуюшая полезная штука - функция gethostbyname, кото-
 рая ставит в соответствие доменному имени IP. прототип прост как угол дома:

 struct hostent *gethostbyname(const char *name);

 где структура hostent выглядит так:

 struct hostent {
         char    *h_name;
         char    **h_aliases;
         int     h_addrtype;
         int     h_length;
         char    **h_addr_list;
     };
 #define h_addr h_addr_list[0]

 h_name - имя хоста
 h_aliases - список присвоенных "псевдонимов"
 h_addrtype - тип адреса, обычно AF_INET
 h_length - длинна адреса в байтах
 h_addr_list - список адресов хоста
 h_addr - первый адрес в списке

 напишем самый простецкий DNS-анализатор:

 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <netdb.h>
 #include <sys/types.h>
 #include <netinet/in.h>

 int main(int argc, char *argv[])
 {
    struct hostent *h;

    if (argc != 2) {
       fprintf(stderr,"Usage: getip <host name>\n");
       exit(1);
    }

    if ((h=gethostbyname(argv[1])) == NULL) {
       herror("gethostbyname");
       exit(1);
    }

    printf("Host name  : %s\n", h->h_name);
    printf("IP Address : %s\n",inet_ntoa(*((struct in_addr *)h->h_addr)));

    return 0;
 }

 вот собственно и  все, что я хотел сегодня рассказать. пробуйте, учитесь, пос-
 тигайте...
