<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<meta name="GENERATOR" content="Microsoft&reg; HTML Help Workshop 4.1">
<Title>Post Fundamentals Of C</Title>
</HEAD>
<BODY bgcolor = white text = black link = darkgray vlink = lightgray alink = red>

<h3>Post-fundamentals of C, behind the veils of libs, includes and file access - <i>By AcidFlux</i></h3>
<font size = "2">
First of all, if things are not clear, try to find
things on the internet. My closest friends are
<br><br>
<a href = "http://www.altavista.com">www.altavista.com</a><br>
<a href = "http://astalavista.box.sk">astalavista.box.sk</a><br>
<a href = "http://www.yahoo.com">www.yahoo.com</a><br>
<br><br>
I take it you know how to search for things, but here
are some tips still. Use a + sign between two words
if you want links that have both words in the text,
not just one. If you try to find something about
GNU Public License for instance, try using the
main keywords you won't find anywhere else that
easily, like GNU+License, this will probably give
you many URL's already to look for more information,
more below...
<br><br>
To find any program on your Linux system, you can
use the find command, explained into detail in
the man pages. Just type "<font face = courier>man find</font>". I mostly
use <font face = courier>find / -name &lt;filename&gt;</font>, which will search
the complete system for the occurence of <filename>.
<br><br>
This document is intended to show you around a bit on
a linux system, see where your files you are actually
using are located and give you paths where to look for
more information on this subject. Let's start with some
practical things here.
<br><br>
UNIX is a commercial distribution for which you have to
pay money. However, Linux, as a UNIX clone, has the same
software that's used in UNIX. This software however, does
not come from the commercial distributions, but has been
written by many different programmers and freely contributed.
<br><br>
The software is subject to the GNU Public License, this 
means that it is 'copyleft'. This is intended to prevent
others from putting 'copyright' on the software. A copy
can be found on the internet very easily. The software from
GNU closely mimics the software found on UNIX systems,
but is not the same.
<br><br>
Some software you'll need throughout the course:
<br><br>
GCC  &lt;== your C-compiler.<br>
G++  &lt;== your C++ compiler, which will be invoked through
GCC as well, when using flags.<br>
gdb  &lt;== source code level debugger, I never used it though,
         so good time for me to start as well.<br>
gnumake &lt;== this is a version of UNIX make. It actually compiles
            installs source code through a compiler script.<br>
            If you've compiled the kernel before, you'll remember
            typing things like <font face = courier>./configure</font>, make and make install
            make zlilo or whatever. The <font face = courier>./configure</font> is where you
            configure the script and the make compiles the sources
            according to the script. make install links the object
            files and places them in the correct subdirs. make zlilo
            places your kernel on the / in the right place.<br>
bison  &lt;==  parser generator compatible with UNIX yacc (no experience
	    herewith)<br>
bash   &lt;==  that rings a bell, it's the normal command shell for users.<br>
emacs  &lt;==  my favourite for editing. use any editor you like though.
            other examples are pico, vi, vim, joe, xjed...<br>
<br>
<b>some info:</b><br>
<br>
First of all, you'll probably have compiled something before,
exploits or port scanners and placed them somewhere in some
bin directory. There's a difference between the root <font face = courier>/bin</font> and
the <font face = courier>usr/local/bin</font>, since only root uses <font face = courier>/bin</font> and users can only
execute progs from <font face = courier>/usr/local/bin</font>.
<br><br>
When DOS users compile a program, link it, they'll be able to
execute it in that directory immediately. It's an .exe or .com
there. However, in linux, you need to place it in the right 
directory before execution OR run it with a <font face = courier>"./"</font> in front to
tell the kernel the program can be found in the current dir.
<br><br>
Let's browse around your system:
<br><br>
I'm running SuSE 6.0 and forgot where the files are for
other distributions, but I expect them to be the same.
<br><br>
"gcc" is in my <font face = courier>/usr/bin</font> directory. It executes as both
user and root.
<br><br>
your "library files" are located in some "lib" directory
under i486-linux-libc5. My full path is
<br><br>
<font face = courier>"/usr/lib"</font>
<br><br>
Other lib-directories exist, but many times these are
just versions of the <font face = courier>/lib</font> directory. I'm not completely
sure, but I believe some libraries do still exist in the
other directories under i486-linux-libc*x* that are
upgrades of previous versions or used for that version only.
<br><br>
DLL's in windows are like library files in UN*X (yeah, correct,
windows has in many ways actually been stolen from UN*X and
Apple, but I guess you already knew that)... nowadays
though, windows seems to have matured in it's own way
and diverts quite from any UN*X system. Once in a while
though, MS claims to have created this new technique or
software which has already been around on UN*X for ages,
but never advertised so much... getting back to the
subject.
<br><br>
So the libraries contain all the functions and procedures
you can use to talk to the system or use for your own
convenience. For instance, when you invoke a sleep() command
that pauses the program for a while, a procedure exists
in the library that does exactly that. it's not possible
to talk to the system with ASCII to make it do anything
you want, a function/procedure  has to be written first.<br>
Normally, smart people who know ASM or C/C++ really take
good care of this. By layering some interfaces, more dumber 
people can access the same functionality without diving
into the code too much.
<br><br>
You must have seen <font face = courier>#include</font> in many occasions. Every program
contains at least one. We call the files that are included to
the program "header files". These files can include other
header files at their time and so on. Be careful not to
create cross-references, including a header file that includes
the previous, it may give strange results. However, the
compiler sees this, so don't worry too much.
<br><br>
In the header files is information about structures (oh shit, 
haven't explained these yet)... umm... imagine a structure
to be something of an array. For instance, it can contain
three separate numbers, four characters and another structure,
why not? If you're not sure about this, just imagine a block
of variables. The header file also reserves possible
variable names and contains "links" to your library
files (what functions are stored and how they're called
and so on). Basically, you don't need to interfere too much
with the header files, not even when you've progressed, 
so I won't bother your minds with em yet (here's a line that
many mentors use when they're not so sure about a subject
and want to hide their inexperience)
<br><br>
There are some subdirectories in there as well. Famous
for hackers is <font face = courier>"/usr/include/net"</font> or <font face = courier>"/usr/include/netinet"</font>,
these header files are all about socket programming. Good
thing is that for every protocol your system understands
there's a header file. Try to find tcp.h and check it out,
there's the implementation of TCP for linux, caress it!
<br><br>
Especially, check out struct tcphdr, it's a TCP header,
you WON'T find this in windows, it's hidden through their
implementation. Therefore, TCP headers cannot be changed in
windows, except when you create a miniport driver and plug
into the vxd-stuff. It's a virtual device driver, very
low level that's passing the TCP packets on to the
TCP/IP stack. When passing through, you can catch the headers
and modify the headers there. Another way is to 'patch'
the winsock.dll, but ah well, without the source, you're
kinda lost in assembly there. These are the only ways
I could ever think of. Don't ask me to do it though, cause
it's beyond my level... You could use the info to look smart
on IRC though... :)
<br><br>
Anyway, since it's in the linux headers and we'll be using
raw sockets after some more, you have access to the
headers and can freely modify them. Not easy, but it's
not too hard as well.
<br><br>
Ok, for now, I have given you enough info. I'm sure you
want to get a kick out of yourself by programming your
first thing in linux. It'd be nice to actually see the
program do anything.
<br><br>
Pick up your favourite editor and clear the buffer. Next, type
in the following, it's just a simple "hello world!" program,
but by keeping the previous in mind, I'm sure you suddenly
get much more knowledge and insight in what the program
is actually doing and calling. Especially the library
calls and header files. Don't blame me for not giving you
the source to any "smurf" or IP spoofing program, but they
are freely around on the internet. If you just wish to
"look" smart, go ahead and download them and compile them.
We're here to actually learn something and get to understand
that. After knowing it, you'll see the need for doing
those things will dissolve. 
<br><br>
#include &lt;stdio.h&gt;   &lt;== include the standard input/output header
                         find it in the "include" dir and study
			 it for a bit. Although you won't understand
			 it (I even don't), you'll still see the
			 function call "printf" somewhere. It's being
			 called from the library files :)<br>
<br>
This file should be saved as "hello.c"
<br><br>
<font face = courier>
#include &lt:stdio.h&gt;<br><br>
int main() // main function, always present in a C/C++ program.<br>
{<br>
   printf("Hello world!\n");  // printf function<br>
   exit(0);  // exit function.<br>
}</font><br>
<br><br>
Ok, compile it with<br>
<br>
<font face = courier>"gcc -o hello hello.c"</font><br>
<br>
next, run it with <br>
<br>
<font face = courier>"./hello"</font><br>
<br>
/* There ya go. Let's notice some things already. // is used to
place any comment on the same line. If you wish to add more lines
of commenting, use /* to open it and */ to close your comments, like
is done in this paragraph. */ 
<br><br>
This way, the compiler knows what's there does not require compiling
and no errors will come up.
<br><br>
"printf" is a very simple print function that simply
displays something between the brackets on screen. The
\n is a special character called a newline, there are more
special characters like that, like \r for carriage return
and whatever. You can often recognize them being 'escaped' by
the \  - backslash character. The compiler interprets them
as ASCII codes 10 for newline and 13 for carriage return. It's
impossible to put these in the source code, so that's why the
escaping sequence is used!
<br><br>
Well, you're free to put this proggie into your /usr/local/bin
directory and run it once in a while to have your system greet
the world, but it's not really of any use, so just discard it
and browse some more through the system. I'm sure you have
some .c files somewhere. Look what header files they use. By
the way, a good tip. If you need to find information about
a structure, the way it has been declared that is, browse through
the header files, the declaration is in there!!! (kewl tip! kewl tip!)
<br><br>
Ok, I can understand your mind rings and you're numb now,
but don't be discouraged, sleep on it and ask me questions, that's
why I am mentor. I'll be hearing it when you guys are through
reading it and want to get to know more!  We're actually
advancing quite fast, but well, I'm focusing on C/C++ put into
practice, not actually understanding completely in theory
what it's all about...
<br><br>
variables as substitutions in the line.
<br><br>
example:
 <br><br>
<font face = courier>printf("hehe %d is actually not really a number. know what %s?  I think %d is better!", number1, string1, number2);
 <br><br>
bill.c and fred.c </font>
<br><br>
---------------------------
 <br><br>
<font face = courier>
#include &lt;stdio.h&gt;
 <br><br>
void bill(char *arg)<br>
{<br>
  printf("bill: you passed %s\n", arg);<br>
}<br>
 <br>
<br><br>
#include &lt;stdio.h&gt;<br>
<br>
void fred(int arg)<br>
{<br>
  printf("fred: you passed %d\n", arg);<br>
}<br>
</font>
 <br><br>

Ok, so there exist some substitutions here and there. Here's a list:
 <br><br>
%d  is substituted by an integer<br>
%i same<br>
%u = unsigned int<br>
%ld = long int<br>
%f  = float<br>
%c = single character<br>
%e = floats in exponential format  (e.g: 1.2575484e+01)<br>
%s = array of characters  (array of char, e.g.: char title[255]  = "ya dude!")<br>
%p = pointer address<br>
 <br>
there are some other ways, but they're not really interesting at 
this point...
 <br><br>
Now, we should compile the bill.c and fred.c programs into object modules. 
Do not use the -o option when compiling, cause this will also try to link it. 
That fails, because no main routine is created in the program.
 <br><br>
Type:<br>
 <br>
<font face = courier>"gcc -c bill.c fred.c"</font>
 <br><br>
This has created files "fred.o" and "bill.o"
 <br><br>
Next, we will start to create a program that calls the function "bill". 
For that to work, we need to create a header file first.
 <br><br>
lib.h:
<br><br>
---------------- <br>
<font face = courier>/*<br>
  This is lib.h. it declares teh functions fred and bill for users<br>
*/<br>
 <br>
void bill(char *);<br>
void fred(int);<br>
 <br><br></font>
----------<br>
 <br><br>
 
program.c:<br>
<br>
---------------<br>
 <br>
<font face = courier>#include "lib.h"<br>
 <br>
int main()<br>
{<br>
  bill("Hello world!");<br>
  exit(0);<br>
}<br>
 <br></font>
----------<br>
 <br>
save this as "program.c"<br>
 <br>
so, what we have done now is create a reference to bill.o by including "lib.h". <br>
This time, lib.h is not between &lt;&gt; characters. This is because &lt;&gt; specify the 
include file should be looked for in the general "include" directory, while "" 
characters specify it should be found in the current directory, that is, where 
the program is located.
 <br><br>
Let's do:<br>
 <br><br>
<font face = courier>"gcc -c program.c"</font><br>
 <br>
This has created an object file program.o. We need to link this program.o with 
bill.o in order for it to work:
 <br><br>
<font face = courier>gcc -o program program.o bill.o</font>
 <br><br>
This has linked program.o and bill.o together in "program". You can now execute 
./program and it will look like as if the function bill was programmed 
into "program.c".
 <br><br>
Ok, next step is to actually create a library, not link object modules together.
 <br><br>
<font face = courier>"ar crv lib.a bill.o fred.o"</font>
 <br><br>
and:
 <br><br>
<font face = courier>"ranlib lib.a"</font>
 <br><br>
'ar' is a general UNIX utility for archiving. You see it can be used for libraries 
as well. Because some UNIX systems, especially derived from Berkeley, need a table 
of contents we use the ranlib utility which does that. it's harmless to use, 
so just do it!
 <br><br>
Final step:
 <br><br>
<font face = courier>"gcc -o program program.o lib.a"</font>
 <br><br>
there you go.... program has used an object module in the 'lib.a' archive and linked 
that object code into it's own program. This is all possible because of the header 
file and compiler options. executing "./program" does the same thing.
 <br><br>
The bad thing is that the code is actually retrieved from the library and linked 
inside the program. Sometimes, you may wish to use shared libraries, which load 
themselves into memory and allow themselves to be shared across multiple programs. 
DLL's work exactly the same way. The code is loaded in memory, but cannot be executed 
by itself. However, the functions are ready for execution. once a program needs to 
use a published function or procedure, it transfers execution to the address, 
where the function/procedure is located and executes from there. Next, it returns
to the program and continues execution from there. Multiple programs have access to this
memory space, it works quite efficient. Linux has shared libraries as well, 
called .so files. The .sa libraries or .a libs are static libraries and you can 
link their functions in your own programs.
<br><br>

questions????

<br><br>
<b>Escape characters:</b>
<br><br>
Someone asked me a question about escape characters.<br>
These characters are used to put in character codes
in the text, without doing something ugly.<br>
<br>
Special character codes comprise characters before
code 32 dec or 20-hex. These are often characters
that will not show up, because they are the same as
system delimiters. For instance:
<br><br>
\a = ASCII bell character<br>
\b = backspace character<br>
\f = formfeed character<br>
\n = newline character<br>
\r = Carriage return (no linefeed)<br>
\t = Horizontal tab<br>
\v = Vertical tab<br>
\\ = Backslash character<br>
\' = single quote<br>
\" = double quote<br>
\? = Question mark<br>
\nnn = ASCII value in octal<br>
\xnnnn = ASCII value in hexadecimal<br>
<br><br>
Don't ask me what a vertical tab is, I really wouldn't
know. All chars above have not been tested in Linux,
so I can't be sure if they work. For \n and \r I'm very
sure, because that is really standard.
<br><br>
If you would program something like
<br><br>
<font face = courier>
void function blabla(void)<br>
{<br>
  printf("look at this");<br>
  printf(" line");<br>
}<br></font>
<br><br>
it would print all the stuff on one line. Now, by using
the \n at the end or somewhere in between where you like,
you can separate the lines so they start on different
lines, instead of writing the data on the same.
<br><br><font face = courier>
printf("look at this\n");
<br><br></font>
would be the solution to do it. Often, for system utils,
there's a help function. They often print multi lines,
in the program code, there are some printf's that use
the same concept.
<br><br>
Let's start some bits on the command shell, that # or $
you see so frequently. While in many ways it's similar to
DOS, it's much more and more powerful than DOS command.com.
<br><br>
A shell is available on every UN*X system and you can find
out if simple ideas work. I'm not talking about big progs
of course, but simple progs that will convert your
text files or basically, just gadgets you want to run now
and then.
<br><br>
UN*X has always been built very modular, that means it contains
utilities that can be re-used by other programs or users.
<br><br>
For instance, 'more' is a utility that enables you to
view an output of a list to a 'one-screen-at-a-time' view.
This is done by piping the output of the list to to this
utility, which receives the output and makes sure the
screen is not scrolled at the end.
<br><br>
You can pipe many times, like
<br><br>
<font face = courier>"man bash | col -b | lpr"</font>
<br><br>
This will print a reference copy of the bash-shell.
Col is a utility to take out backspaces and
format the output a bit. lpr is the printer spooler,
it prints the input to the printer as soon as 
resources become available.
<br><br>
For an example of shell 'programming', have a look
at <font face = courier>'startx' , '.xinitrc', '/etc/rc.d'</font> to see what
it's all about. It's not really C++, but definitely
some issues come forward that you want to know and
have a look at. For C++ programming, you can often
make use of utilities without having to reprogram the
same functionality in your own utility.
<br><br>
<b>A shell by definition:</b>
<br><br>
"A shell is a program that acts as the interface between
you and the UNIX system, allowing you to enter commands
for the operating system to execute."
<br><br>
Because of this, it resembles DOS, but hides the details
of Kernel operation for you. It's a sort of high
level programming language for UNIX itself.
<br><br>
If we go further into Tcl (pronounced 'tickle') or
Tk, we shall meet the 'tcsh' or 'wish' shells.
For now, let's continue.
<br><br>
If you've worked around UNIX for a while, you'll know
how to output the directory to a txt file or something,
so you can read it later with 'less', which is nothing
less than more, actually more.
<br><br><font face = courier>
"ls -l > lsoutput.txt"
<br><br></font>
Is the way to do it.
<br><br>
The standard output is in this way 're-directed' to the
file system by using "&gt;". If the file exists, it's overwritten,
so by using "&gt;&gt;" you can append to any existing file.
<br><br>
By using the command <font face = courier>"set -C"</font> you can override the
existing default behavior to overwrite existing files using
redirection. It sets the 'noclobber' option.
<br><br>
There are three file descriptors:
<br><br>
0 = standard input to a program<br>
1 = standard output<br>
2 = standard error output<br>
<br><br>
They are used by prefixing the "&gt;" with those numbers.
If you want to use the <font face = courier>'kill'</font> command from a script for
example, you can use these to generate error logs if
something can't be killed or redirect success logs for
everything that was successful.
<br><br>
<font face = courier>"kill -1 1234 &gt;killout.txt 2&gt;killerr.txt"</font>
<br><br>
This will <font face = courier>'kill -1' process '1234'</font> and write a log
of this to 'killout.txt', except when it failed, it will
generate an error log to 'killerr.txt'
<br><br>
If you do not want to see any messages at all, there's
a nice feature in UNIX, called the 'bit bucket'. A bit
bucket is like a black hole, everything put in there
simply disappears.
<br><br>
<font face = courier>"kill - 1 1234 &gt;/dev/null 2>&1"</font>
<br><br>
This tells the system to redirect standard output to 
/dev/null and redirect standard error output to the same
place as standard output (& + file descriptor, 1 = standard
output).
<br><br>
A silly example to redirect input:
<br><br>
<font face = courier>"more &lt; killout.txt"</font>
<br><br>
This will accept the file "killout.txt" as input to
"more", but it's silly, cause more can accept parameters
that will do the same thing.
<br><br>

<b>More about pipes:</b><br>
----------------<br>
<br>
<font face = courier>"ps &gt; psout.txt"<br>
"sort psout.txt &gt; pssort.out"<br></font>
<br>
will output the 'ps' command to 'psout.txt'. However,
psout.txt is sorted to 'pssort.out', where a sorted list
of all processes is stored. This can be piped to one single
line of command like:
<br><br>
<font face = courier>"ps | sort &gt; pssort.out"</font>
<br><br>
output of 'ps' is hereby piped to 'sort', which will store
it's output to pssort.out.
<br><br>
I'm hammering so much on pipes, because later we'll do some
programming in this respect and you really need to understand
the concept.
<br><br>
<font face = courier>"ps | sort | more"</font>
<br><br>
is nice, it 'mores' out a list of ps, which is sorted.
<br><br>
how about this one ?
<br><br>
<font face = courier>"ps -a | sort | uniq | grep -v sh | more"</font>
<br><br>
it takes the output of 'ps', excluding shells, sorts it
in alphabetical order, extracts processes using 'uniq',
uses 'grep -v sh' to remove processes called 'sh',
and finally displays paginated on the screen.
<br><br>
For hacking, you may want to know some of this stuff in
order to take out things you do not want to show the
webmaster. By re-compiling the utilities and storing
them in the 'bin' again, you are cloaking your own
existence in this way.
<br><br>

<b>Programming the shell:</b><br>
-----------------------<br>
<br><br>
It's not really programming, but more like scripting
the shell. All different shell commands and variables
can be done through any script. Example without script:
<br><br>
<font face = courier>$for file in *<br>
&gt;do<br>
&gt;if grep -l POSIX $file<br>
&gt;then<br>
&gt;more $file<br>
&gt;fi<br>
&gt;done<br>
</font>
<br>
Run these commands from your shell, notice the ">" which
tells you that you need to input more commands or
parameters for the process to start working. 
<br>
$file is the output of a sub-process, a sub-process is
something like a 'find' routine in a script... like
<br>
<font face = courier>"for file in *"</font>
<br>
tells the system you want to search every directory on
the system and you call every iterated file 'file'.
<br>
Then, you can use it the same way you use a variable
with 'grep'. Now, it's the output of a sub-process.
grep -l prints every file you found and has "POSIX" in
it to the printer. Furthermore, it displays the contents
of that file with 'more' on the screen.
<br>
Now, create a script that does about the same:<br>
----------<br>
<br><font face = courier>
<br>
#!/bin/sh<br>
<br>
#first.sh<br>
# This file looks through all the files in the current<br>
# directory for the string POSIX and then prints those<br>
# files on the standard output.<br>
<br>
for file in *<br>
do<br>
  if grep -q POSIX $file<br>
  then<br>
    more $file<br>
  fi<br>
done<br>
<br><br>
exit 0<br>
<br></font>
---------------<br>
<br>
'grep -q' suppresses standard output and stops on the first
match. That means if a file has at least one match, it
will continue to the next.
<br><br>
Do a <font face = courier>'man grep'</font> to find out much more about this really
useful tool.
<br><br>
This script is much like a cgi-script. I'd encourage you
to look at it in more detail, since it will help you if
you want to start cgi scripting later in your life or
possibly other lessons about this subject...
<br><br>
The script is treated essentially as standard input to
your shell, so setting your PATH parameter right, you
can reference any UNIX command in your script and have
it executed. It will give you the same authorisation
as yourself..
<br><br>

<b>Administration of scripts:</B><br>
--------------------------<br>
<br>
Now that you have a script we can run it two way,
invoking the shell with the script filename parameter
or simply running it from your current shell...
<br><br><font face = courier>
"/bin/sh first.sh"</font>
<br><br>
would do it, or first change the file mode to executable:
<br><br>
<font face = courier>"chmod +x first.sh"</font>
<br><br>
then use "first.sh" to execute it, or, if the PATH environmental
parameter is not set for you, run it with "./first.sh"
<br><br>

<b>Hack:</b><br>
-----<br>
<br>
if the environmental parameters of 'root' are set like
<br><br>
<font face = courier>'PATH=$PATH":."'</font>
<br><br>
which means, look in the current directory to execute something,
and then go to other-dir. Creating a hack-script, you can have
the root user execute something he wouldn't have wanted. Remember,
that a script works because it's like standard input, someone
writing a malicious script can just have it sit there and
possibly trick 'root' to run it. Moreover, if root/bin is not 
'write-protected' (dream on!), you're home free possibly...
<br><br>
After shell programming, we really start to dive in
into C/C++ programming, File access!!!
<br><br>
File access is really important and I'll try to
delve as much into it as I can. You'll need file
access a lot...
<br><br>

questions ????

<br>
At the moment I found a good book for developing 
Linux applications in the X-environment using
GDK and GTK+. The advantage is that it gives
you a good idea what object programming is all
about. It's quite easy as well, if you understand
it's concept. Since some OO concepts are hidden
from the programmer in Windows, but not in GTK/GDK,
it'll give you much better understanding about
the OO - programming, what containers are etc...
Don't worry about it yet though, it's future work
and I'm here to tutor, not give a headache. And
we still need a prelude to OO before we can take
it on anyway.
<br><br>
This week I started on a Object - oriented C++ 
project in Windows. As soon as we get some more
done in C, I'll divide the text up a bit into
OO and advanced C (sockets/whatever).
<br><br>
Last time I showed some examples in Shell Programming.
I told you guys I'd carry on with that, but since
the content was quite basic and stuff uninteresting
regarding UNIX environment, I'll decide to carry on
with.... FILES!! ah yeah.. why so hard at once? hmm..
Cause the best way to learn things is by doing it.
If you can't get to compile or have problems, lemme
know, I may be able to give you some tips where to look.
<br><br>
<b>FILES:</b>
<br><br>
We all should know what files are by now, they're rather
the same in DOS, except that file access in Linux is
different. You won't be able to access your ext2 filesystem
in DOS, however, from Linux you can. That is because
many file system modules are inside the kernel or plugged
in as a module. I can work through my windows files
anyways, because I have told the system where it is
mounted and what file system it contains. But that's
Linux administration, let's carry on with C here.
<br><br>
The basic operations on files are creating/opening/
reading/writing and closing them. On top of that we
need to organize files in directories, so you want to
know how to create, scan and delete directories, for
example.
<br><br>
In Linux, everything is a file. Therefore, file I/O
and programming there-in is really important. When
compiling your files as a user, you won't be able to
cause havoc in the system though. Examples are the
programs you are using to browse through directories
or try to manage them. If you, as a user, are not 
permitted, not even a program will give you that 
access.
<br><br>
I hope you all know how files work in Linux. DOS has
no control about who can read/write/execute files.
NT has it though, in the implementation of NTFS,
UNIX was originally built that way as a multi-user
system (true multi-user, contrary to NT).
<br><br>
Information about a file is stored in the 'inode'. 
Picture this as some sort of File Allocation Table.
The system will just use a number to access the
file, but for our convenience, all files have a 
description, size and access privileges stored in
the 'inode' as well.
<br><br>
A directory is in essence a file as well, but to us
they seem transparent, as if files are stored 'within'
a directory. When you delete a directory (and thereby
a 'file'), you delete a 'link' to the file 'inode' and
the system looses track of the information in the file.<br>
Just like DOS, deleting a file merely deletes it's name.
Or rather, it marks the file as 'not to be allocated'
anymore. Next time another file is created, it'll know
it can write to certain bytes on your hard disk. If you
have not written to disk yet and the information is still
there, you are able to 'undelete' the file by restoring
the file name and thereby the link. With UN*X, you can't
though, so files deleted will really be gone, unless you
use the trick that is documented in Linux documentation,
which should be available in your HOWTO's somewhere.
<br><br>
Because everything is a file, the hardware - specific
control programming can be done by accessing the files
through the device 'driver'. Suppose you want to search
for a file somewhere. Doing that on a tape or on a
harddisk or cdrom really differs. Luckily, these have been
made transparent to us, so what we simply do is call
"open", "write", "ioctl()", and other functions on our
devices and the driver will handle the hardware-specific
actions to take by itself.
<br><br>
Here are five system calls we can perform:
<br><br>
- open   : to open a file or device for access<br>
- read	 : to read from an open file or device<br>
- write	 : to write to a file or device<br>
- close	 : to close a file or device from access<br>
- ioctl	 : specific control of the device itself<br>
<br><br>
ioctl (input/output control) can for instance be used
to rewind a tape drive or set flow control characteristics
of a serial tape. Therefore, not all functionality can
be called for every device/file.
<br><br>
do a:<br>
<br><font face = courier>
"man open"<br>
"man close"<br>
"man ioctl"<br>
<br><br></font>
to find out more, especially the last one is useful.
<br><br>
Some problems that we are facing is with the making
of the system calls. Not that anyone cares to ring the
kernel, but because it causes so much overhead. You
actually step out of the program, execute its kernel
code and switch back. It's more expensive than own
function calls. Some hardware has restrictions on
the size of the data you want to write. For instance,
a tape can write 10K, but when you write 4K to the
tape, it will only write 4K but advance the tape for
10K. That's a limitation. File access ain't usually
that hard though.
<br><br>
The standard library functions we have for file access
are in the standard I/O library. We have discussed
header files and libraries in the previous three
lessons. To elaborate on this:
<br><br>
*  A library is like a DLL in windows, it has function 
calls you don't need to rewrite and they are already
stable. (as in not unstable).
<br><br>
* A header file is an included file in your own program.
The functions of the libraries are included in there,
so when your program sees a call to a function in your
program, it won't be scared shitless and provide no
error.
<br><br>
So, we have the standard I/O library somewhere in the
<font face = courier>/usr/lib/</font> directory called <font face = courier>"libstdio.a". </font>Then we have
the header file <font face = courier>&lt;stdio.h&gt; in the /usr/include</font> directory.<br>
If you browse through the <font face = courier>&lt;stdio.h&gt;</font> file, you'll notice
some things now, with clearer sight. I mentioned
"open", "write" and "ioctl" functions. Do a "less stdio.h"
and browse with me (asynchronously that is).
<br><br>
#defines are used to declare constants in a program.
Suppose you want to check for errors later on. If you
have a function for instance that is able to determine
whether the guy at "www.icepick.com" has something in
his fridge and you want to return one of the next codes:
<br><br>
0 = he has absolutely nothing in his fridge.<br>
1 = he has something in his fridge.<br>
<br>
So you start coding more functions with the same protocol.<br>
This time functions that determine whether someone
rang his doorbell, sat on his toilet, been in his
kitchen or was sitting at his computer.
<br>
Now, when your boss wants 0 to be replaced by -1, because
it looks better, you have to change every function you
wrote and believe me, sometimes you cannot be sure
you had every function. This increases bugs. So, what
does a #define do?
<br><br>
Find "#define NULL 0" in the header file. This means that
when you create a:
<br><br>
<font face = courier>return(NULL);</font>
<br><br>
it will actually do a "return(0);". But if your boss wants
the return value to change to -1, you simply change the
define into:
<br><br>
<font face = courier>"#define NULL -1"</font>
<br><br>
This means the program (with "return(NULL);"), will actually
do a <font face = courier>"return(-1);"</font> this time. Isn't that smart?
<br><br>

<b>FILES (for real this time):</b><br>
===========================<br>
<br>
There are three file descriptors already in your system.
These are 0 for standard input, 1 for standard output,
2 for standard error. We saw last time how to redirect
output to somewhere else.
<br><br>
A file descriptor is called a "handle" in windows. They
took that name, because it is a reference to your file.
The system will give you back a "handle" or descriptor
when you successfully open a file for write or read access
or whatever (you must specify what you want to do with
a file).
<br><br>
This file descriptor is just like the above numbers, just
an integer value. But it's used by the system to keep
track of files in some internal open files table.
(actually, an array of structures with dedicated information,
but let's not worry about that, have a look at the
struct _IO_FILE   declaration in "libio.h".
<br><br>
Now, let's elaborate on file descriptors already.
Since your standard input, output and error are already
opened for use and default on your system, you can
already use them. We need access to a function called
write to be able to write to them. In "unistd.h" is one.
<br><br>
The next program illustrates files usage:
<br><br>
<font face = courier>#include &lt;unistd.h&gt;
<br><br>
int main()<br>
{<br>
  <br><br>
  if ((write(1, "Here is some data\n", 18)) != 18)<br>
     write(2, "A write error has occurred on file descriptor 1\n", 46);<br>
   exit(0);<br>
}<br>
<br></font>
name this program anything you like (we call it &lt;filename&gt;).
compile using <font face = courier>"gcc &lt;filename&gt; -o &lt;filename&gt;".</font>
now run with <font face = courier>"./&lt;filename&gt;".</font>
<br><br>
See what it does!
<br><br>
Stepping through line by line:
<br><br>
* include unistd.h and thereby it's library where it's from.<br>
* int main() or void main() or something. "main()" is your
  stepin point for your program and every program should have
  one. Remember that!  It says int main() to tell the compiler
  this function WILL return a value at the end. So it should
  contain an exit(&lt;number&gt;) or return(&lt;number&gt;); at the
  end!<br>
* opening and ending braces "{" and "}" give the context
  of the function, the code that belongs to this function
  itself. It's possible to have more functions in the same
  file, they are enclosed with braces as well.<br>
* the "if-line" is weird and needs more explaining:
<br><br>
the function write you use in the if-line is declared in &lt;unistd.h&gt;
as follows:
<br><br>
size_t write(int fildes, const void *buf, size_t nbytes);
<br><br>
This means it takes a file descriptor (fildes) 
to send the buffer to,
takes a buffer (const void *buf) to write to that file 
and the size of that
buffer at the end (so you may need to dynamically measure
the size of the sent buffer when you as a programmer are not
sure what size it is. Suppose you are reading another text
file line by line. You don't know the size of the lines and
thus the buffers you are reading. You read them in, determine
the size of the buffer and write the buffers away again,
along with the measured size of the buffer.).
<br><br>
"const void *buf" means these things:
<br><br>
"*" means it sends along a pointer to a memory location.
In this case it's the location of where the program was
stored in memory and then the start of the line "Here is".
<br><br>
"buf" is a variable that will receive the pointer.
<br><br>
"void" it can contain integers, strings, chars whatever.
<br><br>
"const" means the buffer cannot be changed within the
function 'write'. This is for protection of the data,
a neat way actually of the program, neat code! Per
Bothner is quite a nice guy!
<br><br>
"size_t" is an integer, but GNU dedicated "size_t" as
an integer that counts bytes. Don't think too hard about
this, cause your program will work anyway!
<br><br>
So, what happens is you want to write the line :
"Here is some data\n" to file 1 (standard output).
\n is replaced by ASCII code 10 (newline, but \ marks
an escape character, in this case \n), and you tell
the function you want to write 18 bytes of data to
this file. "write" itself returns a value, which is
the actual amount of bytes written to this file,
or less, and you compare
this to 18. Now, if you get 18 back from "write", 
you'll know it all worked out ok. If you get -1
back, something went totally wrong and you should
raise an error. If it was less,
a maximum block size could have been the problem.<br>
However, if the 
two values differ, you'll know something went wrong
(taken into account it's only standard output).<br>
You want to alert the user to this and write the
"something went wrong blabla" line to the file
descriptor 2, standard error. There is no way to
get other feedback to the user, since if this doesn't
work out it simply means the user has no terminal
on the computer. Only thing you can still do is
write something to the log. Finally,
<br><br>
* exit(0);
<br><br>
means the program exits with return code 0. Which
means successful exiting the program without core
dumps or segmentation faults (better leave it at
that remark, don't ask me what it's about, cause
I don't. Ppl doing assembly language and CPU abuse
would!).
<br><br>
Next, let's get kicking with "read" for the first
time. It is declared as follows:
<br><br>
<font face = courier>size_t read(int fildes, void *buf, size_t nbytes);</font>
<br><br>
it's like "write" a lot, so I'll only explain what
it does:
<br><br>
* it reads up to nbytes of data. No more is read
  with every function call.<br>
* it returns the amount of bytes actually read.<br>
* if it returns 0 it had nothing to read (end of file).<br>
* if it returns -1 there was an error! (file not
  open for reading or simply not open).<br>
<br><br>
simple_read.c:<br>
==============<br>
<br><br><font face = courier>
#include &lt;unistd.h&gt;
<br><br>
int main()<br>
{<br>
  char buffer[128];<br>
  int nread;<br>
<br>
  nread = read(0, buffer, 128);<br>
  if (nread == -1)<br>
     write(2, "A read error has occurred\n", 26);<br>
  if ((write(1, buffer, nread)) != nread)<br>
     write(2, "A write error has occurred\n", 27);<br>
  <br>
  exit(0);<br>
}<br>
<br></font>
===============<br>
<br>
compile again <font face = courier>"gcc simple_read.c -o simple_read"<br></font>
<br>
something funny happens when executing. It takes off
128 bytes, but the rest is sent to the shell as a
command. Therefore, anything you type after that will
be considered as if you wanted to execute a file.<br>
Two more ways to run it:
<br><br>
<font face = courier>"echo hello there | ./simple_read"</font>
<br><br>
<font face = courier>"./simple_read &lt; some_filename_with_text_in_it.txt"</font>
<br><br>
<b>Assignment:</B><br>
===========<br>
<br><br>
Figure out the program logic. <br>
- When is the read error line triggered and for what?<br>
- When is the write error line triggered and for what?<br>
- Look at previous explanation and I'm sure you'll know.<br>
<br><br>

<b>Open:</b><br>
=====<br>
<br>
We've played around with three files now. It was fun,
it was a bitch (possibly), but we want to do some more.<br>
We actually want to create our own files (on disk or 
on your soundcard or your parallel port and read/write
from it).
<br>
Declaration of open in the library:
<br><font face = courier>
int open(const char *path, int oflags);<br>
int open(const char *path, int oflags, mode_t mode);<br>
<br></font>
Look up this declaration in the "fcntl.h" header file
and read the remarks.<br>
It will look like:
<br><br>
<font face = courier>extern int open __P ((__const char *__file, int __oflags, ...));</font>
<br><br>
this is because some dude with a serious 'underscore' 
addiction wrote it. (Not really, but I was too lazy
to look it up why the underscores appear. I'm sure
it's got to do with the way looking up the actual
function in the library works. Remember though that
the word "open" if called "__open" should be called
with "__open" if it's called that way, unless it's 
called "open" in which case it should be called with
"open". Take "__P" (that is pee) away though and the
other two underscores after that and you'll be able
to read it again...
<br><br>
Declarations of "open" and file related matter are in:
<br><br><font face = courier>
"fcntl.h"<br>
"sys/types.h"<br>
"sys/stat.h"<br></font>
any includes referenced in "fcntl.h"<br>
<br>

"open" returns a file descriptor. We now know what that
is. A path of access to a file, a "file handle" in 
windows, a handle from a bucket to be able to fill it
with water, or empty it in the streams. Two users can
have access to the same file, but the file descriptors
are different. This means data may become overwritten
when write access is used. (but not part of our challenge
yet!).
<br><br>
<b>oflags:</b><br>
=======<br>
<br>
O_RDONLY   Open for read only<br>
O_WRONLY   Open for write-only<br>
O_RDWR	   Open for reading and writing<br>
<br>
oflags, the second parameter, is used to control
file access and the way data should be written, some
additional parameters. But wait, it's only an int,
that means an integer, how can I stuff all that data
into one number?
<br><br>
I'm quite sure you have done some binary arythmetics.<br>
1, 2, 4, 8, 16, 32, 64, 128. (blabla)
<br><br>
When OR-ing these values together, the resulting value
can be used to determine whether one setting was made or
not. Basically, we use #defines here to give a constant
value to a variable. Browse through "fcntlbits.h" to find
O_RDONLY and the lots defined. Because "fcntl.h" should
be included within programs with file access and fcntl.h
itself includes "fcntlbits.h", we have access to these
constants and #defines. Their values are different
from the array above though... anyways, we don't need
to concern us with details. Here are other parameters
to open it (also oflags):
<br><br>
O_APPEND   place written data at the end of the file.<br>
O_TRUNC	   set length of file to zero (kinda like delete).<br>
O_CREAT	   create the file, with permissions set in "mode".<br>
O_EXCL	   ensures that the caller of function actually creates
	   the file. (it's a multi-user OS!).<br>
<br>
All above parameters for oflags are added as follows,
by bitwise OR-ing them. (using the character | on the
keyboard, look below for an example, after the definition
of the other parameters, I got the character above my
backslash on a US win95 (*ouch*) keyboard),<br>
It means that each constant can be used to heighten a value, 
but it's details yet.<br>
(I'm bound to get questions here). It'll look like:
<br>
When you use O_CREAT, you should specify the permissions,
something which is done automatically when saving a file
from emacs or whatever. Have a look into "/sys/stat.h"
for the definition. Look for :
<br>
S_IRUSR		    = read permission for owner<br>
S_IWUSR		    = write permission for owner<br>
S_IXUSR		    = execute permission for owner<br>
<br>
substitute USR with GRP for group privileges,
OTH for others permissions. (and look in stat.h).
<br><br>
<b>example:</b><br>
========<br>
<br><font face = courier>
open("myfile", O_CREAT, S_IRUSR | S_IXOTH);<br>
<br></font>
when this code is used in a program, you get the result:
(it's not compiled on my machine, taken from a book).
<br><br>
<font face = courier>"ls -ls myfile"</font>
<br><br>
<font face = courier>"0 -r-------x    1  stupid_user  software   0 Sep 22 08:11 myfile"</font>
<br><br>

It's boring to let you read so much, so let's carry on
with close and compile a program already... umask should
have been stated here but that basically is just three
digits after each other stating privileges for
owner, group and others permissions.
<br><br>
digit 1 = user permissions,<br>
digit 2 = group permission,<br>
digit 3 = others permissions,<br>
value 0 = no disallowments,<br>
value 4 = read disallowed,<br>
value 2 = write disallowed,<br>
value 1 = execute disallowed.<br>
<br>
So, 032 (a umask) has 0 in digit 1, 3 in digit 2, 2 in digit 3.
this means:<br>
0 = no disallowments for user.<br>
3 = 2 & 1 = write and execute disallowments for group.<br>
2 = write disallowed for others (but execute allowed (weird setting anyway!)).<br>
<br>
AAAAHHHHHHHHHHHHHH!!!!!!!!!!
<br><br>
It's boring, boring, boring!! let's get busy!
<br><br>
<b>File copy program (char_copy.c):</b><br>
================================<br>
<br><font face = courier>
#include &lt;unistd.h&gt;<br>
#include &lt;sys/stat.h&gt;<br>
#include &lt;fcntl.h&gt;<br>
<br>
int main()<br>
{<br>
  char c;<br>
  int in, out;<br>
<br>
  in = open("file.in", O_RDONLY);<br>
  out = open("file.out", O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR);<br>
  while(read(in, &c, 1) == 1)<br>
	write(out,&c,1);<br>
  <br><br>
  exit(0);<br>
}<br>
<br>
compile with "gcc char_copy.c -o char_copy"
<br><br></font>
"file.in" should exist, just copy it over there from
any text file and rename it to file.in in the same
process.
<br><br>
this file copies a file character by character to file.out.
this is not very efficient, I already made this remark about
system calls and overhead shit... here's where it starts,
the last example in this chapter will cover block copying and
when doing large files, you may notice the difference... sure,
you think, as a single-user to your multi-user environment,
this won't hit me much on my Cray@home, but once doing some
C/C++ for your organization, related to server management,
things start oozing around the corner there....
<br><br>
Quick! block_copy is last one today, just pick up char_copy.c
and look for any changes, save as block_copy.c... two lines
changed, char block[1024] was added and the while line changed.
<br><br>
<b>block_copy:</b><br>
===========<br>
<br><font face = courier>
#include &lt;unistd.h&gt;<br>
#include &lt;sys/stat.h&gt;<br>
#include &lt;fcntl.h&gt;<br>
<br>
int main()<br>
{<br>
  char block[1024];<br>
  int in, out;<br>
  int nread;<br>
<br>
  in = open("file.in", O_RDONLY);<br>
  out = open("file.out", O_WRONLY | O_CREAT, S_IRUSR|S_IWUSR);<br>
  while((nread = read(in,block,sizeof(block))) > 0)<br>
	 write(out,block,nread);<br>
<br>
  exit(0);<br>
}<br>
<br>
</font>
<b>Beat your heart out:</b><br>
====================<br>
<br>
* three includes, we know what they do...<br>
* int main()  (what? don't know what it means? re-read previous text);<br>
* char block[1024], create array of 1024 chars, called "block".<br>
* int in,out  (two integers who will hold file descriptors);<br>
* open (we just covered that!);<br>
* while line: <br>
<br>
interesting, I'll explain that one...<br>
read from file descriptor "in", put into "block", determine
the size of "block" (this is 1024, always, no matter if
end of file is reached), assign actual amount of bytes read
to nread, and as long as this value is larger than zero,
we continue to write to the "out" file (file.out), which
is the block we just read (block) and the amount of bytes (nread),
we just read. When end of file is reached at "in", no more
bytes can be read, nread will become "zero", and the while-
loop will be exiting...
<br><br>
all goes well, no core dumps, no segmentation fault, so
program exits with code zero (safe!).
<br><br>
i think that's enough for now!
<br><br>
questions????
</font>
</BODY>
</HTML>
