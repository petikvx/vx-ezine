Intro

Что по своей сути плугин? Это некий код, который вирус выкачивает и подсоединяет к себе, вроде так да? Давайте посмотрим на этот код ближе, мы видим call [x], проверка чего-то, потом либо call [y] либо call [z], и снова проверки, и т.д. А все эти call'ы в конечном счете приводят к вызову API функций. Получается, что львиную долю работы делают именно апишные функции, а остальной код составляет логику их связывания, т.е. все, что делает плугин это просто добавление новой логики в готовый вирус, бывают и исключения, скажем сложные алгоритмы шифрования или пермутации делают апишные вызовы только в начале и в конце своей работы. Юзерская тачка напичкана готовыми функциями, которые только и ждут, чтобы их вызвали, нам остается только вызывать их в нужной последовательности, некоторые из этих последовательностей называются прикладными программами, а другие вирусами. Таким образом, вирус отличается от обычной программы своей логикой, а не своим бинарным кодом, удивительно :) Если антивирус (эвристик) усматривает какую-то нездоровую последовательность действий программы он приходит к выводу, что это вирус.

Плугинная технология предлагает частую смену логики, вирус постоянно обновляет себя расширяя и замещая свою функциональность, аверы, просто, не успевают находить новые сигнатуры, засовывать их в новые базы, а юзеры эти новые базы скачивать. Все это будет работать до тех пор, пока не появятся эвристики способные на нетривиальную тотальную эмуляцию кода. Зачем аверу париться искать сигнатуру, если можно выловить из кода всего на всего одно действие - запись в экзешник и сразу ясно, что это вирус. Я не буду затрагивать проблемы резидентных мониторов, которым и анализировать ни чего не надо, вызовы к ним сами в лапы идут.

Из выше сказанного получаем следующее: вирус не должен обладать вирусной логикой. Парадокс. Если у вируса нет соответствующей логики, то, как он будет функционировать? Можно эту логику хитро прятать (полиморфики) или сложным образом изменять инструкции ее образующие (пермутация), а можно взять и отказаться от ее хранения. Нет логики - нет вируса.



VRPC

VRPC позволяет вызывать любые функции, хранящиеся в библиотеках удаленного компьютера. Делается это практически также просто, как и вызов функции из локальной библиотеки, даже немного проще - не нужно соблюдать обратный порядок запушивания параметров в стек при вызовах в формате stdcall, и очищать стек при cdecl (в стеке все равно ни чего полезного оказаться не может). Происходит это следующим образом: настраиваем поля структуры описывающей удаленный хост и библиотеку, в ESI заносим указатель на имя функции, в ECX количество ее параметров, пушим параметры в стек и делаем вызов, естественно, что на хосте должен работать наш сервер. Результат работы функции как обычно возвращается EAX, но следует учесть, что все возвращаемые адреса указывают в адресное пространство удаленного процесса. Например:

	; структура вызова vrpc	
	mov		EDI, offset vrpc_cs
	; порт сервера
	mov		[EDI.vrpc_call_addr.sin_port], VRPC_SERV_PORT
	; адресс сервера 127.0.0.1
	mov		[EDI.vrpc_call_addr.sin_addr], 0100007Fh
	; имя нужной библиотека
	mov		[EDI.vrpc_call_lib], offset kern32
	; формат передачи параметров на сервере:
	mov		[EDI.vrpc_call_cnv], 0
	; тип функции:
	mov		[EDI.vrpc_call_kind], 0

	; бипкнем
	mov		ESI, offset fBeep
	mov		ECX, 2
	push	1000
	push	200
	call	vrpc_call

Все удаленные функции поделены на три типа:
1.	Внешние - хранящиеся в библиотеках.
2.	Внутренние - обрабатываемые самим сервером.
3.	Вызываемые по адресу - передается точный адрес функции

Поддерживаются три формата передачи параметров:
1.	stdcall, WINAPI
2.	cdecl
3.	fastcall, register

Что позволяет вызывать любые функции, даже ориентированные на работу с объектами.

Существуют также две функции, отвечающие за передачу данных:
1.	vrpc_read - получение данных
2.	vrpc_write - отправка данных

Думаю у троянистов уже загорелись глаза и мышь выпадает из рук. ;)


А зачем это ВеРеПеЦе вообще нужно?

Продемонстрирую на наглядном примере. Даете вы дискету с сервером VRPC своему недругу или, быть может, другу, а может и никому не даете (все зависит от типа личности). Идете в интернет клуб, ждете пока жертва объявиться в инете, затем исполняете такую последовательность вызовов функций, которая приводит к заражению всех экзешников кодом сервера на его тачке. Через некоторое время жертва вкупается, что чего-то с его софтом не так и отсылает неработающую копию своей любимой игры, весом 500 мегатонн, на мыло аверам, те долго капаются во внутренностях игрушки и не находят там ни какого кода, который мог бы хоть чего-то заразить. А юзер в своем письме накатал, что мол прям все позаражалось у него и комп постоянно только и делает, что винтом трещит выискивая новую жертву. Тут у авера и приключится приступ неверия в реальность всего происходящего и ощутят оные, что разум их подвешен в пустоте. :) Вы залегаете на недельку на дно, затем опять идете в клуб, сканите IP-шники местных провайдеров и замечаете что ваш сервак уже на 10-ти тачках.
 

Outro

Все это конечно далеко от реальности, ведь по сути код сервера тоже имеет сигнатуру и так же может быть обнаружен, но и цель достигнута - возможно создать вирус не хранящий собственную логику, который совершенно чист с эвристической точки зрения. Ни что не мешает при заражении отпермутировать и стать чистым и с сигнатурной точки зрения, а ежели еще прибавить UEP и перемешивание с жертвой...
