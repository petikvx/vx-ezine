<html>
<head>
	<link rel="stylesheet" type="text/css" href="../inoz2.css">
	<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
	<meta name="author" content="SBVC">
	<title>Ring0 под Windows 9x</title>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="3" width="100%">
<tr>
 <td>
 <tt> 
<p>Работа вируса в Ring0 подробно описана в трудах Z0MBiE, с которыми можно
ознакомится на его сайте - <a href=http://z0mbie.host.sk target="_blank">http://z0mbie.host.sk</a></p>
<p>Всё ниженаписанное является лишь обобщением и не притендует на новизну! :)</p>

<p>Итак, подведём итоги работы вируса в нулевом кольце под Win9x...</p>

<p>Для перехода в ноль есть несколько методов, вот основные:</p>
<ul type="circle">
<li>Через IDT (Interrupt Descriptor Table, таблица дескрипторов прерываний)
<li>Через GDT (Global Descriptor Table, таблица глобальных дескрипторов)
<li>Через LDT (Local Descriptor Table, таблица локальных дескрипторов)
<li>Через модификацию контекста с использованием Win API
<li>Через SEH (Точнее модификация контекста с использованием SEHа)
</ul>
<p>Нужно оговориться, что первые два метода являются самыми неэффективными,
т.к. их можно обломать, например, если на компе стоит Dr.Web'овский спайдер,
то попасть в ноль через IDT и GDT не получиться.</p>

<p>Самым эффективным, на наш взгляд, является 3-ий метод (через LDT).</p>

<p>К данной статье прилагается примеры на все способы перехода в ноль. Работают
они одинаково - после запуска блокируют полностью систему пока не нажмут
клавишу ESC.</p>

<p>Мы попали ногой(и даже всем телом) в ноль. А что дальше?<br>
Теперь мы имеем доступ к системе в полном объёме, т.е. к памяти, диску,
портам и т.д... надо обустраиваться! :)<br>
<p>Как известно, в нуле нельзя просто вызывать обычные апишные функции, зато можно
делать VXDCallы.</p>
<p>Что такое VXDCall? Это нижеуказанная последовательность кода:</p>
<pre>
 int    20h
 dw     Service
 dw     VxD
</pre>
<p>где Service-это функция (например InstallFileSystemApiHook, Ring0_FileIO), а
VxD-это драйвер (например IFSMGR, VMM)</p>

<p>Нужно заметить, что после вызова прерывания, обработчик заменит этот код на 
Call adress, поэтому следует ПРЕДварительно скопировать код в к-нить 
буфер, для сохранения его первозданности.</p>
 
<p>С помощью этих колов можно делать всё то, что нам нужно - работать с файлами,
памятью и всеми устройствами.</p>

<p>Например, если нам надо выделить немного памяти, мы сделаем следущее...</p>
<pre>
 xor    EAX, EAX
 push   PAGEFIXED + PAGEZEROINIT; Атрибуты
 push   EAX                      
 push   EAX                      
 push   EAX                      
 push   EAX                      
 push   EAX			 
 push   PG_SYS	; Распределить системную память
 push   nPages	; Количество 4к-байтных страниц
 int    20h
 dw     PageAllocate
 dw     VMM
 add    ESP, 32	; Очистим стек
</pre>
<p>И ещё один момент. Параметры передаются через стек, но стек за собой эти 
функции не освобождают....</p>

<p>К статье прилагается .inc файл со всеми необходимыми константами и функциями.</p>

<p>Теперь мы можем написать обычный вирус, который рыщет по дискам в поисках жертв.
Но зачем тогда нам ноль?:) Наша цель - Резидентность!</p>

<p>Самый просиой способ - это перехватить обработчик файловой системы (IFS), точнее 
написать свой и заменить им стандартный. Что нам это даст? Таким образом, 
каждый раз, когда идёт обращение к файловой системе, ядро вызывает нас, 
а уже мы вызовем, что требуется...</p>
<pre>
 push   offset OurIFS
 int    20h
 dw     InstallFileSystemApiHook
 dw     IFSMGR
 add    ESP, 4
</pre>
<p>К статье прилагается соответствующий пример.</p>

<p>...Наверно этого будет достаточно :)</p>
<p>Все вопросы в форум <a href="http://sbvc.net/forum/" target="_blank">http://sbvc.net/forum/</a></p>
10.07.02
 </tt> 
 </td>
</tr>
</table>
</body>
</html>