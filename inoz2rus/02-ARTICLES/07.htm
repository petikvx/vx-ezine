<html>
<head>
	<link rel="stylesheet" type="text/css" href="../inoz2.css">
	<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
	<meta name="author" content="SBVC">
	<title>Четыре шага до пермутации :)</title>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="3" width="100%">
<tr>
 <td>
 <tt> 
<p>
Вам, наверное, известно, что мы уже больше чем 1.5 года занимаемся 
проблемами самоизменения кода. Так вот, только сейчас мы уже реально близки к 
желаемому результату. На данном этапе мы закончили работу над движком, который позволяет разбирать 
код по командам, изменять его и проч.
</p>
<p>Сам движок состоит из 2х файлов:
<ol>
<li><b>alma.inc</b> - дизасм Alma v3.0
<li><b>belma.inc</b> - набор необходимых процедур.
</ol>
<p>
Все нижеописанные процедуры используют одну и туже структуру переменных, ссылка на которую должна быть в регистре EBP:
<pre>
  BelmaGlobalVars	struc
   MAproc	dd ?	; Адрес процедуры выделения памяти
   MFproc	dd ?	; Адрес процедуры освобождения памяти
   CStart	dd ?	; Начало кода
   CLen	dd ?	; Длина кода
   Head	dd ?	; Голова списка
   ComNum	dd ?	; Количество команд в списке
   TempVar dd ?	; Переменная, использующаяся в различных целях
   TempVar2 dd ?	; Переменная, использующаяся в различных целях
  BelmaGlobalVars	ends
</pre>
Т.к. практически все процедуры работают с памятью, вы должны указать адреса необходимых функций. Предполагается, что формат вызова этих функций такой же как у АПИшных GlobalAlloc и GlobalFree.
</p>
<p>
Вот схема действий движка:
</p>
<ol>
<li><p><b>Дизассемблируем код и составляем список инструкций</b>
<p>
На этом этапе работает наш дизасм инструкций Alma v3.0. Он позволяет не только получить длину команды, но и полностью разобрать её структуру, а так же понять что данная команда использует и изменяет (т.е. регистры, память, флаги). Полное описание структуры отдизассембленной команды (ComandInfo)  смотрите в <b>alma.inc</b>
</p>
<p>
Процедура <b>Belma_Dizasm</b>, которая лежит в <b>belma.inc</b>, позволяет перевести код в список.<br>
</p>
<p>Структура элемента этого списка:
<pre>Item    struc
INext   dd  ?         ; Next
IFlags  db  ?         ; Flags
                      ; 1-Jmp
                      ; 2-Labels
                      ; else-nothing = 0
ICmdAdr dd  ?         ; Исходный адрес команды
ITo     dd  ?         ; Указатель на метку (если JMP)
ICI     ComandInfo ?  ; Cтруктуры отдизассембленной команды
Item    ends
</pre>
<p>Вход этой процедуры:
<pre>
[EBP.CStart] = начало кода (DWord)
[EBP.CLen] = длина кода (DWord)
</pre>
<p>Выход:
<pre>
[EBP.Head] = указатель на начало списка, или 0 при ошибке
[EBP.ComNum] = количество команд в списке (DWord)
</pre>
<p>
Т.о. если всё правильно, то после вызова данной процедуры мы получим полностью разобранный код, с которым можно будет немного поработать...
</p>
<p>
Кстати, небольшая оговорочка - КОД ДОЛЖЕН БЫТЬ ЛИНЕЙНЫМ :) Т.е. не должно быть относительных команд перехода за пределы нашего кода и не должно быть данных среди нашего кода! Гм, обычные правила пермутации :)
</p>
<li><p><b>Мутация</b>
<p>Здесь делается что угодно с нашим списком... Замена команд на синонимы, добавление мусора и т.д.</p>
<p>Для этих целей в движок заложены следующие процедуры:</p>
<p>
<b>Belma_Insert</b> - Процедура, для вставки куска кода в заданное место списка.
</p>
<p>Вход:
<pre>
[EBP.CStart] = Адрес памяти где лежит код, который надо вставлять
[EBP.CLen] = Длина кода
[EBP.Head] = Голова списка
[EBP.TempVar] = Адрес элемента списка, после которого вставлять
</pre>
<p>Выход:
<pre>
CF = 1 при ошибке
</pre>
<p>
Т.е. вы передаёте кусок кода, который вы бы хотели вставить после определённого элемента списка, Belma_Insert сама его дизасемблирует и вклеит в нужное место.
</p>
<p>
<b>Belma_Replace</b> - Процедура, для замены одного элемента списка куском кода в заданном месте.
</p>
<p>Вход:
<pre>
[EBP.CStart] = Адрес памяти где лежит код, которым надо заменять
[EBP.CLen] = Длина кода
[EBP.Head] = Голова списка
[EBP.TempVar] = Адрес элемента списка, после которого замещать
</pre>
<p>Выход:
<pre>
CF = 1 при ошибке
[EBP.TempVar] = Адрес последнего элемента, вставленного подсписка
</pre>
<p>
Т.е. вы опять передаёте кусок кода, которым вы бы хотели заменить некую команду, Belma_Replace сама его дизасемблирует и вклеит в нужное место :) + она ещё и сама удалит ненужную замещённую команду.
</p>
<p>
К сожалению, мы ещё не написали удобных процедур для перестановки команд местами, но это дело недалёкого будущего...
</p>
<p>
Кстати, саму процедуру мутации напишите сами :)), конечно же используя вышепредставленные две процедуры.
</p>
<li><p><b>Ассемблирование списка</b>
<p>Тут всё просто - переводим список в готовый работаспособный код. Для этого вам необходимо выделить достаточное количество памяти под будущий код и вызвать процедуру <b>Belma_Asm</b>:
</p>
<pre>
mov    [EBP.CStart], offset на память
call   Belma_Asm
</pre>
<p>
Для того, чтобы правильно определить нужное количество памяти, можно воспользоваться переменной [EBP.ComNum] - она показывает количество команд в данный момент в списке. Например так:
</p>
<pre>
mov     ECX, [EBP.ComNum] ; Возьмём количество команд 
shl     ECX, 4            ; и умножим на 16
</pre>
<li><p><b>Освобождение памяти из-под списка</b>
<p>
Это, пожалуй, самый важный шаг в нашей работе :) Ведь мы не имеем права захламлять память ничего не подозревающих бедных юзеров... Так вот, для освобождения памяти из-под списка есть процедура <b>Belma_FreeList</b>:
</p>
<p>Выход:
<pre>
[EBP.Head] = Голова списка
</pre>
<p>
Вот и всё!
</p>
</ol>
<p>
Ещё хочется отметить, что в <b>belma.inc</b> имеются процедуры <b>GetCommandLen</b> для определения размера одной разобранной команды и <b>Belma_AllocOneElement</b> для удобного выделения памяти под 1 элемент списка. Описания их вызовов смотрите в <b>belma.inc</b>
</p>
<p>Напоминаем, что для работы ВСЕХ процедур этого проекта просто необходимо заполнить поля  <b>MAproc</b> и <b>MFproc</b>. И не портить регистр EBP, конечно же! :)</p>
<p>
Данная версия движка ещё не закончина полностью и работа по его усовершенствованию ведётся постоянно. Наш дизасм понимает большинство команд x86 процесоров (полный список понимаемых команд см. <b>alma.inc</b>) за исключением, пожалуй, всяких извратных команд MMXа, навороченых команд последних AMDшек и т.п. Но для нашей цели вполне достаточно того что есть...
</p>
20.08.02
 </tt>
 </td>
</tr>
</table>
</body>
</html>