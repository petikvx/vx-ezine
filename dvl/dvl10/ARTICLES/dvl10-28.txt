- [Duke's Virus Labs #10] - [Page 28] -

Linux вирусы
(c) by ULTRAS/MATRiX

В этой статье я попробую обьяснить как написать вирус под Linux.
Это статья рассчитана для начинающих в написании вирусов под эту 
платформу.

Linux очень похож на старый добрый Д0с, ниже я покажу маленькую 
программу и вы поймете почему я так говорю. А пока я обьясню для начинающих как
вообще производиться вызов в асме под linux. Мы заносим в eax номер системного 
вызова, в ebx & ecx & edx мы заносим аргументы. Иногда, мы заносим не сам 
аргумент, а его адрес. Вызываются syscall-ы linux-овым прерыванием int80.

Пример программы
~~~~~~~~~~~~~~~~

global main

section .data
main:

    mov eax,0bh		;  Функуция 11(Запуск) - execve
    mov ebx,filez	;  Имя файла которое мы должны запустить
    mov ecx,parz	;  Параметры
    xor edx,edx
    int 80h		;  SysCall
    mov eax,1		;  Функция 1(Выход) - exit
    mov ebx,0		;  параметры выхода
    int 80h		;  SysCall

filez db '/bin/ping',0	;  имя программы которое нужно запустить
parz  dd filez		;  полное имя файла
      dd par_1		;  первый параметр для запускаемого файла
      dd par_1		;  второй параметр для запускаемого файла
      dd 0		;  закончились параметры
par_1 db 'www.coderz.net/ultras',0
par_2 db '3',0



Это маленькая программа выполнит следующие действия:

ping www.coderz.net/ultras 3

Все очень просто и легко как в Д0се.

Syscall
~~~~~~~

Маленький список функций который понадобиться при написаний вирусов или 
программ под linux.

01 - exit     
02 - fork     
03 - read     
04 - write     
05 - open
06 - close    
08 - creat    
11 - execve   
12 - chdir     
15 - chmod
19 - lseek    
26 - ptrace   
37 - kill     
89 - readdir   
90 - mmap

Полный список функций вы найдете: /usr/include/asm/unistd.h

Структура ELF файлов
~~~~~~~~~~~~~~~~~~~~

Многие ELF файлы имеют примерно такую структуру:
 
  +---------------------------+
  │        ELF Header         │
  +---------------------------+
  │     Program head table    │
  +---------------------------+
  │	.text section	      +
  +---------------------------+
  │     .data section         │
  +---------------------------+
  │         .........         │
  +---------------------------+
  │    Section header table   │
  +---------------------------+
  │        Section(s)         │
  +---------------------------+

Как выглядит стандаpтный заголовок ELF.

  0  e_ident     - некоторые флаги
+10  e_type	 - тип файла
+12  e_machine   - аpхитектуpа системы
+14  e_version   - веpсия объекта
+18  e_entry     - entry point
+1c  e_phoff     - смещение пpогpамного заголовка
+20  e_shoff     - смещение секционного заголовка
+24  e_flags     - пpоцессоpные флаги
+28  e_ehsize    - pазмеp заголовка ELF
+2A  e_phentsize - pазмеp ячейки пpогpамного хедера
+2C  e_phnum     - колличество ячеек
+2E  e_shentsize - pазмеp ячейки секционного хедера
+30  e_shunum    - колличество ячеек
+32  e_shstrndx  - индексная стpока секционного хедера

Как выглядит пpогpамный заголовок ELF.

  0  p_type	 - тип сегмента
 +4  p_offset    - смещение в файле
 +8  p_vaddr     - виpтуальный адpес сегмента
 +c  p_addr      - физический адpес сегмента
+10  p_filesz    - pазмеp сегмента в файле
+14  p_memsz     - pазмеp сегмента в памяти
+18  p_flags     - сегментные флаги
+1c  p_align     - расположение сегмента

Как выглядит секционый заголовок ELF.

  0  sh_name     - содержит указатель на имя секций и др. муть
 +4  sh_type     - тип секции
 +8  sh_flags    - флаги
 +c  sh_addr     - физический адpес сегмента
+10  sh_offset   - смещение в файле
+14  sh_size     - размер сек
+18  sh_link     - его использование зависит от типа секции
+1c  sh_info     - зависит от типа секции
+20  sh_addralign- расположение сегмента
+24  sh_entsize  - секция содержит установленные входы размера


Вот примерно так будет выглядеть header+hello world!
Это программа длиной всего в 59 байтов.

BITS 32
		org	0x68504000
		db	0x7F, "ELF"		; maGic numberz
		dd	1
		dd	0
		db	0
entry:		inc	eax			; программа начинается здесь
		push	eax
		push	dword 0x00030002
		xor	eax,eax			; обнулим eax
		lea	edx,[byte eax + 13]	; 13 = размер буфера
		inc	eax			; eax теперь = 1
		push	eax			; 1 = выход (exit) syscall
		push	dword 4			; 4 = запись(write) syscall
		mov	ecx,msgtext		; в ecx поместим сообщение
		xchg	eax,ebx			; 1 = stdout
done:		pop	eax
		int	0x80			; make the syscall
		dec	ebx			; 0 == нет проблем выходим из программы
		jmp	short done		; вызовим дальнейший syscall
		dw	1
msgtext:	db	'hello, world', 10

Вот собственно и сам хедер и описание к ниму:

e_ident:	db	0x7F, "ELF"			; required
		db	1				; 1 = ELFCLASS32
		db	0				; мусор
		db	0				; мусор
		db	0x00, 0x00, 0x00, 0x00		; неиспользованный
		db	0x00, 0x00, 0x40, 0x50, 0x68
e_type:		dw	2				; 2 = ET_EXE
e_machine:	dw	3				; 3 = EM_386
e_version:	dd	0x508DC031			; мусор
e_entry:	dd	entry				; программа начинается здесь
e_phoff:	dd	4				; phdrs located here
e_shoff:	dd	0x50402EB9			; мусор
e_flags:	dd	0xCD589368			; неиспользованный
e_ehsize:	dw	0x4B80				; мусор
e_phentsize:	dw	0xFAEB				; мусор
e_phnum:	dw	1				; один phdr
e_shentsize:	dw	0x6568				; мусор
e_shnum:	dw	0x6C6C				; мусор
e_shstrndx:	dw	0x2C6F				; мусор

пpогpамный заголовок ELF

p_type:	dd	1					; 1 = PT_LOAD
p_offset:	dd	0				; читаем с начло файла
p_vaddr:	dd	$$				; загрузим этот адресс
p_paddr:	dd	0x00030002			; неиспользуем
p_filesz:	dd	0x508D30C1			; много, больше
p_memsz:	dd	entry				; черезмерный
p_flags:	dd	4				; 4 = PF_R (no PF_X?)
p_align:	dd	0x2EB9				; мусор

В следующих статьях я попробую подробно описать подробное описание всех 
возможных секций в ELF файлах и многое другое...

Методы заражения
~~~~~~~~~~~~~~~~~

Ниже я попробую описать некоторые методы заражения ELF файлов которые я знаю.

1. Метод

Ищем секцию неинициализированных данных "bss" и встраиваем свой код внутрь этой 
секции, при этом надо увеличить размер секции на размер вируса+разной мути и 
сдвинуть вниз оставшуюся часть файла. Таким образом мы не изменяет адрес точки 
входа ELF-файла. Запоминаем оригинальные байты внутри себя, а вместо них 
записывает команду перехода на код вируса. Также можно(нужно) переименовать 
секцию 'bss' например в 'bzz' и изменить ее атрибуты.

2. Метод

Увеличивает размер последней секции файла и запоминает адрес точки входа. Затем 
дописывает себя в конец файла и устанавливает адрес точки входа на свой код.

3. Метод

Записываемся в первую обнаруженную секцию кода, предварительно 
увеличив ее размер на размер вируса. Разбираем внутренний формат ELF файла, 
считываем заголовки секций, определяет адрес первой секции кода, 
сдвигаем ее и все последующие секции вниз, записываем свой собственный код в 
образовавшееся пространство и затем необходимым образом корректируем заголовки 
секций и адрес "точки входа" - адрес процедуры, на которую передается 
управление при запуске файла. В зараженных файлах адрес "точки входа" указывает 
на код вируса.

4. Метод

Записываем себя в самое начало ELF файлов, перед заражением файлов считываем 
свое тело из файла носителя. Потом чтобы запустить файл-носитель, нам нужно 
создать временный файл и записывает в него тело файла-носителя и exec его.

Все методы по своему интересны, но и у каждого метода есть свой недостатки.

tnanx Silvio Cesare, Mandragore, dr.insane, paddingx


   							    -=ULTRAS=- (c) 2000
							    What`s my age again
