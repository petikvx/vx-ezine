- [Duke's Virus Labs #4] - [Page 20] -

Утилита DAT2ASM v0.01
(c) by Duke/SMF

   При создании демонстрационных вирусов HLLC.TRANS.Demo, HLLC.PINC.Demo
и HLLO.TPPE.Demo мне потребовалось упаковать несколько TXT-файлов так,
чтобы потом быстренько извлечь их на диск. И при этом хотелось, чтобы не
было зависимости вируса от наличия распаковщиков на диске.
   Первое, что приходит в голову, это создание SFX-архива. Но SFX имеют
структуру EXE-файла (читай - лишнее место под заголовок), выводят на экран
всякие сообщения, чересчур универсальны (и поэтому громоздки).
   Поэтому на скорую руку я слепил (другие слова здесь не подойдут :) эту
утилиточку. Размер получаемого COM-файла превосходит размер DAT-файлов
лишь на сотенку байт. Но нам-то нужна упаковка... Берем утилитку PKLITE
(DIET или еще какую) и сжимаем COM-файл. Полученное ничуть не уступает
любому другому SFX-архиву по качеству и размеру.
   Если надо запаковать несколько файлов (скажем, text1.dat - text9.dat)
в архивчик, то создаем текстовичок pack.txt вида:
   text1.dat
   .........
   text9.dat
и напускаем на него утилитку :
   dat2asm 2 pack.txt packing.asm
В итоге в файле packing.asm имеем исходник ;) будущего SFX-архива.
Для одного файла data.txt все и того проще :
   dat2asm 1 data.txt packing.asm
И все ! Телемаркет !
   Если кого-то что-то не устраивиет - пишите сами !  (8-P

===== Cut here =====
program dat2asm;
var txt,as:text;
    st:string;
    n,d:byte;
{---------------------------}
procedure About;
begin
writeln('DAT2ASM v0.01 (c) by Duke/SMF  * DVL Utilities *');
writeln('Usage : DAT2ASM <option> <filename> <target.asm>');
writeln('Option: 1 - convert <filename> to <target.asm>');
writeln('        2 - convert files from <filename> to <target.asm>');
halt;
end;
{--------------------------}
procedure Head;
begin
assign(as,paramstr(3));rewrite(as);
writeln(as,'; This file created with DAT2ASM v0.01 by Duke/SMF');
writeln(as,'model tiny');
writeln(as,'.code');
writeln(as,'org 100h');
writeln(as,'Start:');
end;
{--------------------------}
procedure Heart;
begin
writeln(as,';-------------------------------');
writeln(as,'NewFile PROC    NEAR');
writeln(as,'');
writeln(as,'        mov     ah,3Ch           ; функция создания');
writeln(as,'        mov     cx,0             ; атрибутов нет');
writeln(as,'        int     21h');
writeln(as,'        mov     Handle,ax        ; описатель файла');
writeln(as,'        ret');
writeln(as,'        endp');
writeln(as,';-------------------------------');
writeln(as,'Write   PROC    NEAR');
writeln(as,'');
writeln(as,'        mov     ah,40h           ; функция записи');
writeln(as,'        mov     bx,Handle        ; описатель');
writeln(as,'        int     21h');
writeln(as,'');
writeln(as,'        mov     ah,3Eh           ; функция закрытия файла');
writeln(as,'        mov     bx,Handle');
writeln(as,'        int     21h');
writeln(as,'        ret');
writeln(as,'        endp');
writeln(as,';------------------------------');
writeln(as,'Handle  dw 0');
writeln(as,'');
end;
{--------------------------}
procedure Tail;
begin
writeln(as,'end Start');
close(as);
end;
{--------------------------}
procedure Code(s:string);
begin
n:=n+1;
writeln(as,'    mov dx, offset name',n);
writeln(as,'    call NewFile');
writeln(as,'    mov cx,len',n);
writeln(as,'    mov dx,offset Data',n);
writeln(as,'    call Write');
writeln(as,'');
end;
{--------------------------}
procedure Data(s:string);
var f:file of byte;
    k:byte;
    i:byte; {счетчик}
begin
d:=d+1;
writeln(as,'Name',d,': db ''',s,''',0');
writeln(as,'Data',d,': ');
assign(f,s);reset(f);
i:=0;
write(as,'db ');
while not eof (f) do
   begin
   i:=i+1;
   read(f,k);
   write(as,k);
   if i=20 then
     begin
     writeln(as,'');
     if not eof(f) then write(as,'db ');
     i:=0;
     end
   else if not eof(f) then write(as,',');
   end;
writeln(as,'');
writeln(as,'len',d,' equ ',filesize(f));
close(f);
end;
{--------------------------}
begin
if paramcount<>3 then About;
n:=0;
d:=0;
st:=paramstr(1);
case st[1] of
   '1' : begin
         Head;
         Code(paramstr(2));
         Heart;
         Data(paramstr(2));
         Tail;
         end;
   '2' : begin
         Head;
         assign(txt,paramstr(2));
         reset(txt);
         while not eof(txt) do
           begin
           readln(txt,st);
           Code(st);
           end;
         Heart;
         reset(txt);
         while not eof(txt) do
           begin
           readln(txt,st);
           Data(st);
           end;
         close(txt);
         Tail;
         end;
   else About;
   end;
end.
===== Cut here =====
