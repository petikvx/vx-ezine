<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Da Renegade fuckin' HTML Creator">
<TITLE>assembly</TITLE>
<META NAME="Version" CONTENT="8.0.3429">
<META NAME="Date" CONTENT="11/19/96">
<META NAME="Template" CONTENT="D:\Office 97 Pro\Office\HTML.DOT">
</HEAD>
<BODY TEXT="#000000" VLINK="#800080" BGCOLOR="#000000">

<P ALIGN="CENTER"><IMG SRC="night.ren" WIDTH=120 HEIGHT=108><B><FONT SIZE=7 COLOR="#ffff00">L'assembly<IMG SRC="night.ren" WIDTH=120 HEIGHT=108></P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Eccoci qua, dopo un sacco di teoria iniziamo il vero lavoro.Ovviamente non vi posso insegnare l'intero assembly, per&ograve; almeno una piccola introduzione ve la dar&ograve;. Sarete voi che dovrete interessarvi, altrimenti non ce la farete mai.Comunque per farvi qualche idea di come funziona l'assembly, iniziamo pure.</P>
<P>La prima cosa da capire, forse la pi&ugrave; importante, sono i registers.Ci sono tre diverse grandezze di registers, quelli a 8, 16 e 32-bit.Iniziamo con i "General Purpose Registers", quelli che userete di pi&ugrave;.Sono quattro, </FONT><B><FONT FACE="Arial" COLOR="#00ff00">ax,bx,cx,dx.</B></FONT><FONT FACE="Arial" COLOR="#ffff00">Questi sono registers a 16 -bit, che per&ograve; possono essere divisi in un high e low byte, ciascuno con un valore di 8-bit.Prendiamo come esempio </FONT><B><FONT FACE="Arial" COLOR="#00ff00">ax, </B></FONT><FONT FACE="Arial" COLOR="#ffff00">che pu&ograve; essere usato con un high byte,</FONT><B><FONT FACE="Arial" COLOR="#00ff00">ah</B></FONT><FONT FACE="Arial" COLOR="#ffff00">, oppure con un low byte,</FONT><B><FONT FACE="Arial" COLOR="#00ff00">al.</B></FONT><FONT FACE="Arial" COLOR="#ffff00">Cos&igrave; si ottengono in tutto tre diversi registers che potrete infatti trattare come se fossero tutti diversi.</P>
<P>Poi ci sono gli Index Registers,</FONT><B><FONT FACE="Arial" COLOR="#00ff00">si,di,ip </B></FONT><FONT FACE="Arial" COLOR="#ffff00">e sono registers a 16-bit.Esistono anche Segment Registers,</FONT><B><FONT FACE="Arial" COLOR="#00ff00">cs,ds,es,ss </B></FONT><FONT FACE="Arial" COLOR="#ffff00">e infine i Stack Registers,</FONT><B><FONT FACE="Arial" COLOR="#00ff00">bp e sp.</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Per arrivare ad un indirizzo di 20-bit, si usa una specie di overlap del </FONT><B><FONT FACE="Arial" COLOR="#00ff00">ds e si</B></FONT><FONT FACE="Arial" COLOR="#ffff00">.<B>DS</B> contiene il segment mentre <B>SI</B> contiene l'offset.I segment registers sapete gi&agrave; quali sono, mentre i registers dell'offset sono:</FONT><B><FONT FACE="Arial" COLOR="#00ff00">bx,di,si,bp,sp,ip.</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Lo stack: E' una piccola area di memoria dove potete salvare e ripristinare valori.I commandi che si usano sono </FONT><B><FONT FACE="Arial" COLOR="#00ff00">push e pop.</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Ora, per mandare dati in un register, si usa il commando </FONT><B><FONT FACE="Arial" COLOR="#00ff00">mov.</B></FONT><FONT FACE="Arial" COLOR="#ffff00">Vi faccio un esempio.Se voglio mettere il valore 10 in ax, user&ograve; questo commando :</FONT><B><FONT FACE="Arial" COLOR="#00ff00"> mov ax,10</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>La prima cosa dopo il mov sar&agrave; la "destinazione", la seconda "l'origine".Nel nostro caso la destinazione &egrave; il register ax, l'origine il valore 10 che vogliamo mettere in ax.</P>
<P>Ritorniamo allo stack:Quando farete un programma in assembly, spesso avrete bisogno di pi&ugrave; di quella decina di commandi che avete a disposizione.Per questo si possono salvare valori nello stack e , in un secondo tempo, ripristinarli quando ne avrete bisogno.Per portare un valore nello stack, come gi&agrave; detto, si usa il commando </FONT><B><FONT FACE="Arial" COLOR="#00ff00">pop,</B></FONT><FONT FACE="Arial" COLOR="#ffff00">per ripristinare un valore, </FONT><B><FONT FACE="Arial" COLOR="#00ff00">push.</B></FONT><FONT FACE="Arial" COLOR="#ffff00">Il concetto che dovete capire, &egrave; che non potete salvare e ripristinare come lo volete voi, ma potete ripristinare sempre solamente l'ultimo valore che avete salvato.Un esempio: </P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Push cx </B></FONT><FONT FACE="Arial" COLOR="#ffff00">"pusher&agrave;" cx nello stack</P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Push ax </B></FONT><FONT FACE="Arial" COLOR="#ffff00">"pusher&agrave;" ax nello stack</P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Pop cx </B></FONT><FONT FACE="Arial" COLOR="#ffff00">"popper&agrave;" il primo valore dallo stack in cx</P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Pop ax </B></FONT><FONT FACE="Arial" COLOR="#ffff00">"popper&agrave;" il prossimo valore dallo stack in ax</P>
<P>Per&ograve; a causa di quel concetto, i valori cx e ax saranno scambiati.Per questo si usa il commando </FONT><B><FONT FACE="Arial" COLOR="#00ff00">xchg.</B></FONT><FONT FACE="Arial" COLOR="#ffff00">Nel nostro caso basterebbe un </FONT><B><FONT FACE="Arial" COLOR="#00ff00">xchg ax,cx </B></FONT><FONT FACE="Arial" COLOR="#ffff00">per rimettere le cose come dovrebbero stare.Dovete per&ograve; sempre stare attenti a non mettere troppi dati nello stack, altrimenti rischierete lo "stack overflow".</P>
<P>Adesso vi far&ograve; vedere una lista generale degli opcodes.Cercate di procuravela da qualche parte, forse la includer&ograve; nella prossima edizione, cos&igrave; vedrete un p&ograve; i commandi che esistono.</P>
</FONT><B><FONT FACE="Arial" SIZE=1 COLOR="#00ff00"><P>AAA - Ascii Adjust for Addition</P>
<P>AAD - Ascii Adjust for Division</P>
<P>AAM - Ascii Adjust for Multiplication</P>
<P>AAS - Ascii Adjust for Subtraction </P>
<P>ADC - Add With Carry </P>
<P>ADD - Arithmetic Addition</P>
<P>AND - Logical And</P>
<P>ARPL - Adjusted Requested Privilege Level of Selector (286+ PM)</P>
<P>BOUND - Array Index Bound Check (80188+) </P>
<P>BSF - Bit Scan Forward (386+)</P>
<P>BSR - Bit Scan Reverse (386+) </P>
<P>BSWAP - Byte Swap (486+) </P>
<P>BT - Bit Test (386+) </P>
<P>BTC - Bit Test with Compliment (386+)</P>
<P>BTR - Bit Test with Reset (386+)</P>
<P>BTS - Bit Test and Set (386+) </P>
<P>CALL - Procedure Call</P>
<P>CBW - Convert Byte to Word </P>
<P>CDQ - Convert Double to Quad (386+)</P>
<P>CLC - Clear Carry</P>
<P>CLD - Clear Direction Flag </P>
<P>CLI - Clear Interrupt Flag (disable) </P>
<P>CLTS - Clear Task Switched Flag (286+ privileged)</P>
<P>CMC - Complement Carry Flag</P>
<P>CMP - Compare</P>
<P>CMPS - Compare String (Byte, Word or Doubleword) </P>
<P>CMPXCHG - Compare and Exchange </P>
<P>CWD - Convert Word to Doubleword </P>
<P>CWDE - Convert Word to Extended Doubleword (386+)</P>
<P>DAA - Decimal Adjust for Addition</P>
<P>DAS - Decimal Adjust for Subtraction </P>
<P>DEC - Decrement</P>
<P>DIV - Divide </P>
<P>ENTER - Make Stack Frame (80188+) </P>
<P>ESC - Escape </P>
<P>HLT - Halt CPU </P>
<P>IDIV - Signed Integer Division </P>
<P>IMUL - Signed Multiply </P>
<P>IN - Input Byte or Word From Port</P>
<P>INC - Increment</P>
<P>INS - Input String from Port (80188+) </P>
<P>INT - Interrupt</P>
<P>INTO - Interrupt on Overflow </P>
<P>INVD - Invalidate Cache (486+)</P>
<P>INVLPG - Invalidate Translation Look-Aside Buffer Entry (486+)</P>
<P>IRET/IRETD - Interrupt Return</P>
<P>Jxx - Jump Instructions Table</P>
<P>JCXZ/JECXZ - Jump if Register (E)CX is Zero</P>
<P>JMP - Unconditional Jump </P>
<P>LAHF - Load Register AH From Flags </P>
<P>LAR - Load Access Rights (286+ protected)</P>
<P>LDS - Load Pointer Using DS</P>
<P>LEA - Load Effective Address </P>
<P>LEAVE - Restore Stack for Procedure Exit (80188+)</P>
<P>LES - Load Pointer Using ES</P>
<P>LFS - Load Pointer Using FS (386+) </P>
<P>LGDT - Load Global Descriptor Table (286+ privileged)</P>
<P>LIDT - Load Interrupt Descriptor Table (286+ privileged) </P>
<P>LGS - Load Pointer Using GS (386+) </P>
<P>LLDT - Load Local Descriptor Table (286+ privileged) </P>
<P>LMSW - Load Machine Status Word (286+ privileged</P>
<P>LOCK - Lock Bus</P>
<P>LODS - Load String (Byte, Word or Double)</P>
<P>LOOP - Decrement CX and Loop if CX Not Zero</P>
<P>LOOPE/LOOPZ - Loop While Equal / Loop While Zero </P>
<P>LOOPNZ/LOOPNE - Loop While Not Zero / Loop While Not Equal </P>
<P>LSL - Load Segment Limit (286+ protected)</P>
<P>LSS - Load Pointer Using SS (386+) </P>
<P>LTR - Load Task Register (286+ privileged) </P>
<P>MOV - Move Byte or Word</P>
<P>MOVS - Move String (Byte or Word)</P>
<P>MOVSX - Move with Sign Extend (386+) </P>
<P>MOVZX - Move with Zero Extend (386+) </P>
<P>MUL - Unsigned Multiply</P>
<P>NEG - Two's Complement Negation</P>
<P>NOP - No Operation (90h) </P>
<P>NOT - One's Compliment Negation (Logical NOT)</P>
<P>OR - Inclusive Logical OR</P>
<P>OUT - Output Data to Port</P>
<P>OUTS - Output String to Port (80188+) </P>
<P>POP - Pop Word off Stack </P>
<P>POPA/POPAD - Pop All Registers onto Stack (80188+)</P>
<P>POPF/POPFD - Pop Flags off Stack </P>
<P>PUSH - Push Word onto Stack</P>
<P>PUSHA/PUSHAD - Push All Registers onto Stack (80188+) </P>
<P>PUSHF/PUSHFD - Push Flags onto Stack </P>
<P>RCL - Rotate Through Carry Left</P>
<P>RCR - Rotate Through Carry Right </P>
<P>REP - Repeat String Operation</P>
<P>REPE/REPZ - Repeat Equal / Repeat Zero </P>
<P>REPNE/REPNZ - Repeat Not Equal / Repeat Not Zero </P>
<P>RET/RETF - Return From Procedure </P>
<P>ROL - Rotate Left</P>
<P>ROR - Rotate Right </P>
<P>SAHF - Store AH Register into FLAGS</P>
<P>SAL/SHL - Shift Arithmetic Left / Shift Logical Left </P>
<P>SAR - Shift Arithmetic Right </P>
<P>SBB - Subtract with Borrow/Carry </P>
<P>SCAS - Scan String (Byte, Word or Doubleword) </P>
<P>SETAE/SETNB - Set if Above or Equal / Set if Not Below (386+)</P>
<P>SETB/SETNAE - Set if Below / Set if Not Above or Equal (386+)</P>
<P>SETBE/SETNA - Set if Below or Equal / Set if Not Above (386+)</P>
<P>SETE/SETZ - Set if Equal / Set if Zero (386+)</P>
<P>SETNE/SETNZ - Set if Not Equal / Set if Not Zero (386+)</P>
<P>SETL/SETNGE - Set if Less / Set if Not Greater or Equal (386+) </P>
<P>SETGE/SETNL - Set if Greater or Equal / Set if Not Less (386+) </P>
<P>SETLE/SETNG - Set if Less or Equal / Set if Not greater or Equal (386+) </P>
<P>SETG/SETNLE - Set if Greater / Set if Not Less or Equal (386+) </P>
<P>SETS - Set if Signed (386+)</P>
<P>SETNS - Set if Not Signed (386+) </P>
<P>SETC - Set if Carry (386+) </P>
<P>SETNC - Set if Not Carry (386+)</P>
<P>SETO - Set if Overflow (386+)</P>
<P>SETNO - Set if Not Overflow (386+) </P>
<P>SETP/SETPE - Set if Parity / Set if Parity Even (386+)</P>
<P>SETNP/SETPO - Set if No Parity / Set if Parity Odd (386+)</P>
<P>SGDT - Store Global Descriptor Table (286+ privileged) </P>
<P>SIDT - Store Interrupt Descriptor Table (286+ privileged)</P>
<P>SHL - Shift Logical Left </P>
<P>SHR - Shift Logical Right</P>
<P>SHLD/SHRD - Double Precision Shift (386+)</P>
<P>SLDT - Store Local Descriptor Table (286+ privileged)</P>
<P>SMSW - Store Machine Status Word (286+ privileged) </P>
<P>STC - Set Carry</P>
<P>STD - Set Direction Flag </P>
<P>STI - Set Interrupt Flag (Enable Interrupts)</P>
<P>STOS - Store String (Byte, Word or Doubleword)</P>
<P>STR - Store Task Register (286+ privileged)</P>
<P>SUB - Subtract </P>
<P>TEST - Test For Bit Pattern</P>
<P>VERR - Verify Read (286+ protected)</P>
<P>VERW - Verify Write (286+ protected) </P>
<P>WAIT/FWAIT - Event Wait</P>
<P>WBINVD - Write-Back and Invalidate Cache (486+)</P>
<P>XCHG - Exchange</P>
<P>XLAT/XLATB - Translate </P>
<P>XOR - Exclusive OR</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Ma non pensate che sia tutto qua, per esempio per il commando Jump,</FONT><B><FONT FACE="Arial" COLOR="#00ff00">jmp,</B></FONT><FONT FACE="Arial" COLOR="#ffff00"> esistono un sacco di altri commandi, visto che per ogni tipo di condizione occorre un altro commando.Ecco le funzioni del jump :</P>
</FONT><B><FONT FACE="Courier New" SIZE=1 COLOR="#00ff00"><P>Mnemonic Meaning Jump Condition</P>
<P>JA Jump if Above CF=0 and ZF=0</P>
<P>JAE Jump if Above or Equal CF=0</P>
<P>JB Jump if Below CF=1</P>
<P>JBE Jump if Below or Equal CF=1 or ZF=1</P>
<P>JC Jump if Carry CF=1</P>
<P>JCXZ Jump if CX Zero CX=0</P>
<P>JE Jump if Equal ZF=1</P>
<P>JG Jump if Greater (signed) ZF=0 and SF=OF</P>
<P>JGE Jump if Greater or Equal (signed) SF=OF</P>
<P>JL Jump if Less (signed) SF != OF</P>
<P>JLE Jump if Less or Equal (signed) ZF=1 or SF != OF</P>
<P>JMP Unconditional Jump unconditional</P>
<P>JNA Jump if Not Above CF=1 or ZF=1</P>
<P>JNAE Jump if Not Above or Equal CF=1</P>
<P>JNB Jump if Not Below CF=0</P>
<P>JNBE Jump if Not Below or Equal CF=0 and ZF=0</P>
<P>JNC Jump if Not Carry CF=0</P>
<P>JNE Jump if Not Equal ZF=0</P>
<P>JNG Jump if Not Greater (signed) ZF=1 or SF != OF</P>
<P>JNGE Jump if Not Greater or Equal (signed) SF != OF</P>
<P>JNL Jump if Not Less (signed) SF=OF</P>
<P>JNLE Jump if Not Less or Equal (signed) ZF=0 and SF=OF</P>
<P>JNO Jump if Not Overflow (signed) OF=0</P>
<P>JNP Jump if No Parity PF=0</P>
<P>JNS Jump if Not Signed (signed) SF=0</P>
<P>JNZ Jump if Not Zero ZF=0</P>
<P>JO Jump if Overflow (signed) OF=1</P>
<P>JP Jump if Parity PF=1</P>
<P>JPE Jump if Parity Even PF=1</P>
<P>JPO Jump if Parity Odd PF=0</P>
<P>JS Jump if Signed (signed) SF=1</P>
<P>JZ Jump if Zero ZF=1</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Per questo &egrave; molto importante avere una lista completa sempre a disposizione.La lista degli opcodes viene fornita da Intel &egrave; specialmente all'inizio pu&ograve; essere un grande aiuto.</P>
<P>Visto che stiamo parlando di liste, un'altra lista, <B>indispensabile</B> per ogni programmatore, &egrave; la lista degli interrupt.La pi&ugrave; nota e completa &egrave; la "Ralf Brown's Interrupt list", la troverete sicuramente in Internet.Questa per&ograve; non la pubblicher&ograve;, perch&egrave; la lista completa occupa qualche mega di spazio.Quindi dovrete vedere voi un p&ograve; in giro, ma non dovrebbe essere un problema.Vi ricordo che avrete assolutamente bisogno di questa lista, prima o poi, quindi cercatela.</P>
<P>Questo &egrave; un piccolo riassunto, fatto da Bent Lynggaard, degli 256 interrupts.</P>
</FONT><B><FONT FACE="Arial" SIZE=1 COLOR="#00ff00"><P>INT 00 - CPU-generated - DIVIDE ERROR</P>
<P>INT 01 - CPU-generated - SINGLE STEP; (80386+) - DEBUGGING EXCEPTIONS</P>
<P>INT 02 - external hardware - NON-MASKABLE INTERRUPT</P>
<P>INT 03 - CPU-generated - BREAKPOINT</P>
<P>INT 04 - CPU-generated - INTO DETECTED OVERFLOW</P>
<P>INT 05 - PRINT SCREEN; CPU-generated (80186+) - BOUND RANGE EXCEEDED</P>
<P>INT 06 - CPU-generated (80286+) - INVALID OPCODE</P>
<P>INT 07 - CPU-generated (80286+) - PROCESSOR EXTENSION NOT AVAILABLE</P>
<P>INT 08 - IRQ0 - SYSTEM TIMER; CPU-generated (80286+)</P>
<P>INT 09 - IRQ1 - KEYBOARD DATA READY; CPU-generated (80286,80386)</P>
<P>INT 0A - IRQ2 - LPT2/EGA,VGA/IRQ9; CPU-generated (80286+)</P>
<P>INT 0B - IRQ3 - SERIAL COMMUNICATIONS (COM2); CPU-generated (80286+)</P>
<P>INT 0C - IRQ4 - SERIAL COMMUNICATIONS (COM1); CPU-generated (80286+)</P>
<P>INT 0D - IRQ5 - FIXED DISK/LPT2/reserved; CPU-generated (80286+)</P>
<P>INT 0E - IRQ6 - DISKETTE CONTROLLER; CPU-generated (80386+)</P>
<P>INT 0F - IRQ7 - PARALLEL PRINTER</P>
<P>INT 10 - VIDEO; CPU-generated (80286+)</P>
<P>INT 11 - BIOS - GET EQUIPMENT LIST; CPU-generated (80486+)</P>
<P>INT 12 - BIOS - GET MEMORY SIZE</P>
<P>INT 13 - DISK</P>
<P>INT 14 - SERIAL</P>
<P>INT 15 - CASSETTE</P>
<P>INT 16 - KEYBOARD</P>
<P>INT 17 - PRINTER</P>
<P>INT 18 - DISKLESS BOOT HOOK (START CASSETTE BASIC)</P>
<P>INT 19 - SYSTEM - BOOTSTRAP LOADER</P>
<P>INT 1A - TIME</P>
<P>INT 1B - KEYBOARD - CONTROL-BREAK HANDLER</P>
<P>INT 1C - TIME - SYSTEM TIMER TICK</P>
<P>INT 1D - SYSTEM DATA - VIDEO PARAMETER TABLES</P>
<P>INT 1E - SYSTEM DATA - DISKETTE PARAMETERS</P>
<P>INT 1F - SYSTEM DATA - 8x8 GRAPHICS FONT</P>
<P>INT 20 - DOS 1+ - TERMINATE PROGRAM</P>
<P>INT 21 - DOS 1+ - Function Calls</P>
<P>INT 22 - DOS 1+ - PROGRAM TERMINATION ADDRESS</P>
<P>INT 23 - DOS 1+ - CONTROL-C/CONTROL-BREAK HANDLER</P>
<P>INT 24 - DOS 1+ - CRITICAL ERROR HANDLER</P>
<P>INT 25 - DOS 1+ - ABSOLUTE DISK READ</P>
<P>INT 26 - DOS 1+ - ABSOLUTE DISK WRITE</P>
<P>INT 27 - DOS 1+ - TERMINATE AND STAY RESIDENT</P>
<P>INT 28 - DOS 2+ - DOS IDLE INTERRUPT</P>
<P>INT 29 - DOS 2+ - FAST CONSOLE OUTPUT</P>
<P>INT 2A - NETBIOS</P>
<P>INT 2B - DOS 2+ - RESERVED</P>
<P>INT 2C - DOS 2+ - RESERVED</P>
<P>INT 2D - DOS 2+ - RESERVED</P>
<P>INT 2E - DOS 2+ - PASS COMMAND TO COMMAND INTERPRETER FOR EXECUTION</P>
<P>INT 2F - Multiplex</P>
<P>INT 30 - (NOT A VECTOR!) - DOS 1+ - FAR JMP instruction</P>
<P>INT 31 - overwritten by CP/M jump instruction in INT 30</P>
<P>INT 32 - (no special use)</P>
<P>INT 33 - MS MOUSE</P>
<P>INT 34 - FLOATING POINT EMULATION - OPCODE D8h</P>
<P>INT 35 - FLOATING POINT EMULATION - OPCODE D9h</P>
<P>INT 36 - FLOATING POINT EMULATION - OPCODE DAh</P>
<P>INT 37 - FLOATING POINT EMULATION - OPCODE DBh</P>
<P>INT 38 - FLOATING POINT EMULATION - OPCODE DCh</P>
<P>INT 39 - FLOATING POINT EMULATION - OPCODE DDh</P>
<P>INT 3A - FLOATING POINT EMULATION - OPCODE DEh</P>
<P>INT 3B - FLOATING POINT EMULATION - OPCODE DFh</P>
<P>INT 3C - FLOATING POINT EMULATION - SEGMENT OVERRIDE</P>
<P>INT 3D - FLOATING POINT EMULATION - STANDALONE FWAIT</P>
<P>INT 3E - FLOATING POINT EMULATION - Borland "SHORTCUT" CALL</P>
<P>INT 3F - Overlay manager interrupt (Microsoft/Borland)</P>
<P>INT 40 - DISKETTE - RELOCATED ROM BIOS DISKETTE HANDLER</P>
<P>INT 41 - SYSTEM DATA - HARD DISK 0 PARAMETER TABLE; CPU - MS Windows</P>
<P>INT 42 - VIDEO - RELOCATED DEFAULT INT 10 VIDEO SERVICES (EGA,VGA)</P>
<P>INT 43 - VIDEO DATA - CHARACTER TABLE (EGA,MCGA,VGA)</P>
<P>INT 44 - VIDEO DATA - CHARACTER FONT (PCjr); Novell NetWare</P>
<P>INT 45 - Z100/Acorn</P>
<P>INT 46 - SYSTEM DATA - HARD DISK 1 DRIVE PARAMETER TABLE</P>
<P>INT 47 - Z100/Acorn/Western Digital/SQL Base</P>
<P>INT 48 - KEYBOARD (PCjr) - Z100/Watstar/Acorn/Western Digital/Compaq</P>
<P>INT 49 - SYSTEM DATA (PCjr) - Z100/TI/Watstar/Acorn/MAGic</P>
<P>INT 4A - SYSTEM - USER ALARM HANDLER</P>
<P>INT 4B - IBM SCSI interface; Virtual DMA Specification (VDS)</P>
<P>INT 4C - Z100/Acorn/TI</P>
<P>INT 4D - Z100</P>
<P>INT 4E - TI/Z100</P>
<P>INT 4F - Common Access Method SCSI</P>
<P>INT 50 - IRQ0 relocated by software</P>
<P>INT 51 - IRQ1 relocated by software</P>
<P>INT 52 - IRQ2 relocated by software</P>
<P>INT 53 - IRQ3 relocated by software</P>
<P>INT 54 - IRQ4 relocated by software</P>
<P>INT 55 - IRQ5 relocated by software</P>
<P>INT 56 - IRQ6 relocated by software</P>
<P>INT 57 - IRQ7 relocated by software</P>
<P>INT 58 - IRQ8/0 relocated by software</P>
<P>INT 59 - IRQ9/1 relocated by software; GSS Computer Graphics Interface</P>
<P>INT 5A - IRQ10/2 relocated by software</P>
<P>INT 5B - IRQ11/3 relocated by software; Network</P>
<P>INT 5C - IRQ12/4 relocated by software; Network Interface</P>
<P>INT 5D - IRQ13/5 relocated by software</P>
<P>INT 5E - IRQ14/6 relocated by software</P>
<P>INT 5F - IRQ15/7 relocated by software; HP 95LX GRAPHICS PRIMITIVES</P>
<P>INT 60 - reserved for user interrupt; multiple purposes</P>
<P>INT 61 - reserved for user interrupt; multiple purposes</P>
<P>INT 62 - reserved for user interrupt; multiple purposes</P>
<P>INT 63 - reserved for user interrupt; multiple purposes</P>
<P>INT 64 - reserved for user interrupt; multiple purposes</P>
<P>INT 65 - reserved for user interrupt; multiple purposes</P>
<P>INT 66 - reserved for user interrupt; multiple purposes</P>
<P>INT 67 - reserved for user interrupt; LIM EMS; multiple purposes</P>
<P>INT 68 - multiple purposes</P>
<P>INT 69 - multiple purposes</P>
<P>INT 6A - multiple purposes</P>
<P>INT 6B - multiple purposes</P>
<P>INT 6C - CONVERTIBLE; DOS 3.2; DECnet DOS network scheduler</P>
<P>INT 6D - VGA - internal</P>
<P>INT 6E - DECnet DOS - DECnet NETWORK PROCESS API</P>
<P>INT 6F - Novell NetWare; 10NET; MS Windows 3.0</P>
<P>INT 70 - IRQ8 - CMOS REAL-TIME CLOCK</P>
<P>INT 71 - IRQ9 - REDIRECTED TO INT 0A BY BIOS</P>
<P>INT 72 - IRQ10 - RESERVED</P>
<P>INT 73 - IRQ11 - RESERVED</P>
<P>INT 74 - IRQ12 - POINTING DEVICE (PS)</P>
<P>INT 75 - IRQ13 - MATH COPROCESSOR EXCEPTION (AT and up)</P>
<P>INT 76 - IRQ14 - HARD DISK CONTROLLER (AT and later)</P>
<P>INT 77 - IRQ15 - RESERVED (AT,PS); POWER CONSERVATION (Compaq)</P>
<P>INT 78 - DOS extenders; multiple purposes</P>
<P>INT 79 - multiple purposes</P>
<P>INT 7A - Novell NetWare; IBM 3270; multiple purposes</P>
<P>INT 7B - multiple purposes</P>
<P>INT 7C - multiple purposes</P>
<P>INT 7D - multiple purposes</P>
<P>INT 7E - RESERVED FOR DIP, Ltd. ROM LIBRARY; multiple purposes</P>
<P>INT 7F - multiple purposes</P>
<P>INT 80 - reserved for BASIC; multiple purposes</P>
<P>INT 81 - reserved for BASIC</P>
<P>INT 82 - reserved for BASIC</P>
<P>INT 83 - reserved for BASIC</P>
<P>INT 84 - reserved for BASIC</P>
<P>INT 85 - reserved for BASIC</P>
<P>INT 86 - IBM ROM BASIC - used while in interpreter; multiple purposes</P>
<P>INT 87 - IBM ROM BASIC - used while in interpreter</P>
<P>INT 88 - IBM ROM BASIC - used while in interpreter; multiple purposes</P>
<P>INT 89 - IBM ROM BASIC - used while in interpreter</P>
<P>INT 8A - IBM ROM BASIC - used while in interpreter</P>
<P>INT 8B - IBM ROM BASIC - used while in interpreter</P>
<P>INT 8C - IBM ROM BASIC - used while in interpreter</P>
<P>INT 8D - IBM ROM BASIC - used while in interpreter</P>
<P>INT 8E - INT EE = IBM ROM BASIC - used while in interpreter</P>
<P>INT EF - BASIC - ORIGINAL INT 09 VECTOR</P>
<P>INT F0 - BASICA.COM, GWBASIC, compiled BASIC - ORIGINAL INT 08 VECTOR</P>
<P>INT F1 - reserved for user interrupt</P>
<P>INT F2 - reserved for user interrupt</P>
<P>INT F3 - reserved for user interrupt</P>
<P>INT F4 - reserved for user interrupt</P>
<P>INT F5 - reserved for user interrupt</P>
<P>INT F6 - reserved for user interrupt</P>
<P>INT F7 - reserved for user interrupt</P>
<P>INT F8 - reserved for user interrupt</P>
<P>INT F9 - reserved for user interrupt</P>
<P>INT FA - reserved for user interrupt</P>
<P>INT FB - reserved for user interrupt</P>
<P>INT FC - reserved for user interrupt</P>
<P>INT FD - reserved for user interrupt</P>
<P>INT FE - AT/XT286/PS50+ - destroyed by return from protected mode</P>
<P>INT FF - AT/XT286/PS50+ - destroyed by return from protected mode</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Ora ritorniamo alla nostra programmazione.Prendiamo un semplice esempio, un file che visualizza un testo sullo schermo.</P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>.model small</P>
<P>.stack</P>
<P>.data</P>
<P>messaggio db "Assembly e' facile$"</P>
<P>.code </P>
<P>mov dx, offset messaggio</P>
<P>mov ax, seg messaggio</P>
<P>mov ds, ax</P>
<P>mov ah,9</P>
<P>int 21h</P>
<P>mov ax,4c00h</P>
<P>int 21h</P>
<P>end </P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Questo codice lo dovete salvare in un formato "nomefile".asm .Poi copiatelo nella directory dove si trova il Turbo Assembler (TASM) &egrave; digitate : Tasm "nomefile".asm</P>
<P>e, se non vi viene segnalato nessun errore (non dovrebbe succedere), continuate con Tlink "nomefile" (di solito l'estensione sar&agrave; .obj).Cos&igrave; avete creato un file eseguibile.Fatelo partire e vedrete apparire il testo "Assembly e' facile".</P>
<P>Ma esaminiamo attentamente il codice:</P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>.model small :</B></FONT><FONT FACE="Arial" COLOR="#ffff00"> Model small indica che tutto il codice &egrave; stato messo in un unico segment.Anche il data segment &egrave; stato messo in un unico segment.</P>
<P>Poi esistono ancora il model </FONT><B><FONT FACE="Arial" COLOR="#00ff00">tiny,</B></FONT><FONT FACE="Arial" COLOR="#ffff00"> significa che tutto il codice e il data si trovano in un unico segment.Il model </FONT><B><FONT FACE="Arial" COLOR="#00ff00">compact,</B></FONT><FONT FACE="Arial" COLOR="#ffff00">in questo caso tutti gli elementi del codice sono in un unico segment, per&ograve; ogni porzione del data pu&ograve; essere messa in un segment.Poi esistono il model </FONT><B><FONT FACE="Arial" COLOR="#00ff00">medium, large e flat,</B></FONT><FONT FACE="Arial" COLOR="#ffff00">che per&ograve; per ora non ci interessano.</P>
<P>&nbsp;</FONT><B><FONT FACE="Arial" COLOR="#00ff00">Messaggio db "Assembly e' facile$" :</B></FONT><FONT FACE="Arial" COLOR="#ffff00"> Questo &egrave; il messaggio che verr&agrave; visualizzato.</FONT><B><FONT FACE="Arial" COLOR="#00ff00">Messaggio</B></FONT><FONT FACE="Arial" COLOR="#ffff00">,in questo caso &egrave; il label, cio&egrave; il nome al quale il programma fa riferimento nel codice.</FONT><B><FONT FACE="Arial" COLOR="#00ff00">db </B></FONT><FONT FACE="Arial" COLOR="#ffff00">significa declare byte.il byte(che sar&agrave; in ASCII),pu&ograve; essere "dichiarato" in bytes, </FONT><B><FONT FACE="Arial" COLOR="#00ff00">db, </B></FONT><FONT FACE="Arial" COLOR="#ffff00">words,</FONT><B><FONT FACE="Arial" COLOR="#00ff00">dw,</B></FONT><FONT FACE="Arial" COLOR="#ffff00"> e double word,</FONT><B><FONT FACE="Arial" COLOR="#00ff00">dd.</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Troverete spesso anche un "?" alla fine di una dichiarazione, tipo </FONT><B><FONT FACE="Arial" COLOR="#00ff00">esempio db ?</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Ci&ograve; significa che il data non &egrave; inizializzato, che non ha valora con il quale inziare.</P>
<P>Ci possiamo mettere anche : </P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Esempio1 db 0</P>
<P>Esempio2 dw 1</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Cos&igrave; quando il programma caricher&agrave;, </FONT><B><FONT FACE="Arial" COLOR="#00ff00">esempio1 </B></FONT><FONT FACE="Arial" COLOR="#ffff00">sar&agrave; uguale a </FONT><B><FONT FACE="Arial" COLOR="#00ff00">0</B></FONT><FONT FACE="Arial" COLOR="#ffff00">,e</FONT><B><FONT FACE="Arial" COLOR="#00ff00"> esempio2 </B></FONT><FONT FACE="Arial" COLOR="#ffff00">sar&agrave; uguale a </FONT><B><FONT FACE="Arial" COLOR="#00ff00">1.</B></FONT><FONT FACE="Arial" COLOR="#ffff00">Anche qua vi dovete rendere conto che c'e' una cosa importante da rispettare.Se dichiarate qualcosa come word, non potete mettere il valore di esso in un register di 8 bit e non potete neanche mettere il valore di una dichiarazione di un byte in un register di 16-bit.Un esempio:</P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Mov al, Esempio1 </B></FONT><FONT FACE="Arial" COLOR="#ffff00">Nessun problema</P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Mov ax, Esempio1 </B></FONT><FONT FACE="Arial" COLOR="#ffff00">Non potete farlo!</P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Mov bx, Esempio2 </B></FONT><FONT FACE="Arial" COLOR="#ffff00">Va bene</P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Mov bl, Esempio2 </B></FONT><FONT FACE="Arial" COLOR="#ffff00">Impossibile!</P>
<P>Infine troviamo il nostro testo che deve essere visualizzato </FONT><B><FONT FACE="Arial" COLOR="#00ff00">"Assembly e' facile$".</B></FONT><FONT FACE="Arial" COLOR="#ffff00">Il testo dovr&agrave; essere messo sempre tra </FONT><B><FONT FACE="Arial" COLOR="#00ff00">" ..." </B></FONT><FONT FACE="Arial" COLOR="#ffff00">e alla fine del vostro messaggio dovrete mettere un </FONT><B><FONT FACE="Arial" COLOR="#00ff00">$.</B></FONT><FONT FACE="Arial" COLOR="#ffff00">Questo significa per l'assembler che la riga &egrave; finita.</P>
<P>Ora riprendiamo il nostro piccolo programma come esempio.Lo scopo nel programmare in assembly e, specialmente quando programmate virus, &egrave; quello di rendere il codice pi&ugrave; corto possibile, visto che in questo modo il virus avr&agrave; la grandezza di KB pi&ugrave; piccola.Ci sono molti piccoli esempi, tipo </P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Mov bx,ax</P>
<P>Xchg bx,ax</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Il primo commando occuper&agrave; 2 bytes, il secondo invece solo 1...questo solo per dimostrarvi che potete facilmente rimpicciolire il vostro codice usando dei commandi diversi.Nel nostro caso potete scambiare</P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Mov dx, offset messaggio</P>
<P>Mov ax, seg messaggio</P>
<P>Mov ds, ax</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Con un semplice</P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Mov dx, offset messaggio</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Inserendo il seguente commando all'inizio del codice:</P>
</FONT><B><FONT FACE="Arial" COLOR="#00ff00"><P>Mov ax,@data</P>
<P>Mov ds,ax</P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Tutto questo perch&egrave; tutto il data nel segment ha lo stesso valore del </FONT><B><FONT FACE="Arial" COLOR="#00ff00">seg. </B></FONT><FONT FACE="Arial" COLOR="#ffff00">Mettendo tutto quanto in ds non lo dovremo ricaricare ogni volta che vogliamo usare un'altra cosa nello stesso segment.</P>
<P>&nbsp;Il commando per visualizzare il testo &egrave; </FONT><B><FONT FACE="Arial" COLOR="#00ff00">mov ah,9.</B></FONT><FONT FACE="Arial" COLOR="#ffff00">L'</FONT><B><FONT FACE="Arial" COLOR="#00ff00">int 21h </B></FONT><FONT FACE="Arial" COLOR="#ffff00">eseguir&agrave; il commando e con </FONT><B><FONT FACE="Arial" COLOR="#00ff00">mov ax,4c00h</P>
<P>           Int 21h </P>
</B></FONT><FONT FACE="Arial" COLOR="#ffff00"><P>Ritorneremo al Dos.Alla fine ci dovrete mettere solamente un "end".</P>
<P>Questo &egrave; tutto per la lezione di oggi, rileggetevi tutto con calma, rimediate quelle cose di cui vi ho detto...e non fatevi scappare la prossima edizione.</P>
<P>&nbsp;</P>
</FONT><P ALIGN="CENTER"><A HREF="indice.ren#INDICE"><B><U><FONT SIZE=5 COLOR="#00ffff">INDICE</B></U></FONT></A></P></BODY>
</HTML>
