

       ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
       º                                                        º
       º  ÞÛÛÝÞÝÞÝÞÝ Û    ÞÛÛÝ ÞÝ ÞÛÛÝ ÞÛÛÞÝÞÝ    ÞÛÛÝÞÝÞÝÞÝ Û  º
       º   Û ÛÞÝÞÝÞÛ Û     Û Û ÛÛ ÞÞÝÝ Û ÛÞÝÞÝ     Û ÛÞÝÞÝÞÛ Û  º
       º   Û ÛÞÝÞÝÞÛÝÛ     Û ÛÞÝÞÝ ÞÝ ÞÝ  ÞÝÞÝ     Û ÛÞÝÞÝÞÛÝÛ  º
       º   ÛÛÝÞÝÞÝÞÝÛÛ     ÛÛÝÞÝÞÝ ÞÝ ÞÝ  ÞÛÛÝ     ÛÛÝÞÝÞÝÞÝÛÛ  º
       º   ÛÛ ÞÝÞÝÞÝÞÛ     Û ÛÞÛÛÝ ÞÝ ÞÝ  ÞÝÞÝ     ÛÛ ÞÝÞÝÞÝÞÛ  º
       º   ÛÞÝÞÝÞÝÞÝ Û     Û ÛÞÝÞÝ ÞÝ  Û ÛÞÝÞÝ     ÛÞÝÞÝÞÝÞÝ Û  º
       º  ÞÛ Û ÛÛ ÞÝ Û    ÞÛÛÝÞÝÞÝ ÛÛ  ÞÛÝÞÝÞÝ    ÞÛ Û ÛÛ ÞÝ Û  º
       º                                                        º
       º                                                        º
       ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼


                        The Run Batch Run Book


                  Copyright (c) 1998, Finn Roaas
                      All Right Reserved, World Wide












                            Finn Roaas
                            Postboks 75 - Furuset
                            N-1001 Oslo, Norway



                            froaas@online.no
                            Voice (registrations only) +47 22301372
                            Fax:                       +47 22301304













     =====================================
      RUN BATCH RUN REGISTRATION FORM
     =====================================

     Remit to:  Finn Roaas
                Postboks 75 - Furuset
                N-1001 Oslo, Norway


     ---------------------------------------------------------------------
     | Item                          | Quantity |  Price     |    Total   |
     |-------------------------------|----------|----------- |------------|
     | RBatch12 version 1.2 (Nor)    | ________ | NOK100.00  | __________ |
     |                               |          |            |            |
     | RBatch14 version 1.4 (Eng)    | ________ |   $ 15.00  | __________ |
     | (A Companion Disk included)   |          |            |            |
     | Diskette 3.5 ( ) 5.25 ( )     | ________ |   $  8.00  | __________ |
     |                               |          | NOK 50.00  |            |
     | Schools (free use 1000        |          |            |            |
     | students for one year         | ________ | NOK1.000,00| __________ |
     | Subscription                  |          |   $ 80.00  |            |
     | Abonnement                    | ________ | NOK480.00  | __________ |
     |                               |          |            |            |
     | Shipping                      | ________ |   $  5.00  | __________ |
     |------------------------------------------------------ |------------|
     |                                                       |            |
     |   Total amount enclosed                               | __________ |
     ----------------------------------------------------------------------

     Payment by:  ( ) Check or money order
                  ( ) American Express
                  ( ) Diners Club
                  ( ) MasterCard
                  ( ) Visa
                  ( ) PO # ______________

     Card #: ____________________________________  Exp. Date: _________


 Signature of card holder: ____________________________________________


     Name:     ________________________________________________________

     Company:  ________________________________________________________

     Address:  ________________________________________________________

               ________________________________________________________

               ________________________________________________________

     Phone:    ________________________________________________________


    (  )  Check or money order payable to Finn Roaas in U.S. funds enclosed
    (  )  SWIFT transfer to 6065.56.31588 (Kredittkassen 1067 Oslo, Norway)
    (  )  SWIFT transfer to 0521 1589665 (Postbanken, Norway)






TABLE OF CONTENTS
=================

Chapter 1:  Save your files - different methods
Chapter 2:  One day you will regret that you didn't take backup seriously
Chapter 3:  How to make a choice about how a batch should proceed?
Chapter 4:  Edit a batch program
Chapter 5:  Batch pipe problem
Chapter 6:  Searching for files is often time consuming
Chapter 7:  Customizing the command dir
Chapter 8:  How can a batch program answer Y for yes
Chapter 9:  Batch files can be used with memory and RAM
Chapter 10: To remove files accidentally extracted
Chapter 11: Choice
Chapter 12: How to get the system date
Chapter 13: Extracting text strings
Chapter 14: Different batch enhancers and using scan codes
Chapter 15: Batch files and mail
Chapter 16: How to suppress the writing on the screen?
Chapter 17: How to have a batch file testing if Windows is running
Chapter 18: Invisible cursor
Chapter 19: Numbered repeats in batch files
Chapter 20: How you can write batch files that will execute
            certain commands based on the time of day?
Chapter 21: Return to directory
Chapter 22: Make a log with the time and date
Chapter 23: Books, magazines and programs about batch files
Chapter 24: Remove file comment
Chapter 25: FOR in batch files
Chapter 26: Ansi codes in batch file
Chapter 27: About errorlevel
Chapter 28: Rebooting from a batch file
Chapter 29: How to execute a batch file on a certain weekday?
Chapter 30: Y/N in batch files
Chapter 31: Remap keys
Chapter 33: Detecting DblSpace drive
Chapter 34: How to add a path to the existing path?
Chapter 35: Numlock on
Chapter 36: Changing the date during execution
Chapter 37: Undocumented commands
Chapter 38: Ctrl-c/break
Chapter 39: Can't delete directory
Chapter 40: Batch file for cd-rom
Chapter 41: Get the beep out of CHOICE
Chapter 42: How to tell MS DOS not to display any messages?
Chapter 43: Recall of previously issued commands for re-entry

                        >>>>@@@@<<<<


Chapter 1: Save your files - different methods.
===============================================

At the end of this book you will find a presentation of the
the author. As you will see I'm also a novelist and
a writer of modern norwegian literature.
I know how important it is to save my files in a secure
and efficient way. The day you have lost important data
you will understand the importance of taking good care
of all files you produce. When your hard disk is down
and one year's work is wasted it is to late to plan
how you are going to save your files.

Some years ago I lost all chapters in a new book I was
writing because of problems with my WC-card. A lot
of different thoughts went through my head when I
realized what had happened, but fortunately I also
remembered that I had copied the files to a floppy.
I looked through my diskettes and thank God I found what
I was looking for. The floppy made it possible to restore
all files to my hard disk.

As I said, this happened many years ago. Experience has taught me
the lessons to take good care of my files. This is our first subject.
Let's have a closer look at a batch file I have called


SAV1.BAT
========

@ECHO OFF 
:start 
IF " %1" ==" " GOTO end
ECHO ***%1 will be saved ***
IF NOT EXIST A:%1 COPY %1 A:
SHIFT 
GOTO start 
:end

Every day when I had finished writing a manuscript, essays
or letters, I needed to save the files to a floppy.
The files had different names and I wanted to make a program
that was able to copy more than 9 files. I knew that %1 to %9
parameters gave me the opportunity to run nine variables
through a batch program, but it was not enough. Then I
discovered SHIFT. The command allowed me to use more than nine
batch parameters.

The SHIFT command moves the parameters one step to the left
in a batch file. It moves the remaining parameters down one
value, a new %9 is brought in if any exists. In the example
above I use the SHIFT command with three parameters. When a
SHIFT command is executed, it moves the %3 parameter down to
the %2 parameter. The value %2 moves into %1. The original %1
has disappeared. After executing another SHIFT command, the
original %3 has become %1, and the original %2 and %3 are both
gone.

The SHIFT command makes it possible to make a short batch
program to execute any number of parameters. The batch file
above illustrates this method. SAV1.BAT may be used to backup
any number of files. Below you will find a description of how
the file works, line by line.

The first line turns off the echoing with the command
ECHO  OFF.

The label :START in line 2 marks the start of the command
and will be repeated for each parameter.

In line 3 the IF command tests if it exists a parameter in
the variable %1. The command makes a comparison between
%1 and the double quotation marks enclosing nothing (" "). This
is called an empty string. You ask MS DOS to compare the first
parameter with nothing or with an empty parameter. If the
comparison is true, the GOTO command ends at the label :end.

The ECHO command in line 4 shows the name of the file being
copied.

The IF command in line 5 lets your batch file test if the
files you save exists on the diskette in A. If it not exists
the COPY command copies the file from the active drive and
directory to A:.

In line 6 the SHIFT command moves parameters one step to the
left.

The GOTO command in line 7 returns MS DOS to :START.

The label :end in line 8 marks the end of the of the batch file.

You run SAV1.BAT with the following command line:

C:\> SAV1.BAT autoexec.bat config.sys command.com

The batch file ends when %1 is equal to " " - or in another
words - when it is no files left to copy. But the batch file
won't stop. It displays this message:


Syntax error
*** will be saved ***
A: File not found
        0 File(s) copied.

The quickest way to end the program is to press CONTROL - C.


The command has the following syntax:

SAV1 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14

I usually name my manuscripts, essays and letters with,
short abbreviations like CHAP1 etc.

The end of the batch program above is far from
impressing. But as long as you use the correct
syntax and the file exists the job is done.
Immediately you write a filename that does not
exit or the file does not exist, you'll get an
error message.

When the job is done, the SHIFT command runs in loop.
I finish with Control-C. Not very elegant, but
SAV1.BAT gives you an idea how the SHIFT command
works.

SAVE.BAT
========

@ECHO OFF
CLS
REM PRESS THE TAB WHEN ECHO IS DONE
ECHO                *** SAVE ***
ECHO.
ECHO Have you inserted the floppy in drive A:
REM The warning will not be displayed if already saved
IF NOT EXIST A:%1 GOTO ready
ECHO
REM CTRL-G creates i bip
ECHO 
a:%1 exists. Press CTRL-BREAK to terminate, or...
PAUSE
:ready
COPY %1 a:%1
IF EXIST A:%1 erase %1
ECHO 
ECHO %1 has been saved to the diskette!


I have always been looking for good methods to
protect and save my work, but I have also been
looking for ways to control the performance.
In long periods I have made use of the batch program
above. Only when a certain condition exists or come true,
for example a certain file exists, the command will be
issued. I noticed immediately that the method improved
my batch files. The method may be used in many different
situations, what you will find in this book. The IF
command is used when you want a batch command to be
carried out only after certain conditions have been met.
For example, the following command starts Qedit when Q
is used as a parameter:

IF "%1"=="Q" D:\QE3\Q

The command use three parameters:

IF (NOT) <condition> <command>
 
The parameter NOT specifies that MS DOS should carry out the
command only if the condition is false. 

In the parameter <condition> it is the condition that must be met.
There are two ways to use <condition>:

EXIST <file name> tests wether a specified file exists or not.
Sometimes the system needs the path and directories written.
If the <file name> exists, the condition is met.

<string1>==<string2> compare two strings. These values
can be strings or batch variables such as %1. If the
strings are identical, the condition is met. Notice that
two equal signs are required.

<command> is any MS DOS command.

The command CLS in line 2 makes batch file starts
with cleared screen, and the user sees only the message.

The command REM in line 3 reminds us of that the space in
line 4 is produced by pushing the tab key three times.

The headline * * * SAVE * * * in line 4 shows up,
and is displayed in the center, because we have pressed three
times on the tab key.

The command ECHO in line 5 displays empty line just below
the headline. <Alt-255> is the ASCII code for empty character.
To produce ANSI characters that are not on your keyboard, you
have to use the following method: Hold down Alt and type the
number that corresponds to the character you want
NumLock must be on. Then release Alt.

The command REM in line 8 makes a comment on the command
GOTO in line 9.

There is another command ECHO in line 10. It has a
dot and displays en empty line to make the warning
more visible.

The command REM in line 11 comments the sound in
line 12 and it's used together with ECHO.
Hold down CTRL and type G

The command ECHO in line writes a message du the screen:
The file has been saved to the diskette.

COPY ALL FILES
==============


Neither COPY *.* nor XCOPY *.* copy all files if you want to
copy to more than one diskette. But there are easy methods to
get COPY *.* to do what you want the command to do, namely copy
all and don't leave out files because the diskette is full.

Below I will take a detailed look at two little used methods
to search for bugs in batch files. I will also look at a smart
way how you can run "for in .. do" loops without display a lot
garbage!

The COPY *.* A: means: Copy all files from your hard disk
to drive A:. Did I type all? Yea, but that's exactly what
it doesn't do. Suddenly the diskette in drive A: is full.
The floppy in drive A: takes only 720 Kbyte, but you need
maybe to copy 900 Kbyte. If you want to backup the rest of
your files, you will really get a difficult job to find
the files you're missing.

There are at least four ways to use to copy all files.
The first I will discuss is the most time consuming one.
Copy *.* to A:. Write the name of the last file listed on
a sheet of paper. This file was not copied to A:.
Type DIR/p and notice all files that are listed below the
file you have written on the sheet of paper.
These are the files that you still haven't copied.

Why is it so? Because the command DIR and COPY treat the
files in the same way. You have to copy the listed files
manually. It's a boring job. But the command XCOPY
does copying files simple and easy.
Type XCOPY *.* A:/p.

Now you have to answer yes/no for each file you will
copy. At the beginning of the list you just answer N for NO.
When you reach the file you have written on your sheet of
paper, you start answering Y for Yes.

It's easy to make a list of all the files you haven't copied.
Type the three lines below:

     ECHO OFF
     FOR %a IN (*.*) DO IF NOT EXIST A:%a ECHO %a
     ECHO ON

þ    The first line turns off the PROMPT.

þ    The third line displays the PROMPT.

þ    Unless you want your screen filled up with unnecessary
     information it's recommended use ECHO OFF and ON.
     The second line demonstrates how you can make a "for in
     .. do-loop" in MS DOS without writing it into a batch
     file.

After typing the commands above a list of files is displayed.
Stop the scrolling by pressing Ctrl-S. (Don't make mistakes.
Don't type %a on one side and %A on the other side of the
parenthesis. Don't make mistake number two: Use %%a if you
write a batch program. Don't make mistake number three:
MS DOS has problems copying files with 0-bytes. May be one
of your files is a 0-byte file.

Sometimes the prompt disappears. This happens for example when
you terminate a batch file or run another batch file using CALL.
Or may be your batch file doesn't run properly. Instead of reboot,
type ECHO ON. Sometimes it occurs that MS DOS can't remember
wether echo is on or off.

In creating batch programs you often find yourself testing the
files over and over again. A simple "debug-trick" is to leave
out @ECHO ON in the first line when you run the file.
You save time. You don't need to edit and save all the time.

An other method is to place a variable for ECHO OFF.
If your first line is

@%test% ECHO OFF

you can turn ECHO on and off with the command SET! Type:

SET TEST=REM and run the batch file with ECHO on.
Type SET TEST= run the batch file with ECHO off.

TOA.BAT provides an easy way to create an advanced batch file
which types a list containing the names of all files in the
directory, make a copy from the list and at last displays it.
Look at TOA.BAT below, it's a nice piece of work.
The program use the command XCOPY to copy possible 0 byte
files, and because XCOPY reports when the diskette is full.
Run TOA.BAT without any arguments at the prompt.
MS DOS moves to the label :START and deletes the old
file catalog called, LISTE.BAT.

TOA.BAT uses a temporary batch file to run itself repeatedly.
The program copy all files of a directory to several floppy
diskettes.

TOA.BAT
=======

@ECHO OFF 
IF %1X==X GOTO START 
IF %1==CATALOG.BAT GOTO END
COPY %1 A:>NUL 
IF EXIST A:%1 GOTO END
REM Don*t stop because of 0 byte files:
XCOPY %1 A: 
IF EXIST A:%1 GOTO END
ECHO Change diskette in A: - Insufficient disk space for %1
PAUSE 
%0 %1 
:START 
IF EXIST CATALOG.BAT DEL CATALOG.BAT
FOR %%a IN (*.*) DO ECHO CALL %0 %%a >>CATALOG.BAT
CALL CATALOG
DEL CATALOG.BAT
:END

Normally when you try to delete files that do not exist, you
get the error message "File not found". This message is confusing
and many of you will jump on the keyboard and press CTRL-C.
What's going on! The program is supposed to copy files and can't
find the file! To avoid error messages we will first check it out
TOA.BAT IF CATALOG.BAT exists by executing the command IF EXIST i
line 13.

If you already got a file called CATALOG.BAT you need to change
the name, and find another unique name to your catalog.

The catalog reporting all the files in the directory is created
in a FOR-IN-DO-LOOP. We create the list with double redirection
operators >> in line 14. A new will be added for each new filename.
Preceding each filename you find the command CALL TOA.
If you are using a MS DOS version earlier than 3.3 you must
use COMMAND /c to run a batch file from within another. You
can't use CALL.

When you run CATALOG.BAT MS DOS executes the CALL CATALOG in line 15.
The format of the command CALL is as follows:
CALL <command file> parameters
But what exactly does CALL TOA?
It starts TOA.BAT program and accepts file name as a parameter.
The parameter is a file name in the directory. TOA.BAT try to
copy files A:. If TOA.BAT can't make it, the program asks for
a new diskette i A: and you must try again. Notice that TOA.BAT
in the third line 3 pass CATALOG.BAT. We don't need to copy
the temporary and specific report.

þ    TOA.BAT creates and starts CATALOG.BAT. CATALOG.BAT starts
     TOA.BAT successive before each file name. When the last file
     has been copied, we are back to the starting point. The temporary
     file CATALOG.BAT is erased, the batch file ends and returns
     to MS DOS.

þ    I use %0 when the program is asked to call it self. If
     you rename the file TOA.BAT to CHINABOX.BAT, you can
     type CATALOG.BAT and read CALL CHINABOX FILE NAME in
     CATALOG.BAT.

þ    The at sign @ and the command CALL works only in MS DOS
     versions 3.3 and later. The command XCOPY was new in MS
     DOS 3.2. If you don't use XCOPY you have to delete all
     files with 0 byte before you execute the batch file.

Method number three is the simplest. With number one you had
to remember files that you wanted to copy. TOA.BAT created a
file called CATALOG.BAT that kept a record of all the files
in the directory. In this method we will use the archive
attribute as an invisible label attached to each file.

By turning off the archive attribute with the command ATTRIB +A
*.*. XCOPY/m copy only those files where the attribute is not set.
Think of the attribute as a label where it's written: "must be
copied". All the files have now got such a memo.
Then I start XCOPY: XCOPY *.* A:/m.

After a while the diskette is full and XCOPY stops doing the job
without asking for a new diskette. That's silly, but the switch
/m is handy. The /m switch copies source files that have their
archive file attributes set. the /M switch turns off archive file
attributes in the files specified in source.

We insert a new diskette, repeats the command and
XCOPY carries on.

This is possible because the command  XCOPY /m turns off
the archive attribute during execution, but only those files
that you really copy. Imagine how XCOPY writes on each file:
"this is done" and attach the memos to the copied files.

As you can see, it's easy to continue. Repeat the command
(press F3) when you have changed the diskette.
XCOPY will continue coping files.

When the batch is done turn on the archive attribute, for
the cause of safety.

The next batch file, CPTOA.BAT, contains these commands:
The program draws the maximum benefit from XCOPY'S little
known and often unused ability to provide exit-status values
that you can test using ERRORLEVEL codes. (See ERRORLEVEL codes
in chapter 27 in this book.)

CPTOA.BAT
=========

@ECHO OFF
IF %1.==. GOTO END
IF %a%X==X ATTRIB +A *.*
SET A=some
:AGAIN
XCOPY *.* %1 /m/w
IF ERRORLEVEL 4 GOTO AGAIN
IF ERRORLEVEL 2 GOTO END
ATTRIB +A *.*
SET A=
:END
IF %1.==. ECHO %0 A: or ?


To start the program type drive A: or B:
on the PROMPT command line. This is possible because
Initialization error occurred.  There is not
enough disk space, and produces and errorlevel 4.
XCOPY has stopped to copy files, but there are still more left.
That's why the MS DOS batch file is asked to go to :AGAIN in
line 5. XCOPY starts.

XCOPY/m/w means that the program is waiting for an keyboard
input so you can change the diskette. This is how we avoid an
extra command PAUSE.

If you want to terminate you can easily use Ctrl-C which
provides ERRORLEVEL 2. May be something is wrong or you
have no formatted diskettes left. But I assume that you
plan to carry on, so no steps are taken to restore
the archive attributes. This is the reason why I create
a new system variable in the line SET A=something. If you
stop the execution, the system variable A will still be
there. When MS DOS encounters %A% in line number 2 ATTRIB
is not executed. In other words:  CPTOA.BAT continue where
it stopped. The line SET A= at the end removes A
so you can run the batch file in other directories.
CPTOA.BAT must be in PATH.

If you wonder what the use of the @ symbol in a
batch file is for, this is the explanation:

As far as I can see, the only thing the "@"-symbol does, when used in
batch files, is the same as an "echo off". When you have a one-liner
batch file which just says

@ver

the MS-DOS version will be displayed without the "ver" command also
echoed.

If youïve come this far, you should have a pretty good understanding of
how important it is to save your files and know some methods on how to
do it. I haven't discussed everything there is to know about saving
files, oh course, but you have come familiar with some powerful batch
files and terms you're likely to run into in your day-to-day dealings with
your computer and MS DOS. If you should decide to make use and test out
the batch files in this chapter, you can get a companion disk sent to
you by e-mail or, if you haven't an email address, on a diskette, all
you have to do is to register yourself as a supporter of this book.

At last a batch program that bump the file one at a time from at ramdisk
to a directory called ARCHIVE.

As usually the file starts with turning the echo off.
The next line also has an ECHO followed by a dot which normally produce
an empty line. The third line consists of an IF statement. If the
strings are the same the statement will not be handled and the
processing moves on to no_file. At no_file you are presented with a help
text telling you the meaning of the file and how you should use it. The
next line continues the processing and is caused by the line above. MS
DOS wil write a message on screen pointing out the problem for you,
namely File not found and terminate the batch program. The line is an IF
NOT EXIST statement.
        Then the new directory will be created, MD Archive. A new tests
finds out if the directory exists, and if it does moves on to
dir_exists. A new message is written to the screen to inform the user
that it's not possible to create a new directory by the same name. It is
also convenient to test whether the directory is empty or not? Then the
command COPY is used to bump the file from for example your ram-disk to
C:\ARCHIVE. The /v switch verifies if the new file is written correctly
and the execution will be slower, though everything is relative. The
command STOP.COM is similar to PAUSE, but STOP allows you to write your
own text that moves from the right side of the screen to left. STOP.COM
is one of the many DEBUG programs on the RUN BATCH RUN Comapanion
disk, both the script and the com file.

TO_ARCH.BAT
===========

ECHO OFF
ECHO.
IF "%1"=="" GOTO no_file
IF NOT EXIST %1 GOTO file_not_found
MD C:\ARCHIVE
IF NOT EXIST C:\ARCHIVE\nul GOTO dir_exists
IF EXIST C:\ARCHIVE\*.* GOTO dir_not_empty
COPY /v %1 C:\ARCHIVE\%1
ECHO %1 copied to C:\ARCHIVE\%1
STOP
IF EXIST %1 GOTO in_tree
COPY /v C:\ARCHIVE\%1 %1
ECHO C:\ARCHIVE\%1 copied to %1
GOTO trash
:in_tree
ECHO %1 already exists!
ECHO Apply break to exit without copying
ECHO (IF you break, you must then manually remove the ARCHIVE directory and its files)
STOP
COPY /v C:\ARCHIVE\%1 %1
ECHO C:\ARCHIVE\%1 copied to %1
GOTO trash
:no_file
ECHO Usage TO_ARCH.BAT is to bump a File Name Without Path
ECHO.
ECHO This batch is intended for bumping one file at a time from your
ECHO ramdisk to the directory you use for saving files you work with on a
ECHO ramdisk.
ECHO Wildcards are allowed, but not recommended. Do not make use of path
ECHO together with your filenames.
GOTO _out
:file_not_found
ECHO File %1 not found
GOTO _out
:dir_exists
ECHO It's not possible to create directory C:\ARCHIVE
GOTO _out
:dir_not_empty
ECHO C:\ARCHIVE is not empty
GOTO _out
:trash
IF not "%1" == "*.*" GOTO trash2
IF NOT EXIST C:\ARCHIVE\%1 GOTO clean_up
ECHO y|del C:\ARCHIVE\%1 > nul
GOTO clean_up
:trash2
IF EXIST C:\ARCHIVE\%1 del C:\ARCHIVE\%1
:clean_up
RD C:\ARCHIVE
:_out
ECHO on


Chapter 2: One day you will regret that you didn't take backup seriously
========================================================================

You want to backup the files and directories from your
computer's hard disk to high density floppies.  This is something
you have never done before, so yiu are nervous about trying.

This is good. Your nervousness makes you cautious enough to ask
questions (and intelligent ones, at that).

Before I reveal my system I would like to add a few comments of my own.

First, your backup will depend on what DOS version you are running
or the size of the HD you wish to back up. Not terribly important,
but worth some consideration.

XCOPY isn't a very good choice when you are speaking of backing up any
HD. But, it is an excellent tool for this purpose when speaking of a few
files/directories. Especially when restoration may be expected on a
different DOS machine that may not contain any software tools other than
basic DOS.

DOS's original BACKUP/RESTORE combo is a notoriously cranky old beast. I
have a lot of experience with it, personally and professionally, and
would not recomend it. Actually, I don't think any knowledgable person
recommends it. It is workable and reliable, just difficult and
inefficient.

MS-BACKUP that comes with DOS 6.x is good for both novice and advanced
users (although there are much better third party routines available).
You won't go wrong by using this.

There is a third method that is also quite popular. Using a
file compression program such as PKZip or LHA. As an example, PKZip
2.04g will use 65% of the number of disks that MS-BACKUP requires (eg:
pk=23 when ms=35), spans multiple disks with ease, it will do a backup
in about 50% of the time, and it is very portable. As a practical
consideration, copy PKUnzip.exe to the first disk of your backup set
(making the set self-contained). You can quickly restore the backup on
any machine that runs almost any version of DOS.

Lastly. If your HD is a large one, you may want to consider not using
disks at all. Investing in a tape drive may be the cheaper alternative.

Here is what I usually council my clients. Do general full backups to
tape and also backup critical data files to disk as an additional
safeguard. Time and monetary costs are minimized, while retaining high
reliability.

You might think about trying PKzip to compress all this stuff on to
the floppy. You get at least 1.5 to 1. and sometimes 2 to 1.
You can download a testdrive PK204g.zip from most BBSs.

As I understand it, the BACKUP command will fill up each
floppy "to the brim", and will split files between diskettes, if

PK will do this too.

You would appreciate knowing:

What is the difference between the quality of the
results from the BACKUP and XCOPY commands?

None. Same for PK.

Will both commands assign a sequential number to the
diskettes (01, 02, 03, etc.) during backing up and also ask for
the diskettes in sequential order when restoring the data back to
the hard disk?

Only Backup and PK (used with the disk spaning switch) will do this.

Is there a way to use the BACKUP command so that it will
not split files between diskettes?

I don't think so.

Play with each on a small directory and see which one you like.
You can always delete/reformat a floppy and start over with something else.
Been using them all for a few years. No fails yet.

As you understand it, the BACKUP command will fill up each
floppy "to the brim", and will split files between diskettes, if
necessary.  On the other hand, the XCOPY command will copy only
complete files, without splitting a file between two diskettes.
For this reason, I am inclined to favor the XCOPY command; but is
it OK to have files split between diskettes?

Of course it is.  If you have a file that's larger than a disk, the
XCOPY command can't do the slightest thing with it.  Period.  Your
whole backup would halt at that point and refuse to go any further.
The BACKUP command, on the other hand, handles it with the greatest of
ease.

What is the difference between the quality of the
results from the BACKUP and XCOPY commands?

No difference in the quality at all.  There are a lot of people who
think that the BACKUP/RESTORE commands are not reliable, but that is
quite false.  If you start with floppy disks that are known to be good
(in other words they've JUST been formatted WITHOUT the /Q switch and
FORMAT did not say that any "bytes in bad sectors" were found), and
you know how to use the BACKUP and RESTORE commands, then you have
absolutely no problem.  But the fact is, most people don't have a clue
how to use BACKUP and RESTORE, but since they THINK they do, they
blame the problem on the commands when it turns out they can't get
their files back.

When in actuality, if they simply gave DOS the corrent RESTORE command
syntax, they would find all their files returned to them immediately.

RESTORE A: C:\*.* /S
restores every file on the backup disks to the corresponding directory
on the C: drive (creating those directories, if necessary).
RESTORE A: C:\WP51\*.* /S
restores every file on the backup disks which had originally come from
a directory named \WP51, or its subdirectories, to a directory named
\WP51 on the C: drive, and its subdirectories (creating the
directories if necessary).  A lot of people try to restore the \WP51
files from the backup disks to a directory on the hard drive named
\WORD, for example.  And of course RESTORE says "No files found to
restore" because there aren't any \WORD\*.* files on the backup disks.
There are only \WP51\*.* files there.  RESTORE does not restore files
to a directory other than that from which it was backed up, because
BACKUP stores files according to their FULL filename, including the
directory specification.

Another real common mistake people make with BACKUP/RESTORE is they
type the directory name instead of the filename they want restored.
RESTORE A: C:\WP51 /S
tells RESTORE to restore one specific file named WP51 to the root
directory of the C: drive.  RESTORE doesn't restore directories.  It
restores files.  C:\WP51 doesn't mean the \WP51 directory.
C:\WP51\*.* does.

Another common one is
RESTORE A:*.* C: /S
That doesn't mean anything to RESTORE at all.  The filename
specification belongs on the target side, not the source side.

Without the proper syntax, RESTORE will not restore the files that the
user THINKS he's telling it to restore.  But when the user does tell
RESTORE what he really wants done---IN RESTORE'S LANGUAGE, NOT THE
USER'S---then RESTORE is just as reliable as can be.  No problem
whatsoever.

Now, there is a difference between the results of BACKUP and XCOPY
though, that's not related to quality at all.  BACKUP disks can be
used only by the RESTORE command.  Without RESTORE, those files are
inaccessible.  And RESTORE can't get to a file on the fifth disk
without first going through disks one, two, three, and four.  XCOPY,
on the other hand, makes disks which contain files in their normal
state, which can be accessed by any DOS command at all.  So you can
use DIR to see which files are where.  You can use COPY to get any
particular file you want, off of one of the disks, without even having
access to any of the other disks.

But if you have a file that's larger than a disk, XCOPY can't do a
thing.  And it also wastes a lot of disk space.  XCOPY copies files IN
ORDER.  Period.  There is no way to make it do otherwise.  If the next
file in line is 300K in size and at the moment XCOPY is ready, there's
only 299K of space left on that disk, you'll have to get out the next
disk and leave that 299K on the first disk empty.  Wasted.

Also, XCOPY by itself, without some trickery, doesn't make
multiple-disk copies.  When the target disk runs out of space, XCOPY
stops.  It does not say "Insert the next disk and press any key to
continue...." or anything like that.  It just stops.  Period.  To
solve this problem, what you have to do is
  A)  Before you start, give the +A attribute to all the files you
want to copy.

  B)  Use XCOPY's /M switch, which tells it to only copy files that
have the +A attribute, and turn off that attribute for each file it
copies.
  C)  When XCOPY quits with the "Insufficient disk space" message, you
put in a new disk and execute the same XCOPY command again, with the
/M switch again.  Since the files that have already been copied had
their A attributes turned off, and since XCOPY /M only copies files
that have +A attributes, this means that now XCOPY is going to copy
only the files that haven't already been copied.

So it ends up working just like the BACKUP command in that regard, but
only if you remember to ATTRIB +A all the files before you begin.

Will both commands assign a sequential number to the
diskettes (01, 02, 03, etc.) during backing up and also ask for
the diskettes in sequential order when restoring the data back to
the hard disk?

BACKUP/RESTORE does that.  XCOPY does not, since the disks it creates
contains files that are in their original normal perfectly accessible
format.

Is there a way to use the BACKUP command so that it will
not split files between diskettes?

No.  You wouldn't want it to do that at all.  If it did that, there
would be absolutely no reason for its existence whatsoever.

A couple other things to mention.  BACKUP puts all the files into one
file on the backup disks.  The only thing on the backup disks is one
index file and one great big data file on each disk.  That's why there
is no wasted space on the disks, and that's why the files can't be
retrieved from the disks without the RESTORE command.

Since XCOPY stores the files in their original format, you can
overwrite an old version of a particular file with a newer version of
it, by simply copying the new version to the correct directory on the
disk.  With BACKUP, on the other hand, if you do an appended backup of
a file, to the last disk in a backup set, and that disk already had
the old version of that same file....the new version will NOT
overwrite the old.  The backup disk will contain BOTH versions of the
file, so it's a waste of space!  But you can't get the old version
back!  Even if you end up needing the old version back, you can't get
it.  RESTORE will restore the old version and immediately overwrite it
with the new version, and there is no RESTORE syntax or switch that'll
prevent that.  So BACKUP wastes space by keeping two copies of the
same file on the same disk, without the benefit of letting you have
access to the older version if you ever need it again.  But XCOPY
doesn't let you keep multiple versions of the same file either, unless
you keep them on separate disks (which BACKUP would also let you do).

After several years as a PC user I have produced thousands of
files. Most of them I keep saved at my hard disk or on diskettes.
Not everything is important, but experience has taught me that
it is difficult to say anything about the future. One day I will
need the note I wrote in the summer 1987. A good backup
makes it easy to update and keep a record of thousands of files.
To an average user with a homeoffice like the one I've got, I will
recommend a system, a routine, which is based on a three generations
backup.

During a period of three year I have used a routine that
backup the hard disk every month. It's up to you how you will
adapt the routine to your own needs. May be it's sufficient to
make a main copy once a year. As I have mentioned, my system is based
on a main copy every month. The main copy I used every month, took
care of the files I wanted to erase. I didn't want them be included
in my backup and then eventually restored.

In addition to the main copy, I backed up parts of the files every week.
As with the main copy I erased the files from this partial copy that I
didn't want to keep for just a short period.

Additionally I assign the value 0 to the place where the daily
copy is kept, so it's kept to a minimum concerning diskettes.
My daily backup was performed once and sometimes twice a day,
and should only contain a few files so I didn't use the whole day
to backup.

I wanted to make an automatic routine of the backup job.
You all know how easy it is to skip or forget boring backups,
especially when your system has functioned without problems for
months or may be years. But one day, sooner and later, your
computer will have problems, it will stop working and you may
face really problems with getting data from your hard disk.
When it comes to losing my work I am a coward, I don't take risks.
I want to run a safe system.

I decided that backup should be an integrated part of my daily
upstart. AUTOEXEC.BAT is the only batch file I have to
execute every day.
You should also backup your files as your last thing to do
every evening. Fires usually starts at night, or water leakage.

Below I present a way to manage your backup, a system I have
tested for years. You will probably find it detailed, but it
works and it takes good care of your important data.
The batch file was written some years ago and is related to
earlier versions of MS DOS than 6.0.

The batch file uses the commands BACKUP, RESTORE, GETMONTH,
GETDAY, DOW and call other batch programs. In your MS DOS manual
you will find details upon how BACKUP and RESTORE works.
The batch file uses three different switches: /s indicates
that you want to copy subdirectories, /a that you add the
files to be backed up to those already on the backup disk and
do not erase saved files on the backup disk. /m back up only
those files that have changed since the last backup.
     
Run EDLIN or EDIT from the command prompt and specify the name
SECURITY.FIL. I myself prefer Qedit as an editor to write my batch
files. It provides many features that make batch programming
easier and faster. Be accurate when you create your batch file.
All files must be in the same directory, for example DOS.

Comments on the files below:
----------------------------

1) Don't miss spaces! When the files have been saved, see to that
DEBUG resides in the DOS directory and type DEBUG<DATES.SCR.
After a while you have three new programs.

2) Add the batch file BCOPY.BAT to your AUTOEXEC.BAT and call
it with the command COMMAND /c BCOPY.
If you use MS DOS version 3.30 or newer you can write
CALL BCOPY.

3) The main program SECURITY.BAT contains the logic
The only changes you have to do is decide the directories
and files you want to be backed up.

4) The file SETCOPY.FIL contains the parameter used by the main
program.


SECURITY.FIL
============

GETDAY
IF ERRORLEVEL 2 GOTO start
GOTO BCOPY
:start
IF ERRORLEVEL %daycopy% GOTO BCOPY
GOTO notcopy
:BCOPY
GETMONTH
IF ERRORLEVEL %maincopy% GOTO maincopy
DOW
IF ERRORLEVEL %partcopy% GOTO partcopy
GETDAY
IF ERRORLEVEL %daycopy% GOTO daycopy
GOTO end
:maincopy
ECHO  * * * THE MAIN COPY * * *
ECHO ------------------
ECHO Insert diskettes for  * * * THE MAIN COPY * * * (1. day of the month)
PAUSE
BACKUP C:\DEASE B: /s
BACKUP C:\DATATIME B: /s
BACKUP C:\CATALOG B: /s
BACKUP C:\SKPLUS B:
BACKUP C:\BATCH B:
IF %maincopy% == 12 set newcopy=1
IF %maincopy% == 11 set newcopy=12
IF %maincopy% == 10 set newcopy=11
IF %maincopy% ==  9 set newcopy=10
IF %maincopy% ==  8 set newcopy=9
IF %maincopy% ==  7 set newcopy=8
IF %maincopy% ==  6 set newcopy=7
IF %maincopy% ==  5 set newcopy=6
IF %maincopy% ==  4 set newcopy=5
IF %maincopy% ==  3 set newcopy=4
IF %maincopy% ==  2 set newcopy=3
IF %maincopy% ==  1 set newcopy=2
set maincopy=%newcopy%
GOTO end
:partcopy
ECHO  * * * THE PART COPY * * *:
ECHO ----------------------------
ECHO Insert diskettes for  * * * THE PART COPY * * * (every friday)
PAUSE
BACKUP C:\DEASE B: /s /l:C:\REPORT\PARTCOP1.LOG
BACKUP C:\BATCH B:
BACKUP C:\DATAKURS B: /s /l:C:\REPORT\PARTCOP3.LOG
BACKUP C:\CATALOG B: /l:C:\REPORT\PARTCOP4.LOG
ECHO Insert the diskette(s) for DAILY COPY (all files erased)
FORMAT A:
GOTO end
:daycopy
ECHO  * * * THE DAILY COPY * * *:
ECHO --------------------
ECHO Insert diskette(s) for  * * * THE DAILY COPY * * * (every morning)
PAUSE
BACKUP C:\DEASE B: /s /a /m
:end
GETDAY
IF ERRORLEVEL  1 set daycopy=2
IF ERRORLEVEL  2 set daycopy=3
IF ERRORLEVEL  3 set daycopy=4
IF ERRORLEVEL  4 set daycopy=5
IF ERRORLEVEL  5 set daycopy=6
IF ERRORLEVEL  6 set daycopy=7
IF ERRORLEVEL  7 set daycopy=8
IF ERRORLEVEL  8 set daycopy=9
IF ERRORLEVEL  9 set daycopy=10
IF ERRORLEVEL 10 set daycopy=11
IF ERRORLEVEL 11 set daycopy=12
IF ERRORLEVEL 12 set daycopy=13
IF ERRORLEVEL 13 set daycopy=14
IF ERRORLEVEL 14 set daycopy=15
IF ERRORLEVEL 15 set daycopy=16
IF ERRORLEVEL 16 set daycopy=17
IF ERRORLEVEL 17 set daycopy=18
IF ERRORLEVEL 18 set daycopy=19
IF ERRORLEVEL 19 set daycopy=20
IF ERRORLEVEL 20 set daycopy=21
IF ERRORLEVEL 21 set daycopy=22
IF ERRORLEVEL 22 set daycopy=23
IF ERRORLEVEL 23 set daycopy=24
IF ERRORLEVEL 24 set daycopy=25
IF ERRORLEVEL 25 set daycopy=26
IF ERRORLEVEL 26 set daycopy=27
IF ERRORLEVEL 27 set daycopy=28
IF ERRORLEVEL 28 set daycopy=29
IF ERRORLEVEL 29 set daycopy=30
IF ERRORLEVEL 30 set daycopy=31
IF ERRORLEVEL 31 set daycopy=32
ECHO set maincopy=%maincopy%  > setcopy.fil
ECHO set partcopy=%partcopy% >> setcopy.fil
ECHO set daycopy=%daycopy% >> setcopy.fil
:notcopy


BCOPY.BAT
=========

@ECHO OFF 
REM BCOPY.BAT
CLS 
COPY setcopy.fil+security.fil security.bat >nul
security.bat

SETCOPY.FIL
===========
set maincopy=8
set partcopy=5
set daycopy=25

BCOPY.BAT and SETCOPY.FIL should be in root directory.
The contents of SETCOPY.FIL must be adjusted every month.
Decide on which weekday and date you want the routine to
begin. It's important that the computers date is correct.

DATES.SCR 
=========

n GETMONTH.com
a 100 
mov ah, 2a 
int 21 
mov al, dh 
mov ah, 4c 
int 21 
 
rcx 
a 
w 

n GETDAY.com
a 100 
mov ah, 2a 
int 21 
mov al, dl 
mov ah, 4c 
int 21 
 
rcx 
a 
w 

n DOW.com
a 100 
mov ah, 2a 
int 21 
mov ah, 4c 
int 21 
 
rcx 
8 
w 
q

BACKUP1.BAT
===========

@ECHO OFF
REM BACKUP1.BAT
IF /%1==/ GOTO SHOW
REM %1 is not empty,no problems will occur when strings are compared
IF %1==1 CD\
IF %1==1 BACKUP C: A: /s
IF %1==1 GOTO END
IF %1==2 CD\
IF %1==2 BACKUP C: A: /m
IF %1==2 GOTO END
IF %1==3 CD\
IF %1==3 BACKUP C: A: /m /a
IF %1==3 GOTO END
REM If %1 is true, the program moves to the end
REM Display an error message
ECHO YOU HAVE WRITTEN AN INVALID SWITCH!!
:SHOW
ECHO TYPE A 1 FOR A TOTAL BACKUP
ECHO TYPE A 2 FOR A CERTAIN CHOICE BACKUP
ECHO TYPE A 3 FOR A CERTAIN CHOICE BACKUP THAT WILL BE ADDED TO AN EXISTING DISK
GOTO END
:END

The batch file is an unfinished example which can handle
many parameters or none at all. I leave it to you my reader
to complete it? It's a fine study to learn how IF sentences
can enhance your batch programs and make them more flexible.

Chapter 3:
=================================================================


Chapter 4: Edit a batch program
===============================

Two years ago, someone offered the following batch file, and I
have found it to be indispensable. Like most other users, I keep all my
batch files in one directory, and I used to have to type in the entire
directory\pathname\filename.ext or change drives\directories just to
edit a given batch file. With this BAT.BAT file placed in your batch
file directory, you can edit any given batch file from any
drive/directory. All that is required is to enter BAT FILENAME.
No extensions are necessary.

BAT.BAT
=======
@ECHO OFF
:: REM  BAT.BAT
:: REM  I can edit ANY batch file in D:\BATCH from anywhere in any drive
cls
IF %1 .==. goto NOT
q d:\batch\%1.bat
goto END
:NOT
q d:\batch\
:END
cls

Notice that I use QEdit, and it is also in my path......

I really appreciate that people share batch files.
Users that are new to computers often like to experiment
with writing batch files. It's exciting when you can help
someone else with a batch due to the fact that applications
are scary enough for them.


Chapter 5: Batch pipe problem
=============================

Now and then I get questions about different batch problems.
A frequently asked question is how we can run a batch file
with the command MORE. Is there a way to get around " | more"
not working to scroll output?

@ECHO OFF
for %%f in (%2) do find /i "%1" %%f

Yes, each 'find' command is a completely different command,
opening and closing the pipes.

Here's how I would do it in regular dos.

for %%f in (%2) do find /i "%1" %%f >> temp.x
type temp.x | more

Considering each 'find' operation is a separate command, the
append '>>' symbol is necessary or else you only get the results
of the last file in the list.

 for %%f in (%2) do find /i "%1" %%f

The problem is that the MORE filter only works with one instance of
STDOUT output at a time. If the output from any ONE of the FIND
statements would make the screen scroll, you'd find that the filter does
work--for that single FIND statement only.

Try attacking this from another angle--direct all of the STDOUT output
into a text file, then pass that text file through the MORE filter:

del txt
for %%f in (%2) do find /i "%1" %%f >> txt
type txt | more

If you don't want the "---<filename>" lines in your output, change the
FOR..IN..DO loop to read

for %%f in (%2) do find /i "%1"<%%f>>txt

Yea, it's working nicely with both suggestions.

Most people are aware of the '>' redirect command. But, they
don't know that they can append text also with '>>'. Nice!

I'll try modifying it also to get rid of the  '---<filename>'
header.

@ECHO OFF
for %%f in (%2) do find /i "%1" %%f

I think it's because you only get one command
after "do", in this case it's find. "more"
gets lost in the shuffle.
This is one of the serious drawbacks to DOS,
as it's fairly simplistic as far as operating
systems go.
As a test, make a batch file with -just- find
followed by more, like:

find "hello" txtfile.txt | more

...to see if it works there.  If not, then either
"find" or "more" is the problem, otherwise it's "do".

In any case, you may have to output your stuff to
a file first, then "more" that to the screen.

SEARCH.BAT
==========

@ECHO OFF
FOR %%f IN (%2) DO FIND /i "%1" %%f


SEARCH1.BAT
===========

@ECHO OFF
FOR %%f IN (%2) DO FIND /i "%1" %%f >> temp.x
TYPE temp.x | MORE


SEARCH2.BAT
===========

@ECHO OFF
FOR %%A IN (*.*) DO FIND /i "%1" %%A >> TEMP.X
TYPE TEMP.X | MORE


SEARCH3.BAT
===========
@ECHO OFF
FOR %%A IN (*.*) DO FIND /i "%1" %%A >> TEMP.X
TYPE TEMP.X | MORE
DEL TEMP.X


Chapter 6: Searching for files is often time consuming
======================================================

In this chapter we are going to look closer at
different ways to look for files and specific
text strings. If you are working with large data
files, searching for certain text strings in giga-
bytes of information you probably know how time-
consuming it is and how much time it takes to find
the files you are looking for. Every day I use different
methods to find files where I have stored essential
information.
Normally I work in a Windows environment. Windows provides
excellent methods to execute a search, find files, look
for special documents that are stored some place on your
hard disk. Still I prefer to search in plain MS DOS. It's
faster, especially when I'm searching through hundreds,
may be thousands of different files.

Below is one of my favourites. I call it LAF.BAT
(List all files).

The logic in the batch file is simple, but with great
functionality. I keep it in my batch directory and has defined
the directory in my path. I can use it all over the hard disk.
The syntax is very easy:

LAF search string

LAF.BAT
=======

@ECHO OFF
CHKDSK/V|FIND "%1"

In the first line I turn off the command ECHO. I don't
want to view the execution of the batch file.
I'm only interested in the report.
In the second line I use the options CHKDSK offers and
/v that displays the name of each file in every directory
as the disk is checked. 
The list piped to the MS DOS command FIND. FIND looks
through the list searching for the specific string you
want to search for. We add the switch /i to the command
FIND, so we don't have to worry about if the search is
case-sensitive or not. If you ignore /i, the specified
string of text must be written in capital letters. This
is how MS DOS will display it.

I hope you enjoyed it. Let's take a look at other batch
programs. Let's take a closer look at the smart file below.

ALL.BAT
=======

ECHO OFF
:START 
IF "%1"==" " GOTO END
CLS 
ECHO           *** Lines in *.bat that contain %1 ***
ECHO  
FOR %%p IN (*.bat) DO FIND /c "%1" %%p 
ECHO  
PAUSE 
SHIFT 
GOTO START 
:END


The batch file searches for a specific string of text in
a specified file or files. The name of the files you are
looking for is specified in the batch file. You are allowed
to type several parameters. This method is useful if you
want to search within the same group of files. In the example
below, I search through all the batch files. 
                                           
Both the command FOR and SHIFT is used in the batch file to
search for more than one string i several files. Below is
a line by line description.

_    Line 1 turns ECHO off

_    The label :START sets the beginning of the command sequence
     you need to repeat. The label is the destination for the command
     in GOTO on line 11.

_    The command IF controls whether the parameter is an empty
     parameter. If it is, the condition is met and the command
     GOTO will make MS DOS move on to the end of the batch file
     at line 12.

_    Line 4 clears the screen and place the prompt at the top of
     the screen.

_    The command ECHO in line 5 displays a message to the user.
     Line 6 displays a blank line.

_    The command FOR searches every file with the suffix BAT, and
     displays the amount of lines with the string (" %1 "),
     which is the first specified parameter in the batch file All.BAT

_    As line 6 line 8 displays a blank line.

  
-    Suspends processing of a batch program and displays a
     message that prompts the user to press any key to continue.
     You can use this command only within batch programs. 

_    The command SHIFT in line 10 moves parameter one step to the left.

_    The command GOTO returns MS DOS to the label :START.

_    The label :END identifies the end of the batch file.
     (the destination for the command GOTO i line 3).

To run ALL.BAT you must write the text, the words, the strings you
are looking for as parameters. Notice! The command FIND is
case-sensitive.

Say you want to search for the words ECHO, COPY and
message.
     Use the following syntax:
     
     ALL ECHO COPY melding

ALL clears screen, searches the suffix BAT for the word ECHO,
displays the amount of lines and stops.
You are asked to press any key and the batch file carry on and
searches the files for the word copy and displays the result.
The batch process repeats until all the words you have specified
have been found.

/c displays the amount of lines containing the given string
i each file. The switch is one of the command FIND'S many
options.
To end the batch file you must press CTRL-C and answer Y for
Yes.

FIND.BAT
========

Somewhere on your hard disk you remember that one of your most
important files is located, but exactly where is the question?
FIND.BAT use the switch /v belonging to the command CHKDSK.
The switch displays a list of all existing files on the hard disk.
If redirects the list to a file you can produce a fast search with
with the command FIND.
First time you run FIND, the program will create a file
called CATALOG.DAT in the root directory. Below is an example
how you can use it.

C:\>FIND BAT
The execution of the command will make a list of all batch files
on your hard disk. Notice the FIND.BAT doesn't take wildcards like
* or ?. In addition to search for files you can use FIND.BAT to
check if there are more copies of the same file in different
directories. All you have to do is to type the file name and
FIND will immediately list all file names that match. The
disadvantage is that FIND can't automatically register changes
on your hard disk. To upgrade \CATALOG.DAT you just have to use
the parameter new in the search string. If you are depending on
an upgraded list or maybe you need to search only once, you can
use the technique this way.

CHKDSK /v | FIND ".BAT"

You redirect the outprint directly to FIND that will display only
the lines containing the string "BAT". Since it takes at least the
same time to run the command CHKDSK it will always pay to use
\CATALOG.DAT if you intend to repeat the search. Users that run
the version 4.0 of MS DOS it's much easier. The MS DOS command
FIND has been improved so you can search for files all over your
hard disk. The command FIND *.BAT will list all batch files, but
not so fast as our batch file.

FIND.BAT
========
@ECHO OFF
IF NOT "%1 "==" " GOTO OK
:INSTR
ECHO 
ECHO [1mCommand
ECHO FIND {string} [new]      Find the file name containing the {string}
ECHO                {string} must be UPPER case
ECHO                The option NEW updates the catalog.
GOTO END
:OK
IF "%2"=="ny" GOTO CHKDSK
IF NOT "%2"==" " GOTO INSTR
IF EXIST \CATALOG.DAT GOTO FIND_FILE
:CHKDSK
ECHO [5mUpdates the catalog....[m
CHKDSK /v >\CATALOG.DAT
ECHO [1A
:FINN_FILE
FIND "%1" \CATALOG.DAT
:END

_    Line 2 skips the instructions if you specify at least
     one parameter.

_    Line 4-8 displays instructions on how to use the batch file.

_    Line 11 executes CHKDSK if the parameter NEW is specified.

_    Line 13 jumps directly to the search routine if the file
     \CATALOG.DAT exists.

_    Line 16 runs the command CHKDSK and redirects the outprint
     to the file \CATALOG.DAT.

_    Line 17 blanks the outprint from line 15.

_    Line 19 look for the specified string in the file \CATALOG.DAT

LOOKFOR.BAT
===========

ECHO off
CLS
ECHO           ***LINES I %1 CONTAINING %2***
ECHO
for %%p in (%1) do find "%2" %%p

To show all lines containing a certain string LOOKFOR.BAT can
point out the file you must search and the string you must specify.
Each line containing the string in the file, will be displayed.
Wildcards are allowed to search in groups of files.

The job is done in the last line of the batch file. The
previous line clears the screen and displays a title.
The command FOR in line 5 makes the command FIND
be repeated for each file name stated in your first parameter
when you type your LOOKFOR.BAT command. The command FIND looks
for the string  you specified as the second parameter. To display
each line containing the word "NOT" in all files in
current directory you must type:

LOOKFOR C:\SHAREWARE\PLENTY??.* NOT

Chapter 7: Customizing the command dir
======================================

Next to the command COPY DIR is maybe the most common
command you use. Every day we need to list directories,
find files with specified names or file extensions.
The command DIR has really improved since the earliest
MS DOS versions and provides several useful different
options. Very often you find yourself listing directories
containing  directories with hundreds of files and it's
impossible to read the screen. The switch /p is very handy.
When you need to look at your files in wide format the switch
/w provides as many as five file names or directories. Of course,
the command DIR offers several useful possibilities, but the
human nature needs changes and searches always for new ways to do
things. The imagination and the creativeness start working. There
will always be people that are looking for that special command
that does not exist. With our batches we can create them.

How is it possible to list all files in a directory
except those that have got a specific file extension?
The problem has different solutions. For example you can
write a program like

LAFUEXT.BAT
===========
@ECHO OFF
DIR | FIND /i /v %1 > dirfile
TYPE dirfile | more

(Lists all file without the extension.)

The program starts as usual with turning ECHO OFF. DIR
lists the directory and redirects the list to FIND. FIND has
offers the following options: /i means that FIND will be case
sensitive. /v displays all lines in the file not containing
the specified string.
The result is redirected to a file we call "dirfile",
and the command TYPE displays the contents of dirfile screen by
screen. The command MORE one screen of information at a time.

We can also do it in another way.

LAFUEXT1.BAT
============
@ECHO OFF
IF %1. ==. GOTO END
DIR | FIND "%1" /v
:END

In this example we solve the problem with a little help
from a simple IF-sentence. If %1 contains a file extension
the program jumps to :END. The rest will be displayed
without the specific string.

We can also solve the problem by using the command ATTRIB,
a command which is not very often used, and as a lot of batch
files offers excellent functionality.

LAFUEXT2.BAT
============
@ECHO OFF
ATTRIB +h %1
DIR
ATTRIB -h %1

This is what happens:

ATTRIB puts the files with the specified extension to hidden.
DIR won't list  hidden files. The result is a list containing
all file except those with a specified file extension.

There is also a rather handy tool that is capable of
solving the task. You can use NO.COM together with
ordinary MS DOS commands.

NO.COM
======

Copy the script file.

 NNO.ZIP
 E100 FC BB 03 00 BF D4 01 BE CC 01 33 C9 AD 86 CC AA FE C0 E2 FB 4B
 E115 75 F5 B9 FF FD BA 20 02 52 B4 3F CD 21 5F 72 60 8B F7 50 8B C8
 E12A B0 2A F2 AE 75 55 B0 0D F2 AE 87 F7 BB 00 01 B2 04 AC 3C 2A 72
 E13F 62 74 46 57 BF D2 01 B9 40 00 8A E1 F2 AE 5F 75 35 FE C1 2A E1
 E154 88 27 43 FE CA 75 E0 56 BE 00 01 AD 86 C4 8B D0 AD 86 C4 5E B1
 E169 02 D2 E0 D3 E0 D2 E2 D3 EA D0 E1 D1 EA D1 D8 E2 FA 86 C2 AA 8A
 E17E C4 AA 8A C2 AA EB B1 BF 20 02 58 33 D2 F7 D8 13 D2 F7 DA 33 DB
 E193 8B CA 8B D0 B8 01 42 CD 21 8B 0E CA 01 CC AC 3C 0A 75 FB AC 57
 E1A8 BF D2 01 B9 40 00 8A E1 F2 AE 5F 75 D0 FE C1 2A E1 86 E0 32 E4
 E1BD 8B 1E CA 01 03 D8 89 1E CA 01 E9 6C FF 00 00 30 0A 41 1A 61 1A
 E1D2 2B 2D
 G=100
 W220
 Q GXDPlus 1.0
*XXBUG20--00000422--18021994--964D7791------------------NO.ZIP
nI2g1--E++U+6++++e-HLxixSdE6++C+0+++4++++HYwiEoxBDJ1jGpBT51
vbSXSrFUM3
nJfukQwgWBXIf2DALmhKYfAqM98dZnCre9amvQbQL9EcaEXKjv0wcG97SK3zlWlTQJ
gn-
n6Uit3TeWLdIYp3oHYMq6aihqbB8-1rnCwrmStzCQYxN-aVg8wimUKo15HnLIcwjgk2-B
nVyAuuoQxULsDurSnjY32QvIJe6Tb-ba5pwisI5wEoKs5vq5k30DQt1kiJ42ByUH5XINY
nhe+-3XB1X-AtCOzLsLCV8oACf4E2VjRTfH7Pw-11iDmckq737qffY8a6bT2tCNtbb+6u
nXTL6WUq8S0z56SkGr973+cTQf6gdIioS1yRo00nbqonLvq4wFNWqb1zTPivsVyZFRJA
9
nq1eMgzNoohhLCmtDgNDeN8eNwCyB-u0YZmYNDKjS8TmMykNX4d0RGgLDkQEkq
3+IJQW9
nbveJNHKEBxzBnFb6o0rM4B1wJzItctDqmlHN9XIybPMrYA8VGNjsQvGr2DfS7bL7J1k
A
nyQT470PogHNgONaqHzO70uOriEZXQX9QiUd5AiH120-1ldG2keLnLQElSfkODAf1Q4
I-
nXdKdi2e6gH6B2JwiYGdYGgGOi62ojN5AAiIrhCk4ka4w7RqeWjAOED-YoohS4ly5uFcp
nwOR2GEBJikMZGqMlr9cCBwIslvGxY7pupIa+XGUs8JDrmfDEi-W3i7pFNkbZ1V+fpy
3k
n0V1WmYVepzzYIYMuWxzm+j6qPIFP1Ile6UTXGz-6e+I6hCpWH+RmHuvp0LdXAe
OeqObA
npt3tLOLqE4bsW7sEDnnDkmXcZealpt4DYKHYjMXFyxg95q+PDvbtyHC3KO+Mk0U
CIqFY
n77OhkNKXMjoe3AjLcGpV6ALTmXtUuJDqU+hFEAjIkMIRvu6EBtSy98QaEfRJ2DWJy
UhE
nGkA23++0++U+OVtD5-lgExSr++++tE++++M+++-CHmt2HoDXtJ7EID-9n2
qpIj1nprDq
nxyLZsiI880oem0w40XbatCGL3miYJWHbZ8NYteIf70eYNSOY3VSY7WiY3SLb8dFYd0
cY
n7dRYtiQdt8Q-NNDnQrAHwp7+VWU2JyOJ73O+n2JcUgcfF-QY3U2h9IYh8cs38LOhG
Akh
nm+2vEY399wcnEA53pET6oU8P-+DVaHYt0WadCI-x0cZ+7hVMVOHG2e+vUCtJ8A
wgmE+u
n+eExhO6YBOwMu0uE+E-EGk203++I++6+0++++8UIpzPjLeI0++1U+U++-
U++++++++++
n+0++++++++++HYwiEoxBI2g-+VE+3++0++U+OVtD5-lgExSr++++tE
++++M+++++++++
a+E+U++++mE6++2tD9YFDEp-9-EM++++++U+0+4U+++0Y+k++++
++
*XXBUG Version 2.20 by Chad Wagner

Execute the following command DEBUG < NNO.ZIP and you have become
the happy owner of a new DOS tool. You have to be a registered user
of PKUNZIP.EXE for unpack the file. You will receive NO.COM and NO.DOC
which is a short user reference.

If you register your copy of the Run Batch Run Book
you will receive along with your order a companion disk
containing my enhanced DIR command XDIR.

Chapter 8: How can a batch program answer Y for yes
===================================================

DELETE displays the following question when you executes
the command:

C:\> DEL *.*
All files i directory will be deleted!
Are you sure (Y/N)?

One line of a batch file can't be
executed until the previous line is DONE.  A batch file
that says DEL *.* and then Y will execute the DEL *.*
command and then when that's OVER WITH, THEN it'll execute
a Y command.  The Y doesn't do anything; isn't even READ by
DOS, until after the DEL command is FINISHED.  So by the
time DOS sees the Y, the DEL command is over and the Y will
get executed as a command.  So "Bad command or filename"
will be the result, unless you happen to have a program
named Y on your system.

A batch file is not a list of keystrokes that'll get typed
as if you were typing them at the keyboard. It's a list of
COMMANDS that get executed, one by one, separately from
each other, as if you were typing each one at each
successive C:\> prompt.  Having DEL *.* in a batch file
will have the exact same effect as typing DEL *.* at the
command line.  Regardless of what commands might be in the
batch file before or after.  A command line has to be
complete in and of itself, at the command line, in order
for it to be complete in a batch file.  The commands that
come before or after it don't affect it.  ECHO Y | DEL *.*
works in the batch file because it works at the command
line.

Now there's one exception, of course.  A program called a
keyboard stuffer.  There are several in existence.  PC
Magazine's KEY-FAKE and 4DOS's KEYSTACK, etc.  Such
programs stuff keystrokes into the keyboard buffer.  So
that the next program that executes, that wants a keystroke
or some keystrokes, will find that "you" have already
"typed" them (or so that program will THINK).  If you used
a keyboard stuffer to stuff a "Y" into the keyboard buffer
before your DEL *.* command in your batch file, then it
WOULD effect the DEL command, in contradiction to what I
said above.  The DEL command would find Y in the keyboard
buffer and think you typed it, because the previous command
in the batch file (the keyboard stuffer program) had put it
there before the DEL command executed.

It works the same way as ECHO Y | DEL *.* with a couple
exceptions.

1.  It would work for darn near any program, instead of
only those that take input from what's called Standard
Input, like DEL does.  Because the | (pipe) symbol takes
the first program's Standard Output (the ECHO command
above would be sending a Y to Standard Output) and pipes it
as Standard Input to the program after the | symbol. So
DEL gets its Y from Standard Input. But some programs look
directly at the keyboard to get their input, instead of
using Standard Input. For such programs, the ECHO Y |
trick won't work, but a keyboard stuffer program will.

2.  Since it doesn't involve redirection of Standard Input,
it works for programs that are going to want more input
than just what's stuffed.  If you used the ECHO X | PROGRAM
trick to send one keystroke to a program that wanted five
keystrokes, you'd have to reboot your computer. Because
the program would wait all day for its other four
keystrokes to come from the same location the first one had
come from!  No matter what you typed at the keyboard, it
would have no effect because the program had been more or
less told to ignore the keyboard!  Standard Input had been
redirected from the keyboard to the ECHO command. So the
ECHO command is the ONLY place that program is going to
take its input from, and the ECHO command only sent one
keystroke so that's all the program gets!  That program
will never do anything further so you have to reboot!

But a keyboard stuffer doesn't cause that problem because
it doesn't redirect Standard Input the way the | symbol
does. It just stuffs a keystroke (or several keystrokes)
into the place where Standard Input (or any other kind of
input) comes from the keyboard buffer.

So....the ECHO X | WHATEVER trick is good for some things,
but not all. And a batch file just simply can not do what
you were asking, without the help of a keyboard stuffer
program which you use to send the keystroke before you
execute the program that wants the keystroke not after
that program is finished.

From time to another you need to erase more than one directory.
This is very often a tedious job. Now your fantasy starts working.
You construct a useful batch. After a while you are in charge
of some useful tools. Ooops! Did I say in charge? Well, below I
will present to you a rather dangerous tool that may, if you
don't watch out, delete the total hard disk.

Let's start working. This is the basic lines.

ERASE.BAT
=========

@ECHO OFF
CLS
DEL *.*

When you run the batch program you have to
answer Y/N. If you have planned to erase all the
files in the directory, this turn out to be a rather
heavy job. We don't want the warning. We want action:
The directory is about to be erased. In the batch file
ERASE1.BAT, you will get no more questions.

ERASE1.BAT
==========

@ECHO OFF
CLS
ECHO Y | DEL *.*

By redirecting the Y through a pipe to the command DEL
we solve the problem. You can also use another method.

ERASE2.BAT
==========

@ECHO OFF
ECHO Y > ANSWER
DEL *.* < ANSWER

The batch program creates a file called ANSWER. The files
contain Y and ENTER that DEL *.* needs. The Y is redirected to
the command DEL and everything is all right. The smart thing is
that the file ANSWER will be deleted as well, and everything
is still all right because DEL has already read it. If you want
to see how it runs, use REM to let MS DOS leave out ECHO OFF.

Imagine there was a program that would repeat the command
you just have executed. Imagine how it moves from one directory
to directory. Lovely, isn't it? And the best thing is: you
can have it. You can make it yourself by using Scan codes.

REPEAT.SCR
==========

This little program is created to repeat another command in
the subdirectories. It starts from the directory where you
first typed the command and continues to the very end.
This is how the syntax looks like:

C:\> REPEAT ERASE2

As you probably have understood at this moment the command will
delete all files in the subdirectories below. It's a devil!
You may use it with many different MS DOS commands, DIR, TYPE,
etc. If you run it carelessly it is a very dangerous command.
Not so that it will hurt you or do you any harm, but it could
course a great deal of unnecessary work.
My advice is that you better think twice.
Plan how you will use it.

Here is the script file, REPEAT.SCR:

N REPEAT.COM
E 0100 E9 AD 00 0D 0A 52 45 50 45 41 54 20 2D 3E 20 20
E 0110 20 20 20 00 3A 5C 00 00 00 00 00 00 00 00 00 00
E 0120 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
E 0130 00 00 00 00 00 00 00 00 00 1A 4E 65 65 64 73 20
E 0140 44 4F 53 20 32 2E 30 20 2B 24 41 6C 6C 6F 63 61
E 0150 74 69 6F 6E 20 50 72 6F 62 6C 65 6D 24 53 57 45
E 0160 45 50 3A 20 43 4F 4D 4D 41 4E 44 20 50 72 6F 62
E 0170 6C 65 6D 24 53 57 45 45 50 3A 20 41 62 6E 6F 72
E 0180 6D 61 6C 20 45 78 69 74 24 00 00 00 43 4F 4D 53
E 0190 50 45 43 3D 00 00 00 00 00 00 7D 00 00 00 5C 00
E 01A0 00 00 6C 00 00 00 2A 2E 2A 00 2E 2E 00 8F 04 00         
E 01B0 B4 30 CD 21 3C 02 73 09 BA 3A 01 B4 09 CD 21 CD
E 01C0 20 86 C4 A3 89 01 BC 8F 04 BB FE 09 B1 04 D3 EB
E 01D0 B4 4A CD 21 73 05 BA 4A 01 EB E0 06 BB 2C 00 8E
E 01E0 07 2B FF BE 8C 01 FC 26 80 3D 00 74 14 56 57 B9
E 01F0 08 00 F3 A6 5F 5E 74 0F 2A C0 B9 FF FF F2 AE EB
E 0200 E6 07 BA 5D 01 EB B4 83 C7 08 89 3E 94 01 8C 06
E 0210 96 01 8C 06 98 01 8C 0E 9C 01 8C 0E A0 01 8C 0E
E 0220 A4 01 07 A0 80 00 04 03 A2 7D 00 C6 06 7E 00 20
E 0230 C7 06 7F 00 2F 43 B8 00 33 CD 21 88 16 8B 01 2A 
E 0240 2D B8 01 33 CD 21 BA 3C 03 B8 23 25 CD 21 B4 19
E 0250 CD 21 04 41 A2 13 01 BE 4F 03 2A D2 B4 47 CD 21
E 0260 BE 16 01 2A D2 B4 47 CD 21 BE 03 01 FC AC 0A C0
E 0270 74 08 8A D0 B4 02 CD 21 EB F3 B9 F4 01 B4 0B CD 
E 0280 21 E2 FA 81 3E 89 01 0A 03 72 0C B2 0D B4 02 CD
E 0290 21 B2 0A B4 02 CD 21 BB 98 01 C5 16 94 01 2A C0
E 02A0 B4 4B CD 21 8C C8 8E D8 8E C0 8E D0 BC 8F 04 9C
E 02B0 2A D2 B8 01 33 CD 21 8A 16 13 01 80 EA 41 B4 0E
E 02C0 CD 21 9D BA 5D 01 72 0C BA 15 01 B4 3B CD 21 73
E 02D0 0A BA 74 01 B4 09 CD 21 EB 62 90 8B 16 AD 01 B4
E 02E0 1A CD 21 80 3E AF 01 00 75 0C BA A6 01 B9 10 00
E 02F0 B4 4E CD 21 EB 04 B4 4F CD 21 72 25 8B 1E AD 01
E 0300 F6 47 15 10 74 F0 83 C3 1E 80 3F 2E 74 E8 8B D3
E 0310 B4 3B CD 21 83 06 AD 01 2B C6 06 AF 01 00 E9 3F
E 0320 FF 81 3E AD 01 8F 04 74 13 83 2E AD 01 2B C6 06
E 0330 AF 01 FF BA AA 01 B4 3B CD 21 EB 9F BA 4E 03 B4
E 0340 3B CD 21 8A 16 8B 01 B8 01 33 CD 21 CD 20
R CX
24F
W
Q

Type the whole script in your editor. My
favourite is SEMAFOR'S QEDIT, PLAIN ASCII-text.
Then execute the following command to get REPEAT.COM.

DEBUG < REPEAT.SCR

Put the new command where you keep your utilities. You
are now probably the happy owner of a new and very useful
tool. But don't blame me if you erase important files.

Chapter 9: Batch files can be used with memory and RAM
======================================================

It's always exciting when you find new unconventional ways
of using batch files. I usually test these programs immediately
to see how I can use them in my work. Below I will show you some
interesting samples.

Sometimes you need to find out wether a program is loaded
into memory or not? Here is a way to do it, it's not
so very elegant, but it works.

ISRES.BAT (Is resident)
=======================

@ECHO OFF
REM ISRES.BAT - Tests if a program is loaded into memory
REM by using
MEM/C
SET ISRES=N
MEM  /c > %temp%memtxt
FIND "%1" /i < %temp%memtxt > %temp%$$there
COPY %temp%$$there %temp%isthere > nul
IF EXIST %temp%isthere SET ISRES=Y

IF %isres%!==Y! ECHO "%1" the driver is resident.
IF %isres%!==N! ECHO "%1" The driver is NOT resident.

DEL %temp%??there > nul
DEL %temp%memtxt > nul

Now, what happens in the file?

As usually we start the program by turning ECHO OFF, we
don't want the command lines displayed. The second line
contains comments that explain what the program does. In
the third line a variable is sent to the environment which
put ISRES=N. When MS DOS discovers a named parameter in a
a batch program, the system looks immediately in the
environment for an entrance assigned a value:

SET ISRES=N

In the fourth line MS DOS executes the command MEM with the
switch /c. The /c is short for /classify. It lists the programs
that are currently loaded into memory and shows how much
conventional and upper memory each program is using. MEM
/classify also summarizes overall memory use and lists the
largest free memory blocks. You can use the /classify switch
with /page but not with other MEM switches. You can abbreviate
/classify as /c. The report is redirected to a directory called
temp and a file called MEMTXT is created.

In the fifth line FIND takes over the command. The switch /i
make the command case-sensitive. The string I'm looking for in
my case is "HIMEM". The file FIND shall search is MEMTXT,
the redirecting sign  < tells FIND where to search. The result
is redirected to C:\WINDOWS\TEMP$$THERE. $$THERE is not so easy
to understand, but I copy  $$THERE to ISTHERE. I don't want
any messages that says that 1 file (s) copied and is therefore
redirected to nothing, > NUL. In the next line the command IF EXIST
tests if ISTHERE exists and if it does the result is that the
SET VARIABLE in environment is set Y with SET ISRES=Y.
I line eight and nine we get the message:
If the variable is set to Y, ECHO shows : "HIMEM"
driver is resident.
If the variable is set to N, ECHO displays  "HIMEM" driver
is NOT resident. When the job is done the batch program
deletes the files ??THERE and MEMTXT.

The syntax is simple:
Type ISRES prog_name.

If "prog_name" exists the report from MEM /c the ISRES
variable will be set to Y, or will continue to N. Notice
that MS DOS doesn't copy 0-byte files. If the search string
does not exist in the report from MEM /c, the file
$$THERE won't be copied to ISTHERE, and the line IF...EXIST
will fail.

RAMDRIVE.BAT
============

Very simple you can define a RAM-disk as a diskette where
the files isn't stored physically on a magnetic disk,
but temporary in the computer's memory. From a user's point
of view a RAM-disk behaves just like other diskettes, but since
the computer doesn't need to read disks a RAM-drive is very fast.
But very few make use of the possibility. The reason is that the
RAM-drive use memory wether you need it or not, and you lose the
content when you turn off the computer. A much better alternative
is a so called CACHE-buffer, which acts as an "intelligent"
RAM-disk.

RAM-drives are created in the CONFIG.SYS file by typing the
command DEVICE=RAMDRIVE.SYS. In addition you have to specify
the disksize, the sectorsize and the number of files and directories
you can create in the RAM disk's root directory. RAMDRIVE or VDISK is
allocated automatically in the first empty logical location.
If your computer is equipped with to diskette drives (A and B) the
RAM-drive will be C. If your computer has got a hard disk the RAM drive
will be D.

RAMDRIVE.SYS has four parameters:

DEVICE=RAMDRIVE.SYS <disksize><sectorsize><numentris>
and two switches /e and /a,

/e Creates the RAM disk in extended memory instead of in
expanded memory or conventional memory.

/a Creates the RAM disk in expanded memory instead of in
extended or conventional memory.
  
Syntax 
  
    DEVICE=[drive:][path]RAMDRIVE.SYS [DiskSize SectorSize [NumEntries]]] 
    [/E | /A] 
  
Parameters 
  
[drive:][path] 
    Specifies the location of the RAMDRIVE.SYS file. 
  
DiskSize 
    Specifies how many kilobytes of memory you want to use for the RAM 
    drive. For example, to create a 640K RAM drive, specify 640. If you 
    don't specify an amount, RAMDrive will create a 64K RAM drive. You can 
    specify a value from 4 to 32767. However, you cannot specify more memory 
    than your system has available. 
  
SectorSize 
    Specifies the disk sector size in bytes. The size can be 128, 256, or 
    512 bytes. (If you include a SectorSize value, you must also include a 
    value for DiskSize.) 
  
    Generally, you should use the default sector size of 512 bytes. 
  
NumEntries 
    Limits the number of files and directories you can create in the RAM 
    drive's root directory. The limit can be from 2 to 1024 entries; the 
    limit you specify is rounded up to the nearest sector size boundary. If 
    you do not specify a limit, you can create up to 64 entries in the RAM 
    drive's root directory. (If you include a value for NumEntries, you must 
    also include values for DiskSize and SectorSize.) 
  
    If there is not enough memory to create the RAM drive as specified, 
    RAMDrive will try to create it with a limit of 16 directory entries. 
    This may result in a RAM drive with a different limit from the one you 
    specified.   
  
    For RAMDrive to use extended memory, your system must be configured so 
    that it provides extended memory, and a DEVICE command for the 
    extended-memory manager (such as HIMEM.SYS) must appear in your 
    CONFIG.SYS file before the DEVICE command for RAMDRIVE.SYS. In general, 
    it is best to create a RAM drive in extended memory if your system has 
    extended memory. 
  
  
    For RAMDrive to use expanded memory, your system must be configured so 
    that it provides expanded memory, and the DEVICE command for the 
    expanded-memory manager (such as EMM386, 386MAX, CEMM, or QEMM) must 
    appear in your CONFIG.SYS file before DEVICE command for RAMDRIVE.SYS. 
  

DEVICE=C:\DOS\RAMDRIVE.SYS 128 256 16

or create a RAM-disk with 1.5 Megabyte, 512-byte
sectors and 200 file names in extended memory:

DEVICE=C:\DOS\RAMDRIVE.SYS 1500 512 200 /E

The use of RAM-disk can be divided in two groups. To optimize
a certain process or you need to increase the speed generally.
A typical example of optimizing a certain process is for example
a program that reads two files at the same time and you get
a disk trashing. This leads to that the reading head jumps
between the to files as they are read into the computer. In
addition you sit and wait for the computer to finish. If you
place at least one of the files on a RAM-disk you avoid the
problem. If you use the technique on similar problems you can
achieve a much better efficiency and you can automate it. Think
of a routine that automatically copy a file to a RAM drive, runs
the job and maybe copies the file back and removes it from
the RAM drive.

You can also speed up DOS by using external commands or useful
tools with a RAM drive. For example in AUTOEXEC.BAT which the
computer runs each time you turn it on. The RAM-disk should be
written in the beginning of the PATH-variable.

To make it easier to use a RAM-disk you can run the batch file
below, RAMDRIVE.BAT. The file will create and remove a RAM-disk
to your needs. You don't have to make changes in the CONFIG.SYS
directly. The RAMDRIVE.BAT uses to commands called
REPLY and RESET. REPLY stops and waits for you to press a key
and returns an ASCII-code.
If you press any of the special keys on the keyboard it returns
the enhanced ASCII-code (Extended ASCII). RESET reboots the
computer as (Ctrl-Alt-Del) so the new changes can take place.
The can make the programs by using scan codes and compile them
in DEBUG. Here is how to do it: Create a file called .SCR-file
and redirect it to DEBUG:

DEBUG<filename.scr

Type the following in your favourite editor, mine is Qedit:

REPLY.SCR
=========

n reply.com 
a 100 
mov ah,8 
int 21 
cmp al,0 
jnz 10a 
int 21 
mov ah,4c 
int 21 
 
r cx 
e 
w 
q 


RESET.SCR
=========

n reset.com 
a 100 
mov ax,40 
mov ds,ax 
mov ax,1234 
mov [0072], ax 
jmp f000:e05b 
 
r cx 
10 
w 
q

You write RAMDRIVE.BAT as a normal batch file. But be accurate. The
file is rather complicated.

RAMDRIVE.BAT
============

@ECHO OFF
CLS
C:
CD\
IF "%1"=="none" GOTO NOTHING
IF "%1"=="new" GOTO RAMDRIVE
IF "%1"=="add" GOTO RAMDRIVE
ECHO Syntax:
ECHO RAMDRIVE add {size} {sector} {files} [/E]
ECHO RAMDRIVE new {size} {sector} {files} [/E]
ECHO RAMDRIVE none
GOTO STATUS
:NOTHING
COPY CONFIG.$$$ CONFIG.NEW >nul
IF EXIST ramdrive.log DEL ramdrive.log
IF EXIST log.new DEL log.new
IF EXIST config.new DEL config.new
GOTO RESET
:RAMDRIVE
IF not "%2"=="" IF not "%3"=="" IF not "%4"=="" GOTO OK
ECHO You must specify at least three parameters to the ramdrive
GOTO END
:OK
IF %1==none COPY config.$$$ config.new >nul
IF %1==new COPY config.sys config.new
IF %1==add IF EXIST RAMDRIVE.log COPY RAMDRIVE.log log.new >nul
ECHO DEVICE=C:\DOS\RAMDRIVE.sys %2 %3 %4 %5 >>config.ref
COPY config.ref+config.$$$ config.new >nul
IF "%5"=="" ECHO %2 Kbyte disk with %3-byte sectors and max %4 files>>log.new
IF "%5"=="/E" ECHO %2 Kbyte disk with %3-byte sectors and max %4 files in extended memory>>log.new
:RESET
ECHO The following RAMDRIVES are now defined:
IF EXIST log.new type log.new
IF NOT EXIST log.new ECHO ***  NOTHING  ***
ECHO Press F1 to continue or any other key to cancel.
REPLY
IF ERRORLEVEL 59 IF NOT ERRORLEVEL 60 GOTO DO_IT
ECHO ***  CANCELLED ***
IF EXIST log.new DEL log.new
GOTO STATUS
:DO_IT
DEL config.sys
REN config.new config.sys
IF EXIST log.new COPY log.new Ramdrive.log >nul
RESET
:STATUS
ECHO Active RAMDRIVE:
IF EXIST RAMDRIVE.log type RAMDRIVE.log
IF NOT EXIST RAMDRIVE.log ECHO ***  NOTHING  ***
:END

Before you run RAMDRIVE.BAT you must copy the original
CONFIG.SYS to CONFIG.$$$.
Then you type RAMDRIVE. Both REPLY and RESET must be in
the path. RAMDRIVE.BAT must be located in the root
directory.

Chapter 10: To remove files accidentally extracted
================================================

DEZIP.BAT
=========
@ECHO OFF
:DEZIP.BAT - Removes file accidentally extracted to the wrong directory.
:            (Type "DEZIP /?" (not the quotes) for brief instructions).
 ECHO.
:Check user parameters------------------------------------------------
 if (%1)==() goto SYNTAX
 if (%1)==(?) goto SYNTAX
 if (%1)==(/?) goto SYNTAX
 if (%2)==() goto SYNTAX
 if (%2)==(?) goto SYNTAX
 if (%2)==(/?) goto SYNTAX
:Check target directory ------------------------------------------------
 if not exist %1\nul echo   Error: %1 does NOT exist!
 if not exist %1\nul goto SYNTAX
 if not exist %1\*.* echo   Error: %1 does NOT contain any files!
 if not exist %1\*.* goto SYNTAX
:Check for ZIP file ----------------------------------------------------
 if not exist %2 echo   Error: %2 does NOT exist!
 if not exist %2 goto SYNTAX
:Check for PKZIP.EXE ---------------------------------------------------
 ctty nul
 ver|pkzip>temptemp
 ctty con
 copy temptemp+,,>nul
 if not exist temptemp echo   Error: PKZIP is NOT available!
 if not exist temptemp goto SYNTAX
:Do it! ----------------------------------------------------------------
 pkzip- -fm %2 %1\*.*>nul
 if errorlevel 18 echo   Error: PKZIP reports it is unable to open 1 or
 if errorlevel 18 echo          more specified files.
 if errorlevel 18 goto SYNTAX
 if errorlevel 17 echo   Error: PKZIP reports there are too many files
 if errorlevel 17 echo          for the amount of memory available.
 if errorlevel 17 goto SYNTAX
 if errorlevel 16 echo   Error: PKZIP reports bad or illegal parameters
 if errorlevel 16 echo          specified.
 if errorlevel 16 goto SYNTAX
 if errorlevel 15 echo   Error: PKZIP reports the ZIP file is read-only
 if errorlevel 15 echo          and can not be modified.
 if errorlevel 15 goto SYNTAX
 if errorlevel 14 echo   Error: PKZIP reports your disk is full.
 if errorlevel 14 goto SYNTAX
 if errorlevel 13 echo   Error: PKZIP reports the specified ZIP: %2
 if errorlevel 13 echo          was NOT found.
 if errorlevel 13 goto SYNTAX
 if errorlevel 12 echo   Error: PKZIP reports NO files were found to
 if errorlevel 12 echo          add/delete to/from ZIP file.
 if errorlevel 12 goto SYNTAX
 if errorlevel 11 echo   Error: PKZIP reports Insufficient memory.
 if errorlevel 11 goto SYNTAX
 if errorlevel  3 echo   Error: PKZIP reports error in ZIP file.
 if errorlevel  3 goto SYNTAX
 if errorlevel  1 echo   Error: PKZIP reports bad file name or file
 if errorlevel  1 echo          specification.
:SUCCESS ---------------------------------------------------------------
 echo Any files that were in subdirectory: %1
 echo with the same filenames as files in: %2
 echo have been successfully removed from: %1
 echo.
 echo.
 goto CLEANUP
:SYNTAX ----------------------------------------------------------------
 echo.
 echo    Name: DEZIP.BAT v1.1 - Vernon Frazee 06/91
 echo.
 echo Purpose: Removes files accidentally unZIPped to the wrong directory.
 echo.
 echo  Syntax: [d:][\path\]DEZIP  d:\path  d:\path\filename.zip
 echo.
 echo   Where: "d:\path" is the drive:\directory containing the files
 echo           you want DEZIP to remove.
 echo.
 echo          "d:\path\filename.zip" is the ZIP file containing the
 echo          filenames you want removed from "d:\path".
 echo.
 echo                           \/--------------[ Any files in this ZIP
 echo Example: DEZIP  C:\LOTUS  D:\NEW\FOO.ZIP
 echo                 /\------------------------[ remove from this DIR.
 echo.
 echo English: Remove all the files from the C:\LOTUS directory that are
 echo          duplicates of any files found in D:\NEW\FOO.ZIP.
 echo.
 echo    Note: PKZIP.EXE must be available somewhere in your PATH.
 echo.
:CLEANUP ---------------------------------------------------------------
 if exist temptemp del temptemp
:END ------------------------------------------------------------- -vjf-


Chapter 11: Choice
==================

While experimenting with DOSSHELL I pressed the Enter
key with a Batch File highlighted.  Of course the file was executed even
though I didn't really want to defrag my drive at the moment.  Associating
this batch file with the .BAT extension provides the option to Edit, Run
or Cancel.  Seems like this could also be cloned to send .DOC files to the
Word Processor, ASCII Editor, or Viewer; view or extract archives; etc..

MULTIJOB.BAT
============

  @ECHO off
  rem CLS bright white on blue (ansi)
  ECHO 
ECHO ===============================[Multi-Associate]===========================
ECHO Please select action to take with: %1
ECHO.
  CHOICE /c:erc Edit, Run, or Cancel
  IF errorlevel 3 GOTO clear
  IF errorlevel 2 GOTO run
  IF errorlevel 1 GOTO editor
:editor
  ECHO 
  edit %1
  GOTO end
:run
  ECHO 
  CALL %1
  GOTO end
:clear
  ECHO 
:end
rem -- multiple-association batch file for DOSSHELL --

Chapter 12:  How to get the system date
=======================================

In this chapter we will discuss among other topics how
to get the system date, using only three letters and without
a complicated batch file with labels and GOTO.
We start with a simple COM program called MON.COM. created
with scan codes.

Write the following into your editor. My favourite is
Qedit.

MON.SCR
=======

N MON.COM
A 100
MOV AH, 2A
INT 21
MOV AL, DH
MOV AH, 4C
INT 21

R CX
A
W
Q


;int 21h/2a Get System Date
;returns:
; al day of week (0-6)
; cx year (1980-2099)
; dh month (1-12)
; dl day (1-31)
        mov ah,2ah
        int 21h
        mov al,dh          ; we send the month in errorlevel
        mov ah,4ch
        int 21h

Then the batch file.

MON.BAT
=======
@echo off
mon
if errorlevel 1 set mon=jan
if errorlevel 2 set mon=feb
if errorlevel 3 set mon=mar
if errorlevel 4 set mon=apr
if errorlevel 5 set mon=may
if errorlevel 6 set mon=jun
if errorlevel 7 set mon=jul
if errorlevel 8 set mon=aug
if errorlevel 9 set mon=sep
if errorlevel 10 set mon=oct
if errorlevel 11 set mon=nov
if errorlevel 12 set mon=dec


Technically what we have here is an exception to the high -> low testing of
errorlevel. In our example it works because we are constantly
overwriting a single variable from the lowest errorlevel to the one that
you want. Although it works, I believe it is poor programming practice
because:
        1) it is an exceptional case and programming techniques should
        be as consistent as possible both for the benefit of the
        programmer, who does not have to consider "is this an exception
        and therefore I can do another way if I want to", and more
        importantly for anybody else who may need to read, and or
        maintain, the code.
        2) it is less efficient since you are consuming extra memory
        cycles for each errorlevel below the one you want by rewriting
        the variable each time.

I guess I have been in this business too long, but I continue to
look with amazement at the bloat that has taken place in both program
size and machine cycle capability to perform them. There have been
several batch files that will set a date or
time in an environment variable. They are smaller and do
not require any additional unique programs or capabilities other than
what can be done with plain DOS.

Despite all of the above, I think the program is a clever use of
both assembly language and a batch file.


Here is another batch file which gets the system date.

GETDATE.BAT
===========

: Sets the date as an environment variable.

ECHO @ECHO OFF > C:\CURRENT.BAT
ECHO @SET TODAY=%%4 >> C:\CURRENT.BAT
ECHO. | DATE | FIND "Current" > C:\GDATE.BAT
CALL C:\GDATE.BAT < C:\CURRENT.BAT
DEL C:\CURRENT.BAT > NUL
DEL C:\GDATE.BAT > NUL

This puts the current date as mo-da-year in the environment variable
TODAY.

ECHO @ECHO OFF > C:\CURRENT.BAT
ECHO @SET TODAY=%%4 >> C:\CURRENT.BAT
ECHO. | DATE | FIND "Current" > C:\GDATE.BAT
CALL C:\GDATE.BAT < C:\CURRENT.BAT
DEL C:\CURRENT.BAT > NUL
DEL C:\GDATE.BAT > NUL

the mo-da-year will be in TODAY.

echo.|date>!!temp.bat
echo set today=%%4>current.bat
call temp.bat
del temp.bat
del current.bat
rem>%TODAY%.T$T

NOTE! Following lines beginning with "for" should be all on one line.
Also note that the line beginning with "for %%y" handles years 1993
through 1999 only. You will need to change this on January 1, 2000.

for %%m in (01 02 03 04 05 06 07 08 09 10 11 12) do if exist %%m-??-19.T$T set M=%%M
for %%d in (01 02 03 04 05 06 07 08 09 10) do if exist %M%-%%d-19.T$T
set D=%%d
for %%d in (11 12 13 14 15 16 17 18 19 20) do if exist %M%-%%d-19.T$T
set D=%%d
for %%d in (21 22 23 24 25 26 27 28 29 30 31) do if exist %M%-%%d-19.T$T
set D=%%d
for %%y in (3 4 5 6 7 8 9) do if "%TODAY%" == "%M%-%D%-199%%y" set Y=%%y
del %TODAY%.T$T
SET TODAY=
SET M=
SET D=
SET Y=



@ECHO off
::set month to alpha as an environment variable using plain dos
ECHO.|date>gdate.bat
ECHO set today=%%4 > current.bat
CALL gdate.bat
DEL gdate.bat
DEL current.bat
REM>%TODAY%
FOR %%m IN (01 02 03 04 05 06 07 08 09 10 11 12) DO IF EXIST
%%m-??-?? SET MN=%m
IF "%MN%" == "01" set MON=Jan
IF "%MN%" == "02" set MON=Feb
IF "%MN%" == "03" set MON=Mar
IF "%MN%" == "04" set MON=Apr
IF "%MN%" == "05" set MON=May
IF "%MN%" == "06" set MON=Jun
IF "%MN%" == "07" set MON=Jul
IF "%MN%" == "08" set MON=Aug
IF "%MN%" == "09" set MON=Sep
IF "%MN%" == "10" set MON=Oct
IF "%MN%" == "11" set MON=Nov
IF "%MN%" == "12" set MON=Dec
IF exist %MN%-??-?? DEL %MN%-??-??
set TODAY=
set MN=

@echo off
rem GETDTVAR.BAT
rem Put current day, date, time into every LOGDAY, LOGDATE and LOGTIME
ver | date > %temp%\gd.bat
echo set logday=%%3 >current.bat
echo set logdate=%%4 >>current.bat
call %temp%\gd
ver | time>%temp%\gd.bat
echo set logtime=%%3 >current.bat
call %temp%\gd
for %%a in (%temp%\gd.bat current.bat) do del %%a>nul

Get (GET26A.ZIP) is great for just this kind of thing.  A shareware
utility that does all kinds of things involving the environment.

I need a way to (1) save the current DATE and (2) set the DATE
ahead by a fixed number of days.

Saving is easy, there'll be an ECHO . | DATE > in there
somewhere.

The second is trickier. I know that DATE will deliver a text
string that will call CURRENT.BAT, which thus gets the MM DD and
YYYY of today's system date.

I believe too that if I can increment those values (wrap-around
at end-of-month and end-of-year would be nice!) I can reset the
date using the new values.

How to increment string values?

I've toyed with the idea of building a value by repeated copying
of a 1-byte file:
        COPY ERASE1+1BYTE ERASE1
and then grabbing the size field of the DIR command output.

I've toyed with the idea of setting a string to be the
appropriate length (here's a 5-character string that represents
today's date, here's a 14-character string that represents two
weeks into the future, calculate them. My suggestion is to write
a computer program to do it, even in BASIC.
It would be cleaner, faster, and easier too, and could utilize
system resources for doing the wrap or even avoiding February
problems in leap years, or whatever.

This won't be an answer to the problem as much as it is a theory that
may apply. You may find it easier to manipulate the dates within the
Julian Calendar, and when you've done all your calculations and so
forth, then translate the Julian Calendar back to our normal calendar,
and voila.

REM BUMPDAY.BAT
::      Increment the DAY by 1. Roll into next month.
::      Calls SETMAXDY, BUMPMTH (and hence BUMPYEAR)
@echo off
call SETMAXDY
set MAXMTH=12
if "1"=="31" goto BUMPMTH
set RES=1
call INCBY1
set DAY=2
goto EXIT
:BUMPMTH
call BUMPMTH
:EXIT
@echo 8/2/1
REM end of BUMPDAY.BAT
=======================================================================
REM SETMAXDY.BAT
::      Define MAXDAY based on MONTH number
::      Called from BUMPDAY.BAT
@echo off
if "%month%"=="1" set maxday=31
if "%month%"=="2" set maxday=28
if "%month%"=="3" set maxday=31
if "%month%"=="4" set maxday=30
if "%month%"=="5" set maxday=31
if "%month%"=="6" set maxday=30
if "%month%"=="7" set maxday=31
if "%month%"=="8" set maxday=31
if "%month%"=="9" set maxday=30
if "%month%"=="10" set maxday=31
if "%month%"=="11" set maxday=30
if "%month%"=="12" set maxday=31
REM end of SETMAXDY.BAT
==================================================================
REM BUMPMTH.BAT
:: Bump the MONTH number up by 1. Roll into the next YEAR.
::      Called from BUMPDAY. Calls BUMPYEAR
set DAY=1
if "2"=="12" goto BUMPYEAR
:BUMPMONTH
set RES=2
call INCBY1
set MONTH=2
goto EXIT
:BUMPYEAR
call BUMPYEAR
:EXIT
REM End of BUMPMONTH.BAT
=======================================================================
REM BUMPYEAR.BAT
:: Increment the year by 1. Called from BUMPMTH.BAT
set MONTH=1
set RES=8
call INCBY1
set YEAR=2
REM end of BUMPYEAR.BAT
=======================================================================
REM INCBY1.BAT
:: Increment the environment variable RES by 1
::      called from BUMPDAY. BUMPMTH, BUMPYEAR
@echo off
if "%res%"=="30" goto 31
if "%res%"=="29" goto 30
if "%res%"=="28" goto 29
if "%res%"=="27" goto 28
if "%res%"=="26" goto 27
if "%res%"=="25" goto 26
if "%res%"=="24" goto 25
if "%res%"=="23" goto 24
if "%res%"=="22" goto 23
if "%res%"=="21" goto 22
if "%res%"=="20" goto 21
if "%res%"=="19" goto 20
if "%res%"=="18" goto 19
if "%res%"=="17" goto 18
if "%res%"=="16" goto 17
if "%res%"=="15" goto 16
if "%res%"=="14" goto 15
if "%res%"=="13" goto 14
if "%res%"=="12" goto 13
if "%res%"=="11" goto 12
if "%res%"=="10" goto 11
if "%res%"=="9" goto  10
if "%res%"=="8" goto 9

set YEAR=8
set DAY=1
set MONTH=2
call BUMPDAY (repeatedly)
=======================================================================
REM BUMPDAY.BAT
::      Increment the DAY by 1. Roll into next month.
::      Calls SETMAXDY, BUMPMTH (and hence BUMPYEAR)
@echo off
call SETMAXDY
set MAXMTH=12
if "1"=="31" goto BUMPMTH
set RES=1
call INCBY1
set DAY=2
goto EXIT
:BUMPMTH
call BUMPMTH
:EXIT
@echo 8/2/1
REM end of BUMPDAY.BAT
=======================================================================
REM SETMAXDY.BAT
::      Define MAXDAY based on MONTH number
::      Called from BUMPDAY.BAT
@echo off
if "%month%"=="1" set maxday=31
if "%month%"=="2" set maxday=28
if "%month%"=="3" set maxday=31
if "%month%"=="4" set maxday=30
if "%month%"=="5" set maxday=31
if "%month%"=="6" set maxday=30
if "%month%"=="7" set maxday=31
if "%month%"=="8" set maxday=31
if "%month%"=="9" set maxday=30
if "%month%"=="10" set maxday=31
if "%month%"=="11" set maxday=30
if "%month%"=="12" set maxday=31
REM end of SETMAXDY.BAT
==================================================================
REM BUMPMTH.BAT
:: Bump the MONTH number up by 1. Roll into the next YEAR.
::      Called from BUMPDAY. Calls BUMPYEAR
set DAY=1
if "2"=="12" goto BUMPYEAR
:BUMPMONTH
set RES=2
call INCBY1
set MONTH=2
goto EXIT
:BUMPYEAR
call BUMPYEAR
:EXIT
REM End of BUMPMONTH.BAT
=======================================================================
REM BUMPYEAR.BAT
:: Increment the year by 1. Called from BUMPMTH.BAT
set MONTH=1
set RES=8
call INCBY1
set YEAR=2
REM end of BUMPYEAR.BAT
=======================================================================
REM INCBY1.BAT
:: Increment the environment variable RES by 1
::      called from BUMPDAY. BUMPMTH, BUMPYEAR
@echo off
if "%res%"=="30" goto 31
if "%res%"=="29" goto 30
if "%res%"=="28" goto 29
if "%res%"=="27" goto 28
if "%res%"=="26" goto 27
if "%res%"=="25" goto 26
if "%res%"=="24" goto 25
if "%res%"=="23" goto 24
if "%res%"=="22" goto 23
if "%res%"=="21" goto 22
if "%res%"=="20" goto 21
if "%res%"=="19" goto 20
if "%res%"=="18" goto 19
if "%res%"=="17" goto 18
if "%res%"=="16" goto 17
if "%res%"=="15" goto 16
if "%res%"=="14" goto 15
if "%res%"=="13" goto 14
if "%res%"=="12" goto 13
if "%res%"=="11" goto 12
if "%res%"=="10" goto 11
if "%res%"=="9" goto  10
if "%res%"=="8" goto 9
if "%res%"=="7" goto 8
if "%res%"=="6" goto 7
if "%res%"=="5" goto 6
if "%res%"=="4" goto 5
if "%res%"=="3" goto 4
if "%res%"=="2" goto 3
if "%res%"=="1" goto 2
if "%res%"=="0" goto 1
pause
goto exit
:31
set res=31
goto exit
:30
set res=30
goto exit
:29
set res=29
goto exit
:28
set res=28
goto exit
:27
set res=27
goto exit
:26
set res=26
goto exit
:25
set res=25
goto exit
:24
set res=24
goto exit
:23
set res=23
goto exit
:22
set res=22
goto exit
:21
set res=21
goto exit
:20
set res=20
goto exit
:19
set res=19
goto exit
:18
set res=18
goto exit
:17
set res=17
goto exit
:16
set res=16
goto exit
:15
set res=15
goto exit
:14
set res=14
goto exit
:13
set res=13
goto exit
:12
set res=12
goto exit
:11
set res=11
goto exit
:10
set res=10
goto exit
:9
set res=9
goto exit
:8
set res=8
goto exit
:7
set res=7
goto exit
:6
set res=6
goto exit
:5
set res=5
goto exit
:4
set res=4
goto exit
:3
set res=3
goto exit
:2
set res=2
goto exit
:1
set res=1
goto exit
:0
set res=0
goto exit
:1
set res=1
goto exit
:exit
REM end of IncBy1.BAT
==================================================================
        Run this through  DEBUG, like so: DEBUG < SPFOWARD.SCR.

n spfoward.com
a 100
mov ah,2c
int 21
inc ch
mov ah,2d
int 21
ret
(blank line)
rcx
b
w
q

Then, anytime *before* 11PM on any day (because it doesn't
check to see if the hours are > 11PM and won't adjust the day right if
so), just do SPFOWARD from DOS. When fall comes, make a copy of
SPFOWARD.SCR  called FALLBACK.SCR, change the N at the top to read N
fallback.com, change the "inc ch" to "dec ch", and run the fallback.scr
through DEBUG, run FALLBACK from DOS *after* 1am on any day and you'll be
back to non-DST time. Hope this helps.



Chapter 13: Extracting text strings
===================================

The other day I received a letter on my bulletin board.
The writer wanted to know if there was a method to extract
parts of a text string and use it in a batch file.

I write this message to ask if either of you know a way to extract
portions of a text string using batch commands. If available, I could
eliminate use of the GWBASIC program referred to above, making the
program all-batch.

Can't help with extracting strings within a batch program except by
using some external program as you have done. But if you are only
interested in parsing the date, the following is an extract of a batch
program I saved from this conference that does that.

echo.|date>!!temp.bat
echo set today=%%4>current.bat
call temp.bat
del temp.bat
del current.bat
rem>%TODAY%.T$T

NOTE! Following lines beginning with "for" should be all on one line.
They just wouldn't fit that way in my editor. Also note that the line
beginning with "for %%y" handles years 1993 through 1999 only. You will
need to change this on January 1, 2000 <g>.

for %%m in (01 02 03 04 05 06 07 08 09 10 11 12) do if exist %%m-??-19.T$T set M=%%M
for %%d in (01 02 03 04 05 06 07 08 09 10) do if exist %M%-%%d-19.T$T
set D=%%d
for %%d in (11 12 13 14 15 16 17 18 19 20) do if exist %M%-%%d-19.T$T
set D=%%d
for %%d in (21 22 23 24 25 26 27 28 29 30 31) do if exist %M%-%%d-19.T$T
set D=%%d
for %%y in (3 4 5 6 7 8 9) do if "%TODAY%" == "%M%-%D%-199%%y" set Y=%%y
del %TODAY%.T$T
SET TODAY=
SET M=
SET D=
SET Y=

The code we're discussing looks like part of a date-formatting program.
I wrote such a batch program, setting DAY to Tue (or whatever), and
DATE to 05-29-1926 (or whatever), but I couldn't figure out how to
extract the components of DATE (ie. separate 05 from 29 from 1926)
with batch commands. So, my batch program calls a GWBASIC program
which does the extraction and conversion of month from numeral
to month-name, and sets the month-name. This lets me place in my
opening menu such gems as Tuesday the 8th of May 1926.

The basic program is fine, assuming every machine you run this on
has gwbasic.  if you want to keep everything DOS-ish, the way I
described is the way to go.  I'll try to explain it better:

echo @echo off > current.bat
echo @set day=%%3 >> current.bat
echo @set date=%%4 >> current.bat
echo. | date | find "Current" > gdate.bat
call gdate.bat < current.bat

Here goes:

The first three lines simply create another batch file.
It's contents are:

   @echo off
   @set day=%3
   @set date=%4

This batch file sets a var "day" and a var "date" based on
parameters passed to it, the 3rd and 4th specifically.

The 4th line of the first batch file creates a file containing
one line.  Here's the contents of gdate.bat:

Current date is Tue 02-12-93

Finally, the last line runs the batch file created, using
the contents of the 2nd file as -input- ... the %3 and %4
pick up "Tue" and "02-12-93" respectively.
It's a way of getting around an inefficiency in DOS.
From my point of view, using a program is fine, too.  That's
what PC's are for.

TODAY.BAT
=========
for %%m in (01 02 03 04 05 06 07 08 09 10 11 12) do IF exist %%m-??-19.T$T set M=%%M
for %%d in (01 02 03 04 05 06 07 08 09 10) do IF exist %M%-%%d-19.T$T set D=%%d
for %%d in (11 12 13 14 15 16 17 18 19 20) do IF exist %M%-%%d-19.T$T set D=%%d
for %%d in (21 22 23 24 25 26 27 28 29 30 31) do IF exist %M%-%%d-19.T$T set D=%%d
for %%y in (3 4 5 6 7 8 9) do IF "%TODAY%" == "%M%-%D%-199%%y" set Y=%%y
del %TODAY%.T$T
SET TODAY=
SET M=
SET D=
SET Y=


Chapter 14: Different batch enhancers and using scan codes
==========================================================

This book will describe different utilities, batch
enhancers, shareware, public domain and the use of
scan codes that increase the flexibility and
functionality of batch files further.
Sharewares are like the book you are just reading:
You find these programs on bulletin boards and
internet all over the world and download them to
your own computer. Normally you can evaluate the
shareware for a certain time. Do you find the product
useful and will continue using it, you have to pay for
it. This is also what you have to do with the first program
I will discuss later in this book, GET.EXE


Chapter 15: Batch files and mail
================================

I often visit different databases, bulletin boards and internet
to collect and get information. The information is automatically
loaded into my computer. The mail is read in my off-line
mailreader. I want it to fetch my off-line
mail packets from my download directory, place them in a mail directory
and start my mail reader.  Now, here's the tricky part.
I'd like it to rename, rather than overwrite any existing packets, and
I need it to be able to deal with packets from several BBSs at the
same time.

This is a batch file I've been working on. It seems to work okay when
dealing with mail from one BBS only.  I don't know enough about how
DOS handles these commands when dealing with multiple files to even
guess what might happen when there are several QWK packets involved.

I wonder if it might be better to rename the packets before reading them.
For general use, an on-screen message warning of impending deletions might
be better.  The beeps and .QQQ file extension meet my needs.

MAIL.BAT
========

@ECHO OFF
CLS
rem if no new mail, just read old mail
IF NOT EXIST C:\ZDOWN\*.QWK GOTO READ
  rem
  rem fetch packets from d/l directory
  MOVE C:\ZDOWN\*.QWK C:\ZMAIL > NUL
  rem warn if old packets will be deleted after this session
  IF NOT EXIST C:\ZMAIL\*.QQQ GOTO READ
  rem beep.com, beeps speaker
  BEEP
  BEEP
:READ
  rem
  rem start mail reader
  C:\SLMR\SLMR.EXE
  rem if there was no new mail we are finished
  IF NOT EXIST C:\ZMAIL\*.QWK GOTO END
  rem delete oldest packets
  ECHO Y | DEL C:\ZMAIL\*.QQQ > NUL
  rem renumber packets
:QW3
  IF NOT EXIST C:\ZMAIL\*.QW3 GOTO QW2
  REN *.QW3 *.QQQ > NUL
:QW2
  IF NOT EXIST C:\ZMAIL\*.QW2 GOTO QW1
  REN *.QW2 *.QW3 > NUL
:QW1
  IF NOT EXIST C:\ZMAIL\*.QW1 GOTO QWK
  REN *.QW1 *.QW2 > NUL
:QWK
  IF NOT EXIST C:\ZMAIL\*.QWK GOTO END
  REN *.QWK *.QW1 > NUL
:END
  rem goodbye!
  CLS

Chapter 16: How to suppress the writing on the screen?
======================================================

I keep most of my programs zipped in a directory called zips
and use this batch file to run them:

@echo off
md \temp
cd \temp
pkunzip c:\zips\anyname.zip
anyname.exe
pkzip /u c:\zips\anyname.zip
cd \
deltree /y c:\temp

This works just fine, but I would like to suppress the writing
on the screen of pkzip as it un-compresses I believe it involves
using >@ after the line " pkunzip c:\zips\anyname.zip >@
and this seems to work except that the @ keeps getting updated
when I close the program.

What I want is to  "> nul" to prevent screen writing while unzipping.

@echo off
md \temp
cd \temp
pkunzip c:\zips\anyname.zip  > nul
anyname.exe
pkzip /u c:\zips\anyname.zip
cd \
deltree /y c:\temp


The redirection command is > nul not >@.

The only thought about how to improve your batch file would be to use a
command line variable for the name of the zip file (anyname). If your
batch file, for example, is named dozip.bat, then you could call it with
dozip anyname and substitute the variable %1 where ever anyname appears
in your batch file. This would make the batch file general purpose for
any zip filename.


Chapter 17: How to have a batch file testing if Windows is running
==================================================================

EXITING WINDOWS?

What is the best "Exit Windows" command?

Not sure if this is a help but there's a 8192 byte exe file
called Winexit.exe you could use as a quick exit from Windows. If put in
windows as an icon, you would double click it and you are back to dos.

If you are trying to automate a windows, have you tried the
key-stroke recorder in windows?
Have you heard or tried Winrun.exe? Its a program that lets you
start a windows program from the command line or a batch file. I have
one that goes right to Winfax.
If you are interested in Winexit.exe and can't find it let me
know and I'll send it to you as a debug script.
I use WinBatch from WilsonWindowWare to do this kind of thing.
It allows you to do just about anything you need and you can use the
included compiler to create .EXE files. I love this thing...

...and it's cheap.

1. I've found that Winclock does not allow me to run winexit.exe
as an alarm (although it can run all other programs as WP, Excel,
Becker tools Backup and many more. It even allows you to write lines to
these programs when starting them.

2. I've got the DOS-version of my fax program, so I can simply
run my fax as an TSR and then make a batch-file calling the BBSs.

It's quite a tool.  I used it last week to run a PC maintenance program
on 100+ PCs notion wide. It contains most of the needed
logical expressions of a full programming language, with the simple
syntax of dos.  I tend to use it for the windows functions of my batch
files, where my batch file calls windows after replacing Startup.grp
with a new one including my winbatch .EXE. It is kind of shareware, but
you need to buy the full boat to get the compiler(well worth it!)

How to have a batch file test to see if Windows is running.
You know about using EXIT, but this program needs to be
executed from another shell that also employs the exit
command. Further, you need to echo a message to the user
if Windows is running. Well, you would take windows out
of the path statement, or move it to the end of the statement,
and insure that the following is in a path that occurs before
the windows......


@echo off
cls
prompt Type EXIT to return to Windows!$_$P$G
C:\WINDOWS\WIN %1 %2
prompt $P$G
cls


You can test if the variable windir exists:

        if '%windir%==' echo Not in Windows!
        if not '%windir%==' echo Windows running!


@echo off
cls
prompt Type EXIT to return to Windows!$_$P$G
C:\WINDOWS\WIN %1 %2
prompt $P$G
cls

Did you know you can do this with "set winpmt="?  That will
accomplish the same thing, except you don't need a batch file
to load win.

I use a simple utility called ISWIN (look for it on your favorite
BBS). When run in the batch file it returns an errorlevel that you
can test for and branch your batch file accordingly. Simple, easy
to use..

If you don't mind using a third party program, try out this
little number that I just whipped together for you:

 --- CUT ---
n iswin.com
e 0100 B8 80 46 CD 2F 3D 00 00 75 05 B0 01 EB 15 90 B8 00 16 CD 2F
e 0114 3C 00 74 09 3C 80 74 05 B0 01 EB 03 90 B0 00 B4 4C CD 21
rcx
0027
w
q

 --- CUT ---

Save the text between those two '--- CUT ---' lines to a file
called ISWIN.ASC and compile it to a .COM file like so:

    DEBUG < ISWIN.ASC.

 This will create the file ISWIN.COM which you then include in
your batch file.  This file will set ERRORLEVEL to 1 if windows is
running, or 0 if not.  Here's a demo:

 --- CUT ---
 :* Example batch file to demo ISWIN.COM

 @ECHO OFF
 ISWIN
 IF NOT ERRORLEVEL 1 GOTO NoWin
 ECHO Windows is currently running.
 GOTO EndIt
 :NoWin
 ECHO Windows is *NOT* running.
 :Endit

 --- CUT ---

Interestingly enough, one of the windows
magazines I read, had a batch file for this sort of thing, that
set a environmental variable of something like set W=Y, and the
batch file looked for this variable if you were shelled out of
Windows to Dos, and tried to enter dos by typing WIN again.
Wonder why they just didn't have the batch file search for the
WINDIR variable.

One other way would be to pipe the output of MEM/C to FIND WIN. 
Again, try before you rely.

I assume that you mean to test for the presence of MS Windows
being "loaded" as apposed to a program running. For that purpose
there is the environmental variable "windir" which identifies
which directory the MS Windows program resides.  It only exists
when MS Windows has been loaded.  You would test for it as follows:

if "%windir%"=="C:\windows" [insert a command here]

Note that the correct case is important.  After loading MS
Windows, you can type "SET" at the DOS prompt to find the
correct directory and the exact case usage of "windir".

Exactly what were you referring to about knowing about EXIT usage?
Were you eluding to the fact that when your attempt to exit MS
Windows, open DOS programs are check for and identified as
running, inhibiting the closure of MS Windows.

I see I was a bit vague there.  Let me better explain.  First,
something you already know (for those that may not). When you
place something like %EVAR% into a batch file, DOS replaces all
occurrences of %EVAR% with the contents of the respective named
environment variable. So, if you have something like 'HOMEDIR=C:\FINN' in
your environment, then the batch file command 'CD %HOMEDIR%' is
translated to 'CD C:\FINN'.  If DOS cannot find an environmental variable
of that name, then it simply replaces it with nothing. (eg, if
HOMEDIR was not defined, then 'CD %HOMEDIR%' would just become 'CD '.)

Now, for the new stuff (maybe!).  DOS is CASE SENSITIVE when it
compares things (like environment variables, filenames, etc).
AND it turns everything it processes from command lines and batch
files into UPPER CASE (other that ECHO's and the like).  Therefore,
the line in your batch file:

 IF '%windir%==' echo Not in windows!

   becomes

 IF '%WINDIR%==' ECHO Not in windows!

Notice how the WINDIR environment variable *NAME* (not contents!)
has been converted to UPPER CASE there?  Now DOS searches for the
occurrence of *UPPER CASE* environment variable called WINDIR.

Do a SET from a DOS window and look at your environment
variables. The 'windir' variable is in lower case.  DOS,
though, is looking for it in UPPER CASE.  In DOS, upper
case 'WINDIR' is not the same as lower case 'windir'
(remember, COMMAND.COM is CASE sensitive!), so it
 replaces %WINDIR% with nothing.  As a result your line is
translated to:

 IF '==' ECHO Not in windows!

 every time!

Questions?
When you have registered your Run Batch Run Book you may get
support for your batch problems by sending email to the address
below.

         *** Finn Roaas, Oslo, Norway, internet: froaas@online.no ***

Now, another method that comes to mind is to pipe a SET command
to FIND end search for "windir":

        SET | FIND "windir" > temp.fil

Next, one could use COPY to determine if the file is zero length.
Another way would be to pipe the output to a batch file, CALL
that file, then run the test as before (DOS will have set WINDIR from the
temporary batch file).  And, as I mentioned in another message, one could
search the output of MEM/C.


         if '%windir%==' echo Not in Windows!
         if not '%windir%==' echo Windows running!

Unless you are running NDOS/4DOS, this won't work, though. If you are
using NDOS/4DOS, be aware that you will be taking chances if you need
to run it on other machines!  Also, take a look at the little
ISWIN.COM which will do the job nicely.


Chapter 18: Invisible cursor
============================

Is there an ANSI.SYS prompt to make the cursor invisible?
If you do not mind the cursor blinking just set the prompt to
prompt $H. This is the 'backspace' command for the prompt,
so it overwrites the C> default. If you DO mind the blinking
cursor you can use ansi to color the foreground and background
the same as your normal background color.


Chapter 19: Numbered repeats in batch files
============================================

I have the following batch file to print labels...
LABEL.BAT
=========

:LOOP
COPY D.TXT lpt1
GOTO LOOP

and the file 'D." is

D.TXT
=====
Finn Roaas
Ole Reistads vei 39
N-1068 Oslo
NORWAY

Now, the batch file works perfectly, but with my printer
having a buffer, I'm not sure how many labels I'm gonna get.
If I don't press CTRL-BRK, I'll blow up the printer or it'll
go till we're all dead. How do I get the batch file above to
ask for a number to print, then print that many and quit?

There are a couple of ways:
1. I can get a shareware program called GET which does
arithmetic within a batch.

2. I can try modifying and incorporating the following batch
files:

CHANGEJ.BAT
===========

Rem changej.bat
@echo off
REM Calling is done via:
REM CALL CHANGEJ 0 U  (increase)
REM CALL CHANGEJ 9 U  (decrease)
REM Variables H, T, U must be
REM initialized to single digits.
set X=%2
if %X%==U set O=%U%
if %X%==T set O=%T%
if %X%==H set O=%H%
set S=P
if %1==9 set S=M
goto %S%%O%
:P0
:M2
set V=1
goto Y
:P1
:M3
set V=2
goto Y
:P2
:M4
set V=3
goto Y
:P3
:M5
set V=4
goto Y
:P4
:M6
set V=5
goto Y
:P5
:M7
set V=6
goto Y
:P6
:M8
set V=7
goto Y
:P7
:M9
set V=8
goto Y
:P8
:M0
set V=9
goto Y
:P9
:M1
set V=0
:Y
set %X%=%V%
if "%X%"=="U" if %U%==%1 CALL changej %1 T
if "%X%"=="T" if %T%==%1 CALL changej %1 H
set J=%H%%T%%U%
for %%v in (N O S X) DO set %%v=

CNT.BAT
=======

REM Cnt.bat
@echo off
REM   CNT.bat to demonstrate
REM      CHANGEJ.bat
REM   =========================
for %%v in (U T H) DO set %%v=0
cls
echo This routine counts from 1 to
echo 12 and then backwards from 12
echo to 1. This is achieved using
echo DOS statements only. It sets
echo a variable J which may be used
echo for stack-handling. The range
echo of J is 000 through 999, but can
echo be enlarged easily.
echo.
echo Hit any key to go on ...
pause >nul
cls
:INCR
CALL changej 0 U
echo %J%
if not %J%==012 goto INCR
:DECR
CALL changej 9 U
echo %J%
if not %J%==001 goto DECR
:Z
for %%v in (U T H J) DO set %%v=

Neither of the above .bat files are mine. I picked them up some
time ago and unfortunately did not record the name of the author.

If you want plain dos and you don't want too many copies, or you
are prepared to execute the batch file several times, this would
do the job quick and dirty. Place the number of arguments on the
line (any character will do) for each time you want it executed.
Put 20 on the line, execute it, do an f3 to recopy the line, and
you got 40 labels.  Not pretty, but if you want something quick,
that will do it.

X.BAT
=====

@echo off
:loop
COPY D.TXT lpt1
GOTO LOOP
shift
if not '%1'=='' goto loop

Try this file I wrote called COUNT.BAT. It avoids having to use
any disk access and can easily be expanded out to whatever number
of digits you need to use. Simply pass the number of times to loop
as a command line variable.

COUNT.BAT
=========

@echo off
Rem Use this file as a basis for counting functions
Rem COUNT.BAT accepts variable %1 as the number of times to loop

Rem Initialize Place Holder Variables
 set d1=0
 set d2=0
 set d3=0

Rem Start the incrementing process
:incr
 if %count% == %1 goto incr_exit
 if %d1%%d2% == 00 goto 1digit
 if %d1%     == 0  goto 2digit
 set count=%d1%%d2%%d3%
 goto do

:1digit
 set count=%d3%
 goto do

:2digit
 set count=%d2%%d3%
 goto do

Rem Functions,programs, etc. to be looped %1 number of times
:do
 echo %count%

Rem Increment the 1s digit.  When it reaches ten, move on the 10s
increment
:incr_1
 if %d3% == 9 goto incr_10
 if %d3% == 8 set d3=9
 if %d3% == 7 set d3=8
 if %d3% == 6 set d3=7
 if %d3% == 5 set d3=6
 if %d3% == 4 set d3=5
 if %d3% == 3 set d3=4
 if %d3% == 2 set d3=3
 if %d3% == 1 set d3=2
 if %d3% == 0 set d3=1
 goto incr

Rem Reset 1s digit. Increment the 10s digit. When it reaches 100, move on
Rem to 100s increment
:incr_10
 set d3=0
 if %d2% == 9 goto incr_100
 if %d2% == 8 set d2=9
 if %d2% == 7 set d2=8
 if %d2% == 6 set d2=7
 if %d2% == 5 set d2=6
 if %d2% == 4 set d2=5
 if %d2% == 3 set d2=4
 if %d2% == 2 set d2=3
 if %d2% == 1 set d2=2
 if %d2% == 0 set d2=1
 goto incr

Rem Reset 10s digit. Increment the 100s digit.  When it reaches 1000, let
Rem the user know the counter is beyond capacity
:incr_100
 set d2=0
 if %d1% == 9 goto :incr_outofrange
 if %d1% == 8 set d1=9
 if %d1% == 7 set d1=8
 if %d1% == 6 set d1=7
 if %d1% == 5 set d1=6
 if %d1% == 4 set d1=5
 if %d1% == 3 set d1=4
 if %d1% == 2 set d1=3
 if %d1% == 1 set d1=2
 if %d1% == 0 set d1=1


 goto incr

Rem Let user know the file has looped beyond it's capacity
:incr_outofrange
 echo Count has gone beyond 999!
 beep

Rem Continue normal batch execution at this point
:incr_exit


Chapter 20: How you can write batch files that will execute
            certain commands based on the time of day?
===========================================================

EXAMPLE .....some kind of "IF, ELSE" condition such as if the
time of day is 3pm then xxx will be executed.

I found the following debug script which creates a 10 byte executable
called HOUR.COM. When you run HOUR.COM it returns an errorlevel that is
the hour number in the 24 hour clock (11pm=23, etc.). You can then use
the errorlevel to control your batch file.

Extract the following between, but not including the lines to an ASCII
editor and save as HOUR.SCR in the directory in which you want the
HOUR.COM program to exist. Then at the command line for that directory
run debug < hour.scr to create the hour.com file.

HOUR.SCR
========

 N HOUR.COM
 E 0100 B4 2C CD 21 88 E8 B4 4C CD 21
 RCX
 000A
 W
 Q


Look at the documentation for the GET H command in Bob Stephan's
BATch enhancer, GET.EXE. Look for GET25.ZIP on a BBS near you.
There are third-party utilities that return errorlevels based on the
time of day. For example, Bob Stephan's GET can return an errorlevel and
environment string based on the hour, minute or second:

GETCURRE.BAT
============

rem Loop until 3:00 pm
:Loop
rem Get the current hour
get h 16
if not errorlevel 15 goto Loop
rem This will execute at or shortly after 3:00pm (more or less)
:MinLoop
get h 32
if not errorlevel 15 goto MinLoop
rem This will execute at 3:15pm +/- a second or so

You could toss together a "poor man's" version of the H subcommand of
GET by using the following DEBUG script, which produces a small COM file
(473 bytes) built around the DOS Int 21/2Ch function:

GETTIME.SCR
===========

E165"GETTIME.COM" 0
E200"dTJ.BcEJn3qNZd165J2JIZIH3/mK6lLHwBJLU.06rVKNmJK18Y.GUo16GJ4Rp"
E23D"7bPn/mMp7bQZt4RUUqPp756VB56Z7bQj75PZNLNg/06UU0AisWAnYG18YEHUo"
E27A"16GJ4Rp7bPn/mMp7bQZt4RUoKOiJ5RZ/GMn/GNm7rPmlKNqJ4PUU0AisGBtYG"
E2B7"18YkIUo16GJ4Rp7bPn/mMp7bQZt4RUALNXxaPY/GMn/GNm7rPmlKNqJ4PUU0A"
E2F4"isGBtYG18E3OZ/0NZNKMpl4RUw4QoZqPi/GOn/0GioU08QIFIFJGBJ26q3X9k"
E331".16L7LOoFLNi/GAm.mHXFrPWJaQU2HCtE16GxaMZ75RU6Y9UA2PV7rOUkXQj7"
E36E"KNmFb9XlKMmh4Edt4NttmMjpaDBc.FjtKMoJ4NUErPU.LRWlKOX/0NjpKMdta"
E3AB"9Bc.78IYQmxaQgJaRZl46q34PpJ46dB56YE99B50g6/cD.0..oJ.c00.7Tn1G"
E3E8"pJ.Wcbi4.kHHpJ.W6bS2.knIpJUW4bC0.cv./USF..vzuGY.cr1.mECu2..hA"
E425"pQ6HNZIEhf0.s9..c9..Qzw6GNn0MID..ERlHf.8G7n0s2U01HnVAcz.ILwMd"
E462"ZLPBA.......3h7oQ6MBA"
E100 B8 0 3C BA 65 1 33 C9 CD "!rC" BE 0 2 50 BD D9 1 55 BF 88 90
E117 "W3" DB B1 FA 8A F0 80 C1 6 32 E4 AC "<9v" 8 "<Zv" 2 2C 6 2C
E12F 7 2C 2E E3 E8 D3 E0 A C6 AA 2 D8 92 "IIMu" E0 80 FB 3D 75 9 5A
E147 59 5B B4 40 CD 21 73 7 B4 9 BA 58 1 CD 21 CD 20 7 "Error!$"
G
Q

Here's how you could use GETTIME in a batch file:

GETTIME1.BAT
============

rem Perform task after 12:34:56 pm
:Hour
gettime h
if not errorlevel 12 goto Hour
:Min
gettime m
if not errorlevel 34 goto Min
:Sec
gettime s
if not errorlevel 56 goto Min
rem Do task here at 12:34:56--accuracy basically depends
rem on disk access speed.

GETTIME reports the errorlevel to the console; if that bothers you,
redirect STDOUT to the NUL device (gettime h > nul). Good luck!

Recently a friend of mine got a new dx2 at work and he
installed some games and other useful programs.
But his boss was a little pissed at a couple employees that seem to
be more interested in playing than actually doing their jobs.
He wanted my friend to restrict their access.

What he would like to have was a batch file that,
when it started to run a program, it first checked
the time and if it was between 6am - 5pm would give
a message that this program will not operate during
business hours. He wanted to include a password that
will allow access.

I could put passwords in or just completely keep them out but
that would be bogus. He would just like to let them know in
an interesting way not to screw up a good thing.

The simplest way I know of to do this is to create a small
file called HOUR.COM (see the same file above) from the
following debug script (this script was originally
published by Brett Glass in InfoWorld several years ago).

HOUR.SCR
========

N HOUR.COM
E100 B4 2C CD 21 88 E8 B4 4C CD 21
RCX
A
W
Q

If you put HOUR.COM in a directory on your path then you can use it
in your batch file. Hour sets an errorlevel to the current hour of the
day (with 0 for midnight and 23 for 11 pm). You can then test the
errorlevel in the next statements in your batch file, e.g.

RUNATTM.BAT
===========
hour
if errorlevel 17 goto ok
if errorlevel 6 goto nogood
:ok
<put the commands here that will run the program being asked for>
goto end
:nogood
<put the commands or message here that you want to convey>
pause
:end

The errorlevel statements test for the argument or greater. If
errorlevel 17 indicates that the time is between 5pm (17 hours in
international time) and midnight, and will branch to the ok label and
run the program. The next statement, if errorlevel 6 indicates that the
time is 6am or greater, but that statement will not be executed if the
previous statement has been executed. If the errorlevel 6 statement is
executed, then the branch will be to the nogood label and your message
will be displayed until another key is struck at which time the batch
file will end and return to where it was called. If the hour is between
0 and 5 neither errorlevel statement will be executed and the
command(s) in the ok label will be executed. Thus, all the hours you
are interested in are covered in the two errorlevel statements. In this
way a password is not necessary.

Also, a knowledgeable user would still be able to run the program
directly from a command prompt if he knew the command to run the
program. Even if you added password protection into a batch file, the
user would still have the same work around.

PC's are not secure machines.  Only baby-baby novices would
be fooled by a batch file that wouldn't allow access to a
program; nothing would prevent them from running it directly.

Personally, I'd disallow games on a business machine.

If you must, just leave the policing of the hours up to
management.  It's a simple matter of self-control on the part
of an employee, one that can be discussed at his next evaluation
if he can't stick to work during working hours.  Let the employee
know that's the deal.

The time you spend disabling a program through a batch file
will be wasted; it won't take long for anyone to see through it.

             
Chapter 21: Return to directory
===============================

Using just Dos, there is an easy way to have a batch file return you to
the drive and subdirectory from which the batch file was started from.

Try the following, naming it anything except director.bat or go.bat

EXECUTE.BAT
===========

 @echo off
 echo @echo off> director.bat
 echo set olddir=%%2>> director.bat
 dir | find "Directory"> go.bat
 call go
 if exist director.bat del director.bat
 if exist go.bat del go.bat
 <do whatever else you want to do here>
 cd %olddir% <this gets you back to the original directory>
 <do anything else you want to do here>

The environment variable olddir will hold the name of the directory from
which you called this .bat file. This file works because the dir command
has a heading that includes the line "Directory of <current pathname>".
The find statement finds this line and puts it in go.bat. When you call
go.bat it executes director.bat (the y is dropped since it is the 9th
character and not read by DOS). The pathname is the second variable on
the line and is therefore read into the olddir variable with the set
statement. The %% sign is needed since DOS eliminates a %sign every time
it reads the variable.

I think most people use a 3rd party program. Here's something that
will do the trick. The following DEBUG script will create PUSHPOP.LZH.
PUSHPOP is an LHA archive containing PUSHD.COM and POPD.COM. PUSHD is
installed as a TSR in AUTOEXEC.BAT. Once installed, it creates a
directory stack, and will save the location of the directory you are
currently in when you use it to change to a new directory.
When you wish to return to where you were, POPD "pops" the
previous location from the stack and restores you to it.
In a batch file, it would work like this:

WP.BAT
======

   : WP.BAT - run WordPerfect
   @echo off
   : save current dir, and change to c:\wp
   pushd c:\wp
   wp
   : return to wherever you were when the batch file was invoked.
   popd
   : WP.BAT ends

To get PUSHPOP.LZH, type the following to a file called PUSHPOP.SCR,
and remove everything up to the "N PUSHPOP.LZH" line.  Then feed the
file to DEBUG with "DEBUG < PUSHPOP.SCR".  DEBUG will read the
information into memory and write out the PUSHPOP.LZH archive.  You will
need LHA 2.X to extract the contents.

PUSHPOP.SCR
===========

N PUSHPOP.LZH
E 0100 22 58 2D 6C 68 34 2D 48 01 00 00 CD 02 00 00 33 75 8F 0D 20 01
E 0115 09 50 55 53 48 44 2E 43 4F 4D 7A 18 4D 00 00 01 2B 5A 77 16 25
E 012A FE FF F9 4F F1 08 36 08 38 A4 47 BF C0 D8 62 3E 4E 0A C1 52 84
E 013F 5C 94 E1 6A 52 A2 08 21 17 8A 49 14 3F 7F 8E 2C 6F 0E 1E 66 2C
E 0154 36 59 C1 61 B1 44 14 76 06 60 68 A0 EB 17 CB 04 2E AB 0D 59 2B
E 0169 1F 14 F1 05 E3 A5 E2 D5 44 08 C3 62 7A C0 43 4F 56 6E 8A B2 A6
E 017E 0F 5A 4C C9 B2 B4 A5 8E 31 32 00 F2 18 41 FE FE 72 47 69 83 0A
E 0193 C9 2F 91 20 B2 ED 76 17 F9 16 BE A7 6B E0 F5 E1 03 E3 9B 63 69
E 01A8 15 FD 20 A7 C7 67 C8 32 4A 5A 85 19 56 9D 42 8D 3D B1 9B 71 61
E 01BD CF 5C A5 5A 99 87 42 89 56 9E 6A 85 DF 24 5F DF F7 A3 4F 78 D3
E 01D2 A9 52 5A 81 22 BB 69 A6 3B 2B B1 71 F0 4E 93 2E B4 C2 F0 23 BD
E 01E7 A4 11 1C 15 D4 01 63 2A 10 6B 38 FB A8 0D E8 1D 42 CC 6F 10 EA
E 01FC 3F CE 69 5F A7 15 FB CB 71 5B FB 2C C8 84 1D D4 0C 8D 61 42 0E
E 0211 7F B8 BC 5E EA 18 62 41 4C 9C 11 2A 83 1A FB 3E 0C 80 8E 22 0B
E 0226 8C 83 9F 34 66 76 5D 8B CD E6 1D 44 C9 56 45 D4 02 68 07 1D BB
E 023B C8 37 80 75 0E 38 29 8A D2 59 27 52 BC 44 83 C2 2C 30 A3 6F A1
E 0250 0B 49 62 9D 4B 6E FE 50 F2 E3 83 8B B9 B9 4F 4F 75 0A DD F8 3D
E 0265 2F FC FD AD 02 31 D4 21 BE 2D 6C 68 34 2D E3 00 00 00 74 02 00
E 027A 00 33 75 8F 0D 20 01 08 50 4F 50 44 2E 43 4F 4D AD 5C 4D 00 00
E 028F 00 C4 5B 77 B1 A5 FE DD C5 06 1A 2E 8B 44 A0 4D 17 E4 8D 6E 8B
E 02A4 59 89 21 30 48 14 07 68 11 2B A8 72 9A 24 EE D3 E7 74 E8 53 34
E 02B9 28 99 0F 03 48 D0 D4 18 31 6D EA 8C BE AA DA 28 E2 41 F1 D9 F1
E 02CE 61 A4 00 09 00 BE 38 4B 07 5D DB 35 ED 5C 0B D6 2E 5D B4 FF 50
E 02E3 73 9B 99 A9 C7 48 D7 F9 FC 5B 5E 35 00 AD 01 BB B5 33 CF DB 0E
E 02F8 D3 F7 24 4E 10 3F 07 EA 2C 87 16 20 C0 90 EC 46 45 61 85 1D E6
E 030D E0 6D BE 5B 02 29 10 89 31 45 3A 20 AC 27 0B EB 11 3A 14 18 21
E 0322 13 DF 52 47 26 D8 DB 34 B9 A8 BE 79 D9 E9 23 3D A8 12 6A 51 EC
E 0337 CE C5 EF F4 C8 C5 EF 1B 4F 1E A2 FD 51 D7 E4 59 68 CD 52 60 D0
E 034C 6A 64 CD F8 F4 75 69 91 D2 2E 87 AF 81 74 7B CB D1 35 41 E2 92
E 0361 76 6A F8 DE 6B 2F CD 69 5C DB 29 CE 4D 7F 7B AA 80 00
RCX
0273
W
Q

RETURN.BAT
==========

@echo off
rem     Creates a batch file that restores current directory.
rem     Originally written by Vernon Frazee.

if %1!==! goto Usage
if %1!==/?! goto Usage
for %%a in (s S r R) do if %1==/%%a goto %%a
goto Usage

:S ave directory
echo @prompt CD $p$_$n: > %temp%curr_dir.bat
%comspec% /c %temp%curr_dir > %temp%restdir.bat
del %temp%curr_dir.bat
goto End

:R estore directory
if exist %temp%restdir.bat goto L1
echo @echo There is no previously stored path.>%temp%restdir.bat
:L1
call %temp%restdir
del %temp%restdir.bat
goto End

:Usage
echo.
echo Usage:   SAVEDIR /S or /R
echo Saves current directory or restores last saved directory.
echo    /S   Saves current directory and drive.
echo    /R   Restores last saved directory and drive.

:End

Actually, give this a try.  It requires no other package, and it not very
disk intensive.  I've named it RETURN.BAT and I call to it in my batch files.
At the beginning of the file you use "RETURN SET", and at the end just
"RETURN".  It's pretty quick, too, as long as you do not launch it from a
directory with hundreds of files.

(You can speed it up by changing the "dir *" to "dir ###", as long you don't
mind seeing the "No File Found" error message, or by directing the temporary
files to a ram disk)

RETURN2.BAT
===========

 @echo off
 if "%1"=="set" goto setdrive
 if "%1"=="SET" goto setdrive
 %olddrive%:
 cd %olddir%
 goto end

:setdrive
 echo @echo off> volume.bat
 echo set olddrive=%%3>> volume.bat
 dir * | find "Volume in"> go.bat
 call go.bat

:setdir
 echo @echo off> director.bat
 echo set olddir=%%2>> director.bat
 dir * | find "Directory"> go.bat
 call go.bat

:clean
 if exist director.bat del director.bat
 if exist volume.bat del volume.bat
 if exist go.bat del go.bat
 goto end

:end


4DOS has the ability to do this and it is built right in.

Chapter 22: Make a log with the time and date
=============================================

Okay, I want to make a batch file to create a "boot.log" file.

My computer is always on, except for power failures.
I wanted to make a line in the autoexec.bat something
like this:

TIME > TIME.TXT
COPY BOOT.LOG+TIME.TXT BOOT.LOG

Which should make the time enter line by line for each re-boot.  But,
the "enter new time" prompt makes this not work, because it waits for an
<enter> from the keyboard to continue. Here is a program in
QuickBasic that will do this.

It will append the time and date to "BOOT.LOG" every time you run it.
Here it is:

INFO.BAS
========

DateText$ = "DATE: "                'You can change what's inside the
TimeText$ = "TIME: "                'double quotes if you want..but make
                                    'sure there's a space after it.

Dag$ = DATE$
Tid$ = TIME$
Null$ = ""

CLS

OPEN "C:\BOOT.LOG" FOR APPEND AS #1
  PRINT #1, DateText$; Dag$
  PRINT #1, TimeText$; Tid$
  PRINT #1, Null$                   'Make a blank line
CLOSE #1

SYSTEM                              'Return back to DOS when finished

   If you can't find anyone with QuickBasic 4.x that will compile this
   to an EXE for you, then you can run it through QBASIC that came with
   DOS.

   Add this line to your AUTOEXEC.BAT if you can't compile it to an EXE
   with QuickBasic 4.x...

   QBASIC /run INFO.BAS

I do something similar with a telephone dialing and logging batch file.
Here's how:

ECHO. | TIME | FIND "Current" >> BOOT.LOG

try: echo.|time > time.txt

You might want to do the same thing with date first, since I assume you
don't get a power failure every day and it will be hard to sort out the
time entries unless you also know the date.

Add the following lines to your AUTOEXEC.BAT

Echo. | Date | Find "Current" >> BOOT.LOG
Echo. | Time | Find "Current" >> BOOT.LOG

Which should make the time enter line by line for each re-boot.  But,
the "enter new time" prompt makes this not work, because it waits for an
<enter> from the keyboard to continue.

And old trick is to use the VER command to provide the needed carriage
return; e.g.,

VER|TIME > TIME.TXT

You could also include a pipe to FIND to just get the time line and
eliminate the new time line if you wanted to make it cleaner

ver|time|find "current">>boot.log

will append the time to your BOOT.LOG file. Each line will look similar
to the following:

Current time is 10:12:42.95a

You could make this as fancy as you wish--I'd suggest that you grab the
date and time as environment variables, which gives you as much
flexibility as you need when creating the log text:

GETDTVAR.BAT
============

@echo off
rem GETDTVAR.BAT  - Written 24 November 1993  Robert Clark
rem Put current day, date, time into every LOGDAY, LOGDATE and LOGTIME
rem Assumed that the TEMP evar ends in a terminal backslash.
ver | date > %temp%gd.bat
echo set logday=%%3 >current.bat
echo set logdate=%%4 >>current.bat
call %temp%gd
ver | time>%temp%gd.bat
echo set logtime=%%3 >current.bat
call %temp%gd
del %temp%gd.bat>nul
del current.bat>nul

Your AUTOEXEC.BAT would then look something like this:

AUTOEXEC.BAT
============

...
call getdtvar
echo PC booted on %logday% %logdate% at %logtime%>>boot.log
...

And your BOOT.LOG entry would look like this:

PC booted on Mon 07-18-1994 at 10:20:28.05a


@ECHO OFF
REM Records the date and time every time the PC is (re)booted
REM in the hidden file LOGTRAIL.TXT.

ECHO set currDate=%%3 %%4>CURRENT.BAT
ECHO.|date >CURRENT2.BAT
CALL CURRENT2

ECHO set currTime=%%3>CURRENT.BAT
ECHO.|time >CURRENT2.BAT
CALL CURRENT2

IF EXIST LOGTRAIL.TXT ATTRIB +h LOGTRAIL.TXT
ECHO %currDate%  %currTime%>>LOGTRAIL.TXT
ATTRIB +h LOGTRAIL.TXT

FOR %%v IN (currDate currTime) DO SET %%v=
DEL CURRENT?.BAT

ver|TIME|find /i/v "new" > time.txt

With 4DOS this makes a nice 1 line entry, with COMMAND.COM it
will be 2 lines.


Chapter 23: Books, magazines and programs about batch files
===========================================================

DOS 6 Power Tools
PCMAGAZINE Lab Notes book batch files.
DOS RESOURCE GUIDE > DOS WORLD
Concise Guide to MS-DOS BATCH FILES  Kris Jamsa
Richardson, Ronny MS DOS Batch File Programming 4th. ed.
Richardson, Ronny Dr. Batch Files Ultimate Collection
Wolvorton, Van Supercharging MS DOS, Microsoft Press

Chapter 24: Remove file comment
===============================

Some people like to remove the file_id.diz for zipped
files in a directory and add it as the comment to a zip
file of the same name (in one batch
file or call another batch file from it).

FILE_ID.BAT
===========
IF %2 == ZIP GOTO ZIP
GOTO END
:ZIP
pkzip -z %1 <file_id.diz
:END


Chapter 25: FOR in batch files
===============================
Let's look at a "FOR %%A IN (/%1)" construction.

When a list item begins with a slash, it gets processed
as two items. Thus in my tiny batch file :

FOR %%A IN (/%1) DO ECHO %%A
called as mybatch CCMAIL.SAM
I will see echoed     first:  C
                      then :  CMAIL.SAM

I want to test the first parameter of a batch file for the presence of a
file extent, and I'm going to use the presence of a period as proof.

So my batch file "really" wants to examine each character of the string
until it finds a period - in the example above, I want to stop after the
"L" and before the "S".

The logic in the loop needs to be : If I've got a period, ok, else examine
the remainder of the string.

Using {{  FOR %%A IN (/%1) DO IF "%%A"=="."  }}  won't work, because if
I'm looking at the first character (within the loop) I don't have access
to the string remainder (in order to recurs with the string remainder).
The technique breaks the string into "only" two parts.

Here's a (relatively) short batch file that will parse the drive and
path, filename, and extension. I found it a while ago, modified it a bit
and promptly forgot about it.

SPLITNAM.BAT
============

:: PURPOSE: To extract the path, filename and extension from a
::          filespecification and store the result in the environment
::          variables FDIR, FNAM and FEXT respectively.
::
:: REQUIRES: MS_DOS v6.xx    ::     SYNTAX: SPLITNAM filespecification
::           MS_DOS v3.3x
:: LIMITATIONS: Filespecification must not exceed 29 characters.
:: Did not find file path correctly
:: Removed "." from FNAM & made FIND v3.3+ mods.   ::

@echo off
for %%s in (fdir fnam fext) do set %%s=
set x=%1
if "%x%"=="" goto error
:parse string
set y=%x%
for %%s in (/%x%) do set x=%%s
for %%i in (/%y%) do if "%%i%x%"=="%y%" set y=%%i

:: MS_DOS v3.3x version
echo %x%%y%|find "\">tmp
copy tmp+,,>nul
if not exist tmp if "%fext%"=="" if not %y%==. set fnam=%fnam%%y%
if exist tmp if not %y%==. if "%fnam%"=="" set fdir=%fdir%%y%

:: MS_DOS v6.xx version
:: echo %x%%y%|find "\">nul
:: if errorlevel 1 if "%fext%"=="" if not %y%==. set fnam=%fnam%%y%
:: if not errorlevel 1 if not %y%==. if "%fnam%"=="" set fdir=%fdir%%y%

if %y%==. set fext=%x%
if %fext%!==! goto parse
echo File path:         "%fdir%
echo File name:         "%fnam%
echo File extension:    "%fext%
:error message
if "%x%"=="" echo Missing parameter or out of environment space!
for %%s in (x y) do set %%s=


If you run MS-DOS v6.xx, clip out the MS_DOS v3.3x section and uncomment
the MS_DOS v6.xx code; you'll save a couple hundred milliseconds and
your hard drive will thank you.

TESTCHAR.BAT
============

  REM TESTCHAR.BAT
  @ECHO OFF
  ::      (Based on PcMagazine Nov 8 1994 p287)
  ::      Given a string of characters as its only parameter
  ::              Jump to 80Found if one of them matches a period.
  ::      This batch file determines if a file extent was supplied!
  ::
  SET c=%2
  IF "%2"=="" set c=.
  IF "%1"==""      GOTO 90ended
  IF "%1"=="%c%"     GOTO 80found
  FOR %%a IN (/%1) DO IF NOT %%a==%1 CALL %0 %%a %c%
  GOTO 90ended
  :80found
  set x=
  goto 99exit
  :90ended
  set c=
  :99exit
  REM End of TESTCHAR.BAT

I wanted to take a diskette with multiple .zip files,
and be able to type "install", create a main directory on C:,
then create subdirectories by the zip file names
and unzip the files in each of their respective subdirectories.

I ended up with help from someone in Miami, and with 2 batch files.
Here's what I have:


rocknroll.bat ("Install" file launched from A:)
C:
CD\
MD main
A:
for %%f in (*.zip) do call A:\mdbat.bat %%f


mdbat.bat (2nd batch file)
C:
cd main
md %1
A:\pkunzip a:\%1 C:\main\%1


These work perfect.  There can be any .zip file on A: and it will create
a subdirectory by that file name.  The only confusing thing is the
subdirectory has the zip file name.  The tree would look like this:

C:\main\test01.zip\(All files unziped from test01.zip)
             |
         Directory
            Name


A bit crude, but it works!


@echo off
mkdir c:\main
for %x in (a:\*.zip) do mkdir c:\main\%x
for %x in (a:\*.zip) do copy a:\%x c:\main\%x%\
for %x in (a:\*.zip) do c:\util\zippers\pkunzip -d c:\main\%x%\%x
for %x in (a:\*.zip) do del c:\main\%x%\%x


What I didn't explain is that I have over 1,000 .zip files.

if [...] possible to write one batch file that will recognize the Zip
file name, make a main directory, make a directory(s) by the zip file(s)
name(s), and unzipp each file to it's respective directory.

Create this 17-line batch file C:\MAIN\RUN.BAT and execute by typing RUN

if not "%1" == "" goto sub
echo. > c:ww1.bat
:loop
pause insert next floppy or ^C to terminate
b:
for %%r in (*.zip) do expr "call run %%r" : \(.*\).ZIP >> c:ww1.bat
c:
call ww1.bat
del ww1.bat
goto loop

:sub
mkdir c:\main\%1
cd c:\main\%1
copy b:%1.zip c:
pkunzip -d %1
del c:\main\%1\%1.zip
cd c:\main

When entering the loop there is a pause for you to insert each new floppy.

The Unix style utility EXPR is not part of DOS, so ftp it from simtel:

ftp oak.oakland.edu /SimTel/msdos/calculat/
expr.zip      12380  901222  Unix-like command line expression evaluator
expr_vi2.zip   4497  940918  Tiny Unix 'expr'-like integer expr evaluator

 
Chapter 26: Ansi codes in batch file
====================================

Try changing colors with the ECHO command rather the PROMPT
command. To that end I wrote a small batch file to try.  In
addition I used the DOS 6.0/6.2 CHOICE command to simplify
things.

NOTE: Replace the '$Esc' with an Escape character, Char 027.

TESTMENU.BAT
============

:: TESTMENU.BAT
@ echo off
echo $Esc[0;34;47m
cls
echo  Test Menu
echo.
echo  1 = Option 1
echo  2 = Option 2
echo  3 = Option 3
echo  4 = Option 4
echo  X = Option 5
echo.
choice /c:1234x /n Your choice?
  if errorlevel 5 goto 5
  if errorlevel 4 goto 4
  if errorlevel 3 goto 3
  if errorlevel 2 goto 2
  if errorlevel 1 goto 1

:1
  echo $Esc[1;33;44m
  cls
  echo You selected Option 1 - Bright Yellow on Blue
  goto X

:2
  echo $Esc[1;37;44m
  cls
  echo You selected Option 2 - Bright White on Blue
  goto X

:3
  echo $Esc[1;36;44m
  cls
  echo You selected Option 3 - Bright Cyan on Blue
  goto X

:4
  echo $Esc[1;32;44m
  cls
  echo You selected Option 4 - Bright Green on Blue
  goto X

:5
  cls
  echo You selected Option 5 - No color change

:X
  echo.


Is it possible to make a batch file or DEBUG code to detect if ANSI.SYS is
loaded into memory? Well, let us view the following:

  file 1 C:\batches\br.bat


  @Echo off
  cls
  set DOSSESION=OK
  C:\batches\bprmmen\bprmen.bat

  file 2 C:\batches\bprmmen\bprmen.bat


  @Echo off
  C:\
     ^^^^ Replace with:

     C:

  cd\batches\bprmmen
  cls
  prompt $e[47;34m
     ^^^^^^^^^^^^^
     When you say prompt, you are actually changing the DOS ENVIRONMENT,
     a less permanent way to do it is:

     Echo <esc>[47;34m
           ^^^  ASCII char #27

  Echo  Welcome to the BBC Backup and Restore Main Menu System.
  Echo.
  Echo  You can:
  Echo.
  Echo  1. Go to the BBC Backup Menu System,
  Echo  2. Go to the BBC Restore Menu System,
  Echo  3. Set the current drive at C:, then exit this system, or
  Echo  4. Set the current drive at D:, then exit this system.
  Echo.
       Prompt *$h Enter the number of your choice.:
       if %DOSSESION%==OK goto dos
       goto end
       :dos
       if %DOSSESION%==OK set DOSSESION=NOTOK
       c:\dos\command.com
       :end

      Again we are misusing the prompt command. What we should do is have
      a command line controlled file.
      
The problem is that are trying to use the PROMPT command for
everything, from changing the DOS PROMPT, to changing the COLOR,
to using it as a PROMPT for questions. Here are some ideas:

Instead of using prompt $e try using echo <esc> it is much
safer and runs faster.

PC Magazine's BATCHMAN.COM has an option which can check to see
if ANSI.SYS is loaded, January 30, 1990.

And, of course, if you have 4DOS you can check the %_ansi built-in
variable. If it returns 1 you've got ANSI.

COLROCHT.BAT
============

@echo off
echo `[0m`[2J`[30;47m`[K`[1;10HA N S I   C o l o r   C h a r t`[s
echo `[u  þ  Courtesy of Sleepy Hollow
echo `[0m`[5CNote: An ESC character (not shown here)`[s
echo `[u must precede the left bracket
echo `[30;47m`[4;33H Normal Colors `[0m
for %%x in (0 1 2 3 4 5 6 7) do echo `[5;%%x1H`[40;3%%xm [0;3%%x;40m
for %%x in (0 1 2 3 4 5 6 7) do echo `[6;%%x1H`[41;3%%xm [0;3%%x;41m
for %%x in (0 1 2 3 4 5 6 7) do echo `[7;%%x1H`[42;3%%xm [0;3%%x;42m
for %%x in (0 1 2 3 4 5 6 7) do echo `[8;%%x1H`[43;3%%xm [0;3%%x;43m
for %%x in (0 1 2 3 4 5 6 7) do echo `[9;%%x1H`[44;3%%xm [0;3%%x;44m
for %%x in (0 1 2 3 4 5 6 7) do echo `[10;%%x1H`[45;3%%xm [0;3%%x;45m
for %%x in (0 1 2 3 4 5 6 7) do echo `[11;%%x1H`[46;3%%xm [0;3%%x;46m
for %%x in (0 1 2 3 4 5 6 7) do echo `[12;%%x1H`[47;3%%xm [0;3%%x;47m
echo `[30;47m`[14;33H Bright Colors `[1m
for %%x in (0 1 2 3 4 5 6 7) do echo `[15;%%x1H`[40;3%%xm [1;3%%x;40m
for %%x in (0 1 2 3 4 5 6 7) do echo `[16;%%x1H`[41;3%%xm [1;3%%x;41m
for %%x in (0 1 2 3 4 5 6 7) do echo `[17;%%x1H`[42;3%%xm [1;3%%x;42m
for %%x in (0 1 2 3 4 5 6 7) do echo `[18;%%x1H`[43;3%%xm [1;3%%x;43m
for %%x in (0 1 2 3 4 5 6 7) do echo `[19;%%x1H`[44;3%%xm [1;3%%x;44m
for %%x in (0 1 2 3 4 5 6 7) do echo `[20;%%x1H`[45;3%%xm [1;3%%x;45m
for %%x in (0 1 2 3 4 5 6 7) do echo `[21;%%x1H`[46;3%%xm [1;3%%x;46m
for %%x in (0 1 2 3 4 5 6 7) do echo `[22;%%x1H`[47;3%%xm [1;3%%x;47m
echo `[22H`[0;37;40m
pause>nul

The "for in" batch file syntax is a little hairy at first - it's an
optimization. Let's translate one line for you:

for %%x in (0 1 2 3 4 5 6 7) do echo `[5;%%x1H`[40;3%%xm [0;3%%x;40m

.... in long format ...:

      echo `[5;01H`[40;30m [0;30;40m
      echo `[5;11H`[40;31m [0;31;40m
      echo `[5;21H`[40;32m [0;32;40m
      echo `[5;31H`[40;33m [0;33;40m
      echo `[5;41H`[40;34m [0;34;40m
      echo `[5;51H`[40;35m [0;35;40m
      echo `[5;61H`[40;36m [0;36;40m
      echo `[5;71H`[40;37m [0;37;40m
               ^        ^      ^
               |        |      |
Formerly:     %%x      %%x    %%x


See? For each "%%x" in the statement "`[5;%%x1H`[40;3%%xm [0;3%%x;40m"
we've replaced the "%%x" with the value "in" (0 1 2 3 4 5 6 7). This is
what happens during run time of the batch file.

You can see how much longer this post would have been if each line was
expanded this way!

One last note:  You should replace all the " ` " characters with the
escape character (ASCII 27) before running. With a good editor (like
QEdit) this can be accomplished in a single "find & replace" command.

Is it possible to make a batch file or DEBUG code to detect if
ANSI.SYS is loaded into memory?

I think you can. You may use...

CHKANSI.BAT
===========

MEM/C > TEMP.TMP
FIND "ANSI" TEMP.TMP

More info and examples on this can be found in this chapter
in a new version of the book.

For a little more flexible method try this :

@echo off
mem /m ansi|find "not currently" /i > nul
if errorlevel 1 goto ansi loaded
:noansi
echo ANSI.SYS is not loaded.
rem {you can also add any code you want executed
rem to accommodate ANSI not being loaded}
goto quit
:ansiloaded
echo ANSI.SYS is loaded.
rem --the rest of your batch file--
:quit

Sometime ago I needed a small Util that will
restore the normal ANSI settings to my computer after a program.
How about the one that is built in with DOS?
MODE CO80  seems to do wonders for me...Except, it doesn't work
in all cases. So, there are other solutions.
Here is a script for a small utility that may help.

CLEAR.SCR
=========

n clear.com
e 0100  B4 12 B3 10 CD 10 B8 40 00 8E D8 B8 00 06 B7 1F
e 0110  29 C9 B6 18 80 FB 10 74 04 8A 36 84 00 8A 16 4A
e 0120  00 FE CA CD 10 B4 02 8A 3E 62 00 29 D2 CD 10 C3
rcx
0030
w
q

:: Clears screen to bright white on blue.
:: ANSI.SYS not required.

To create CLEAR.COM type the script in your favourite editor
and save it as CLEAR.SCR. Then at the DOS prompt type:
DEBUG < CLEAR.SCR and press Enter.  Note: The blank line
after "q" is necessary.

If you wish, you can change the colors. To do so choose your
hex color code, nn, from the list.  For example, the default
color scheme is 1F, blue background and bright white text.

   Color           Background  Foreground
   -----           ----------  ----------
   Black             0           0
   Blue              1           1
   Green             2           2
   Cyan              3           3
   Red               4           4
   Magenta           5           6
   White             7           7

   Gray              -           8
   Bright Blue       -           9
   Bright Green      -           A
   Bright Cyan       -           B
   Bright Red        -           C
   Bright Magenta    -           D
   Yellow            -           E
   Bright White      -           F

Then in the directory where CLEAR.COM is stored enter:

DEBUG CLEAR.COM
E 010F nn
W
Q


Is it possible to display (Echo) the date and time in a batch file
without having respond to it?

Such as in a heading line, etc..  Is there a function to do this?
You might be interested in this nayways.
Add ANSI.SYS to your config.sys (if it's not already there), and
use this for your prompt:

Set Prompt=$e[s$e[1;1H$e[K$e[34;40;1m$e[32mToday is $e[35m$d $e[32m& the time is $e[35m$t$h$h$h$h$h$h$e[32m.$e[34m$e[u$e[37m$p$g

All of this goes on one line, and you have to put it in your config.sys,
and take the PROMPT command out of your autoexec.bat. It will display a header
containing the date and time whenever you're at the DOS prompt.

ANSI RESTORATION
------------------------------------------------------------------------

On my computer some programs seem to mess up the colors
and then when I load other stuff, the colors are messed up and my
comm-program messes up the internal color stuff so that i have to
re-boot and then re-install the color setups for it.

But fortunately I have found a small com file fm PCMag called C.COM
which does two things, resets my default colors (like grey on blue)
and clears the screen. Just make the last line of the batch file,
that calls any of these color-messer-uppers, C and you shouldn't have
that problem again. Make sure it's in your path.

NC.COM
======
---------------< cut here >-
 NC.COM
 E100"+"C0 1E"P"B8 3 0 CD 10 B8 0 6 B9 0 0 BA"P "B7 17 CD 10 B4 2 BA
 E119 0 0 B7 0 CD 10 B0 3 BA D9 3 EE CB 1A
 RCX
 27
 W
 Q HEXBUG Version 1.02 by Chad Wagner
---------------< cut here >-

Just save this msg to c.scr and invoke DEBUG<C.SCR. Ig you get any
error messages, just Ignore them. Then deploy c.com in a dir in your
path, and follow the above advice.

Here's also a batchfile that does very much the same. It resets the
ANSI attributes and clears the screen, just like the script.

CLEAR.BAT
=========
----clear.bat----
@echo off
echo {esc}[0m
cls
-----------------

Of course, {esc} is ASCII 27...  Should work.
                                

Chapter 27: About errorlevel
============================

I'm using a simple key reading program to get Y or N and return an
errorlevel.
For example:
@echo off
echo Choose Y or N
batchman getkey "YN"
if errorlevel 1 echo YES
if errorlevel 2 echo NO
pause


I know the right errorlevel values are returned but if "N" is pressed
YES and NO are both echo'd.
How come?

Because "IF ERRORLEVEL 1" means "if the return code is 1 or higher".
If your return code is 2, then both of the above lines are true, since
2 is greater than or equal to both 1 and 2.  So both ECHO YES and ECHO
NO are executed.  What you want to do is use a GOTO command to make
DOS execute only the lines you want to execute.  Something like:
IF ERRORLEVEL 2 GOTO TWO
IF ERRORLEVEL 1 GOTO ONE
GOTO ZERO
:TWO
ECHO NO
GOTO END
:ONE
ECHO YES
GOTO END
:ZERO
WHATEVER
:END
Always, always, always remember that in a situation like this, you
must test for the higher return codes first. If you put
IF ERRORLEVEL 1 GOTO ONE first, then the batch file would ALWAYS
"GOTO ONE" since the return code is ALWAYS (unless your program
does return a 0 under some conditions) 1 or higher, so that
command would ALWAYS be interpreted as "true".  DOS would
never even see an IF ERRORLEVEL 2 command if it came after
the IF ERRORLEVEL 1 command. You need to always write those
tests for errorlevel descending.

 if errorlevel 2 echo YES
 if errorlevel 1 echo NO

Errorlevels need to be checked from high to low not vice versa. An
errorlevel number is really equal to or greater than the number shown.
Also, you need to do something that will skip the next errorlevel check
by using a goto label command on the error level line. Your file should
read something like this:

if errorlevel 2 goto two
if errorlevel 1 goto one
:two
echo NO
goto end
:one
echo YES
goto end
:end
pause


A bad copy doesn't change the errorlevel in 6.22.
COPY is an internal command and as such does not return any kind of
errorlevel (and never has).  Note that 4DOS does provide a way to test
the errorlevel of an internal command (while this may not be useful to
you, it may keep someone else from telling me that 4DOS is better than
sliced bread).

XCOPY does return an errorlevel (see the DOS HELP on XCOPY for its
errorlevels and what they mean).


Chapter 28: Rebooting from a batch file
=======================================

A DOS statement that can be typed at
the prompt (or put into a batch file)
that will re-boot the system:

                echo G=FFFF:0 | debug > nul



 Method 1: echo HPS >%temp%reboot.com
           %temp%reboot

 Note that the " " character is ASCII 203.  In order to avoid having
 multiple copies of REBOOT.COM lying around, I suggest that the TEMP evar
 be set to a RAMDisk (preferably) or at least to a junk directory.

 Use this method if you're not certain that REBOOT.COM already exists in
 the current directory or path.

 If anyone's interested, here's the disassembly of the "HPS " string:

 xxxx:0100 48            DEC     AX  ; AX=FFFF                  "H"
 xxxx:0101 50            PUSH    AX  ; Save FFFF to stack       "P"
 xxxx:0102 53            PUSH    BX  ; Save 0000 to stack       "S"
 xxxx:0103 CB            RETF        ; RETF pops two bytes      " "
                                     ; from stack and resumes
                                     ; execution at that address.
                                     ; So, this RETF passes control
                                     ; to FFFF:0000, which initiates
                                     ; a reboot.

 Method 2: echo g=ffff:0|debug

 Pretty much the same thing, but eliminates a lot of the overhead.  Note
 that the only thing written to disk will be the temp file created from
 the pipe. There will be no .COM file created.  DEBUG.EXE must be in the
 path or current directory.  Again, if you have a TEMP evar set, the temp
 file will be written to that directory rather than to the current one.

 The nice thing about this method is that you don't need to create or use
 an external REBOOT.COM utility.

 Method 3: reboot

 Yet another variation on a theme. This particular REBOOT.COM will always
 perform a warm boot.  By changing the word at offset 0109 to 0000, you
 can force a cold boot.  Use the following DEBUG script to create
 REBOOT.COM, which you should then place in your path:

REBOOT.SCR
==========
 n reboot.com
 a100
 mov dx,0040               ; Set up 40:072 then jump to boot
 mov ds,dx
 mov word ptr [0072],1234  ; Use 1234h for warm boot; 0000h for cold
 jmp ffff:0                ; Jump to boot routine

 rcx
 10
 w
 q

 Note that several shareware BATch enhancement utilities such as GET or
 BATCHMAN provide command line switches that allow you to reboot a
 computer under BATch file control.

 None of the reboot methods I've outlined will protect you from a staged
 write disk cache--to be truly robust, these programs would have to flush
 the cache before proceeding.  Better to do that yourself _before_
 executing REBOOT.COM.  For SmartDrv, the syntax to flush the cache is
 SMARTDRV /C.

   You might try the following:

    1) Exit from all your programs (nothing running in the background)
    2) Make sure your disk cache has dumped everything to disk.  If you are
       using smartdrv the command is smartdrv /c
    3) Then typing:

         echo g=ffff:0000|debug

       will cause most PC's to do a COLD boot (restart with POST).

    If that didn't work on your particular PC, change "3)" above to:

      ECHO HPS[Alt-203]>COLDBOOT.COM
      COLDBOOT

    Note: The "[Alt-203]" means while holding down the [Alt] key type
          203 on the keys on the numeric keypad (not the keys at the
          top of the keyboard), and then release the [Alt] key. Doing
          so will produce ASCII character 203 which looks like a little
          double-line "T" character.

Suppose I'd like to set up a multi-boot disk. Suppose I want it to
regularly boot up with my normal setup.  However, every now and then,
I like to play some games that need more memory, so I have a separate
boot disk for them. I'd like to be able to hold a key down or
something and get my "game" boot up.

NORMAL AUTOEXEC.BAT:
====================
@ECHO OFF
LH /L:0;1,45504 /S C:\DOS\SMARTDRV.EXE /V
LH /L:1,16560 c:\misc\mouse
LH /L:1,3952 C:\MISC\S64DDPMS b9 s10 o15
LH /L:1,24096 MODE LPT1:,,B
LH /L:1,85536 C:\EXPLORER.4L\status\stat4l
LH /L:1,25920 STACKEY /B225/
PROMPT $e[1;33;44m(%%@dosmem[k]k) $p$g
Path C:\;C:\DOS;C:\WINDOWS;C:\XTGOLD;C:\MISC;C:\EXPLORER.4L;C:\TM
cd\
cls
SET TEMP=C:\TEMP
SET TMP=C:\TEMP

GAME AUTOEXEC.BAT:
==================
@ECHO OFF
PROMPT (boot disk) $P$G
PATH C:\;C:\DOS;C:\WINDOWS;C:\XTGOLD;C:\MISC;C:\TM
LH /L:0;1,45472 /S C:\DOS\SMARTDRV /V
LH /L:1,16560 C:\MISC\MOUSE
SET TEMP = C:\TEMP

NORMAL CONFIG.SYS
=================
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS NOMOVEXBDA
BUFFERS=4
FILES=60
DOS=UMB
LASTDRIVE=D
FCBS=4,0
DEVICEHIGH C:\DOS\ANSI.SYS
DEVICEHIGH C:\SCANW\M1904.SYS D3 I5 A2AB S7
STACKS=9,256
DOS=HIGH
SHELL=C:\4DOS.COM /P


GAME CONFIG.SYS
===============
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE 6144 RAM FRAME=E000 I=CC00-EFFF
BUFFERS=4,0
FILES=60
DOS=UMB
LASTDRIVE=E
FCBS=4,0
DOS=HIGH
STACKS = 9,256
SHELL=A:\4DOS.COM /P

Use Configuration Blocks in your config.sys & autoexec.bat.  This was
new in DOS 6.0 and is well described in the User manual/ Upgrade book.
In the DOS 6.20 on-line Help scheme, it is partially described under
the Include command.

I use a scheme I started years ago: I have a directory with sets of
config.sys & autoexec.bat files and a reboot.bat file that selects a
set, renames & copies the files into the C: root as config.sys &
autoexec.bat, and then reboots the system.

 CONFIG.SYS ....

[menu]
menuitem normal,NORMAL SYSTEM CONFIGURATION
menuitem games,GAMES SYSTEM CONFIGURATION

; you can set the menu colors to what ever you like
; 0 - 15 for foreground colors
; 0 - 7 for background colors
; I'll use bright white (15) on blue (1) for menu colors

menucolor 15,1

; set this time-out and default as you like
; I'll pause for 10 seconds then boot normal if no key is pressed

menudefault normal 10

[normal]
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS NOMOVEXBDA
BUFFERS=4
FILES=60
DOS=UMB
LASTDRIVE=D
FCBS=4,0
DEVICEHIGH C:\DOS\ANSI.SYS
DEVICEHIGH C:\SCANW\M1904.SYS D3 I5 A2AB S7
STACKS=9,256
DOS=HIGH
SHELL=C:\4DOS.COM /P

[games]
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE 6144 RAM FRAME=E000 I=CC00-EFFF
BUFFERS=4,0
FILES=60
DOS=UMB
LASTDRIVE=E
FCBS=4,0
DOS=HIGH
STACKS = 9,256
SHELL=A:\4DOS.COM /P

 Note that in config.sys a line beginning with a semicolon
 is a remark line.


 And AUTOEXEC.BAT....

@ECHO OFF

IF %config%==normal GOTO normal
IF %config%==games GOTO games

:normal
 LH /L:0;1,45504 /S C:\DOS\SMARTDRV.EXE /V
 LH /L:1,16560 c:\misc\mouse
 LH /L:1,3952 C:\MISC\S64DDPMS b9 s10 o15
 LH /L:1,24096 MODE LPT1:,,B
 LH /L:1,85536 C:\EXPLORER.4L\status\stat4l
 LH /L:1,25920 STACKEY /B225/
 PROMPT $e[1;33;44m(%%@dosmem[k]k) $p$g
 Path C:\;C:\DOS;C:\WINDOWS;C:\XTGOLD;C:\MISC;C:\EXPLORER.4L;C:\TM
 cd\
 cls
 SET TEMP=C:\TEMP
 SET TMP=C:\TEMP
 goto end

:games
 DEVICE=C:\DOS\HIMEM.SYS
 DEVICE=C:\DOS\EMM386.EXE 6144 RAM FRAME=E000 I=CC00-EFFF
 BUFFERS=4,0
 FILES=60
 DOS=UMB
 LASTDRIVE=E
 FCBS=4,0
 DOS=HIGH
 STACKS = 9,256
 SHELL=A:\4DOS.COM /P

:end

 (if you are not familiar with labels...)
 Note the goto end at the end of the normal autoexec.bat section.
 and the :end label at the end. If you add more boot setups, you
 need to have a goto end after each one (except the last) to jump
 over the ones you don't want.

CONFIG.SYS:

[Menu]
menuitem=Normal, Normal setup
menuitem=Game, Game setup
menudefault=Normal,10

[Normal]
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS NOMOVEXBDA

[Game]
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE 6144 RAM FRAME=E000 I=CC00-EFFF

[Common]
BUFFERS=4,0
FILES=60
DOS=UMB
LASTDRIVE=E
FCBS=4,0
DOS=HIGH
STACKS = 9,256
SHELL=A:\4DOS.COM /P
(end of CONFIG.SYS)


AUTOEXEC.BAT:

if "%CONFIG%" == "GAME" goto Game

@ECHO OFF
LH /L:0;1,45504 /S C:\DOS\SMARTDRV.EXE /V
LH /L:1,16560 c:\misc\mouse
LH /L:1,3952 C:\MISC\S64DDPMS b9 s10 o15
LH /L:1,24096 MODE LPT1:,,B
LH /L:1,85536 C:\EXPLORER.4L\status\stat4l
LH /L:1,25920 STACKEY /B225/
PROMPT $e[1;33;44m(%%@dosmem[k]k) $p$g
Path C:\;C:\DOS;C:\WINDOWS;C:\XTGOLD;C:\MISC;C:\EXPLORER.4L;C:\TM
cd\
cls
SET TEMP=C:\TEMP
SET TMP=C:\TEMP
goto End

:Game
@ECHO OFF
PROMPT (boot disk) $P$G
PATH C:\;C:\DOS;C:\WINDOWS;C:\XTGOLD;C:\MISC;C:\TM
LH /L:0;1,45472 /S C:\DOS\SMARTDRV /V
LH /L:1,16560 C:\MISC\MOUSE
SET TEMP = C:\TEMP

:End
(end of AUTOEXEC.BAT)

You have probably noticed that I use labels as comments in some of
my batch files? Some readers ask if there is some advantage to this
approach or if it's just a personal preferance?

I usually use either ":" or "::" instead of "REM" because there is a
definite speed advantage.


    1) Created a BATch file named X.BAT containing 10,002 lines -- yep,
       ten thousand and two.  (Had to do so so I could get back some
       realistic elapsed times. It goes
       something like this:

       @echo off
       :aardvark
       :aback
       :abacus
       :abaft
       :abandon
       [ ... ]  (9,990 lines of more of the same. (Dictionary words)).
       :dissociates
       :dissociating
       :dissolution
       :dissolve
       :dissolved
       echo Done!<beep_char>

    2) Copied X.BAT to Z.BAT and then overwrote the first four
       characters of all lines but two, with "rem ", like so:

       @echo off
       rem dvark
       rem ck
       rem cus
       rem ft
       rem ndon
       [ ... ]  (9,990 lines of more of the same)
       rem sociates
       rem sociating
       rem solution
       rem solve
       rem solved
       echo Done!<beep_char>

    3) Loaded a timing program (CLK.EXE
       then separately ran Z.BAT and X.BAT three times each (just to
       make sure I got the fastest elapsed time for both).  Results:

       Z.BAT (10,000 lines beginning with REM):  9.35 seconds
       X.BAT (10,000 lines beginning with ":"):   .23 seconds (1/4 sec!)

    As you can see, X.BAT was over 40 times faster!  Why?  Because DOS
    simply insists on reading all lines that don't begin with a ":".





Chapter 29: How to execute a batch file on a certain weekday?
=============================================================

Let's say you need to defrag and backup your hard drive ever
3 days to 7 days... is there something that'll run as either a TSR or a
a nightly event which will keep track how many days it's been since it
last ran the defragger and backup and either end itself, or running the
programs and then end every third day.

Here is a batch solution since this was setup for my system
make sure that you check the path pointers. c:\bin, and c:\temp.
Just change these directories to directories that you use.
You will also need to create a separate batch file for each
day of the week.  SUN.BAT, MON.BAT, TUE.BAT etc..

If you have dos6?  you can use "command /y /c" and watch this work.


CHECKDAT.BAT
============

@echo off
::   this file checks the system date and can be used in other batch
::   files.  This file must be called from from autoexec.bat.
::   ONCEDAY.BAT needs to find this file.

echo.|date>C:\bin\currdat.txt
if not exist c:\bin\lastdat.txt goto NEWDAY
fc c:\bin\currdat.txt c:\bin\lastdat.txt|find /i "no">nul
if errorlevel 1 goto NEWDAY
if errorlevel 0 goto SAMEDAY

:NEWDAY
copy c:\bin\currdat.txt c:\bin\lastdat.txt>nul
CALL ONCEDAY.BAT

:SAMEDAY
DEL C:\BIN\CURRDAT.TXT

ONCEDAY.BAT
===========

@echo off
::   CHECKDAT.BAT must be called from autoexec.bat
::   the next 4 lines can be used to run an event once a week

:NOTTODAY
:: put ONCEDAY commands here
call c:bin\dow.bat

DOW.BAT
=======

@echo off
::  This is DOW.BAT
C:
cd\
VER|DATE|FIND "Current" > C:\TEMP\TEMP.BAT
ECHO SET DAYNOW=%%3 > C:\TEMP\CURRENT.BAT
ECHO SET DATENOW=%%4 >> C:\TEMP\CURRENT.BAT
CD\TEMP
CALL TEMP
CD\bin
call %DAYNOW%


Chapter 30: Y/N in batch files
===============================

NO CHOICE
Batch File Tip

The addition of the CHOICE command to MS-DOS 6 makes it easy
to obtain a Y or N response from the user. Here is a way to
do it if you don't have DOS 6, or you want to create a stand-
alone batch file that works with earlier DOS versions.

Y&N.BAT
=======

@ECHO off
:: Get Y/N response using DOS 5 or less.
REM> $.tmp
ECHO Question [Y/N]?
DEL $.tmp /p>nul
IF NOT EXIST $.tmp GOTO yes
DEL $.tmp
GOTO no
:no
ECHO Response was "n" or "N".
GOTO end
:yes
ECHO Response was "y" or "Y".
::GOTO end
:end

So, how does it work? It's actually fairly simple. Line 3
creates $.tmp, a 0-byte file in the current directory. Using
the DELete command with /p in line 5 causes DOS issue a Y/N
prompt which is not seen because it is redirected to nul. The
batch file then branches according to the users response by
testing in line 6 for the existence of the temporary file.
(The line numbers are for reference only and are not to be
included when entering this batch file into your computer.)

For comparison, here is an equivalent file written using the
DOS 6 CHOICE command.

    @ECHO off
    :: Get Y/N response using DOS 6 CHOICE command.
     CHOICE "question "
     :: N=2  Y=1
     IF ERRORLEVEL 2 GOTO no
     IF ERRORLEVEL 1 GOTO yes
    :no
     ECHO Response was "n" or "N".
     GOTO end
    :yes
     ECHO Response was "y" or "Y".
     ::GOTO end
    :end

But it will only work with DOS 4.0
and later, since the DEL command didn't have a /P switch
before that. A variant of that will work back to DOS
2.0 (before that, too bad!) is to do something like:

        md yntstdir
        cd yntstdir
        rem > $.tmp
        echo question [Y/N]
        del *.* > nul
        if exist $.tmp goto no
        cd ..
        rd yntstdir
        ::do whatever for a Y response
        goto end
        :no
        del $.tmp > nul
        cd ..
        rd yntstdir
        ::do whatever for a N response
        :end

Same idea. Not as elegant (if batch programming like
this can be called elegant) but whatever it works...

I took the beep out of CHOICE.COM. Inside there is a notice that CHOICE
requires MS-DOS version 4.0 or later. Maybe the best bet for 4.0 users
is to get a copy of CHOICE.

Chapter 31: Remap keys
======================

There is a way to remap keys, but it's almost certain that the remapping
will have no effect on your program. I have several of my keys remapped in
DOS, but I've only seen one program that responded to the new key
functions. In fact, I was not happy to find that it did so, as the
functions were DOS commands.  Perhaps you could find a TSR to do it for
you.  If you want to try it anyway, here's how to do it.

There are several ways to accomplish your desired task.  Most publicized
and IMHO least desirable is by using the PROMPT command as follows.  This
will remap SHIFT-F10 as the command "EXIT".  The $E in the following
command represents the escape character. In your AUTOEXEC.BAT or a called
batch file type:

ECHO ON
PROMPT $E[0;93;"EXIT";13p
@ECHO OFF

Using an editor that will generate the escape character, you can do that a
little more efficiently by simply typing the following.  I will also
explain the parts here.

ECHO `[0;93;"EXIT";13p
     |  |     |    | |
     |  |     |    | |---- Command code that makes this a keyboard
     |  |     |    |           redefinition.
     |  |     |    |------ The ENTER key.
     |  |     |----------- This text + the ENTER code make up the new key
     |  |                      definition.  The quotes will not appear
     |  |                      when you press the key.
     |  |----------------- The key being redefined.
     |-------------------- The escape character.
                           I used the ` for the escape character because I
                           want to be able to post this on nets that don't
                           allow special characters.  I will continue to do
                           this.  The actual character is a left pointing
                           arrow.

To generate the escape character in DOS EDIT and in many if not most other
editors, press CTRL-P and then ESC.  Another way to get it is to hold down
the ALT key and type in 27 on the numeric keypad.

My favorite way to do keyboard redefinition is to put the definitions in a
separate file and use the TYPE command to evoke them.  That way, you are
not cluttering up your batch files with cryptic commands, and you stand
less of a chance of accidentally damaging one of the codes while editing
your batch files.  Here is my KEYCODE.FIL.

---------------------------------------------------------------------
Redefining function keys.

 SHIFT-F1 = CLS                         `[0;84;"CLS";13p
 SHIFT-F2 = DELTEMP                     `[0;85;"DELTEMP";13p
 SHIFT-F4 = XTREE                       `[0;87;"XTREE";13p
 SHIFT-F5 = DIR                         `[0;88;"DIR";13p
 SHIFT-F6 = DIR E:\DLOAD                `[0;89;"DIR E:\DLOAD";13p
 SHIFT-F7 = DIR A:                      `[0;90;"DIR A:";13p
 SHIFT-F8 = DIR B:                      `[0;91;"DIR B:";13p
 SHIFT-F9 = MENU                        `[0;92;"MENU";13p
SHIFT-F10 = EXIT                        `[0;93;"EXIT";13p
      F11 = PICKUP                      `[0;133;"PICKUP";13p
      F12 = HANGUP                      `[0;134;"HANGUP";13p
---------------------------------------------------------------------

Above I have put text strings in for the new definitions, but you could put
other keys in as well.  If you're running dos earlier than 6.0, you'll have
to look in your DOS manual for the ANSI sequences you need. With 6.x, you
have to go into the help under ANSI.SYS.  Make sure the line,
"DEVICE=C:\DOS\ANSI.SYS" is in your CONFIG.SYS file.  This assumes that
your DOS files, including ANSI.SYS, are in the C:\DOS directory.

If you want to remap the 0/Ins key (on the numbers pad) to act as "I"
you also want to remap the Numbers pad Enter key to act as PgDn.
Or maybe you only want to do this for one program.

Uh, one problem -- on the PC, there is no difference in the scan codes
for the keypad <ENTER> and the normal <ENTER>.  Ditto with the <INS> key.

But, ignoring that, here's the batch file -- and it will ONLY work if
you have ANSI.SYS being loaded via your CONFIG.SYS file, and NumLock is
ON.

        _______________________________________________________________

        @ECHO OFF                       ; Suppress the echo of commands
        SET OLDPRMT=%PROMPT%            ; Save the current DOS prompt
        PROMPT=$e[;48;"I"p              ; Use DOS prompt to re-assign key
        ECHO ON                         ; Display the prompt
        ECHO OFF                        ; Turn the prompt back off
        PROMPT=$e[;13;0;81p             ; 0;81 is the scan code for <PgDn>
        ECHO ON                         ; Display the prompt
        ECHO OFF                        ; Turn the prompt back off
        RUNFILE.EXE                     ; Run the program
        PROMPT=$e[;73;48p               ; Use DOS prompt to retore key
        ECHO ON                         ; Display the prompt
        ECHO OFF                        ; Turn the prompt back off
        PROMPT=$e[0;81;13p              ; Restore other key
        ECHO ON                         ; Display the prompt
        ECHO OFF                        ; Turn the prompt back off
        PROMPT=%OLDPRMT%                ; Restore the DOS prompt
        SET OLDPRMT=                    ; Remove OLDPRMT from memory
        _______________________________________________________________

I believe this will work. As a manner of practice have ANSI.SYS
loaded.  Also, it may not work as most program
read the keyboard directly, bypassing ANSI.SYS.


Chapter 33: Detecting DblSpace drive
====================================

The following information is provided for whomever asked, though I don't
remember who it was.

How to Detect a DoubleSpace Drive from a Batch File

The information applies to:
- Microsoft MS-DOS operating system version 6.0

SUMMARY
=======
MS-DOS batch files cannot distinguish between compressed drives and
uncompressed drives. However, you can use the MS-DOS Debug utility to
create a program that sets an errorlevel depending on whether a drive
is compressed with DoubleSpace. An MS-DOS batch file can then test
this errorlevel to determine whether the drive is a DoubleSpace-
compressed drive.

NOTE: Microsoft Product Support Services does not provide support for
writing the Debug script or batch file discussed in this article, or
troubleshoot problems related to compiling, running or using this
program or batch file. For more information on DoubleSpace
programming, see the Microsoft Application Note "MS-DOS DoubleSpace
Compressed Volume File (CVF) Format" (PD0836).

This Application Note can be found in the Software/Data Library by
searching on the word PD0836 or S14196. PD0836 was archived using the
PKware file-compression utility.

You can also obtain this Application Note by calling Microsoft Product
Support Services at (206) 454-2030.

MORE INFORMATION
================
This following is an example of how to use the MS-DOS Debug utility to
create a program file called ISDBL.COM. ISDBL.COM determines the
following:

 - Whether DoubleSpace is loaded in memory
                 -and-
 - Whether a specified drive is a DoubleSpace-compressed drive

ISDBL.COM returns the following errorlevels:

   Results                         Errorlevel
   ------------------------------------------
   DoubleSpace compressed drive         1
   DBLSPACE.BIN is not loaded           0
   Invalid drive                        0
   Other errors                         0

NOTE: ISDBL.COM tests the current drive if no drive is specified on
the command line.

Creating ISDBL.COM
------------------
ISDBL.COM is created using a Debug script file, which contains all
the commands you would enter from within DEBUG to create ISDBL.COM.

To create ISDBL.COM, follow these steps exactly:

1. Create a text file called C:\ISDBL.SCR using a text editor (such as
   Windows Notepad; MS-DOS Editor or Qedit). This is the Debug script file.
   C:\ISDBL.SCR should contain the following lines exactly as they
   appear, including the blank line after the INT 21 line and before the
   RCX line.

   NOTE: Press the ENTER key at the end of each line below.

ISDBL.SCR
=========
      A 100
      MOV AX,2901
      MOV SI,81
      MOV DI,012D
      INT 21
      MOV DL,[012D]
      DEC DL
      JGE 0119
      MOV AH,19
      INT 21
      MOV DL,AL
      MOV AX,4A11
      MOV BX,1
      INT 2F
      MOV AX,4C00
      AND BL,80
      JZ 012B
      INC AL
      INT 21

      RCX
      AE
      N ISDBL.COM
      W
      Q

   NOTE: You MUST press the ENTER key twice after the last "INT 21" line
   and once after the "Q" at the end of the Debug script.

2. From the MS-DOS command prompt on drive C, enter the following
   command to create the ISDBL.COM program:

      DEBUG < ISDBL.SCR

   Debug reads and follows the instructions in the ISDBL.SCR file. It is
   recommended that you do not use this command from within Windows or
   when other programs are running. If ISDBL.SCR contains an error, Debug
   probably is not told when to quit; therefore, you will have to restart
   your system. Debug may even be instructed to cause your system to stop
   responding (hang). If this happens, restart your system and examine
   ISDBL.SCR for accuracy.

   If there are no errors in ISDBL.SCR, a few screens of information are
   displayed, ending with

      <nnnn>:012B INT 21
      <nnnn>:012D
      -RCX
      CX 0000
      :AE
      -N ISDBL.COM
      -W
      Writing 000AE bytes
      -Q

   where <nnnn> is a combination of letters and numbers, the exact
   combination of which varies. The remaining information should be
   exactly as above if ISDBL.COM was compiled correctly.

   Debug places the ISDBL.COM file in the current directory, which in the
   example above is C:\. It should be 174 bytes in size.

Using ISDBL.COM
---------------
You can now run the ISDBL.COM program from within a batch file to get
information about a specific drive. Below is an example batch file:

DBLTEST.BAT
===========

   @ECHO OFF
   REM This batch file uses ISDB.COM to test a drive to see if it
   REM was compressed with DoubleSpace.
   REM
   REM DBLTEST.BAT assumes that ISDBL.COM in in the current
   REM directory or a directory on the MS-DOS Path.
   REM
   REM The syntax for running this batch file is:
   REM    DBLTEST <drive>:
   REM
   REM where <drive>: is the name of the drive to test, for example C:
   REM If no drive is specified, the current drive is tested.
   REM
   ISDBL %1
   IF NOT ERRORLEVEL 1 GOTO FAILURE
   ECHO The drive %1 is a DoubleSpace compressed drive.
   GOTO END
   :FAILURE
   ECHO The drive %1 is not a DoubleSpace compressed drive.
   :END

How ISDBL Works
---------------
In determining whether the drive is compressed, ISDBL assumes that
DoubleSpace is running.

ISDBL checks the specified drive by using Interrupt 2F, function 4A11.
This function is the DSGetDriveMapping application programming
interface (API) call for DoubleSpace. If the drive is compressed, then
Bit 7 of BL will be set. Otherwise, it is zero. This result is simply
returned at the end of ISDBL.

REFERENCES
==========
"MS-DOS DoubleSpace Compressed Volume File (CVF) Format," Application
Note PD0836

Chapter 34: How to ADD a path to the existing path?
===================================================

Sometimes you need to be able to add a path to an already existing
path.  You tried the following, but it didn't work:

rem existing path
path=c:\dos

rem path to be appended
path=c:\wp;%path%;

Now, are you doing anything wrong? You tried to append the path on the
command line.

Variable substitution does not work at the command line. You need to create
and use your own XPATH.BAT file as:

    PATH=%PATH%;%1

Unfortunately, Command.Com is too brain-dead to understand things
like %path% on the command line.  You'll need to write a short
batch file to do what you want under DOS 5, or else upgrade to
4DOS or NDOS.

Try:

set path=d:\newpath;%PATH%

Notice that from the command line you must use "set" to change the
environment.

I believe this is dependent of which dos version you are running. However, I
think PATH=%PATH%;%1 should work with any new dos versions.

Adding to, and deleting from the path, with error checking, is
explained in 116907 Jan 30 22:59 ftp://garbo.uwasa.fi/pc/ts/tsbat46a.zip
tsbat46a.zip A collection of useful batch files and tricks.

Chapter 35: Numlock on
======================

DOS 6.nnn & many CMOS's allow you to set numlock.  This one lets you
change at command line or in any batch file. Syntax:

    "numlock +"     turns it on
    "numlock -"     turns it off

Excluding start and end lines, copy the following into a file called
numlock.scr, run it through debug.   "debug < numlock.scr"

NUMLOCK.SCR
===========
A     0100
CLD
MOV   SI,0081
MOV   AX,0040
MOV   ES,AX
LODSB
CMP   AL,20
JZ    0109
CMP   AL,0D
JZ    0127
CMP   AL,2B
JNZ   011D
ES:
OR    BYTE PTR [0017],20
RET
CMP   AL,2D
JNZ   0127
ES:
AND   BYTE PTR [0017],DF
RET

N NUMLOCK.COM
RCX
28
W
Q


Chapter 36: Changing the date during execution
==============================================

HOKUS.BAT
=========

@ECHO OFF
REM This is a program that changes the date during execution
IF NOT .%3==%3. GOTO DEL2
IF NOT .%2==%2. GOTO OK
CLS
ECHO-------------FAILURE!---------------
ECHO SYNTAX IS: HOKUS PROGRAM DD-MM-YY
GOTO END
:OK 
SET PROGRAM=%1
SET TESTDATE=%2
REM THE NEW FILE HOKUS.JBT HAS CURRENT DATE
REM AND THE FILENAME WILL BE USED TO START
REM THIS .BAT-FILE FOR THE SECOND TIME
DIR > HOKUS.JBT
REM FIND MUST BE IN PATH
REM 4 SPACE BETWEEN HOKUS AND JBT
DIR HOKUS.JBT|FIND "HOKUS    JBT">POKUS.BAT
POKUS 
:PART2 DELETE TEMPORARY FILES
DEL HOKUS.JBT
DEL POKUS.BAT
REM %3 WE SAVE IT FOR SYSTEMINFORMATION
SET DATE=%3
REM NOW THE TEST DATE
DATE %TESTDATE%
%PROGRAM%
REM THIS IS WHERE YOU RESTORE CURRENT DATE
DATE %DATE%
SET DATE=
SET TESTDATE=
SET PROGRAM=
:END


HOKUS.BAT is a very complicated batch program. It's created
exclusively for programmers and others that need to manipulate
the date before they execute a program. If you are making
a demo with a time limit, you can get help from HOKUS.BAT
to test the program on different dates. But of course 
HOKUS.BAT is a program that you also can use in the 
opposite way - to make the life of a demo longer.

If you write the following: HOKUS ENLARGE.BAT 02-02-95,
the program ENLARGE.BAT will act as the date is february the
second 1995. When HOKUS has finished, the date will be the same 
as when you started. During the execution HOKUS.BAT has 
created and deleted POKUS.BAT and HOKUS.JBT. Notice
that during the process you have done nothing to get
the current date. You have changed the date during the
the performance, but you have written only one date.

ENLARGE.BAT
===========

@ECHO OFF
SET PATH=%PATH%;%1

Chapter 37: Undocumented commands
=================================
VER with the switch /r produces

MS-DOS version 6.20
Revision A
DOS is in HMA


Chapter 38: Ctrl-c/break
========================

I'had written a little password protection batch file to prevent
unauthorized access.  This in itself is pretty useless unless
the CTRL+C/BREAK is disabled/redefined, at least temporarily until
access is granted, when they should be reactivated. So I was looking for
something along the lines of DOS batch (ie,redefinition of keys), or a
small assembler program using debug to disable and then enable
CTRL-BREAK.

The break command will only determine how often/when the system will
check for the CTRL-BREAK sequence, but will not disable its use.

BREAK=OFF is the default. DOS always has BREAK turned off unless you
TURN IT ON first. Besides that, BREAK does not turn break checking
on and off.  It turns EXTENDED break checking on and off.
With extended break checking on, DOS checks for break each time a
DOS call is made.  With extended break checking off, DOS checks
for break each time it writes anything to the screen or a COM port,
or reads anything from the keyboard or a COM port.
Turning extended break checking off does not even come
close to preventing DOS from checking for break.  It just makes DOS do
so less often than when extended break checking is on.
BREAK Sets or clears extended CTRL+C checking n activity (file sorting,
for example). Typically, MS-DOS checks for CTRL+C only
to other functions, such as disk read and write operations.
Syntax BREAK [O ing syntax: BREAK=ON|OFF Parameter ON|OFF
Turns extended CTRL+C checking

Well, if you read the online help about the BREAK command, then why do
you not know that (1) OFF is the default so there's absolutely no
reason to turn it off unless you'd already turned it on, and (2)
turning off extended break checking does not in any way keep DOS from
checking for break.  It turns off EXTENDED break checking.  It does
not turn off break checking.

 NOABORT.COM

 Clip everything between (not including) the CLIP lines.  This message
 will be broken up into several (it's a long listing) so append each
 together editing out anything in between so you have one solid listing
 from clip line to clip line.  Save this to a DOS Text file called
 NOABORT.ASC, and then from the DOS command line type:

 DEBUG < NOABORT.ASC

 The result should be a 5k file called NOABORT.COM. Simply execute it
 when you want to turn CTRL-C/BREAK/CTRL-ALT-DEL checking on.  It is a
 TSR that will stay in memory until you unload it.  To unload it, use
 the /U parameter.  For example:

 MYBATCH.BAT:
 ============
   @ECHO OFF
   NOABORT

   ECHO. | DATE > LOGFILE.TXT
   F:
   LOGIN
   C:

   NOABORT /U
   :* EOF
 ------------

 *WARNING*  IF ANY OTHER TSR PROGRAMS HAVE BEEN LOADED IN BETWEEN AND
 NOT UNLOADED, AND YOU USE THE /U SWITCH, YOU WILL CRASH THE MACHINE!

 If you have any questions, please give me a holler.

NOABORT.SCR
===========
n noabort.com
e 0100 E9 A4 07 4E 4F 41 42 4F 52 54 20 42 4C 4F 43 4B 20 4D 41 52
e 0114 4B 45 52 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0128 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 013C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0150 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0164 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0178 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 018C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 01A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 01B4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 01C8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 01DC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 01F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0204 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0218 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 022C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0240 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0254 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0268 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 027C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0290 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 02A4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 02B8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 02CC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 02E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 02F4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0308 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 031C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0330 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0344 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0358 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 036C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0380 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0394 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 03A8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 03BC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 03D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 03E4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 03F8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 040C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0420 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0434 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0448 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 045C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0470 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0484 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0498 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 04AC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 04C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 04D4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 04E8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 04FC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0510 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0524 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0538 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 054C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0560 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0574 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0588 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 059C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 05B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 05C4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 05D8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 05EC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0600 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0614 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0628 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 063C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0650 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0664 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0678 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 068C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 06A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 06B4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 06C8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 06DC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 06F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0704 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0718 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 072C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0740 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0754 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0768 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 077C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0790 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 07A4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 07B8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 07CC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 07E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 07F4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0808 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 081C 00 00 00 00 00 40 00 00 00 00 00 9C 50 51 57 56 1E 06 FB 8C
e 0830 C8 8E D8 2E 8E 06 21 08 BE 17 00 26 8A 24 2E 88 26 20 08 B4
e 0844 02 CD 16 24 08 3C 08 75 06 E4 60 3C 51 74 30 2E 8A 26 20 08
e 0858 F6 C4 04 74 3E F6 C4 08 75 0F F6 C4 03 75 34 E4 60 3C 2E 74
e 086C 16 3C 46 74 12 E4 60 24 7F 3C 53 75 22 B4 02 CD 16 24 0C 3C
e 0880 0C 75 18 E4 61 8A E0 0C 80 E6 61 8A C4 E6 61 B0 20 E6 20 07
e 0894 1F 5E 5F 59 58 9D CF 07 1F 5E 5F 59 58 9D 2E FF 2E 23 08 E8
e 08A8 C9 09 0B C0 74 08 E8 CD 0B 3D 02 00 74 07 0B C0 75 06 EB 07
e 08BC 90 E8 BC 09 E8 DB 09 0E 07 33 F6 33 C0 8E D8 BF 20 01 B9 00
e 08D0 02 F3 A5 0E 1F B8 09 35 CD 21 2E 89 1E 23 08 2E 8C 06 25 08
e 08E4 BA 27 08 B8 09 25 CD 21 BA A7 08 CD 27 4E 4F 41 42 4F 52 54
e 08F8 20 42 4C 4F 43 4B 20 4D 41 52 4B 45 52 14 4D 65 6D 6F 72 79
e 090C 20 63 6F 72 72 75 70 74 20 2D 20 50 72 6F 67 72 61 6D 20 61
e 0920 62 6F 72 74 69 6E 67 20 2E 2E 2E 0D 0A 24 43 61 6E 6E 6F 74
e 0934 20 66 72 65 65 20 6D 65 6D 6F 72 79 20 2D 20 50 72 6F 67 72
e 0948 61 6D 20 61 62 6F 72 74 69 6E 67 20 2E 2E 2E 0D 0A 24 24 45
e 095C 52 52 4F 52 3A 20 24 0D 0A 24 00 00 00 00 00 00 00 00 00 00
e 0970 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0984 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0998 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09AC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09D4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09E8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09FC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A24 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A38 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A4C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A74 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A88 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A9C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0AB0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0AC4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0AD8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0AEC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B14 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B28 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B50 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B64 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B78 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B8C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BA0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BB4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BC8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BDC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BF0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C2C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C54 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C68 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C7C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C90 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CA4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CB8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CCC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CE0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CF4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D1C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D44 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D58 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D6C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D94 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DA8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DBC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DD0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DE4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DF8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E0C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E34 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E48 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E5C 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00
e 0E70 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E84 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E98 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0EAC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0EC0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0ED4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0EE8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0EFC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F24 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F38 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F4C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F74 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F88 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F9C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0FB0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0FC4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0FD8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0FEC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1014 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1028 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 103C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1064 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1078 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 108C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10B4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10C8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10DC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1104 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1118 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 112C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1154 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1168 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 117C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1190 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11A4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11B8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11CC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11F4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1208 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 121C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1230 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1244 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1258 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 126C 00 00 00 00 00 00 00 33 C0 E8 2F 00 E8 12 01 C3 33 C0 E8 26
e 1280 00 E8 09 01 0B C0 75 03 E8 13 00 E8 73 01 E8 51 01 E8 C1 01
e 1294 2E C6 06 68 0E 00 E8 01 00 C3 B4 4C 2E A0 68 0E CD 21 C3 E8
e 12A8 7C 00 2E A3 69 0E 2E A3 6C 12 2E C6 06 70 12 00 2E C6 06 71
e 12BC 12 00 2E C6 06 67 0E 00 33 F6 2E 80 2E 67 0E 05 2E 8E 06 6C
e 12D0 12 26 A0 00 00 2E A2 72 12 3C 4D 75 1F E8 4F 00 2E 80 3E 70
e 12E4 12 00 74 0B 2E A1 6E 12 2E A3 6C 12 EB 29 90 2E 83 06 6C 12
e 12F8 01 EB 20 90 2E 80 3E 70 12 01 75 14 2E 80 3E 72 12 5A 75 0C
e 130C 2E C6 06 71 12 01 E8 1A 00 EB 0E 90 E8 83 FF 2E 80 3E 71 12
e 1320 01 74 02 EB A7 C3 B4 52 CD 21 26 8B 47 FE C3 50 53 51 06 2E
e 1334 8E 06 6C 12 26 A1 03 00 8C C3 03 D8 43 2E 89 1E 6E 12 26 8B
e 1348 0E 01 00 2E 8E 06 6E 12 26 8A 1E 00 00 2E 80 3E 71 12 00 75
e 135C 0A 80 FB 5A 74 05 80 FB 4D 75 21 2E 80 06 67 0E 05 33 DB 2E
e 1370 8A 1E 67 0E 2E C6 06 70 12 01 2E A1 6C 12 2E 89 87 66 09 2E
e 1384 89 8F 68 09 07 59 5B 58 C3 33 DB 2E 8A 1E 67 0E 2E C6 06 6B
e 1398 0E 00 8C C8 2E 39 87 68 09 74 10 E8 21 00 0B C0 74 09 2E C6
e 13AC 06 6B 0E 01 EB 0B 90 83 EB 05 83 FB 00 77 DF 33 DB 2E A0 6B
e 086C 16 3C 46 74 12 E4 60 24 7F 3C 53 75 22 B4 02 CD 16 24 0C 3C
e 0880 0C 75 18 E4 61 8A E0 0C 80 E6 61 8A C4 E6 61 B0 20 E6 20 07
e 0894 1F 5E 5F 59 58 9D CF 07 1F 5E 5F 59 58 9D 2E FF 2E 23 08 E8
e 08A8 C9 09 0B C0 74 08 E8 CD 0B 3D 02 00 74 07 0B C0 75 06 EB 07
e 08BC 90 E8 BC 09 E8 DB 09 0E 07 33 F6 33 C0 8E D8 BF 20 01 B9 00
e 08D0 02 F3 A5 0E 1F B8 09 35 CD 21 2E 89 1E 23 08 2E 8C 06 25 08
e 08E4 BA 27 08 B8 09 25 CD 21 BA A7 08 CD 27 4E 4F 41 42 4F 52 54
e 08F8 20 42 4C 4F 43 4B 20 4D 41 52 4B 45 52 14 4D 65 6D 6F 72 79
e 090C 20 63 6F 72 72 75 70 74 20 2D 20 50 72 6F 67 72 61 6D 20 61
e 0920 62 6F 72 74 69 6E 67 20 2E 2E 2E 0D 0A 24 43 61 6E 6E 6F 74
e 0934 20 66 72 65 65 20 6D 65 6D 6F 72 79 20 2D 20 50 72 6F 67 72
e 0948 61 6D 20 61 62 6F 72 74 69 6E 67 20 2E 2E 2E 0D 0A 24 24 45
e 095C 52 52 4F 52 3A 20 24 0D 0A 24 00 00 00 00 00 00 00 00 00 00
e 0970 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0984 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0998 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09AC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09D4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09E8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09FC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A24 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A38 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A4C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A74 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A88 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A9C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0AB0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0AC4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0AD8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0AEC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B14 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B28 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B50 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B64 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B78 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B8C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BA0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BB4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BC8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BDC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BF0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C2C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C54 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C68 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C7C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C90 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CA4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CB8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CCC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CE0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CF4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D1C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D44 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D58 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D6C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D94 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DA8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DBC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DD0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DE4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DF8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E0C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E34 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E48 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E5C 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00
e 0E70 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E84 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E98 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0EAC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0EC0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0ED4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0EE8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0EFC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F24 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F38 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F4C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F74 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F88 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F9C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0FB0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0FC4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0FD8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0FEC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1014 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1028 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 103C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1064 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1078 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 108C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10B4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10C8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10DC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1104 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1118 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 112C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1154 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1168 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 117C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1190 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11A4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11B8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11CC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11F4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1208 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 121C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1230 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1244 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1258 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 126C 00 00 00 00 00 00 00 33 C0 E8 2F 00 E8 12 01 C3 33 C0 E8 26
e 1280 00 E8 09 01 0B C0 75 03 E8 13 00 E8 73 01 E8 51 01 E8 C1 01
e 1294 2E C6 06 68 0E 00 E8 01 00 C3 B4 4C 2E A0 68 0E CD 21 C3 E8
e 12A8 7C 00 2E A3 69 0E 2E A3 6C 12 2E C6 06 70 12 00 2E C6 06 71
e 12BC 12 00 2E C6 06 67 0E 00 33 F6 2E 80 2E 67 0E 05 2E 8E 06 6C
e 12D0 12 26 A0 00 00 2E A2 72 12 3C 4D 75 1F E8 4F 00 2E 80 3E 70
e 12E4 12 00 74 0B 2E A1 6E 12 2E A3 6C 12 EB 29 90 2E 83 06 6C 12
e 12F8 01 EB 20 90 2E 80 3E 70 12 01 75 14 2E 80 3E 72 12 5A 75 0C
e 130C 2E C6 06 71 12 01 E8 1A 00 EB 0E 90 E8 83 FF 2E 80 3E 71 12
e 1320 01 74 02 EB A7 C3 B4 52 CD 21 26 8B 47 FE C3 50 53 51 06 2E
e 1334 8E 06 6C 12 26 A1 03 00 8C C3 03 D8 43 2E 89 1E 6E 12 26 8B
e 1348 0E 01 00 2E 8E 06 6E 12 26 8A 1E 00 00 2E 80 3E 71 12 00 75
e 135C 0A 80 FB 5A 74 05 80 FB 4D 75 21 2E 80 06 67 0E 05 33 DB 2E
e 1370 8A 1E 67 0E 2E C6 06 70 12 01 2E A1 6C 12 2E 89 87 66 09 2E
e 1384 89 8F 68 09 07 59 5B 58 C3 33 DB 2E 8A 1E 67 0E 2E C6 06 6B
e 1398 0E 00 8C C8 2E 39 87 68 09 74 10 E8 21 00 0B C0 74 09 2E C6
e 13AC 06 6B 0E 01 EB 0B 90 83 EB 05 83 FB 00 77 DF 33 DB 2E A0 6B
e 086C 16 3C 46 74 12 E4 60 24 7F 3C 53 75 22 B4 02 CD 16 24 0C 3C
e 0880 0C 75 18 E4 61 8A E0 0C 80 E6 61 8A C4 E6 61 B0 20 E6 20 07
e 0894 1F 5E 5F 59 58 9D CF 07 1F 5E 5F 59 58 9D 2E FF 2E 23 08 E8
e 08A8 C9 09 0B C0 74 08 E8 CD 0B 3D 02 00 74 07 0B C0 75 06 EB 07
e 08BC 90 E8 BC 09 E8 DB 09 0E 07 33 F6 33 C0 8E D8 BF 20 01 B9 00
e 08D0 02 F3 A5 0E 1F B8 09 35 CD 21 2E 89 1E 23 08 2E 8C 06 25 08
e 08E4 BA 27 08 B8 09 25 CD 21 BA A7 08 CD 27 4E 4F 41 42 4F 52 54
e 08F8 20 42 4C 4F 43 4B 20 4D 41 52 4B 45 52 14 4D 65 6D 6F 72 79
e 090C 20 63 6F 72 72 75 70 74 20 2D 20 50 72 6F 67 72 61 6D 20 61
e 0920 62 6F 72 74 69 6E 67 20 2E 2E 2E 0D 0A 24 43 61 6E 6E 6F 74
e 0934 20 66 72 65 65 20 6D 65 6D 6F 72 79 20 2D 20 50 72 6F 67 72
e 0948 61 6D 20 61 62 6F 72 74 69 6E 67 20 2E 2E 2E 0D 0A 24 24 45
e 095C 52 52 4F 52 3A 20 24 0D 0A 24 00 00 00 00 00 00 00 00 00 00
e 0970 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0984 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0998 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09AC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09D4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09E8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 09FC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A24 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A38 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A4C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A74 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A88 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0A9C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0AB0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0AC4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0AD8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0AEC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B14 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B28 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B50 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B64 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B78 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0B8C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BA0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BB4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BC8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BDC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0BF0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C2C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C54 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C68 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C7C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0C90 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CA4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CB8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CCC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CE0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0CF4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D1C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D44 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D58 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D6C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0D94 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DA8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DBC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DD0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DE4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0DF8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E0C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E34 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E48 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E5C 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00
e 0E70 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E84 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0E98 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0EAC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0EC0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0ED4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0EE8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0EFC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F24 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F38 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F4C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F74 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F88 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0F9C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0FB0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0FC4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0FD8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 0FEC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1014 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1028 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 103C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1064 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1078 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 108C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10B4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10C8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10DC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 10F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1104 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1118 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 112C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1154 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1168 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 117C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1190 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11A4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11B8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11CC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 11F4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1208 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 121C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1230 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1244 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 1258 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
e 126C 00 00 00 00 00 00 00 33 C0 E8 2F 00 E8 12 01 C3 33 C0 E8 26
e 1280 00 E8 09 01 0B C0 75 03 E8 13 00 E8 73 01 E8 51 01 E8 C1 01
e 1294 2E C6 06 68 0E 00 E8 01 00 C3 B4 4C 2E A0 68 0E CD 21 C3 E8
e 12A8 7C 00 2E A3 69 0E 2E A3 6C 12 2E C6 06 70 12 00 2E C6 06 71
e 12BC 12 00 2E C6 06 67 0E 00 33 F6 2E 80 2E 67 0E 05 2E 8E 06 6C
e 12D0 12 26 A0 00 00 2E A2 72 12 3C 4D 75 1F E8 4F 00 2E 80 3E 70
e 12E4 12 00 74 0B 2E A1 6E 12 2E A3 6C 12 EB 29 90 2E 83 06 6C 12
e 12F8 01 EB 20 90 2E 80 3E 70 12 01 75 14 2E 80 3E 72 12 5A 75 0C
e 130C 2E C6 06 71 12 01 E8 1A 00 EB 0E 90 E8 83 FF 2E 80 3E 71 12
e 1320 01 74 02 EB A7 C3 B4 52 CD 21 26 8B 47 FE C3 50 53 51 06 2E
e 1334 8E 06 6C 12 26 A1 03 00 8C C3 03 D8 43 2E 89 1E 6E 12 26 8B
e 1348 0E 01 00 2E 8E 06 6E 12 26 8A 1E 00 00 2E 80 3E 71 12 00 75
e 135C 0A 80 FB 5A 74 05 80 FB 4D 75 21 2E 80 06 67 0E 05 33 DB 2E
e 1370 8A 1E 67 0E 2E C6 06 70 12 01 2E A1
e 13C0 0E 2E 88 1E 66 0E C3 33 C0 33 C9 FC 2E 8A 0E 05 09 2E 8E 87
e 13D4 68 09 BE F1 08 BF 03 01 F3 A6 75 01 40 C3 FA 33 DB 2E 8A 1E
e 13E8 66 0E 1E B9 00 02 2E 8E 9F 68 09 BE 20 01 33 C0 8E C0 33 FF
e 13FC F3 A5 1F FB C3 33 DB 2E 8B 0E 6D 09 2E 8A 1E 66 0E 2E 8B 97
e 1410 68 09 BB FB FF 83 C3 05 2E 3A 1E 67 0E 73 35 2E 3A 1E 66 0E
e 1424 77 18 8C C8 2E 3B 87 68 09 74 E6 2E 39 97 68 09 72 DF 2E C6
e 1438 87 6A 09 01 EB D7 2E 39 8F 68 09 74 D0 8C C8 2E 39 87 68 09
e 144C 74 C7 2E C6 87 6A 09 01 C3 BB FB FF 83 C3 05 2E 3A 1E 67 0E
e 1460 73 1B 2E 80 BF 6A 09 00 74 EE 2E 8B 87 66 09 40 06 8E C0 B4
e 1474 49 CD 21 07 73 DE E8 21 FE C3 50 BB 80 00 33 C9 8A 0F 80 F9
e 1488 00 74 26 83 C3 02 B0 2F B4 2D 3A 07 74 0A 3A 27 74 06 43 E2
e 149C F5 EB 12 90 43 80 3F 55 74 08 80 3F 75 74 03 EB 04 90 58 40
e 14B0 50 58 C3
rcx
13B3
w
q

If you got any problems in compiling this script, please
register your copy of this book and I will send you a diskette
with all the files mentioned in this book. Internet: froaas@online.no.


Chapter 39: Can't delete directory
==================================

Oh, joy! A challenging opportunity!  The following is a brute
force method for dealing with those oddball directories that
sometimes show up with non-printing characters. Here we go:

(A)  Make an example to play with. I promise that if you can
make one, you will be able to get rid of it, too.
/////           instructions follow
/////           if you can't do A-1, forget the whole thing
A-1.  go into BASIC, any flavor.
/////           program to make a new dir in c:\
A-2.  10 SHELL "MD C:\AAA"+CHR$(255)+"BBB"
      20 END
/////           execute the program
A-3.  RUN
A-4.  get out of basic.  sometimes command is SYSTEM or whatever.
/////           look at the results
A-5.  DIR *. C:\ /W
/////           notice the new directory AAA BBB?

(B)  Now, pretend that you don't know anything about this directory
with the space in the middle.  We will take it from the edge and
present a generalized method for getting rid of it, or looking
into it, etc.

/////            Put the offending directory listing into a sorted
/////            text file by name of TEMP
B-1.  DIR C:\*.|SORT>C:\TEMP
/////            Look at it and notice AAA BBB is near the top.
B-2.  TYPE C:\TEMP|MORE
/////            Find what the middle character of AAA BBB really
/////            is.  You could use any hex lister, but DEBUG
/////            is more generalized.
B-3.  DEBUG C:\TEMP
/////            Look on the right of the screen for AAA.BBB
B-4.  D <enter>
/////            Keep hitting D enter until you see the directory.
/////            Look at the hex display for 41 41 41 xx 42 42 42
/////            (which is hex for AAA x BBB)
/////            and write down the hex number where the xx is.
/////            Get out of DEBUG
B-5.  Q <enter>
/////           Go into BASIC.  Enter the following program.  BE
/////           SURE to replace the "xx" below with the hex char.
/////           you wrote down in step B-4.
/////           This Renames the Directory "AAAxBBB" to "BADBOY"
/////           by copying the files and deleting AAAxBBB.
B-6.  10 F$="AAA"+CHR$(&Hxx)+"BBB"
      20 SHELL "MD C:\BADBOY"
      30 SHELL "COPY C:\"+F$+\*.* C:\BADBOY"
      40 SHELL "ECHO Y|DEL C:\"+F$+"\*.*"
      50 SHELL "RD C:\"+F$
      60 END
      RUN
/////           Now we get to see what's in directory BADBOY, or
/////           delete the files and the directory, or whatever.
/////           To conclude this example, kill it.
B-7.  Get out of basic, back to dos.
B-8.  RD C:\BADBOY

Have fun with it.

Chapter 40: Batch file for cd-rom
=================================

Here is the batch file I use to view the contents of the ASP CD-ROM.
I use List, rather than the index program on the CD.  What I do is
start another instance of command.com with the /F (fail) switch
to test for a mounted CD-ROM Disk.  Doing so protects the user from
confusing DOS error messages and allows the display of a meaningful
message.  I don't know if MS-DOS 5 supports the /F switch.  If not,
you might consider upgrading DOS, which would also allow Smartdrive
to cache the CD.

I arrived at this technique while working on my AA, BB, CC, etc. batch
files.  In so doing, I found that testing for nul does not work when
checking for the presence of a CD-ROM, and that you must look for *.*
or a more specific filespecification as I did here.

I run ASP.BAT from the DOS command line, or from Windows (using a PIF).
I like using MPAUSE instead PAUSE when running under Windows.  MPAUSE
is a PAUSE clone that includes a mouse click as an keypress. I've
included the debug script for MPAUSE.COM in case anyone wants it.

ASP.BAT
=======

@echo off
:: ASP.BAT/MS-DOS 6.2
 set|find "windir=">nul
 if not errorlevel 1 cls
 echo.
 echo  Checking for ASP CD-ROM....
 rem>c:\$tstdrv$.$$$
 %COMSPEC% nul /f /c IF EXIST f:\bbsvend\*.* DEL c:\$tstdrv$.$$$
 IF NOT EXIST c:\$tstdrv$.$$$ GOTO start
 DEL c:\$tstdrv$.$$$
 GOTO err_msg
:start
 c:\utl\list f:\bbsvend
 goto end
:err_msg
 echo.
 echo  ASP programs not found. Please make sure that
 echo  the ASP CD-ROM is in the drive and try again.
 set|find "windir=">nul
 if errorlevel 1 goto end
 echo.
 echo  Press any key or click mouse to [0;30;47m[Exit][0;1;37;44m
 mpause
:end

MPAUSE.COM
==========

N MPAUSE.COM
E 0100 B8 00 00 CD 33 3D 00 00
E 0108 74 23 B8 01 00 CD 33 B8
E 0110 03 00 CD 33 81 E3 07 00
E 0118 75 0A B4 01 CD 16 74 EF
E 0120 B4 00 CD 16 B8 02 00 CD
E 0128 33 B4 4C CD 21 B4 01 CD
E 0130 16 74 FA B4 00 CD 16 B4
E 0138 4C CD 21 46 8A C2 24 FE
RCX
0040
W
Q

Chapter 41: Get the beep out of CHOICE
======================================

The MS-DOS 6.x CHOICE command is nice except for the BEEP.
Is there a way to disable the beep Choice makes when you hit <enter>?
There's a program I invoke via Choice, and I have to hit <enter> to
go back to Choice's menu.  But then when it goes back to the menu I
get a beep.

    Below is a screen cut from a complete DEBUG session, along with
    brief comments on the right, where I replaced the "07" (bell
    character) in CHOICE.COM with a "1B" (the <Esc> character).

    The actual memory addresses will more than likely be different on
    your system (depends on everything else you have loaded in memory)
    but, the difference doesn't matter, just follow the concept.

    The file size of your CHOICE.COM may also be different.

    Everything I type after loading CHOICE.COM into DEBUG (the first
    line) will be at a DEBUG "-" (hyphen) prompt.  Everything that
    does not begin with a "-", is a DEBUG response.

    +---------------------+
    | DEBUG CHOICE.COM    | Load CHOICE.COM into DEBUG
    | -RCX                | Get the size
    | CX 06DA             | Size is 06DA hex (1754 bytes)
    | :                   | (Ignore this prompt, just hit [Enter])
    | -H 06DA 100         | Add 100 to 06DA
    | 07DA  05DA          | The 07DA on the left is the answer
    | -S 100 07DA B2 07   | Search from 100 to 07DA for sequence "B2 07"
    | 104B:077B           | Bingo!  DEBUG found it at address 104B:077B
    | -E 104B:077B B2 1B  | Edit address 104B:077B to read "B2 1B"
    | -W                  | Write the change to disk
    | Writing 006DA bytes | (Debug writes it to disk)
    | -Q                  | Quit to DOS
    +---------------------+

    If the "S"earch command returns more than one address you may either
    have a different CHOICE.COM than I do or, you may have typed
    something wrong.  In either case, just type "Q" to quit to DOS.

    I'd use a renamed copy of CHOICE.COM.  Maybe QCHOICE.COM (Q=Quiet)?

    BTW, if you're interested, the "B2 07" is hex for instruction:

      MOV DL,07

    meaning put "07" (the bell character) into register "DL".  The next
    instruction would probably be:

      MOV AH,02

    the DOS "display output" function.  And finally a:

      INT 21

    would kick DOS into action.  When I changed the "07" to "1B" I
    actually changed the first instruction to read:

      MOV DL,1B

    Good luck and enjoy!

Chapter 42: How to tell MS DOS not to display any messages?
===========================================================

How to tell DOS not to display any messages like, "1 file(s)
copied" or "bad command or file name"?  I've got a batch file
that runs as part of a menu and everything works great, BUT...
...the effects of my batch running in the background become known when
"1 file(s) copied" pops through the menu for a second.  Echo off tells
the computer not to show what YOU are saying, BUT how do you tell the
computer to soto vocce?

        i.e.    DIR >NUL
For the copy command you can redirect the output to the NUL device.
E.g., copy filename1 filename2 > nul.

If you redirect the command output to device NUL you'll kill all
"normal" output. Sadly this doesn't kill "critical" messages. so the
"File not found" on a delete of a missing file is deemed a critical
error and cannot be stopped by this simple trick.

        COPY {here} {there} > NUL

will run silently.

Add >nul to the end of the lines that load the commands you want to do
quietly.

example
copy c:\user\*.doc c:\bak\*.doc >nul

If you need to hide STDERR text, you'll need to direct all CON I/O to
NUL via the CTTY command:

       ctty NUL
       rem All console I/O directed to NUL; no keybd control!
       echo You'll never see this!
       copy foo.bar fubar.txt
       ctty CON
       echo Console I/O restored.



I just reminding you about that seldom-used command CTTY.
I once had done something like this, but if not reused- forgotten!

Chapter 43: Recall of previously issued commands for re-entry
=============================================================

For many years MS DOS users were forced to use small utilities to recall
the commands they just had executed from the MS DOS prompt. Oh course,
in the very early MS DOS versions you had the function keys that to a
certain extent could provide some help, but at that time other
programs like for example CED was more useful. From MS DOS version 5 the
user were offered the MS DOS program DOSKEY, a very powerful command
to simplify their work. Too many times I have found myself repeating
the same keystrokes over and over again. If you install DOSKEY, MS DOS
will build a report and keep a record of the commands you have been
executing since you turned on your computer.

Starting to use DOSKEY
----------------------

Load the DOSKEY program into memory.
        A:      Type DOSKEY at the prompt like this
                C:\>DOSKEY
                The message DOSKEY installed is written on the screen.

To try out the program you should execute some commands.
        B:      Type the following commands at the prompt
                C:\>DIR
                C:\>TYPE \AUTOEXEC.BAT
                C:\>TREE
                C:\>MEM /c

To the DOSKEY command you can add different switches.
        C:      Type DOSKEY /history at the prompt.

A list of names of each command is displayed as shown below:
DIR
TYPE \AUTOEXEC.BAT
TREE
MEM /c

You can abbriviate the switch /history as /h. The switch displays a list
of all commands stored in memory. You can use a redirection symbol >
with the /history switch to redirect the list to a file. But if you want
to recall the command to the prompt to execute it, the function key F7
is a much better way to do it, because then DOSKEY returns a report with
a number to the left reflecting the command's relative position. DOSKEY
assigns these numbers sequentially, beginning with 1 for the oldest
command stored in memory.

        D:      Press F7

A similiar list like the one below is written on your screen:
1: DIR
2: TYPE \AUTOEXEC.BAT
3: TREE
4: MEM /C
5: DOSKEY /HISTORY
6: DOSKEY /H
The numbers make it easy for you to enter the line number of the desired
command.
        E:      Press F9

DOSKEY prompts you for a command number
C:\>Line number :

and displays the command
associated with the number you specify.
        F:      Type 2

the command C:\TYPE \AUTOEXEC.BAT is written on your screen.
        G:      Press F9
        H:      Type 1

and the command DIR is displayed on your current command line.

The arrow keys
--------------

Most of the time you will make use of the arrow keys to retrieve and
re-enter the commands. The Up arrow and the Down arrow will display the
old commands. Then pressing ENTER when the desired command is displayed.
The command can be edited.

       Let me visualize the stored data as a "stack" of commands. Doskey
        keeps a pointer to a certain position in this stack. The pointer
        points to a location "between" two commands. Each time you press
        <>, the UP arrow, DOSKEY displays the command above the
        pointer, and moves the pointer up one command. Therefore the UP
        arrow <> recalls the MS DOS command you used before the one
        displayed.

Let's suppuse that you have entered the commands DIR, TYPE, TREE, AND
CHKDSK. Below is a table that shows the the pointer's location.

                ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                ³            DIR            ³
                ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³            TYPE           ³
                ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³            TREE           ³
                ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³            CHKDSK         ³    ÄÄÄÄÄÄ The pointer
                ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Unlike some other DOS editors The DOSKEY stack is not circular. 
If the pointer points to a position below the last command in 
the stack, as it does above, it is actually between the last 
command Chkdsk and the first command TREE. In the situation above, 
pressing <>  will display the command TREE and leave the pointer 
between TREE and TYPE. Pressing <> the DOWN arrow will display 
the command TREE. This means that the DOSKEY pointer moves up and 
down a ladder. The <> DOWN arrow recalls the MS DOS
executed before the one displayed. Each time a command is recalled 
MS DOS position the cursor at the end, after the last letter. 
The cursor is in replace mode and if you are going to edit it before 
you execute it, you better press the INSERT button to avoid overstriking 
your command statement. So if you want to change the sentence before 
executing it, MS DOS lets you use the LEFT ARROW KEY, the RIGHT ARROW, 
the CTRL-LEFT ARROW, the CTRL-RIGHT ARROW to move the cursor to the 
word or letter you want to edit.
Below is a table that shows you the different editing keys available to
recall a command:

   ÉÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
   º  Key   º           What it does                                    º
   ÌÍÍÍÍÍÍÍÍÎÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹
   º       º  Recalls the MS DOS command you used before the one       º
   º        º  displayed                                                º
   ºÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
   º       º  Recalls the MS DOS command you used before the one       º
   º        º  displayed                                                º
   ºÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
   º Pg Up  º  Recalls the oldest command in the current session        º
   ºÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
   º PG Dn  º  Recalls the most recent command you used                 º
   ÈÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

Below is a table that shows you the different editing keys available to
edit the command line:

    
   ÉÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
   º  Key   º           What it does                                    º
   ÌÍÍÍÍÍÍÍÍÎÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹
   º       º  Moves the cursor back one charcter                       º
   ºÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
   º       º  Moves the cursor forward one character                   º
   ºÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
   º Ctrl  º  Moves the cursor back one word                           º
   ºÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
   º Ctrl  º  Moves the cursor forward one word                        º
   ÈÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼


   ÉÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
   º  Key   º           What it does                                    º
   ÌÍÍÍÍÍÍÍÍÎÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹
   º Home   º  Moves the cursor to the beginning of the line            º
   ºÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
   º End    º  Moves the cursor to the end of the line                  º
   ºÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
   º Esc    º  Clears the command from the command line                 º
   ÈÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

When you need to make changes at the command line you can use the
Backspace and the Delete keys. With the Insert key you can toggle
between the mode where new characters overstrike the characters
already on the command line. When you press Insert, the cursor changes
from an underscore  _  to a square Ü, DOSKEY switches to insert mode,
and the new charcters are written in to the text, a well known
phenomena in wordprocessing when the charcters are pushed to the
right. This is the default mode, but it can be changed. The use of the 
Insert key requires a bit of explanation. In the default mode, new 
characters replace (overstrike) the characters already on the command
line. The insert mode is reset to overstrike mode when you press ENTER.

This process can be changed by specifying the /INSERT switch when 
starting (or reinstalling) DOSKEY. If you start DOSKEY with the 
/INSERT switch, insert mode becomes the default. Pressing Insert still
causes the cursor to change to a square, but now the new characters
replace the existing characters. The default setting is the equivalent
of using the /OVERSTRIKE switch.)

MS DOS always stores the previous commands as a command template.
It is often easier to create a new command line by editing an old
one. You can use these standard command editing keys to work with
the command as stores in the command template. When you type a command,
MS DOS carries it out and saves it in a temporary location 
called the template. For example, suppose you type the following
command:

        C:\>XCOPY NOTE.TXT A:

When you press ENTER, MS DOS copies the file NOTE.TXT to drive A:
and copies the command XCOPY NOTE.TXT to the template. The 
template can contain only the previously typed command.

You can use the command stored in the template as a starting point
for typing your next command. The following editing keys display
and edit the previous command, stored in the template:

F1      Copies the previous command to your screen, one character
        at a time. One character is displayed each time you press
        F1.

F2      Copies the previous command to your screen, up to but not 
        including the character you specify. For example, suppose 
        the previous command was DIR AUTOEXEC.BAT. If you press F2
        and X, MS DOS displays DIR AUTOE.

F3      Copies the remainder of the previous command to your screen.

F4      Deletes the previous command from the template, starting from
        the beginning of the command, up to but not including the letter
        you specify. For example, suppose the previous command was
        TYPE NOTE.TXT. If you press F4 and type t, and then copy 
        the template to your screen by pressing F3, MS DOS displays 
        TE.TXT.

F5      Copies the current command line to the template, but does not
        carry out the command. It clears the current command line.
        (Note: Without DOSKEY loaded, F5 acts like the Esc key.

F6      Places a CTRL+Z character (^z) in the current command line.
        This is useful when you a writing text by using COPY CON 
        TEXT.FIL. F6 produces an end of file mark.

If you do like myself, repeating many commands during a workingsession,
I will recommend you to increase the buffersize to have more room
for your commands. With default setting you will loose commands on
your list, because of lack of memory. Therefor you should give this
command at the MS DOS prompt:

C:\>DOSKEY /REINSTALL /BUFFERSIZE=3072

and write the sentence into your AUTOEXEC.BAT.

Macros
======

The main difference between a batch program and a macro is that
a macro is stored in RAM, whereas a batch program is stored on
disk. A macro runs much faster and you can run them from any
directory. DOSKEY allows you to create macros, like batch 
programs they are sets of commands that you can carry out by
typing the name. Macros reside in your computer's fast electronic
memory and are lost when reset or restart your system. You should
also be aware of that macros take away memory from your command
history buffer.

To create a macro put commands in a macro definition. In a macro
you type all the commands on the same line and separate each with a
special character. The total length of a macro cannot exceed 127
characters. To stop a macro you must press CTRL+C for every command.
Each time you press CTRL+C in a macro, MS DOS stops the command it
is currently carrying out.

In both batch programs and macros, you can use repaceable
parameters. In batch programs the parameters are %1 through
%9, and in macros they are $1 through $9. In addition, the 
redirection characters you use in macros are different from 
those you use in batch programs and MS DOS commands.

To make your most commonly used macros available each time
your system starts, you can place the DOSKEY commands that 
define the macros in your AUTOEXEC.BAT. You cannot use GOTO
commands in a macro or start other macros from inside a macro.
But you can run a batch file from inside a macro, but you 
can't run a macro from inside a batch program. However, you
can include a command that creates a macro insides a batch 
program. 

Creating a Macro
================

To register a macro:
--------------------
        A: Type DOSKEY followed by the macro's name.
        B: Type the equal sign = 
        C: Type the commands you want the macro to execute.
        D: Use the metacharacter $T or $t to separate the commands

The following DOSKEY command creates a macro named CHDIWTR that
checks your disk, performing DIR in wide format and executes the
command TREE.

        C:\DOSKEY CHDIWTR=CHKDSK $T DIR/W $T TREE

Now you have created your first macro. To execute it type CHDIWTR
at the command prompt, MS DOS runs the macro, performing CHKDSK, 
displays the report, displaying a five-column list of the files 
in the directory and displays grafically the directory structure 
of a path or of the disk in a drive. It doesn't matter which 
directory is current when you run it.

To execute a macro:
-------------------

        A: Type CHDIWTR after C:\>
        like this
        B: C:\>CHDIWTR 
        and press ENTER 

If your macro has parameters, leave a space between the macro name
and the parameters. For example, suppose you create a macro named
MOVE that has as parameters the name of the file you want to move
and the name of the directory that you want to move the file to. To
move all .TXT files from the current directory to the C:\REPORT 
directory, you should type the following command:

        A: Type C:\TXT>MOVE *.TXT C:\REPORT
        B: Remember: There should be no space between
        the command prompt and the macro name. If there is,
        MS DOS does not recognize the name and displays the 
        following message.

Suppose you want to create a macro that has the same name as a
command. For example, you would use the following command to
create a macro caller DIR, which would replace the MS DOS DIR
command:
        A: C:\>DOSKEY DIR=DIR /w

When you have a macro with the same name as a command,
MS DOS runs the macro rather than the command. Thus, when
you type DIR at the command prompt, MS DOS runs the DIR macro 
rather than the DIR command. Whenever you want to use the DIR command
instead of the DIR macro, you can type a space between the command 
prompt and DIR. MS DOS does not recognize DIR as a macro name, 
but it does recognize it as a command.

Editing a macro
===============
        A: Edit the command that created it.
        B: Recall the command to the command line, for example:
        C: Press F7
        D: A list of commands is displayed.
        E: Press F9 and type the number in the list where the macro
        command is located.
        F: Press ENTER and edit.

        Or:
        A: Open the batchfile where your DOSKEY macro is stored.
        B: Edit and run it again.

Saving a macro:
===============

The DOSKEY switch /macros displays a list of all DOSKEY macros. You
can use a redirection symbol (>) with the switch /macros to redirect 
the list to a file. You can abbreviate the switch as /m. Now, you have
been experimenting with macros for a while, and you have had them stored
in memory. You know that all your new macros will be lost when you turn
off your computer. Now, you should create at batch file where your
macros reside.
        A: Suppose you have made about 10 new macros.
        B: At the moment they reside in memory.
        C: Type DOSKEY /macros > MACS.BAT.

If you add the DOSKEY command to the beginning of each macro
that you saved in the MACS.BAT file, you can load the macros
into memory by running the batch program. For example, suppose
you have created the following four macros and saved them in
the MACS.BAT file:

ST=DIR 
M=MODE 
MORY=MEM /C
DIRCMD=DIR /S/W/O/P/a:-D

If you want these macros to be available each time you start 
your system, you must first add the DOSKEY command like I have
done below:

DOSKEY ST=DIR 
DOSKEY M=MODE 
DOSKEY MORY=MEM /C
DOSKEY DIRCMD=DIR /S/W/O/P/a:-D

Each time you run the batch program, Doskey loads the four
macros into memory. You may want to run the batch file within
your AUTOEXEC.BAT. Then you can use the command CALL.

Remove a macro from memory
==========================

To erase one macro from memory, type the following sentence:
        A: Doskey, the name of the macro, followed by an
        equal sign. For example to delete CHDIWTR, you would
        type the following command:
        B: DOSKEY CHDIWTR=
        C: To delete all macro in memory, press 
        ALT+F10

Using replaceable parameters
============================

Earlier in this book I have described how you can use replaceable
parameters to increase the capabilities of your batch programs. By
using %1 through %9 parameters you can create numbered variables, 
placeholders for parameters typed at the command prompt. 
You can also use command-line parameters with DOSKEY. In the case
of macros, however, you access the parameters using the symbols $1 
through $9. For example, the following command creates a macro
a macro named FINDIT. The macro searches through the directories 
on drive C: for filenames that match the one you specify:

        A: DOSKEY FINDIT=DIR C:\$1 /s

In the macro I make use of the command DIR and the switch /s.
The switch /s lists every occurrence, in the specified directory
and all subdirectories, of the specified filename.

To execute the macro:
        A: Type FINDIT and for example a file extension at
        the command prompt. To find all files on drive C: with
        the extension *.dll, you would type the following command:
        B: FINDIT *.DLL.

DOSKEY substitutes the filename you type for the $1 in the macro.

This is how the command really looks like:

        C:\>DIR C:\*.DLL /s

You can use the same parameter more than once in a macro.
The command below cretes a macro called ddel. This macro
moves a file to a directory named DELETED on drive C:

        DOSKEY DDEL=COPY $1 C:\DELETED $t DEL $1
When I run the DDEL macro, I type the name of the file that is
to go into the C:\DELETED directory. Doskey replaces the $1 in
the macro with the filename. It copies the file to DELETED and
then deletes it from its original directory. To delete the files
in the C:\DELETED directory, I use the macro named CLEANUP:

        DOSKEY CLEANUP=DIR C:\DELETED $t DEL C:\DELETED\*.*

The macro displays a list of files in the C:\DELETED directory
and then starts the DEL command. Because the DEL command prompts
you to confirm deletion of all the files, you have a chance to 
review the filenames before deleting files. The following macro 
SHOWEM, uses the replaceable parameters to display its command-line
parameters:
C:\>DOSKEY SHOWEM=ECHO $1 $2 $3 $4 $5 $6 $7 $8 $9

If you invoke SHOWEM with the letters A, B, C, D, E, F, G, H, J, K, 
L, M and N, your screen displays the following:

C:\>SHOWEM A B C
C:\>ECHO A B C
A B C 

Using the $* replaceable parameter:
===================================

You can use the $* replaceable parameter to assign to a 
single parameter all of the text following the command
that starts a macro. Typically, MS DOS distinguishes 
parameters by looking for a space. The text between the first
two spaces is the first parameter, the text between 
the second and the third spaces is the second parameter, and so
on. If you use the $* parameter, DOSKEY ignores spaces and 
assigns all text to the $* parameter.

DOSKEY macros don't support the SHIFT command that moves
parameters one positon to the the left. Instead, DOSKEY
macros support the $* metacharacter, which MS DOS replaces
with the macro's command line minus the macro name.
The $* parameter is most useful when the macro you create
uses a variable number of parameters. For example, you can
use the following command to create a macro named D that 
allows you to abbriviate the DIR command.

C:\>DOSKEY D=DIR $*

This macro works exactly like the DIR command, regardless
of the numbers of paramters you specify. For example, all
of the following commands are carried out in the same way 
with the D macro as they are with the DIR command:

       D *.TXT
       D *.TXT /s
       D *.TXT /s /b

If you use the $1 parameter instead of $* with the macro,
MS DOS substitutes the first parameter and ignores the rest 
of the command line.

Redirecting input and output
============================

You redirect input and output in macros the same way you do 
in MS DOS commands. The only differences is that macros 
requires different characters:

$L (or $l)      Equivalent to less-than sign (<). It redirects
                the input to a a command.

$G (or $g)      Equivalent to the greater-than sign (>). It redirects
                the output of a command.

$G$G (or $g$g)  Equivalent to the double greater-than sign(>>). It
                appends output onto the end of a file.

$B (or $b)      Equivalent to the pipe (|). It redirects output from
                one command to another

For example, the following command creates a macro named PDIR
that print directory listings:

        C:\>DOSKEY PDIR=DIR $G LPT3:

The following command creates a macro named MTYPE that displays
the contents of the file you specify and pauses between each screen
of information:

        C:\>DOSKEY MTYPE=TYPE $1 $B MORE

The following command creates a macro named asort that alphabetizes 
the file and stores the information in a different file:

        C:\>DOSKEY ASORT=SORT $L $1 $G $2

To run this macro, you type the filename you want to sort.
DOSKEY replaces the $1 replaceable parameter with the first
filename you specify. The $L redirects the file to the sort 
command. The $g and $2 parameters redirect the output of the
SORT command to the second file you specify. For example, 
after you create the ASORT macro, you could type the following:

        C:\ASORT INPUT.TXT OUTPUT.TXT

This is the same as typing:

        C:\>SORT < INPUT.TXT > OUTPUT.TXT

When defining a DOSKEY macro you must mark the dollar sign ($)
when it occurs anywhere other than in parameters, command
separators, and redirection characters. You mark it by typing
two dollar signs rather than one. For example, suppose your 
macro copies a file to the $&CENTS directory. When you type
the name of the directory, you must use $$&CENTS in your 
macro definition. As the command is carried out, the dollar
sign is assumed to be standard character rather than a marker 
or parameter.

Create your own macro library
=============================

Using batch programs and macros save your time. Even when I
use Windows 3.11 and Windows -95, I find that some tasks are
easier at the MS DOS prompt. May be I'm stubborn, may be I
do it the wrong way, but over and over again I find myself
returning to my batch programs and macros, running them in
Windows.

If you create a macro that formats different disks, you would
store them in your library file and call the file in your AUTOEXEC.
BAT. When you'r working in Windows and need to format a 720 Kbyte
disk, you just double click at your MS DOS icon and type the macro
name at the prompt.

Below I will show you different ways how I use DOSKEY macros.
To move between subdirectories sometimes needs many keystrokes.
I tend to make a lot of subdirectories and to get to the very bottom
I have to write CD and the name of the subdirectory I want to move
to. Oh course I can make use of different utilities to move fast
between the different subdirectories. But often I create subdirectories
with difficult name, just to describe the contents thoroughly. The
best way to get there is to create a macro. The Run Batch Run Book
resiedes during editing in a subdirectory. By using the command TREE
I can show where the files are located:

Directory PATH listing for Volume AISCHYLOS
Volume Serial Number is 20BE-89C2
C:.
ÃÄÄÄADVANCED
³   ÃÄÄÄCHAP03
³   ÃÄÄÄCHAP05
³   ÃÄÄÄCHAP07
³   ÃÄÄÄCHAP08
³   ÃÄÄÄCHAP11
³   ÃÄÄÄCHAP12
³   ÃÄÄÄCHAP13
³   ÃÄÄÄCHAP14
³   ÀÄÄÄCHAP15
ÃÄÄÄUTSKRIFT
ÃÄÄÄPRT
ÃÄÄÄRBATCH15
ÃÄÄÄTEST
ÃÄÄÄSCRIPT
ÃÄÄÄBIGTXT
ÃÄÄÄRBATCH11
³   ÃÄÄÄRBATCH12.NO
³   ÀÄÄÄENGRBATC.H13
³       ÃÄÄÄHTML
³       ÃÄÄÄVER13
³       ÀÄÄÄVER13ENG
³           ÃÄÄÄSALG
³           ÀÄÄÄENGRBATC.H14
³               ÀÄÄÄLAGER
ÀÄÄÄRBATCH14

Version 1.4 resided in the subdirectory ENGRBATC.H14. To move fast between
the directories I created a macro called PE. In AUTOEXEC.BAT one of lines
are CALL MACRO.BAT. When I open Macro.bat one of the lines are DOSKEY PE=p
engrbatc.h14. P is the name of a batch file which contains the Norton
utility program NCD.

P.BAT
=====
@ECHO OFF
IF NOT %1X==X CTTY NUL:
NCD %1
CTTY CON:

Because I'm tired of reading the advertising from Norton utilities each
time I use NCD I have created this batch file. The CTTY NUL prevents the
advertising from showing up each time NCD is executed.

Appendix 1:
===========


Alphabetical listing of files
=============================

ALL.BAT
AUTOEXEC.BAT
BACKUP1.BAT
BAT.BAT
BUMPDAY.BAT
CLEAR.COM
COLDBOOT.COM
COLROCHT.BAT
CPTOA.BAT
DATES.SCR
DBLTEST.BAT
DEZIP.BAT
DO.BAT
DO1.BAT
DO2.BAT
DO3.BAT
ENLARGE.BAT
ERASE.BAT
ERASE1.BAT
ERASE2.BAT
FALLBACK.SCR
FIND.BAT
GETDATE.BAT
GETTIME.COM
HOKUS.BAT
HOUR.COM
INCBY1.BAT
ISDBL.COM
ISDBL.SCR
ISWIN.COM
LAF.BAT
LAFUEXT.BAT
LAFUEXT1.BAT
LAFUEXT2.BAT
LOOKFOR.BAT
MAIL.BAT
MON.BAT
MON.COM
MON.SCR
MPAUSE.COM
MULTIJOB.BAT
MYBATCH.BAT
NO.COM
NOABORT.COM
NUMLOCK.COM
POPD.COM
PUSHD.COM
PUSHPOP.SCR
RAMDRIVE.BAT
REBOOT.COM
REPEAT.COM
REPEAT.SCR
REPLY.SCR
RESET.SCR
SAV1.BAT
SAVE.BAT
SEARCH.BAT
SEARCH1.BAT
SEARCH2.BAT
SEARCH3.BAT
SPFOWARD.SCR
SPLITNAM.BAT
TEST.SCR
TESTMENU.BAT
TOA.BAT
TO_ARCH.BAT
TODAY.BAT

Appendix 2:
==========

Processing batch files
======================


In this appendix you will learn:

þ How you create batch files

þ How an autoexec.bat file works

þ How to execute a batch file

Why do we use batch files?
--------------------------

We often repeats the same keystrokes, the same errors and
commands to accomplish simple tasks. The disk operating system
MS-DOS provides the capabilities to write one or more commands
into a special file called a batch file. To execute the commands
you just have to write the name of the batch file.
All batch files has the extension BAT, but to run the file
you only have to type the name.

MS-DOS executes the batch files containing your commands
exacetely as you should have written them on your keyboard.
This is what we call a batch file process.
By the benifit of using a batch file, you only need to type
one command, instead of many. Learning how to create and run
your batch files might produce your own personal MS-DOS commands.

How to create a batch file
--------------------------

To create a batch file you can open the line editor Edlin,
or you can copy the batch file from the keyboard. To do this
you perform a copy operation using CON as the source of your
batch file's input. Or you can choose and editor like EDIT that
comes with the operating system MS-DOS. My favourite word processor
is QEDIT which provides a simple and fast method of creating an
ASCII text. Both EDIT and Qedit are excellent tools. As your batch
files grow larger, I will recommend you to use a full-screen word
processor like QEDIT.

In the demonstration below, I choose to create the batch file
by using the copy con method. Now let's take a look at a simple
example. Let's say that we will create a batch file which formats
and checks a new diskette. To begin the batch file copy operation,
type the following at the command prompt:
     
ÚÄ¿
³1³  Type the following at the C:\>
ÀÄÙ
     copy con testny.bat

     Press Enter. This command asks MS-DOS to copy
     information from the keyboard to the file testny.bat.


ÚÄ¿
³2³  Type the following lines, press Enter after each:
ÀÄÙ
     REM This file formats and
     REM checks new diskettes.
     REM The batch file is named TESTNY.BAT
     PAUSE Insert a new diskette in drive A:
     FORMAT A: /v
     CHKDSK A:


ÚÄ¿
³3³  After the last command, press CONTROL-Z or F6 and Enter
ÀÄÙ  to save the batch file. As a result, MS-DOS creates
     the batch file and displays the following message:
     "I File(s) copied".


ÚÄ¿
³4³  To execute this batch file, type the following command:
ÀÄÙ
     TESTNY


The result is the same as if the lines in the batch file
had been entered from the keyboard as single commands.


Understanding batch file processing
-----------------------------------

There are a few things you should know before you try to
run a batch process with MS-DOS.


   þ All batch files have the file extention BAT

   þ To run a batch file, you only need to type
     the filename without the extention.

   þ Press CTRL-C while you execute a batch file, if
     need to terminate the process. MS-DOS will ask your
     confirmation.

   þ If you remove a diskette containing a batch file
     which is being executed, MS-DOS will ask you to
     insert to fullfill the process.

   þ You can run one batch file within another if the name is
     stated in the last line of the batch file. The capability
     allows you to call a batch file from within another
     only until the second file completes execution. CALL and
     COMMAND /C will discussed on another place in this book.

   þ You may use any redirection operator (< > >>) in
     a batch file. If you need more information see
     below under "About Commands".

   þ Use the @ (at sign) in the beginning of a line
     in a batch file to avoid a line from being displayed.

   þ You may use a pipe redirection operator (|) in your
     batch files.

   þ Typing the name of a directory or a drive
     will affect all commands in a batch file.

   þ The of strings in environment will affect all
     commands in a batch file.

NOTE: If you have got more than one externel command in your
environment with the same name, but with different extensions,
MS-DOS will only execute one of them in the following
way, decided by file extension: .com, .exe, .bat.

Assume that your hard disk contains the files format.com and
format.bat. If you type the command format at the prompt, MS-DOS
will always run format.com first. To execute a batch file called
format.bat, this file must be loacted in a subdirectory
and you have to type the complete path.

For example, your format.bat file is located in a directory called
\commands\batch, you must type:

\commands\batch\format
to execute it.

The Autoexec.bat file
----------------------

An AUTOEXEC.BAT file allows you to automatically execute
programs when you start MS-DOS. This is useful when you
want to run a specific package (for example, certain utilities
to tests your computer's hard disk and memory) under MS-DOS,
and when you want MS-DOS to execute a batch program each
time you start your computer. You can avoid loading two
separate disks to perform either of these tasks by using
an AUTOEXEC.BAT file.

When you start your computer, MS-DOS searches the disk for
a file named AUTOEXEC.BAT. The AUTOEXEC.BAT file is a batch
file that is automatically executed each time you start the
system. It must be located in the root directory.

If MS-DOS finds the AUTOEXEC.BAT file, the file is immediately
executed and the date and time prompts are bypassed. If MS-DOS
does not find an AUTOEXEC.BAT file when you first load the MS-DOS
disk, then the date and time prompts appear

Figure 1.1 shows how MS-DOS uses the AUTOEXEC.BAT file:

     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                             FIGURE 1.1
     ³  You load         ³                             ==========
     ³  MS-DOS from disk ³
     ³                   ³
     ÀÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÙ
               ³           
     ÚÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ¿
     ³  MS-DOS looks for  ³
     ³  CONFIG.SYS        ³
     ÀÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÙ
               ³          
       ÉÍÍÍÍÍÍÍÏÍÍÍÍÍÍ»   
       º If CONFIG.SYSº       Yes -
       º exists       ÇÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
       º              º                        ³
       ÈÍÍÍÍÍÍÍÑÍÍÍÍÍÍ¼                        ³
               ³                               ³
               ³                               ³
           No  ³                     ÚÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ¿
              ³                     ³ MS-DOS            ³
               ³                     ³ configures the    ³
               ³                     ³ system            ³
               ³                     ÀÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÙ
               ³                               ³         
               ³                               ³         
               ³ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
               ³                                         
               ³                                         
     ÚÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ¿                              
     ³  Command processor ³
     ³  is automatically  ³
     ³  loaded,           ³
     ³  COMMAND.COM       ³
     ÀÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÙ
               ³                                         
     ÚÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ¿                             
     ³  Command processor  ³
     ³  looks for AUTOEXEC.³
     ³  BAT file.          ³
     ÀÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÙ                             
               ³                                         
       ÉÍÍÍÍÍÍÍÏÍÍÍÍÍÍ»                                  
       º Does it find º      No -
       º Autoexec.bat?ÇÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
       º              º                        ³         
       ÈÍÍÍÍÍÍÍÑÍÍÍÍÍÍ¼                        ³         
         Yes  ³                               ³
     ÚÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ¿         ÚÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ¿
     ³   AUTOEXEC.BAT file ³         ³ MS-DOS time and   ³
     ³   is executed       ³         ³ date prompts are  ³
     ³                     ³         ³ issued            ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ         ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

How to create an AUTOEXEC.BAT file
----------------------------------

If, for example, you want to automatically load PATH, DATE AND TIME
and run a program called MENU each time you start MS-DOS, you could
create an AUTOEXEC.BAT file as follows:

NOTE: When you create an AUTOEXEC.BAT you must remeber to locate
it in the root directory.

ÚÄ¿
³1³  Type the following command and push ENTER:
ÀÄÙ  
     copy con autoexec.bat

     This statement tells MS-DOS to copy the information
     from the console (keyboard) into the AUTOEXEC.BAT
     file. Note that the AUTOEXEC.BAT file must be created
     in the root directory of your MS-DOS disk.
ÚÄ¿
³2³  Now type the lines below:
ÀÄÙ

     PATH C:\;C:\DOS;C:\WP50;C:\NORTON;C:\BATCH;C:\UTILS
     DATE
     TIME
     KEYB NO 865 C:\DOS\KEYBOARD.SYS 
     PROMPT $p$g 

ÚÄ¿
³3³  This statement goes into the AUTOEXEC.BAT. It tells MS-DOS
ÀÄÙ  to keep a certain path in the environmentand to display
     both the date and the time. Press Ctrl-Z or F6 to put
     an end-of-file mark at the end of the file and save it
     to the disk.

When you have created an AUTOEXEC.BAT as the file above, the same
commands will run automatically whenever you start your computer
Path will be defined, you will be asked for date and time, and
the prompt will be  C:\>.

How to create a batch file with replaceable parameters
-------------------------------------------------------

There may be times when you want to create a program and run
it with different sets of data. These data may be stored in
various MS-DOS files.

When used in MS-DOS commands, a parameter is an option that
you define. With MS-DOS, you can create a batch (.BAT) file
with dummy (replaceable) parameters. These parameters,
named %0-%9, can be replaced by values supplied when the
batch file executes.

For example, when ypu type the command line:

copy con newfile.bat

the next line you type are copied from the console to a file
named NEWFILE.BAT on the default drive:

del %3.doc
copy %1.doc + %2.doc %3.doc
print %3.doc

Now press Control-Z and then press Enter. MS-DOS responds
with this message:

1 file(s) copied
C:\>

The file NEWFILE.BAT, which consists of three commands, now
resides on the disk in the default drive.

The dummy parameters %1 and %2 are replaced sequentially by
the parameters you supply when you execute the file. If
you use the dummy parameter %0, it is always replaced by the
drive name, if specified, and the filename of the batch file
(for example, NEWFILE).

NOTE:
        1. Up to 10 dummy paramters (%0-%9) can be
           specified. Refer to the MS-DOS SHIFT command if you
           want to specify more than 10 parameters. (Chapter 6.)

        2. If you use the percent sign as part of a filename
           within a batch file, you must type it twice. For
           example, to specify the file AB%.EXE, you must
           type it as AB%%.EXE in the batch file.

How to run a batch file
-----------------------
To execute the batch file NEWFILE.BAT  and to specify the
parameters that will replace the dummy parameters, you must
enter the batch filename (without its extension) followed by
the parameters you want MS-DOS to substitute for %1, %2, and
%3.

Remember that the file NEWFILE.BAT  consists of 3 lines:

del %3.doc
copy %1.doc + %2.doc %3.doc
print %3.doc

To execute the NEWFILE batch process, type

newfile a:memol b:memo2 b:bigfile

and press Enter. a:memol is substituted for %1,
b:mem2 for %2, and b.bigfile for %3.

The result is the same as if you had typed each of the
commands in NEWFILE  with their parameters, as follows:

del b:bigfile
copy a:memol + b:memo2 b:bigfile
print b:bigfile

The following table shows how MS-DOS replace each of the
above parameters:

BATCH           PARAMETER1      PARAMETER2      PARAMETER3
FILENAME           (%1)            (%2)            (%3)
----------------------------------------------------------
newfile         memol.doc       b:memo2.doc     b:bigfile

Remember that if you specofy the dummy parameter %0 in your
batch file, it is always replaced by the drive name
(if specified) and the filename of the batch file. If you
do not need to refer to the batch file, start your dummy
parameters at number %1.

This method with replaceable parameters improves your batch files,
make the more flexible and easier to use. For example, you can
create a batch file called SORTER.BAT. The file sorts a file
containing a specified sequence of characters or a string.
When you run the file to sort the batch file, you tell MS-DOS
what string you want, what file to search to find the string
and what temporary file you want to be used in sorting.
SORTER will print the result to a printer.


ÚÄ¿                                     
³1³  To create the file SORTER.BAT type the following command
ÀÄÙ  and press ENTER:

     copy con sorter.bat


ÚÄ¿
³2³  Type the following commands:
ÀÄÙ  
     type %2 | find "%1" > %3
     type %3 | sort > prn
     del %3


ÚÄ¿
³3³  Save the batch file by pressing CONTROL-Z and ENTER or F6.
ÀÄÙ  The Batch file SORTER.BAT consists of three command lines
     and is located on the hard disk.


How to use named parameters in a batch file
-------------------------------------------

In addition to ten numbered replaceable parameters, you
use named parameters in a batch file. Named parameters allow
you to define your replaceable parameters with names instead
of digits. When the referance is used in a file, the name
should be placed between two percent signs.

Named parameters are different form replaceable parameters. You
can't specify the variables at the prompt. When MS-DOS encounters
a named parameter in a batch file, MS-DOS searches its environment
for corresponding entry.

The SET command allows you to change or display the entries in the
MS-DOS environment.

For example: Assume that you want to create a batch file called
MYDEL.BAT. The batch process moves a file you want to delete
to another directory. This is a useful method to ensure yourself
that you don't delete an important file by accident.

The file MYDEL.BAT consists of the following commmands:

@ECHO OFF
ECHO Before you use the batch file you need to
ECHO specify the directory by typing the following
ECHO command at the MS-DOS prompt:
ECHO set deldir=directory
ECHO Press Control-C to terminate if you have forgotten
ECHO to set deldir or if deldir does not exist.
PAUSE
COPY %1 %deldir%
DEL %1
DIR /W %deldir%
ECHO You are finished

To get MYDEL.BAT to work you've got to create a directory
named deleted. The following command sets the directory name
to deleted:

set deldir=\deleted

To move the file CONFIG.BAK to the directory deleted, type
the following command:

mydel config.bak

The batch file replace automatically the %deldir% paramtere
with the directory called deleted.

Many users think named parameters are easier to use than
replaceable. This is because you don't have to include so much
information at the prompt. For example you don't need to type
the directory name at the prompt, but you kan still change the
directory name without editing the batch file.

How to run a batch file
-----------------------

To run the batch file SORTER.BAT type the name of the batch file
followed by the parameters you want MS-DOS to use as replacements
for  %1, %2 and %3.

If you register this book "RUN BATCH RUN" you will
receive included a disk containing files to use in
this tutorial. The file contains a list of customers
and capitals.

The file looks like this:
-------------------------

Adamsen, John                        London
Olsen, Gerd                          Copenhagen
Kvaaler, Trygve                      Oslo
Fredriksen, Peder                    Copenhagen
Hansen, Ivar                         Oslo
Dyrhaug, Arild                       Oslo
Bye, Eric                            New York
Howard James Tyler                   Los Angles
Singh, Kushwant                      New Delhi
Antin, Jean Christian                Paris
Stang, Friedrich                     Berlin
Havel, Vaclav                        Prague
Holmquist, Lasse                     Stockholm

If you need an alphabetically list of customers in Oslo
you can run SORTER.BAT, with the right parameters, and
type the following command and press ENTER:

sorter Oslo a:\custom.tut temp.fil


The outprint will look like this:

Kvaaler. Trygve                      Oslo
Hansen, Ivar                         Oslo
Dyrhaug, Arild                       Oslo

Below you'll find a table showing how MS-DOS
replace each parameter in the example above:

Batch filnavnet          (%0)        sorter
Parameter1               (%1)        Oslo
Parameter2               (%2)        A:\KUNDER.TUT
Parameter3               (%3)        temp.fil

The result would have been the same if you had written the commands
in SORTER with parameters as below:

type a:\kunder.tut | find "Oslo" > temp.fil
type temp.fil | sort > prn
del temp.fil

MS-DOS batch processes save your time and are easy to use.

Appendix 3:
===========

About the author
================

                   WHO IS FINN ROAAS?

Finn Roaas (born 1948) lives in Oslo. He is a novelist and writer
and has written both novels, short stories and computer books
One of the books is a tutorial in batch file programming.

He is a Senior Executive Officer, systemoperator, adminstrator
and teacher in computing at the School of Computing, which is
a department of the academic center DATASKOLEN in
Oslo.

He has a Bachelor of Arts degree from the University of Oslo.


             HOW TO REGISTER YOUR RUN BATCH RUN BOOK
             =======================================

The Run Batch Run is changing all the time. It's dynamic.
The book will be changed and altered when the author gets
new things he finds interesting and wants to share with
other users. If you have got ideas, intersting programs please
send me a note or an email to froaas@online.no. Your
registration will support the research of this book, which
is something a do in my leisure time. When I tired of writing
and teaching and just want to relax with a glass of wine, I
work with the Run Batch Run book. It takes my mind to something
different, I need problems to keep me occupied. Your
registration will support the research of new material
and what it costs to maintain this book.
 
You can register your current copy, or subscribe for six
updates. Details are given below.

==============================================================================

    Please remit to:

    Finn Roaas
    Postboks 75 - Furuset
    N-1001 Oslo
    Norway (Europe)


    Please add me as a supporter of THE RUN BATCH RUN BOOK:

    Name    ______________________________________________________________

    Company ______________________________________________________________

    Address ______________________________________________________________

            ______________________________________________________________

    City    ________________________________State _______ Zip ____________

    Country ________________________________

    Email address  ______________________________________________________


    Please mark off your selections with (x) below:


    Basic registration for individuals:
    -----------------------------------

    (  ) NOK 100.00   For payment
                      (ca.US$ 15.00)
                      A Companion disk is included first time you
                      register!
    Option for Basic Registration - for individuals
    -----------------------------------------------
    (  ) US$  2.00    Add to have a copy of the most recent version
                      of the book sent to you on diskett. Only for
                      registered subscribers!
                      (In Norway, NOK 10.00)

                     (  ) 5.25" MS-DOS disk   (  ) 3.5" disk 720KB MS-DOS

    Wants diskett with all files listed in the book
    -----------------------------------------------
    ( ) US$ 8.00      Companian Disk To Run Batch Run
                      (In Norway, NOK 50.00)

    Registration of Six Updates - for individuals
    ---------------------------------------------
    
    (  ) US$ 80.00 NOK 480.00

                      Six updates of the book will be sent to you by mail.

    ( ) US$  60.00    For all method of payment (No shipping.)
                      The reader retrieves all new updates emailed
                      on Internet. Six updates.

    ( ) US$  50.00    When renewing your subscription for six new updates.

    Amount ____________________ Date   _______________

    (  )  Check or money order payable to Finn Roaas in U.S. funds enclosed
    (  )  SWIFT transfer to 6065.56.31588 (Kredittkassen, Norway)
    (  )  SWIFT transfer to 0521 1589665 Postbanken, Norway
    (  )  VISA    (  )  MasterCard    ( ) American Express
    (  )  Diners Club


    Credit card number __________________________________ Exp date _______




  Note: You should not send your credit card number by email, unless
        the data is sent in PGP encrypted form. For information about
        how to do this, read the instruction at the end of this book.

    Discounts for schools and public libraries
    ------------------------------------------
    Special rates available for schools and public libraries. For details,
    send a message to froaas@online.no

    (  ) Please identify what type of discount you are taking advantage of:

         Ref: ______________

         Description: ____________________________________________________

                      ____________________________________________________


    Note: You should not send your credit card number by email, unless
          the data is sent in PGP encrypted form. For information about
          how to do this, read the instruction at the end of this 

    Note: All credit card orders given in US$ will be converted to NOK
          using the current exchange rate. My local card companies require
          charges to be made in Norwegian currency. Then, the amount will 
          be converted to your local currency by your card operator at
          their exchange rate prevailing at the time of transaction.


  Feedback
  --------
  If you already have an evaluation copy of the book, where did you get it? 

  ________________________________________________  Version number: ____



  Comments or suggestions for improvement of The Run Batch Run book __________
  
  ______________________________________________________________________
  
  ______________________________________________________________________
  
  ______________________________________________________________________
  


    Date ___________________

    Signature _________________________________


  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
  ³  T H A N K   Y O U   F O R   S U P P O R T I N G   S H A R E W A R E  ³
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


How to send your registration using PGP encryption 
--------------------------------------------------

To use this method, you must have a copy of the freeware program PGP 
(Pretty Good Privacy) by Philip Zimmermann. It is available for MS-DOS, 
VAX/VMS, Unix, and other computers. 
 
Various versions of this program can be retrieved from online services all 
over the world. If you have access to the Internet, use Archie to locate a 
recent version. I am currently using version 2.6. You can get a copy from
the following Web address:



Follow these steps to encrypt your registration form (you may be able
to do this _without_ reading the documentation): 

Step 1
------
Store your completed registration form on your disk using the file name
ORDER.FRM. 

Cut out the text below, and store it using the file name RBATCH.ASC.
*----BEGIN PGP MESSAGE-----
Version: 2.6.2i

hGwDrWZ/13dqk6kBAwDDocsxAj7ezNKDdlEzY9Z3OXaCm6XG6QH7MRlSUzixFlkl
tgQcUZY7iGIscKSqy5Qos2NOAUiUl9TJmmAQjhf3h1/pcy0/w18fJ6xZV13TrmnV
X+hJHTZW75rQrxLXZWemAAAAMiC+qEdIteLTu9SpWi/jl6td3Aib1gDQi715SOV+
JGAJo/SrFoI1KnlJgtuE+sgGXKRX
=B2hL
*----END PGP MESSAGE-----

Remove the asterisk ()* character at the beginning of the first and last 
lines of the PGP Public Key before adding it to your keyring. For example,
the line

   *-----BEGIN PGP PUBLIC KEY BLOCK-----

should be changed to

   -----BEGIN PGP PUBLIC KEY BLOCK-----

Do the same with the last line.

Step 2
------
Add RBATCH.ASC to your public keyring using the command:

  pgp -ka rbatch.asc

Step 3
------
Encrypt ORDER.FRM using the command

  pgp -ea order.frm froaas@online.no

The resulting file will be called ORDER.ASC.

Step 4
------
Send ORDER.ASC by email to froaas@online.no.









  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
  ³  T H A N K   Y O U   F O R   S U P P O R T I N G   S H A R E W A R E  ³
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ




980401FR



