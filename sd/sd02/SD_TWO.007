
                _____ _____     ___
    _,┌\/┐  :░  :░     :░ ╓ social distortion all about vx-scene ╖
 ,4\┘¤"``"¤┘  ll  l¤`     ll  ::;;;::;;....  ....:;..: ::...;.:;;;:;
:░(_          |    ___    ll ._
 `└/|│S|/┐,_ |¤`┌\╙¤"¤╜/:: |╓,._  Использование "сильных"
_____ ``^"¤└/L, d7┘` ___  7l:;%%|.$| криптографических алгоритмов
$$$$|_ | `7;?( |asd| :: |$$$|$| в вирусах [2000]
$$$$|/┌,.__,┌\:`4│/┐,_  _ll  ``''""¤¤┘┘ by Uncle Fucker
$$$$|`└/|││|\┘`   `¤└/│:


   Сейчас  "стойкие"  криптографические алгоритмы  используются,  буквально,
 везде. Я  никогда  не думал о возможности  их  использования  в  вирусах...
 Однако, прочитав описание вируса  W32/HYBRIS [B,C]  от Sophos,  эта контора
 утверждает, что тело червя (а также его апдейты) "зашифрованы 'сильным' 128
 битным криптографическим алгоритмом", я призадумался.

   Автора я не знаю, вирусного бинарника у меня  нет, поэтому, узнать так-ли
 это, и что за алгоритмы используется в черве, я несмог.  Немного  раньше  я
 читал описание вирусов от этой  конторы - например  W32/BYMER  они называли
 WORM.RC5  (как криптографический алгоритм),  бинарника этого "чуда"  ;))  у
 меня тоже нет, поэтому остается только догадываться.


   Как раз сделав одну интересную вещичку,  я писал для нее мутейшн. Однако,
 прочитав  описание  Hybris'а, я подумал, может стоит плюнуть  на  движок  и
 реализовать какой-нибудь из  простеньких  криптографических  алгоритмов для
 продукта. Сказано - сделанно, я  выбрал  RC4  из-за его простоты  и перевел
 исходник с C на assembler (исходники представленны ниже).

   Т.к.  мой   продукт   использовал    очень  оригинальный   (новый)  метод
 распространения, использование  RC4 было большим плюсом.  Алгоритм позволял
 использовать ключ до 256 байт, причем он (ключ)  должен  находиться  либо в
 теле червя, либо, в каком-то файле.


  ---        плюсы использования strong cryptographic algorythm          ---

   Написанный  мной  продукт  оставался  на машине  (скрывался в 2 местах) и
 распространялся только с помощью почты. Он, как бы, состоит из двух частей:

                             ───   "шпион"   ───

   Списав "спрятанные" вирусные файлы и запустив на другой машине заразиться
 было нельзя, т.к. в  дропперах  контролирующих распространение "зараженной"
 почты, ключ не содержался, он  находился  в том же  каталоге,  но отдельном
 файле и если этот файл  будет  поврежден  или стерт  -  продукт  перестанет
 работать (естественно не завесив систему, а просто тихо передав управление)
 это конечно плохо.  Но,  с другой  стороны, это  антиевристика  и  продукту
 такого типа очень важно, что бы его не смогли обнаружить и удалить.

                         ───   "разносчики заразы"   ───

   С дропперами,  рассылаемыми  по почте продуктом,  было немного подругому.
 Они  должны  содержать  ключ  в  своем  теле,  т.е. должны заразить "машину
 по любому". Это их единственная миссия.


  ---                исходники в пример к статье                         ---

   rc4ex.asm - пример использования алгоритма rc4
   rc4.inc   - файл с процедурами алгоритма rc4
   key.asc   - пример ключа

   Исходники не содержат достаточное количество комментариев, но разобраться
 в нем очень просто. Советую почитать статейки про этот алгоритм, посмотреть
 его исходники на c/pascal (кому, что ближе).


───[rc4ex.asm]───────────────────────────────────────────────────────[start]──
;
; RC4_SCA (x) 2000
;
; compile
; ───────
; tasm /m rc4ex.asm
; if exist rc4ex.obj tlink /t /x rc4ex.obj
; if exist rc4ex.obj del rc4ex.obj >nul
;
;
.model          tiny
.code
 org            256
;───────────────
 code_size             equ (data_end-data_start)
 rc4_key_len           equ (rc4_key_end-rc4_key_start)
;───────────────
 start:         sub     bp,bp
                mov     di,(code_size)
                lea     si,[bp+data_start]
                call    calculate_crc
                mov     word ptr [bp+crc],ax

 crypt_code:    mov     dx,(rc4_key_len)        ; длина ключа
                lea     si,[bp+rc4_key_start]   ; ключ
                call    rc4_exp_key

                mov     dx,(code_size)
                lea     si,[bp+data_start]
                call    rc4_crypt
;───────────────
 decrypt_code:  mov     dx,(rc4_key_len)        ; длина ключа
                lea     si,[bp+rc4_key_start]   ; ключ
                call    rc4_exp_key

                mov     dx,(code_size)
                lea     si,[bp+data_start]
                call    rc4_crypt
;───────────────
 check_code:    mov     di,(code_size)
                lea     si,[bp+data_start]
                call    calculate_crc
;
                cmp     word ptr [bp+crc],ax
                jz      decrypted_ok
;───────────────
 decrypted_er:  mov     ah,9
                lea     dx,[bp+msg_decrypted_ok]
                int     21h
                jmp     exit_to_dos
;───────────────
 decrypted_ok:  mov     ah,9
                lea     dx,[bp+msg_decrypted_ok]
                int     21h
;───────────────
 exit_to_dos:   sub     ax,ax
                int     16h

                mov     ax,4c00h
                int     21h
;─────────────────────────────────────────────────────────────────────────────
 data_start     label   byte
                        db '          Желтая масса наполняет страну,',13,10
                           '         Нашу культуру хотят уничтожить!',13,10
                           '         Но есть патриоты, они не умрут,',13,10
                           ' Будут гнать из страны всех этих желтых!',13,10
                           '                               ─────────',13,10
                           '                               (с) Штурм',13,10
 data_end       label   byte
;─────────────────────────────────────────────────────────────────────────────
 crc                    dw ?
 msg_decrypted_ok       db 'Code decrypted ok$'
 msg_decrypted_er       db 'Code decrypted not correct$'
;─────────────────────────────────────────────────────────────────────────────
 include                key.asc
 include                rc4.inc
;─────────────────────────────────────────────────────────────────────────────
                end     start
;─────────────────────────────────────────────────────────────────────────────
───[rc4ex.asm]─────────────────────────────────────────────────────────[end]──
                                    * * *
───[rc4.inc]─────────────────────────────────────────────────────────[start]──
;─────────────────────────────────────────────────────────────────────────────
; rc4_exp_key - generate key
;
; on start  ds:dx - key size (256)
;           ds:si - key location
;           ds:bp - current ip
;
 rc4_exp_key:   push    ax cx bx di bp sp
                mov     dh,dl                   ; keylenTmp = keylen
;
                sub     ax,ax                   ; y = 0
                sub     di,di                   ; di = ax
;
                sub     bx,bx                   ; x = 0
 init_loop:     push    bx
                add     bx,bp
                mov     byte ptr [bx+rc4_key],bl ; rc4key[x]=x
                pop     bx
                inc     bl                      ; x++
                jnz     init_loop
;
 key_loop:      push    bx
                add     bx,bp
                mov     cl,byte ptr [bx+rc4_key] ; sx = rc4_key[x]
                pop     bx
                add     al,byte ptr [si]        ; y += key[keypos]
                add     al,cl                   ; y += sx
                push    ax
                pop     di                      ; di = ax
;
                mov     ch,byte ptr [di+bp+rc4_key] ; temp = rc4_key[y]
                push    bx
                add     bx,bp
                mov     byte ptr [bx+rc4_key],ch ; rc4key[x] = temp
                pop     bx
                mov     byte ptr [di+bp+rc4_key],cl ; rc4key[y] = sx
                inc     si                      ; ++keypos
                dec     dh                      ; keylenTmp--
                jnz     no_reset_keypos         ; if(!keylenTmp)
;
                sub     si,dx                   ; keypos = 0
                mov     dh,dl                   ; keylenTmp = keylen
;───────────────
 no_reset_keypos:
                inc     bl                      ; x++
                jnz     key_loop
;
                mov     byte ptr [bp+rc4_x],bl  ; rc4->x = 0
                mov     byte ptr [bp+rc4_y],bl  ; rc4->y = 0
                pop     sp bp di bx cx ax
                ret
;─────────────────────────────────────────────────────────────────────────────
; rc4_crypt - crypt data with rc4
;
; on start  ds:dx - data size
;           ds:si - data location
;           ds:bp - current ip
;
 rc4_crypt:     push    ax cx bx di bp sp
                or      dx,dx                   ; if len == 0, exit
                jz      rc4_ret

                sub     ax,ax                   ; ax = rc4.y
                sub     bx,bx                   ; bx = rc4.x
                sub     di,di
                mov     al,byte ptr [bp+rc4_y]
                mov     bl,byte ptr [bp+rc4_x]
;───────────────
 rc4_crypt_lp:  inc     bl                      ; x++
                push    bx
                add     bx,bp
                mov     cl,byte ptr [bx+rc4_key] ; sx = rc4_key[x]
                pop     bx
                add     al,cl                   ; y += sx
                push    ax
                pop     di                      ; di = ax
                mov     ch,byte ptr [di+bp+rc4_key] ; sy = rc4_key[y]
                mov     byte ptr [di+bp+rc4_key],cl ; rc4_key[y] = sx
                push    bx
                add     bx,bp
                mov     byte ptr [bx+rc4_key],ch ; rc4_key[x] = sy
                pop     bx
                add     cl,ch
                sub     ch,ch
                push    cx
                pop     di                       ; di = cx
                mov     cl,byte ptr [di+bp+rc4_key]
                xor     byte ptr es:[si],cl      ; *data ^= rc4key[temp]
                inc     si                       ; data++
                dec     dx                       ; len--
                jnz     rc4_crypt_lp

                mov     byte ptr [bp+rc4_x],bl
                mov     byte ptr [bp+rc4_y],al

 rc4_ret:       pop     sp bp di bx cx ax
                ret
;─────────────────────────────────────────────────────────────────────────────
; calculate_crc - calculate crc 16
;
; on start  ds:si - data
;           ds:di - size of data
;
; on end    ds:ax - crc16
;
 calculate_crc: cld
                push   cx dx bx si
                mov    cx,-1
                mov    dx,cx

 next_byte:     sub    ax,ax
                sub    bx,bx
                lodsb
                xor    al,cl
                mov    cl,ch
                mov    ch,dl
                mov    dl,dh
                mov    dh,8

 next_bit:      shr    bx,1
                rcr    ax,1
                jnc    no_carry
                xor    ax,8320h
                xor    bx,0edb8h

 no_carry:      dec    dh
                jnz    next_bit
                xor    cx,ax
                sub    dx,bx
                dec    di
                jnz    next_byte
                not    dx
                not    cx
                mov    ax,dx
                ror    ax,cl
                add    ax,cx
                pop    si bx dx cx
                ret
;─────────────────────────────────────────────────────────────────────────────
 rc4_x                  db 0
 rc4_y                  db 0
 rc4_key                db 256 dup (?)
;─────────────────────────────────────────────────────────────────────────────
───[rc4.inc]───────────────────────────────────────────────────────────[end]──
                                    * * *
───[key.asc]─────────────────────────────────────────────────────────[start]──
rc4_key_start   label   byte
                        db 'mQENAzmHx+YAAAEIAN7+b0mGO9feYybiICWS36DcXf8XU9eCOfrPy4O7Rt+c821Y'
                        db 'DpNM0RpBaVwmK9ohmxOnWne/1Hx/95hmNlaEHzRz8LJc0PyUcGpnBQ0Kf1cathwn'
                        db 'LOpwtxdQ9GqWgwuwaY1SzqIvWMf73EaqBqRRgukdLqbV2kkS6rtIBVLMVZ4esm9D'
                        db 'BfKzk3ubF6GWvHVrHKb0ZJkJ4OHCZRrxdygh3o6CSAni8w/adOk4oGVEI+Nqpses'
rc4_key_end     label   byte
───[key.asc]───────────────────────────────────────────────────────────[end]──

                                                       (x) 2000 Uncle Fucker