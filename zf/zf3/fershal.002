▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
▓▓▓┌──────────────────────────────────────────────────────────────────────┐▓▓▓▓
▓▓▓│                                       ▄ ▄                            │░░▓▓
▓▓▓│ ▄██▄ ▄██▄  █ █  ▄▀▀▄ █  █ █  █ █▐▌█  ▄▄█▄▄ ▄██▄ █▀▀▄ █ █ █ ▄▀▀█ ▄▀▀█ │░░▓▓
▓▓▓│ ▄▄▄█ █▄▄▄ █ █ █ █    █  █ █  █ █  █  █ █ █ █▄▄▄ █  █ █ █ █ █  █ █  █ │░░▓▓
▓▓▓│ ▄▄▄█ █▄▄▄ █ █ █ █  ▄ █▄▀  █  █ █  █  █▄█▄█ █▄▄▄ █▀▀  ▀▄▀▄▀ █▄▄█ █  █ │░░▓▓
▓▓▓│  ▀▀   ▀▀  ▀ ▀ ▀  ▀▀  ▀ ▀▀  ▀▀▀  ▀▀▀    ▀    ▀▀  ▀     ▀ ▀  ▀  ▀ ▀  ▀ │░░▓▓
▓▓▓├──────────────────────────────────────────────────────────────────────┤░░▓▓
▓▓▓│                            В ы п у с к ∙3∙                           │░░▓▓
▓▓▓└──────────────────────────────────────────────────────────────────────┘░░▓▓
▓▓▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
                    Мутационные технологии
                            by JHB

             ( Вольный перевод - DrMad, 1998 г. )

    Как только я впервые услышал про идею Мутационной Техноло-
гии,  я заинтересовался в том,  чтобы увидеть код, который мог
бы объяснить - как может работать фрагмент непостоянного кода.
Я заимел несколько вирусов,  но большинство Мутационных Техно-
логий  в соответствии с их природой были сложны для дизассемб-
лирования. Так, после знакомства с кодом других авторов, я ре-
шил   попытаться   приложить   свои   ручонки   к  этому  типу
программирования.  Данная статья проиллюстрирует путь, который
я избрал при разработке и реализации Мутационной Технологии.

    Для начала  я попытаюсь определить,  что такое Мутационная
Технология,  ее код, который может быть прилинкован или просто
присоединен к обычной программе или вирусу. Она:

    1. Расшифровывает себя,  также, как и программу, к которой
прилинкована.
    2. Создает  Расшифровщик,  который будет выполняться перед
основной программой.
    3. Каждый Расшифровщик, который она создает, имеет различ-
ные сигнатуры.

    Хорошо, теперь давайте разъясним это определение, сигнату-
ра (когда говорят о коде) - это фрагмент кода,  который должен
быть уникальным для этого кода.  Примером может служить сигна-
тура:

        EA 05 00 C0 07

    Которая является 16-ричным кодом для команды

        jmp     07c0:0005

    Это (как могут отметить многие) - первая строка кода виру-
са Stoned, хотя даже и этот маленький кусочек кода, помещенный
в начале  загрузочного сектора,  используется многими а/в про-
дуктами, как признак. (Далее не проверялось).

    Простейшая Мутационная Технология  состоит  в  том,  чтобы
полностью заменять код на другой, делающий то же самое, но это
увеличило бы размеры Технологии.  Создатели Мутационных Техно-
логий изобрели более легкий способ,  заключающийся в том,  что
они шифруют основной код и Технологию, затем делают расшифров-
щик первым выполняющимся фрагментом.

    Это означает,  что единственая сигнатура,  которая  должна
изменяться - это расшифровщик,  и это основной тип современных
Технологий.

    Первой частью процесса создания является генерация шифров-
щика/расшифровщика,  который должен выполнять достаточно прос-
тую  шифровку.  Я игрался со стандартными xor/add/sub,  но они
вскрываются немедленно расшифровщиками TBAV и F-prot. Поскльку
основная  идея  Мутационной  Технологии - обдуривать и людей и
сканеры,  то это не самый лучший путь.  Во время чтения конфе-
ренций usenet я обнаружил упоминание шифровки, которая исполь-
зует shl/shr.  Многие могут быть удивлены, если Вы используете
shl/shr,  поскольку либо старший,  либо младший бит пропадают,
но это не совсем так, ибо они помещаются в флаг carry. Простым
добавлением этого бита к концу или началу регистров (или слов)
вы можете поиметь реверсивную шифрацию.  Сейчас TBAV обнаружи-
вает  большинство  таких шифровок,  исключая четные количества
сдвигов типа 2,4,8, в то время как F-prot, кажется, пропускает
большинство  их  (только  при  эвристическом  анализе  и ключе
/paranoid ). ( Говорят, это потому чо shl 2,4, 8 может исполь-
зоваться  для быстрого умножения или деления,  так что TBAV не
отмечает это как шифровку). Итак, я немедленно использовал это
для шифровки

             mov bx,offset virus_code
decrypt:
             mov     cx,4        ; ключ шифрации
             mov ax,cs:[bx]      ; взять слово для шифровки
again:
             clc                 ; не нужно, но я был юн, сорри :-)
             shl     1           ; ок, т.к. код перед этим был
                                 ; ax 1000 0000 0000 0000 cf = 0
                                 ; после shl
                                 ; ax 0000 0000 0000 0000 cf = 1
             jnc     no_high_bit ;
             inc     ax          ; это просо делает ax =
                                 ; ax 0000 0000 0000 0001
no_high_bit:
             dec     cx
             jcxz    done_unencr ; нормально завершено, двигаем дальше
             jmp     short again ; двигаем дальше
done_enencr:
             mov     cs:[bx],ax  ; Запоминаем расшифрованный код
             add     bx,2        ; двигаем наш указатель
             dec     dx          ; проверяем, сколько осталось
             jnz     decrypt

virus_code:

    Ок, теперь у нас есть расшифровщик, который использует shr
и Вы имеете шифрующую процедуру ( она в коде, который Вы чита-
ете ;) ).

    Все нормально до этого момента, поскольку у меня есть шиф-
рующая Технология, которая будет обдуривать TBAV и F-prot (вне
зависимости от того, что Вы используете f-prot /paranoid, чего
даже и не делают обычные средние пользователи),  но это не Му-
тационная Технология.  Дык,  простейшая мутация состоит в том,
чтобы изменять регистры, это простейшая вещь всего лишь требу-
ет небольших исследований или хорошей  книжки  по  ассемблеру.
Все команды ассемблера строятся по образцу

                        push    ax          что в 16-м будет
                        50h  или 1001 0000b
                                            теперь
                        push    bx          имеем
                        53h  или 10010 011b

    Обратите внимание,  что 3 последних  бита  -  единственная
вещь, которая изменяется при изменении словных регистров

                        ax = 000  0
                        cx = 001  1
                        dx = 010  2
                        bx = 011  3
                        sp = 100  4
                        bp = 101  5
                        si = 110  6
                        di = 111  7

    ОК, при  помощи простейших команд and/or мы можем изменить
регистры на другие,  и, конечно, мы должны менять их случайным
образом, проверяя,  какие  мы  уже использовали и имея в виду,
что мы заменяем все bx на cx.

    В этом месте некоторые люди начнут путаться, потому что мы
начинаем готовить исполнимый код,  к которому намереваемся об-
ращаться, как к данным. Посмотрите на примерчик:

                mov     cx,0004         ;b90400h

превращается в

shift_reg:
                db      0b9h            ;10111 001  <- cx
                dw      0004

    Теперь мутация для этого кода может выглядеть как

                mov     ax,[shift_reg]    ;
                and     ax,11111000h      ; это изолирует
                                          ; команду mov
                or      ax,00000111       ; это готовит команду
                                          ; mov di

    Лучший способ заключался бы в генерации случайных  чисел и
извлечении  числа  в границах 0-7,  затем в операции OR его на
использованную мной константу.  Конечно, вы должны отслеживать
регистры, котолрые вы уже использовали и какие только собирае-
тесь.

    Теперь, используя эту технику,  мы  получили  ограниченную
Муnационную Технологию, но не забудьте, что F-prot все еще ло-
вит ее.  Следующая простая мутация заключается в использовании
недокументированной формы команды shl.

        shl AX,1        D1 E0    1101 000 1 1110 0000 <-Обычно
        SHL AX,1        D1 F0    1101 111 1 1110 0000 <-Недокум

        SHL AX,1        C1 E0 01                      <-Обычно
        SHL AX,1        C1 F0 01                      <-Недокум


        D1 F0           <-Кажется, FP и TB не найдут это

    Теперь несколько  необычная  часть:  пока весь приведенный
код делает аналогичные вещи, сдвигаем биты в регистре АХ влево
при помощи  F0h,  что не поддерживается большинством ассембле-
ров. ( Тем не менее, я читал про шареварный ассемблер, который
может использовать эти коды,  и, вероятно, трассировщик, пони-
мающий такой код).  Использование "недокументированной"  формы
будет обдуривать F-Prot каждый раз, но на байты C1 F0 01 будет
вставать TBAV-флажок (как же я люблю этот  флажок) "Обнаружена
по крайней мере одна инструкция,  которая требует налиция про-
цессора 80186 или выше". Как будто бы после 8086 в систему ко-
манд не добавлялись новые инструкции!! Но для сгененированного
вирусного кода это не тот флаг,  который вам хотелось  бы  ви-
деть. И вообще,  любой флаг,  которого там нет, будет вызывать
проблемы.

    ОК, итак  мы  имеем  простую мутацию простого реверсивного
шифровщика и как минимум 4 формы  расшифровывающего  кода,  не
содержащего мутации регистров. Следующая часть - это примочка,
которая ничего не делает,  или мусорный код.  Эту  фигню  надо
вводить  в действие осторожно.  Мусорные инструкции или Беспо-
лезные байты - это те,  которые делают нечто, но это не влияет
на ваш код. Примеры такого кода - команды NOP и XCHG AX, AX. В
прежние времена мутационных технологий и эвристических  скане-
ров простое добавление NOP-ов и XCHG делало вирус устойчивым к
сканированию. Но по мере того, как сканеры совершенствовались,
они научились не обращать внимания на мусорный код или предуп-
реждать юзера,  что имеется код, кторый не может служить ниче-
му,  кроме как сокрытию вируса. И снова я считаю, что вы могли
бы использовать некоторые из этих идей,  но имейте в виду, что
два или более NOP-а подряд возбудят TBAV. Итак, я подумал, что
вместо использования однобайтовых  инструкций,  почему  бы  не
иметь процедурок, которые используют вызовы прерываний. Просто
найдите такие,  которые не влияют на многие регистры, или сох-
раняйте/восстанавливайте регистры, это не повлияет на реальный
код. Пример:

noise_6:
        push    ax           ;1 для использования сдвигов
        mov     ax,0200h     ;3 достаточно сохранить и восста-
        int     16h          ;2 новить AX
        pop     ax           ;1
end_noise_6:

    Используйте эти идеи совместно, и вы можете получить инте-
ресный фрагмент кода, который будет генерировать различные ва-
рианты расшифровщиков. А мне больше и не нужно. Если вам дейс-
твительно интересно,    как    хулиганить   с   использованием
Мутационных Технологий,  разберите несколько исходничков и по-
пытыйтесь сделать что-нибудь свое. Даже если вы обломитесь при
производстве работоспособной Мутационной Технологии, вы пойме-
те про них очень многое.  Я,  вообще, и не собирался делать из
моего кода реальную технологию, это только примерчик - и все.
