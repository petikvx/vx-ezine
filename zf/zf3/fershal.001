▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
▓▓▓┌──────────────────────────────────────────────────────────────────────┐▓▓▓▓
▓▓▓│                                       ▄ ▄                            │░░▓▓
▓▓▓│ ▄██▄ ▄██▄  █ █  ▄▀▀▄ █  █ █  █ █▐▌█  ▄▄█▄▄ ▄██▄ █▀▀▄ █ █ █ ▄▀▀█ ▄▀▀█ │░░▓▓
▓▓▓│ ▄▄▄█ █▄▄▄ █ █ █ █    █  █ █  █ █  █  █ █ █ █▄▄▄ █  █ █ █ █ █  █ █  █ │░░▓▓
▓▓▓│ ▄▄▄█ █▄▄▄ █ █ █ █  ▄ █▄▀  █  █ █  █  █▄█▄█ █▄▄▄ █▀▀  ▀▄▀▄▀ █▄▄█ █  █ │░░▓▓
▓▓▓│  ▀▀   ▀▀  ▀ ▀ ▀  ▀▀  ▀ ▀▀  ▀▀▀  ▀▀▀    ▀    ▀▀  ▀     ▀ ▀  ▀  ▀ ▀  ▀ │░░▓▓
▓▓▓├──────────────────────────────────────────────────────────────────────┤░░▓▓
▓▓▓│                            В ы п у с к ∙3∙                           │░░▓▓
▓▓▓└──────────────────────────────────────────────────────────────────────┘░░▓▓
▓▓▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓

╔══════════════════════════════════════════════════════════════╗
║A GENERAL DESCRIPTION OF THE METHODS BEHIND A POLYMORPH ENGINE║
║                      (C) The Black Baron                     ║
║                                                              ║
║ОБЩЕЕ ОПИСАНИЕ МЕТОДОВ, ИСПОЛЬЗУЕМЫХ В ПОЛИМОРФНЫХ ТЕХНОЛОГИЯХ║
║           ( Вольный перевод - (с) DrMad, 1998 )              ║
╚══════════════════════════════════════════════════════════════╝

    ***> ( Прим.  переводчика:  написано шикарным строгим анг-
лийским языком,  явно Black Baron - не обкуренный сопливый па-
цан. :-) ) <***

    Этот документ  пытается  снабдить введением в работу Поли-
морфной Технологии. Имеется в виду, что вы знакомы с ассембле-
ром 8086 и логическими функциями XOR,  AND и OR. Чтобы на этом
закончить,  никаких объяснений или логики ассемблера в  тексте
не  будет!  Также обратите внимание,  что описатель SEGMENT не
будет включен ни в один ассемблерный листинг, так что подразу-
мевается, что вы сами знаете - как их заюзать. Методы, описан-
ные в этом документе, используются в моей Мутационной Техноло-
гии SMEG (Simulated Meramorphic Encryption Generator) и это не
означает, что это единственный способ делать это.

    Маленький глоссарий терминов из этого документа:
    ────────────────────────────────────────────────

    КОДИРОВАНИЕ   = Трансформация из оригинальной в альтерна-
                    тивную форму.
    ДЕКОДИРОВАНИЕ = Трансформирование из альтернативной формы
                    в оригинальную.
    КЛЮЧ          = Регистр или значение, используемые для
                    кодирования/декодирования.
    СКОЛЬЗЯЩИЙ      Ключ, значение которого увеличивается или
    КЛЮЧ          = уменьшается от цикла к циклу.
    СЧЕТЧИК       = Количество байтов в кодируемом коде или
                    данных.
    ИНДЕКС        = Указатель на кодируемый код или данные.
    СИГНАТУРА     = Уникальная группа байтов, которая может
                    быть использована для детектитрования
                    определенных программ.
    ЭВРИСТИКА     = Множество тщательно разработанных правил,
                    применяемых для достижения известного
                    результата.

    Вопрос: Что такое Полиморфность?
    ────────────────────────────────

    Ответ: Дык, Лонгмановский Английский Словарь определяет:

    "ПОЛИМОРФНЫЙ или ПОЛИМОРФИЧНЫЙ - прилагат., формальн., на-
учн. - СУЩЕСТВУЮЩИЙ В НЕСКОЛЬКИХ РАЗЛИЧНЫХ ФОРМАХ."

    Иными словами,  нечто, что имеет способность изменять свою
форму.  По-другому можно определить это как: Мутирующий, Мета-
морфичный и пр.

     Вопрос: Что такое Полиморфная Технология?
     ─────────────────────────────────────────

    Ответ: Программа со способностью кодировать (или перемеши-
вать) другую программу или данные  и  снабжать  их  уникальным
расшифровщиком, и все это дожно приводить к тому , чтобы ника-
кие два зашифрованных варианта одной программы или  данных  не
выглядели одинаковыми.

    Пример: Рассмотрим следующий суперпростой расшифровщик:

           MOV      SI,jumbled_data  ; Указатель на шифруемые
                                     ; данные
           MOV      CX,10            ; Расшифровываем 10 байт
main_loop: XOR      BYTE PTR [SI],55 ; Расксориваем байт
           INC      SI               ; Следующий байт
           LOOP     main_loop        ; Цикл для остальных
                                     ; байтов

    Эта маленькая программулька будет ксорить числом 55 десять
байтов в позиции, на которую указывает SI. Если еще раз заксо-
рить этот фрагмент числом 55,  то байты восстановятся  в  свое
исходное состояние.  Если вы не уверены в этом, освежите в па-
мяти сведения по работе операции XOR.

    ОК, теперь вы могли бы сказать,  что если вы изменяете ве-
личину KEY каждый раз,  то у нас получился Полиморфик?  И да и
нет.  Если вы так сделали,  то зашифрованная часть должна быть
Полbморфичной,  но расшифровщик оставался бы одним и  тем  же,
разве что изменялась бы величина KEY. Таким образом, сигнатур-
ный сканнер (*1*), который работает с WILDCARDS (*2*) по преж-
нему находил бы ваш расшифровщик.

    Одним способом,  которым вы могли  бы  обдурить  некоторые
сигнатурные сканнеры, является обмен местами для некоторых ко-
манд. Итак, имея это в виду, наш расшифровщик мог бы выглядеть
так:

               MOV      CX,10
               MOV      SI,jumbled_data
main_loop:     XOR      BYTE PTR [SI],55
               INC      SI
               LOOP     main_loop

    Как вы  можете видеть,  по прежнему изменения невелики,  и
это не сможет запутать некоторые из хороших сигнатурных  скан-
неров.

  "ФИГНЯ!  ЧТО ТАКОЕ НАСТОЯЩИЙ ПОЛИМОРФИЗМ?" - слышу крики!
  ─────────────────────────────────────────────────────────

    Ладно-ладно, "настоящий" Полиморфик должен  иметь  расшиф-
ровщик, который  полностью  различен каждый раз!  Взгляните на
следующий расшифровщик:

               MOV      CX,10
               NOP
               NOP
               MOV      SI,jumbled_data
               NOP
main_loop:     NOP
               NOP
               XOR      BYTE PTR [SI],55
               NOP
               INC      SI
               NOP
               NOP
               NOP
               NOP
               LOOP     main_loop

    Этот расшифровщик похож на предыдущий, но он содержит слу-
чайное количество команд NOP, внедренных внутрь. Каждый раз вы
должны изменять количество NOPов после каждой команды. Это По-
лиморфизм в его простейшей форме. Но все еще многие из хороших
сигнатурных сканеров не будут иметь проблем с  такими простыми
Полиморфиками. Они просто должны пропускать NOPы,  что откроет
им глаза на реальный расшифровщик,  так что они  теперь  опять
могут использовать сигнатуры.

    Нет, "истинный"  полиморфик  должен  быть го-о-раздо более
сложным, чем этот.  Вместо вставки NOPов внутрь  расшифровщика
он должен  засовывать абсолютно случайное количество абсолютно
случайных команд процессора 8086,  включая JUMPы и  CALLы.  Он
должен также  использовать  расзличные  основные расшифровщики
(возможно, выбирая из заранее подготовленных) и  должен  изме-
нять все регистры, которые расшифровщик использует каждый раз,
учитывая, что генерируемый МУСОРНЫЙ код не  портит  любые  ре-
гистры, используемые  настоящим расшифровщиком.  Итак,  имея в
виду эти правила, вот новый наш простой расшифровщик:

          MOV      DX,10            ;Часть настоящего расшифровщика
          MOV      SI,1234          ;мусор
          AND      AX,[SI+1234]     ;мусор
          CLD                       ;мусор
          MOV      DI,jumbled_data  ;Часть настоящего расшифровщика
          TEST     [SI+1234],BL     ;мусор
          OR       AL,CL            ;
main_loop:ADD      SI,SI            ;мусор
          XOR      AX,1234          ;мусор
          XOR      BYTE PTR [DI],55 ;Часть настоящего расшифровщика
          SUB      SI,123           ;мусор
          INC      DI               ;Часть настоящего расшифровщика
          TEST     DX,1234          ;мусор
          AND      AL,[BP+1234]     ;мусор
          DEC      DX               ;Часть настоящего расшифровщика
          NOP                       ;мусор
          XOR      AX,DX            ;мусор
          SBB      AX,[SI+1234]     ;мусор
          AND      DX,DX            ;Часть настоящего расшифровщика
          JNZ      main_loop        ;Часть настоящего расшифровщика

    Как вы должны теперь способны видеть, полная перепутаница!
Но все еще исполнимый код. Это существенно, чтобы любой мусор-
ный код,  герерируемый Полиморфной Технологией был исполнимым,
так  как  он внедрен внутрь расшифровщика.  Обратите внимание,
что в этом примере часть мусорных команд  используют регистры,
используемые и расшифровщиком!  Это здорово, поскольку обеспе-
чивает, что значения в этих регистрах не изменяются. Также об-
ратите внимание, что теперь мы имеем случайные регистры и слу-
чайные команды каждый раз, что обламывает сигнатурные сканнеры
(даже самые крутые)!  Вместо этого должен использоваться метод
ЭВРИСТИЧЕСКОГО анализа,  что может приводить к ложным срабаты-
ваниям (*3*).

Итак, Полиморфная Технология должна включать 3 основных части:
──────────────────────────────────────────────────────────────

    1 .. Генератор случайных чисел
    2 .. Генератор мусорного кода
    3 .. Генератор расшифровщиков

    Это все очень разные части,  но они должны работать вместе!

    Ну и как это все работает?  Дык, SMEG генерирует случайные
расшифровщики примерно так:

    1 ..  Выбирает случайный набор регистров для использования
внутри этого расшифровщика.  Оставшиеся регистры  используются
как "мусорные" регистры для использования мусорным кодом.

    2 ..  Выбирает  один из ужатых заранее подготовленных рас-
шифровщиков.

    3 ..  Циклически генерирует реальный расшифровщик, разбав-
ляя его мусорным кодом.

    Для понимания того,  как готовятся выбранные регистры  для
расшифровщика и мусора,  вам надо рассмотреть двоичный код ко-
манд 8086 процессора:

      XOR   AX,AX    =    00110001 11000000
      XOR   AX,CX    =    00110001 11001000
      XOR   AX,DX    =    00110001 11010000
      XOR   AX,BX    =    00110001 11011000

    Вы способны  увидеть в этом двоичном коде образец (шаблон)
для команд 8086? Дык, все команды 8086 гененрируются с исполь-
зованием логически образцов (шаблонов), и это именно те образ-
цы (шаблоны),  которые заставляют процессор 8086  использовать
определенные команды  с  соответствующими  режимами адресации.
Полный набор форматов команд и точная логика их работы слишком
сложны, чтобы помещать их здесь. Тем не менее, любая книжка по
системе команд 8086 растолкует вам все это в полном объеме.

    SMEG использует эти логические образцы (шаблоны) для гене-
рации мусорного кода и расшифровщиков со случайными  регистра-
ми,  так как шаблоны непосредственно содержат коды регистров и
т.п.

              SMEG генерирует мусорный код так:
              ─────────────────────────────────

    Внутри SMEGа есть таблица основных двоичных образцов (шаб-
лонов) для всего множества команд 8086 , но с одним важным от-
личием - все режимные биты адресных  регистров  обнулены.  Это
называется СКЕЛЕТНОЙ  ТАБЛИЦЕЙ КОМАНД.  Таблица также содержит
различные другие байты,  используемые SMEGом  для  определения
подходящей битовой  позиции для заполнения регистровых полей в
шаблонах. Эти шаблоны заполняются при помощи логических команд
OR и AND. Используя этот метод, SMEG может генерировать беско-
нечное число случайных команд 8086 без использования каких ли-
бо регистров, используемых расшифровщиком. SMEG также содержит
несколько правил двоичной логики для генерации  ложных  CALLов
на фальшивые процедуры и ложных условных JMPов внутри мусорно-
го кода.

         SMEG генерирует правильный расшифровщик так:
         ───────────────────────────────────────────

    Внутри SMEGа есть таблица,  содержащая варианты часто  ис-
пользуемых команд 8086,  используемых в расшифровщиках,  таких
как XOR [индексный_регистр],регистр и пр. Также есть сохранен-
ная СКЕЛЕТНАЯ ФОРМА с некоторыми управляющими байтами, исполь-
зуемыми генератором расшифровщиков.  Также в  SMEGе  сохранено
несколько предварительно подготовленных расшифровщиков, сохра-
ненных в ужатой форме. В общем, завершенный расшифровщик может
быть описан, как инструкция генератору расшифровщиков, состоя-
щая из 11 байтов в добавлением списка предварительно подготов-
ленных расшифровщиков,  что и безболезненно, и экономит прост-
ранство.

        SMEG генерирует Полиморфный расшифровщик так:
        ─────────────────────────────────────────────

    Сначала он случайным образом выбирает  один  из  предвари-
тельно подготовленных дешифровщиков.  Затем он циклически рас-
паковывает  каждую  команду  расшифровщика,   заполняет   поля
требуемыми  регистрами,  сохраняет  их и затем генерирует (для
каждой реальной команды) случайное  количество  случайных  ко-
манд. Этот цикл повторяется до тех пор, пока не будет изготов-
лен законченый расшифровщик. Окончательный результат - расшиф-
ровщик   случайной   длины,  со  случайными  регистрами  и  со
случайной заготовкой!

    Специально следует остановиться на том, как SMEG генериру-
ет индексированные команды со случайным использованием SI,DI и
BX с использованием случайного смещения.  Например, пусть рас-
шифровщик начинается с адреса 10h,  и вот такой вариант проин-
дексирует этот адрес:

       MOV   SI,10h     ; Стартовый адрес
       MOV   AL,[SI]    ; Индексируем исходный адрес

    Но иногда  SMEG будет генерировать нечто вроде следующего,
снова основанного на расшифровке кода, начиная с адреса 10h:

       MOV   DI,0BFAAh      ; Неявный стартовый адрес
       MOV   AL,[DI+4066h)  ; 4066h+0BFAAh=10010h (а FFFF=10h)!!

    Эти индексированное и исходное значения выбираются  совер-
шенно случайно,  и  примеры  с 0BFAAh и 4066h допустимы,  но в
следующий раз они будут совершенно другими!

    Далее идут два расшифровщика,  которые сгенерированы Поли-
морфной  Технологией SMEG.  Надо отметить,  что я сгенерировал
4000 примера,  и не обнаружилось ни одного совпадения! К сожа-
лению, у меня переполнился диск! Но с большой долей вероятнос-
ти можно сказать, что общее количество комбинаций расшифровщи-
ка достигает МИЛЛИАРДОВ!

    Все строки,  помеченные как ";мусор" в следующих листингах
означают случайные мусорные команды,  которые вставлены в нас-
тоящий расшифровщик, обратите внимание, что SMEG имеет возмож-
ность генерировать мусорные CALLы на ложные  ПРОЦЕДУРЫ,  также
как и генерировать мусорные условные переходы.  Все строки по-
меченные звездочкой * обозначают действительные части правиль-
ного расшифровщика.  Я выбрал две генерации для показа, потому
что их размеры примерно одинаковы, 386 и 480 байтов. SMEG про-
изводит расшифровщики с размерами от 288 до 1536 байтов. Веро-
ятность того,  что любые два сгенерированных  расшифровщика  с
одинаковой длиной также идентичны и внутри - составляет один к
миллиарду!

; Ассемблерный листинг для расшифровщика 1, длина 386 байтов
;───────────────────────────────────────────────────────────
; Размер зашифрованного кода был 07DBh (2011 байтов)
; Зашифрованный код начинался с 0270h

; Этот расшифровщик использует следующие регистры:
;
;   DX = Количество байтов в зашифрованном коде
;   BX = Индекс, указывающий на зашифрованный код
;   AL = Ключ шифрации
;   CL = Основной рабочий регистр

0100    JNS     0103            ;мусор
0102    CLD                     ;мусор
0103    SAR     SI,CL           ;мусор
0105    CMP     BP,0708         ;мусор
0109    STC                     ;мусор
010A    JG      010E            ;мусор
010C    OR      SI,CX           ;мусор
010E    XOR     DI,3221         ;мусор
0112    ADD     BP,0805         ;мусор
0116    AND     BP,3512         ;мусор
011A    SHR     SI,CL           ;мусор
011C    MOV     SI,1B04         ;мусор
0120    SAR     DI,CL           ;мусор
0122    ADC     SI,2506         ;мусор
0126    ADC     DI,1F11         ;мусор
012A    SBB     BP,[0F3E]       ;мусор
012E    CMP     BP,3F1E         ;мусор
0132    DEC     SI              ;мусор
0133    NOT     DI              ;мусор
0135    AND     SI,083D         ;мусор
0139    INC     SI              ;мусор
013A    SBB     DI,0103         ;мусор

013     MOV     DX,1791         ;*Устанавливаем регистр счетчика
                                ; Настоящее количество байтов

0141    CLD                     ;мусор
0142    JB      0146            ;мусор
0144    TEST    SI,AX           ;мусор
0146    SBB     DI,SP           ;мусор
0148    TEST    DI,[251B]       ;мусор
014C    TEST    CL,[SI]         ;мусор
014E    SHL     BP,1            ;мусор
0150    MOV     BX,017D         ;мусор
0153    CMC                     ;мусор
0154    MOV     DI,1218         ;мусор
0158    JO      015C            ;мусор
015A    RCR     DI,1            ;мусор
015C    STC                     ;мусор
015D    CMP     BP,DI           ;мусор

015F    MOV     AX,CS           ;* Помещаем сегмент кода в AX

0161    TEST    CH,[BX+17]      ;мусор
0164    SBB     BP,3107         ;мусор
0168    INC     DI              ;мусор
0169    RCR     BP,1            ;мусор

016B    MOV     DS,AX           ;* Совмещаем сегменты кода и
                                ;  данных

016D    ADD     DI,[3B04]       ;мусор

0171    MOV     AL,50           ;* Устанавливаем ключ дешифрации

0173    JNB     0179            ;мусор
0175    MOV     SI,1439         ;мусор
0179    JB      017D            ;мусор
017B    ADC     DI,AX           ;мусор
017D    JMP     0185            ;мусор
0180    MOV     BP,1B36         ;мусор
0184    RET                     ;мусор
0185    RCR     SI,1            ;мусор

0187    MOV     BX,842D         ;* Устанавливаем индекс

018A    SUB     SI,CX           ;мусор * Сюда возвращается цикл

018C    OR      DI,0B0F         ;мусор
0190    MOV     BP,1E3E         ;мусор
0194    RCL     DI,CL           ;мусор
0196    SUB     BP,2E12         ;мусор
019A    ADD     DI,[2E2A]       ;мусор
019E    ROL     SI,CL           ;мусор

01A0    MOV     CL,[BX+7E43]    ;* Берем следующий расшиф-
                                ;  ровываемый байт. ВНИМАНИЕ:
                                ; оригинальный   индекс  842Dh
                                ; плюс 7E43h=10270h AND FFFFh=0270h!
                                ; А это есть начало расшифровы-
                                ; ваемого кода

01A4    JZ      01AC            ;мусор
01A6    TEST    BH,[DI+2B3B]    ;мусор
01AA    CMP     [BP+SI],DL      ;мусор
01AC    ROL     DI,1            ;мусор
01AE    SBB     DI,263A         ;мусор

01B2    DEC     DX              ;* Декрементируем счетчик

01B3    CALL    0180            ;мусор
01B6    MOV     DI,CX           ;мусор
01B8    ADC     BP,282E         ;мусор

01BC    SUB     CL,AL           ;* Расшифровываем байт с
                                ;  использованием КЛЮЧА

01BE    MOV     SI,372A         ;мусор
01C2    TEST    BP,3A10         ;мусор
01C6    CALL    0180            ;мусор
01C9    ADC     SI,1317         ;мусор
01CD    CLD                     ;мусор

01CE    INC     AX              ;* Увеличиваем ключевой регистр

01CF    XOR     SI,203D         ;мусор
01D3    JMP     01E1            ;мусор
01D6    DEC     DI              ;мусор
01D7    CMC                     ;мусор
01D8    SUB     BP,[3624]       ;мусор
01DC    XOR     SI,0200         ;мусор
01E0    RET                     ;мусор
01E1    CMP     [SI+13],BH      ;мусор

01E4    SUB     DX,0001         ;* Уменьшаем счетчик

01E8    CMP     AX,0517         ;мусор
01EC    SUB     BP,2816         ;мусор
01F0    AND     SI,0807         ;мусор
01F4    SUB     SI,2E03         ;мусор
01F8    ROR     BP,1            ;мусор
01FA    INC     DI              ;мусор
01FB    RCR     SI,CL           ;мусор
01FD    TEST    CH,DH           ;мусор
01FF    SUB     BP,1026         ;мусор

0203    MOV     [BX+7E4],CL     ;* Сохраняем расшифрованный байт

0207    JNB     020D            ;мусор
0209    XOR     DI,1B30         ;мусор
020D    CLD                     ;мусор
020E    ADD     SI,3C38         ;мусор

0212    INC     BX              ;* Увеличиваем индекс

0213    XOR     DI,0B2C         ;мусор
0217    JMP     022F            ;мусор
021A    OR      BP,1C18         ;мусор
021E    JLE     0221            ;мусор
0220    DEC     BP              ;мусор
0221    ADC     SI,0E32         ;мусор
0225    AND     DI,1522         ;мусор
0229    CMP     [BP+SI+36],BH   ;мусор
022C    ROL     SI,1            ;мусор
022E    RET                     ;мусор
022F    SHL     DI,1            ;мусор
0231    SHR     DI,1            ;мусор

0233    DEC     DX              ;* Уменьшаем счетчик
                                ;  долой исходную длину!

0234    JNZ     023F            ;* Если не 0, то идем на 023Fh

0236    TEST    CL,[BP+DI]      ;мусор
0238    ADC     BP,012D         ;мусор

023C    JMP     025B            ;* Конец расшифровки!

023F    INC     BP              ;мусор
0240    JNB     0246            ;мусор
0242    CMP     BX,0E2E         ;мусор
0246    TEST    DI,SI           ;мусор
0248    SBB     SI,3233         ;мусор

024C    MOV     CX,018A         ;* Установка адреса основного
                                ; цикла

024F    ROL     DI,1            ;мусор
0251    SUB     DI,BX           ;мусор
0253    SHR     DI,1            ;мусор
0255    TEST    BL,[BX+DI+1C2E] ;мусор

0259    PUSH    CX              ;*  Адрес цикла в стек
025A    RET                     ;*  Возврат в основной цикл

025B    MOV     SI,211F         ;мусор
025F    CMP     BL,[BX+DI]      ;мусор
0261    SUB     BP,2D33         ;мусор
0265    MOV     BP,3735         ;мусор
0269    XOR     SI,SI           ;мусор
026B    MOV     BP,[0A38]       ;мусор
026F    INC     DI              ;мусор

0270    Зашифрованный код начинается здесь

;****** Конец ассемблерного листинга 1-го расшифровщика ****

; Ассемблерный листинг для расшифровщика 2, длина 480 байтов
;───────────────────────────────────────────────────────────
; Размер зашифрованного кода был 07DBh (2011 байтов)
; Зашифрованный код начинался с 02E0h

; Этот расшифровщик использует следующие регистры:
;
;   AX = Количество байтов в зашифрованном коде
;   BX = Индекс, указывающий на зашифрованный код
;   DL = Ключ шифрации
;   CL = Основной рабочий регистр

0100    NOT     SI              ;мусор
0102    TEST    CH,[BP+DI+0F]   ;мусор
0105    INC     DI              ;мусор
0106    CLD                     ;мусор
0107    ADC     DI,132A         ;мусор
010B    JPE     0111            ;мусор
010D    OR      DI,332E         ;мусор
0111    INC     SI              ;мусор
0112    TEST    AL,CH           ;мусор
0114    JMP     0120            ;мусор
0117    JPE     011D            ;мусор
0119    CMP     DX,1909         ;мусор
011D    RCR     DI,CL           ;мусор
011F    RET                     ;мусор
0120    INC     DI              ;мусор
0121    TEST    DI,BP           ;мусор
0123    JMP     0133            ;мусор
0126    TEST    DI,0E24         ;мусор
012A    TEST    DI,093A         ;мусор
012E    AND     DI,SP           ;мусор
0130    CMP     [BP+SI],BH      ;мусор
0132    RET                     ;мусор
0133    MOV     BP,0C28         ;мусор
0137    TEST    DH,CH           ;мусор
0139    TEST    BP,1C16         ;мусор
013D    ROR     BP,CL           ;мусор
013F    JZ      0145            ;мусор
0141    TEST    DH,[BX]         ;мусор
0143    ADD     DI,SP           ;мусор
0145    TEST    CL,[SI+3435]    ;мусор
0149    MOV     BP,2E08         ;мусор
014D    TEST    CX,DI           ;мусор
014F    CLD                     ;мусор
0150    MOV     SI,3831         ;мусор
0154    AND     BP,363E         ;мусор
0158    ROR     DI,CL           ;мусор
015A    CLC                     ;мусор
015B    JNS     0163            ;мусор
015D    SAR     SI,1            ;мусор
015F    SBB     DI,3308         ;мусор
0163    SBB     DI,362B         ;мусор

0167    MOV     AX,07DB         ;* Установка регистра счетчика

016A    AND     DI,0F1E         ;мусор
016E    JMP     0182            ;мусор
0171    MOV     DI,2F31         ;мусор
0175    CMP     CX,2212         ;мусор
0179    SBB     SI,2E14         ;мусор
017D    TEST    BL,[SI+341D]    ;мусор
0181    RET                     ;мусор
0182    CMP     BH,19           ;мусор

0185    MOV     BX,B977         ;* Установка индексного регистра

0188    TEST    AL,[DI+072C]    ;мусор
018C    TEST    DI,2306         ;мусор
0190    SHR     SI,1            ;мусор

0192    MOV     DX,CS           ;* Поместить в DX сегмент кода

0194    CALL    0171            ;мусор
0197    TEST    SI,1410         ;мусор
019B    CLC                     ;мусор
019C    SHL     DI,CL           ;мусор

019Е    MOV     DS,DX           ;* Совмещаем сегменты кода и данных

01A0    NEG     SI              ;мусор
01A2    CALL    0171            ;мусор
01A5    TEST    CH,[BP+DI+070F] ;мусор

01A9    MOV     DL,8D           ;* Установка ключевого регистра

01AB    MOV     DI,3A30         ;мусор
01AF    JMP     01B9            ;мусор
01B2    JBE     01B5            ;мусор
01B4    INC     DI              ;мусор
01B5    NOT     DI              ;мусор
01B7    CMC                     ;мусор
01B8    RET                     ;мусор
01B9    XOR     CX,DX           ;мусор

01BB    CALL    01B2            ;мусор * Сюда вернем цикл

01BE    TEST    SI,3029         ;мусор
01C2    INC     DI              ;мусор
01C3    SBB     DI,1E19         ;мусор
01C7    MOV     DI,0038         ;мусор
01CB    RCR     DI,CL           ;мусор
01CD    MOV     BP,1809         ;мусор

01D1    NEG     BYTE PTR [BX+4969] ;*  NEG байт в [BX + 4969]
                                   ;   NOTE:  оригинальный индекс B977h плюс
                                   ;   4969h = 102E0h AND FFFFh = 02E0h!
                                   ;   А это начало расшифровываемого
                                   ;   кода

01D5    TEST    BP,2A37         ;мусор
01D9    CMP     CX,2B37         ;мусор
01DD    JMP     01E2            ;мусор
01E0    DEC     DI              ;мусор
01E1    RET                     ;мусор

01E2    MOV     CL,[BX+4969]    ;*  Берем байт в CL

01E6    CMC                     ;мусор
01E7    ROR     DI,CL           ;мусор
01E9    INC     BP              ;мусор
01EA    TEST    DI,281E         ;мусор
01EE    JZ      01F3            ;мусор
01F0    TEST    BH,[BX+DI+05]   ;мусор
01F3    MOV     DI,160C         ;мусор
01F7    SUB     BP,BP           ;мусор

01F9    XOR     CX,DX           ;* Ксорим его с ключом

01FB    TEST    BL,[BP+DI+3C]   ;мусор
01FE    JNB     0204            ;мусор
0200    ADD     BP,0A13         ;мусор
0204    CMP     [BX+DI],CL      ;мусор
0206    CALL    01E0            ;мусор
0209    CALL    01E0            ;мусор
020C    DEC     DI              ;мусор
020D    AND     DI,073A         ;мусор

0211    DEC     AX              ;* Вычитаем счетчик

0212    XOR     DI,2036         ;мусор
0216    NEG     BP              ;мусор
0218    ADC     DI,SP           ;мусор
021A    CMC                     ;мусор
021B    CMP     BL,[BX+SI]      ;мусор

021D    DEC     DX              ;* Уменьшаем ключ

021E    ADC     BP,1821         ;мусор
0222    SHL     DI,CL           ;мусор
0224    CMP     AX,1816         ;мусор
0228    SHL     DI,1            ;мусор
022A    CMP     AL,[BP+DI+1A]   ;мусор
022D    MOV     SI,1819         ;мусор
0231    ADD     SI,063B         ;мусор

0235    DEC     DX              ;* Уменьшаем ключ

0236    SUB     BP,0028         ;мусор
023A    AND     BP,1930         ;мусор
023E    CLD                     ;мусор
023F    ADC     BP,2D1D         ;мусор
0243    SAR     DI,CL           ;мусор

0245    XCHG    CX,DX           ;* Меняем местами CX и DX

0247    TEST    CX,DX           ;мусор
0249    MOV     SI,CX           ;мусор
024B    XOR     SI,030D         ;мусор
024F    SUB     DI,311C         ;мусор

0253    XCHG    DL,[BX+4969]    ;* Меняем местами [index] и DL
                                ; ВНИМАНИЕ: это восстанавливает
                                ; зашифрованный байт

0257    ADD     DI,0E13         ;мусор
025B    CMP     BL,[BP+DI+33]   ;мусор
025E    CLD                     ;мусор
025F    NOT     SI              ;мусор
0261    MOV     SI,3F1C         ;мусор

0265    XCHG    CX,DX           ;* Меняем местами CX и DX,
                                ; восстанавливая ключ в DL

0267    MOV     SI,221A         ;мусор
026B    OR      BP,0D2C         ;мусор
026F    MOV     DI,231B         ;мусор

0273    ADD     BX,0001         ;* Увеличиваем индекс

0277    JMP     0288            ;мусор
027A    ADC     BP,AX           ;мусор
027C    TEST    BL,[DI+19]      ;мусор
027F    TEST    DI,0321         ;мусор
0283    NEG     DI              ;мусор
0285    ROL     SI,CL           ;мусор
0287    RET                     ;мусор
0288    SBB     BP,1B0D         ;мусор
028C    XOR     BP,2A23         ;мусор
0290    CMP     DL,3A           ;мусор
0293    TEST    BH,[DI]         ;мусор

0295    AND     AX,AX           ;* Проверяем счетчик на 0
0297    JNZ     02AD            ;* Идем на 02ADh, если нет

0299    CALL    027A            ;мусор
029C    AND     DI,291F         ;мусор
02A0    JA      02A6            ;мусор
02A2    MOV     DI,0514         ;мусор
02A6    ADC     SI,1F2A         ;мусор

02AA    JMP     02BC            ;* Конец расшифровки

02AD    JMP     02B2            ;мусор
02B0    CLC                     ;мусор
02B1    RET                     ;мусор
02B2    SHL     DI,CL           ;мусор
02B4    CLD                     ;мусор
02B5    ADD     SI,2C1A         ;мусор

02B9    JMP     01BB            ;* Возврат в основной цикл

02BC    TEST    BH,BL           ;мусор
02BE    MOV     DI,210C         ;мусор
02C2    SUB     SI,1600         ;мусор
02C6    CALL    02B0            ;мусор
02C9    XOR     SI,2F1D         ;мусор
02CD    MOV     BP,0430         ;мусор
02D1    TEST    BH,[DI+362A]    ;мусор
02D5    OR      DI,1C21         ;мусор
02D9    STC                     ;мусор
02DA    CMP     DI,2828         ;мусор
02DE    CLC                     ;мусор
02DF    DEC     BP              ;мусор

02E0    Зашифрованный код начинается здесь

;**** Конец ассемблерного листинга 2-го расшифровщика ***

    Далее идут  16-ричные дампы для обоих вышеприведенных рас-
шифровщиков,  расшифровщик 1 слева, расшифровщик 2 справа. Эти
дампы  приведены  для того,  чтобы показать,  насколько сложно
найти сигнатуру,  которую можно было бы применить к каждому из
этих  расшифровщиков.  чтобы детектировать оба,  и это главное
назначение Полиморфной Технологии! Чтобы детектировать, вместо
этого вы должны написать программу, которая пытается использо-
вать интеллект для разборки того,  что выглядит как Полиморфно
сгенерированный расшифровщик. Это будет вызывать ложные сраба-
тывания или, в отдельных случаях, полную потерю расшифровщика!


 16-ричный дамп # 1, 368 bytes    16-ричный дамп #2, 480 bytes
 ──────────────────────────────── ────────────────────────────────
 7901FCD3FE81FD0807F97F020BF181F7 F7D6846B0F47FC81D72A137A0481CF2E
 213281C5050881E51235D3EEC7C6041B 334684C5E909007A0481FA0919D3DFC3
 D3FF81D6062581D7111F1B2E3E0F81FD 4785FDE90D00F7C7240EF7C73A0923FC
 1E3F4EF7D781E63D084681DF0301BA91 383AC3C7C5280C84F5F7C5161CD3CD74
 17FC720285F01BFC853E1B25840CD1E5 04843703FC848C3534C7C5082E85CFFC
 BB7D01F5C7C718127002D1DFF939FD8C C7C6313881E53E36D3CFF87906D1FE81
 C8846F1781DD073147D1DD8ED8033E04 DF083381DF2B36B8DB0781E71E0FE911
 3BB0507304C7C63914720213F8E90500 00C7C7312F81F9122281DE142E849C1D
 C7C5361BC3D1DEBB2D842BF181CF0F0B 34C380FF19BB77B984852C07F7C70623
 C7C53E1ED3D781ED122E033E2A2ED3C6 D1EE8CCAE8DAFFF7C61014F8D3E78EDA
 8A8F437E740684BD3B2B3812D1C781DF F7DEE8CCFF84AB0F07B28DC7C7303AE9
 3A264AE8CAFF8BF981D52E282AC8C7C6 0700760147F7D7F5C333CAE8F4FFF7C6
 2A37F7C5103AE8B7FF81D61713FC4081 29304781DF191EC7C73800D3DFC7C509
 F63D20E90B004FF52B2E243681F60002 18F69F6949F7C5372A81F9372BE90200
 C3387C1381EA010081F8170581ED1628 4FC38A8F6949F5D3CF45F7C71E287403
 81E6070881EE032ED1CD47D3DE84EE81 847905C7C70C162BED33CA845B3C7304
 ED2610888F437E730481F7301BFC81C6 81C5130A3809E8D7FFE8D4FF4F81E73A
 383C4381F72C0BE9150081CD181C7E01 074881F73620F7DD13FCF53A184A81D5
 4D81D6320E81E72215387A36D1C6C3D1 2118D3E781F81618D1E73A431AC7C619
 E7D1EF4A7509840B81D52D01E91C0045 1881C63B064A81ED280081E53019FC81
 730481FB2E0E85FE81DE3332B98A01D1 D51D2DD3FF87CA85CA8BF181F60D0381
 C72BFBD1EF84992E1C51C3C7C61F213A EF1C318697694981C7130E3A5B33FCF7
 1981ED332DC7C5353733F68B2E380A47 D6C7C61C3F87CAC7C61A2281CD2C0DC7
                                  C71B2381C30100E90E0013E8845D19F7
                                  C72103F7DFD3C6C381DD0D1B81F5232A
                                  80FA3A843D23C07514E8DEFF81E71F29
                                  7704C7C7140581D62A1FE90F00E90200
                                  F8C3D3E7FC81C61A2CE9FFFE84FBC7C7
                                  0C2181EE0016E8E7FF81F61D2FC7C530
                                  0484BD2A3681CF211CF981FF2828F84D

    Итак, я надеюсь,  что это короткое введение в работу Поли-
морфных Технологий заинтересует вас и,  возможно, заставит вас
писать их самостоятельно?

                                           (C) The Black Baron

 ***> (

    Примечания переводчика:

    (*1*) антивирусы,  распознающие вирусы по характерным пос-
ледовательностям байтов - сигнатурам;
    (*2*) шаблоны для подстановки,  типа * и/или ?  в командах
DOS;
    (*3*) статья написана в 1993 или 1994 г.

    ) <***
