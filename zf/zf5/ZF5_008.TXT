▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
▓▓▓┌──────────────────────────────────────────────────────────────────────┐▓▓▓▓
▓▓▓│                                       ▄ ▄                            │░░▓▓
▓▓▓│ ▄██▄ ▄██▄  █ █  ▄▀▀▄ █  █ █  █ █▐▌█  ▄▄█▄▄ ▄██▄ █▀▀▄ █ █ █ ▄▀▀█ ▄▀▀█ │░░▓▓
▓▓▓│ ▄▄▄█ █▄▄▄ █ █ █ █    █  █ █  █ █  █  █ █ █ █▄▄▄ █  █ █ █ █ █  █ █  █ │░░▓▓
▓▓▓│ ▄▄▄█ █▄▄▄ █ █ █ █  ▄ █▄▀  █  █ █  █  █▄█▄█ █▄▄▄ █▀▀  ▀▄▀▄▀ █▄▄█ █  █ │░░▓▓
▓▓▓│  ▀▀   ▀▀  ▀ ▀ ▀  ▀▀  ▀ ▀▀  ▀▀▀  ▀▀▀    ▀    ▀▀  ▀     ▀ ▀  ▀  ▀ ▀  ▀ │░░▓▓
▓▓▓├──────────────────────────────────────────────────────────────────────┤░░▓▓
▓▓▓│                            В ы п у с к ∙5∙                           │░░▓▓
▓▓▓└──────────────────────────────────────────────────────────────────────┘░░▓▓
▓▓▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓

               КОМПЬЮТЕРНЫЕ ВИРУСЫ: ТЕОРИЯ И ЭКСПЕРИМЕНТЫ
                            by Фред Коэн, 1984


  (* Перевод с английского by Constantin E.  Climentieff aka DrMAD *)

  1. ВВЕДЕНИЕ И РЕФЕРАТ
  2. КОМПЬЮТЕРНЫЙ ВИРУС
  3. ПРЕДОТВРАЩЕНИЕ КОМПЬЮТЕРНЫХ ВИРУСОВ
  4. ЛЕЧЕНИЕ КОМПЬЮТЕРНЫХ ВИРУСОВ
  5. ОКОНЧАТЕЛЬНЫЕ ВЫВОДЫ И ДАЛЬНЕЙШИЕ ПЛАНЫ
     ПРИМЕЧАНИЯ ПЕРЕВОДЧИКА

                          ВВЕДЕНИЕ И РЕФЕРАТ

    Эта работа определяет проблему компьютерной безопасности, названную
вирусом.  Вирус интересен из-за своей способности присоединять  себя  к
другим  программам  и  превращать  их также в вирусы.  Есть два способа
написания:  "вируссы" и "вирусы".  Мы используем  тот  способ,  который
можно найти в Вебстеровском 3-м Международном Полном Словаре.  С учетом
нынешнего широкого распространения разделения  доступа  к  компьютерным
системам,  угроза вируса,  несущего в себе Троянского коня [Anderson72]
[Linde75],  значительна.  Хотя  в  политике   защиты   от   незаконного
распространения  информации  значительная  часть  работы  уже выполнена
[Bell73] [Denning82],  и для множества систем  осуществлена  защита  от
этих  типов атак [McCauley79] [Popek79] [Gold79] [Landwehr83], все-таки
не так много сделано в области предотвращения попадания информации в те
области, где она может быть повреждена [Lampson73] [Biba77]. Существует
множество путей распространения информации между  системами,  часть  из
которых легальна и безопасна,  но мало известно [Lampson73],  насколько
часто пользователи применяют скрытые возможности.  Мы не будем  в  этой
статье рассматривать такие пути распространения информации.

    Существуют общие подходы для обеспечения доказуемо  правильных схем
защиты [Feiertag79],  но они зависят от политики безопасности,  которая
эффективна лишь против конкретных типов атаки.  Даже для очень  простых
систем  защит невозможно доказать их безопасность [Harrison76].  Защита
от угроз типа "отказ обслуживания"  требует  обнаружения  работающих  с
перебоями программ, что, как хорошо известно, в общем случае невозможно
[Garey79].  Показано,  что проблема точного  выделения  информационного
потока в пределах системы [Fenton73], NP-полна. Использование защиты от
поступления не  заслуживающей  доверия  информации  [Woodward79]  между
пользователями неплохо изучена, но в общем случае ее решение зависит от
способности  доказывать  правильность  программы,   что,   как   хорошо
известно, тоже обладает свойством NP-полноты.

    Программа "червь  Xerox"  [Shoch82]  продемонстрировала способность
распространяться через сеть,  и даже случайно вызвала  ситуацию  отказа
обслуживания.  В  другом  случае,  игра  в "войны в памяти" (core wars)
[Dewdney84] была изобретена,  чтобы заставить  две  программы  бороться
друг  с  другом.  Прочие  примеры  по  этой  теме неофициально сообщены
множеством различных корреспондентов,  но они по  большей  части  могут
рассматриваться  в  контексте  ночных игр между программистами.  Термин
"вирус" также использован в связи с программированием на языке  на APL,
когда  автор вставляет общий вызов в начале каждой функции,  что в свою
очередь заставляет препроцессор бесконечно размножать  фрагменты текста
[Gunn74].

    Проблема потенциальнах    угроз    безопасности   неплохо   изучена
[Hoffman82],  и потенциальный ущерб  для  государственных,  финансовых,
деловых  и  университетских учреждений крайне велик.  Следует отметить,
что эти учреждения стремятся использовать конкретные механизмы защиты в
ответ  на  конкретные  угрозы,  и не злоупотреблять теорией [Kaplan82].
Защищенность современных военных систем зависит в  большой  степени  от
изоляционизма,  тем  не  менее  новые  системы допускают многоуровневое
использование [Klein83].  Ни одна из опубликованных предлагаемых систем
не  определяет  и  не  осуществляет  такую  политику,  которая могла бы
остановить вирус.

    В этой  статье  мы  открываем новую проблему защиты от компьютерных
вирусов.  В ней изучены свойства  вирусной  инфекции  и  показано,  что
последовательное   закрытие   разделяемой  информации  не  препятствует
заражению.  Будучи использован вместе с Троянским конем,  вирус мог  бы
вызвать массовые отказы в обслуживании и/или несанкционированный доступ
к данным.  Результаты нескольких экспериментов с компьютерными вирусами
использованы,  чтобы  продемонстрировать,  что  вирусы являются ужасной
угрозой как в обычных, так и в хорошо защищенных операционных системах.
Пути  разделения  и  передачи информации информационных потоков,  и,  в
общем случае,  пути обработки информации, являются ключевыми сущностями
в проблеме защиты от компьютерных вирусов,  и это показано в результате
последовательного,  случай за случаем,  анализа. Анализ показывает, что
единственные  системы  с  потенциалом  защиты  от  вирусной атаки - это
системы с ограниченной транзитивностью и с ограничениями  на разделение
доступа,  системы  вообще  без разделения доступа,  и системы вообще не
обрабатывающие информацию  (варианты  машины  Тьюринга).  (*1*)  Только
первый  случай содержит практический интерес для современного общества.
Показано,  что  в  общем  случае  обнаружение  вируса  неразрешимо  как
a-приори  так  и  в  процессе анализа,  а без этого обнаружения лечение
будет затруднено или невозможно.

    Предложены и   рассмотрены  несколько  конкретных  контрмер,  и  на
конкретных примерах изучены свойства вирусов.  Системы с  ограничениями
транзитивности  считаются многообещающими,  но показано,  что точная их
реализация невозможна, а неточные в общем случае могут привести к более
-менее  пригодным системам.  Изучено использование вирусных антител,  и
показано,  что результат в общих чертах  зависит  от  решения  проблемы
проблемы неизлечимости.

    Получен вывод,   что  исследование  компьютерных  вирусов  является
важной    научно-исследовательской    областью     с     потенциальными
распространениями  в  другие  области,  что  текущие системы предлагают
плохую или вообще не  предлагают  защиту  от  вирусной  атаки,  и,  что
единственная доказуемо политика безопасности. (*5*)

                          КОМПЬЮТЕРНЫЙ ВИРУС

    Мы определяем  компьютерный  вирус  как  программу,  которая  может
заражать другие программы, модифицируя их таким образом, чтобы внедрять
в них собственную,  возможно видоизмененную,  копию.  Обладая свойством
инфицирования, вирус может распространиться по компьютерной системе или
сети,  используя авторизацию каждого пользователя,  чтобы  заражать  их
программы.   Каждая   зараженная   программа   программа   может  также
действовать как вирус и, таким образом, инфекция распространяется.

    Следующая псевдо-программа  показывает,  как  вирус  мог  бы   быть
написан   на   псевдо-машинном   языке.  Символ  ":="  использован  для
определения, симво ":" означает утверждение, ";" разделяет утверждения,
символ  "="  использован  для  назначения  или  сравнения,  символ  "~"
представляет отрицание, символы "{" и "}" группируют последовательности
операторов  вместе,  а символ "..." использован,  чтобы указывать,  что
неважная часть кода пропущена.

program virus:=
 {1234567;

subroutine infect-executable:=
 {
 loop:file = get-random-executable-file;
 if first-line-of-file = 1234567 then goto loop;
 prepend virus to file;
 }

subroutine do-damage:=
 {
  whatever damage is to be done
 }

subroutine trigger-pulled:=
 {
 return true if some condition holds
 }

main-program:=
 {
 infect-executable;
 if trigger-pulled then do-damage;
 goto next;
 }

next:
}

                           Простой Вирус "V"

    Этот демонстрационный вирус (V) ищет  "здоровый"  выполняемый  файл
программы (E), выбирая файлы без "1234567" в начале, и добавляет V к E,
превращая эту программу в  зараженный  файл  (I).  Затем  V  проверяет,
выполняется   ли   определенное  условие,  и  если  да,  то  производит
разрушения.  Наконец,  V выполняет остальную часть программы, к которой
он был добавлен.  Когда пользователь пытается выполнить программу E, то
вместо этого выполняется программа I; она заражает другой файл, а потом
работает,  как будто бы она есть E.  За исключением маленькой задержки,
выполненной  фрагментом  инфицирования,  программа   I   выглядит   как
программа E, пока выполнение условия не вызовет ущерб.

    Основной недостаток  таких вирусов в следующем.  Программные черви,
войны в памяти и другие аналогичные программы имитируют  жизнь,  но  ни
одна  из них не инфицирует по настоящему.  Ключевой особенностью вируса
является способность заражать другие программы,  таким образом достигая
закрытия   транзитивного  замыкания  между  пользователями.  (*3*)  Так
например,  если V заразил бы один из  модулей  пользователя  A  (E),  а
пользователь B после этого запустил бы E,  то V мог бы распространиться
также и на файлы пользователя B.

    Надо отметить,  что вирус не обязательно может  использоваться  для
злономеренных целей или не обязательно должен быть Троянским конем. Так
например,  мог бы быть написан сжимающий вирус,  предназначенный  чтобы
находить  ранеее  неинфицированные  модули,  сжимать  их  с  разрешения
пользователя,  и  добавлять  себя  к  ним.  (*4*)  Будучи   запущенной,
зараженная  программа "раскручивает" сама себя и выполняется нормально.
Поскольку  такой  вирус  всегда  спрашивает  разрешение   прежде,   чем
выполнить  свои  действия,  то это - не Троянский конь,  но поскольку у
него есть свойство инфицирования,  то это - все еще вирус. Исследования
показывают,  что  такой  вирус  мог  бы сэкономить свыше 50%  дискового
пространства в типичной системе.  Быстродейвствие исполнения зараженных
программ  должно  уменьшиться незначительно за счет "раскрутки".  Такой
сжимающий вирус мог бы выглядеть следующим образом:

programme compression-virus:=
{01234567;

the subroutine infects-program:=
 {
 loop:file = get-free-executed-file;
 if first-line-file = 01234567 then goto cycle;
 the file of the compresses;
 add the compression-virus in file;
 }

main-program:=
 {
 if ask-permit, then infect-program;
 extract-rest-this-file in tmpfile;
 start tmpfile;
 }

}

                         Сжимающий вирус "C"

    Эта программа (C) находит неинфицированную программу  (E),  сжимает
ее  и  добавляет к ней C,  чтобы сформировать зараженную программу (I).
Она затем "выгружает"  оригинальнную  программу  во  временный  файл  и
запускает ее на исполнение.  Когда программа I выполняется,  она ищет и
сжимает  другую  программу  перед  тем,  как  раскрутить  и   выгрузить
программу   E   во   временный  файл  и  выполнять  ее.  Эффект  должен
распространяться  по  всей  системе,   сжимая   выполняемые   файлы   и
востанавливая их перед тем, как они должны быть выполнены. Пользователи
почувствуют небольшие задержки в то время,  как их  модули  извлекаются
перед выполнением.

    Хотя этот  пример  не слишком положителен,  давайте будем полагать,
что мы модифицируем программу V, добавив к ней процедуру "выключатель",
который  оказывается  включенным  после определенной даты и времени,  и
процедуру  выполнения  повреждений  в  бесконечном  цикле.  Большинство
современных  систем  будут становиться непригодными для поражения после
определенной даты и времени.  Ликвидирование ущерба  от  такого  вируса
может потребовать много усилий. Эта модификация показана здесь:
...

subroutine does-damage:= {cycle: goto cycle;}

subroutine pulled trigger:=
{if year>1984, then return truth otherwise inverse lie;}

...

               Отрицание полезности Услужливого Вируса.

    В качестве   аналогии   компьютерного   вируса  надо  рассматривать
биологическую  болезнь,  которая  обладает  100%-ной   инфицируемостью,
распространяется  всякий  раз,  когда  существа общаются друг с другом,
убивает всех зараженных животных немедленно после определенного момента
времени,  но никак не проявляется до этого момента.  Если между началом
заболевания и проявлением задержка составляет ровно одну неделю, то она
должна  весьма  вероятно  оставить  только  несколько удаленных стран в
живых,  и  должна  несомненно  уничтожить  большую  часть  современного
общества. Если компьютерный вирус этого типа мог бы распространяться на
всех компьютерах мира,  то он должен вероятно остановить  использование
вычислительной  техники  на  значительный период времени и организовать
хаос в нынешних правительственных, финансовых, деловых и образовательных
учреждениях.

                 ПРЕДОТВРАЩЕНИЕ КОМПЬЮТЕРНЫХ ВИРУСОВ

    Мы представили читателю понятие вирусов,  и  фактически  определили
концепцию  вирусов  в системах.  Сея зерна потенциально опустошительной
атаки,  вирусы тем не менее очень удобны,  чтобы  исследовать  защитные
механизмы,  которые могли бы помочь защищаться от них. Мы изучаем здесь
предотвращение компьютерных вирусов.

                         Основные Ограничения

    Для того,  чтобы  пользователи  системы  были  способны  передавать
информацию,  должен  существовать путь,  через который информация может
распространяться  от  одного  пользователя  к  другому.  Мы  не  делаем
никакого  различия  между  пользователем и программой,  действующей как
заменитель этого пользователя, поскольку программа всегда действует как
представитель  пользователя  при  любом использовании компьютера,  и мы
игнорируем скрытый путь распространения информации в  обход  системы  и
непосредственно  через  пользователя.  Для того,  чтобы при вычислениях
использовать  модель  машины  Тьюринга,  мы  должны  учесть,  что  если
информация   может   быть  прочитана  пользователем  для  использования
совместно с машиной Тьюринга,  то она может быть скопирована,  а  копия
может затем рассматриваться как данные на ленте машины Тьюринга.

    Рассматривая универсальную систему, в которой пользователи способны
произвольно  использовать  находящуюся  в  их  владении  информацию,  и
способны  обеспечивать передачу такой информации другим лицам,  как они
считают  нужным,  должно  быть  ясно,  что  способность  распространять
информацию   является   транзитивной.   То  есть,  если  есть  путь  от
пользователя А к пользователю B,  и  есть  путь  от  пользователя  B  к
пользователю  C,  то  есть  и путь от пользователя А к пользователю C с
вольным или невольным посредничеством пользователя B.

    Наконец, нет фундаментального различия между  информацией,  которая
может быть использована как данные,  и информацией,  которая может быть
использована как программный код.  Это может быть проиллюстрировано  на
примере транслятора,  который берет исходную информацию, редактирует ее
как данные,  а потом интерпретирует ее как  программу.  Как  результат,
информация   имеет   смысл   только  тогда,  когда  может  подвергаться
интерпретации.

    В системе,  где информация  может  быть  проинтерпретирована  своим
получателем   как   программа,   эта  интерпретация  может  закончиться
инфицированием,  как показано выше. Если имеется разделение доступа, то
инфекция может распространиться в результате интерпретации коллективной
информации.  Если нет  ограничения  на  транзитивность  информационного
потока,   то   возможно  транзитивное  замыкание  (transitive  closure)
информационных потоков,  стартующих  из  любых  источников.  Разделение
доступа,    транзитивность    информационных    потоков    и   общность
интерпретации,  таким образом,  позволяет  вирусу  распространяться  на
транзитивно  замкнутое множество информационных потоков,  запускающихся
из любого источника.

    Ясно, что если нет использования,  то  не  может  быть  и  никакого
распространения  информации  через  информационные  границы,  и,  таким
образом, никакая внешняя информация не сможет быть проинтерпретирована,
и  вирус не сможет распространяться за пределы своего раздела.  Назовем
это термином "изоляционизм".  Подобно этому, система, в которой никакая
программа  не  может  быть  изменена и никакая информация не может быть
использована  для  принятия  решения,  не  может   быть   инфицирована,
поскольку  инфицирование  требует модификации транслируемой информации.
Мы называем эту систему "систнмой с установившимся  назначением первого
функционального  порядка".  Мы должны отметить,  что фактически реально
полезная в научном или инженерном  смысле  система  потребует  общности
интерпретации, и, что изоляционизм неприемлем, если мы хотим выигрывать
в эффективности.  Тем не менее, подобные решения проблемы вирусов могут
быть применены в некоторых ситуациях.

                           Модель разделов

    При распространении   информационного  потока  можно  рассматривать
границы,  которые разделяют пользователей на два подмножества:  на тех,
которые включены в транзитивное замыкание; и на тех, которые нет. Можно
сказать,  что разделители  потоков,  которые  обеспечивают  образование
замкнутых подмножеств,  создают изолированные подсистемы.  Они замыкают
каждую инфекцию внутри одного-единственного раздела.  Они  представляют
собой   жизнеспособные  средства  предотвращения  тотального  вирусного
распространения за счет ограниченного  изоляционизма,  и  -  эквивалент
предоставления каждому разделу собственного компьютера.

    Модель целостности  [Biba77] - пример политики,  которая может быть
использована,  чтобы  разделять  системы  на   замкнутые   транзитивные
подмножества.   В  модели  Biba  уровень  целостности  связан  со  всей
информацией.  Строгие свойства связности - "двойник"  свойств  политики
Bell-LaPadula;  никакой пользователь с определенным уровнем целостности
не может читать объект  с  более  низкой  целостностью  или  записывать
что-либо  в объект с более высокой целостностью.  В оригинальной модели
Biba различие было сделано между чтением и доступом на  исполнение,  но
этот  подход  не  может  не  быть  реализован  с  ограничением общности
информационной интерпретации,  поскольку программа  с  высоким  уровнем
целостности  может писать в объект с низким уровнем целостности,  делая
низкоуровневые собственные копии,  и затем читать и писать в объекты  с
низким уровнем целостности.

    Если модель  целостности и модель Bell-LaPadula сосуществует,  то в
результате получается форма ограниченного изоляционизма,  которая делит
пространство на подмножества транзитивного замыкания. Если одни и те же
способы разделения используются для  обоих  механизмов  (более  высокая
целостность   позволяет  писать  в  объекты  с  более  высоким  уровнем
безопасности), то изоляционизм приводит к перемещениям информации между
уровнями  безопасности и целостности,  а это недопустимо.  Когда модель
Biba  рассматривает   ограничения   в   пределах   ограничений   модели
BellLaPadula, то инфекция может распространиться только с более высоких
уровней целостности на более низкие, оставаясь в пределах одного уровня
безопасности.  Наконец,  когда  ограничения  Bell-LaPadula  находятся в
пределах ограничений Biba, то инфекция может распространиться только от
более  низких  уровней  безопасности к более высоким в пределах данного
уровня  целостности.  Всего  существует  9  вариантов,  относящихся  ко
всяческим соответствиям более низких ограничений более высоким, но три,
изображенных ниже, достаточны для понимания.

Одинаковые     Biba в B-L.    B-L в Biba.
-------------- -------------- --------------
Biba B-L  Итог Biba B-L  Итог Biba B-L  Итог
---- ---- ---- ---- ---- ---- ---- ---- ----
|\\| |//| |XX| |\\| |//| |XX| |\\| |//| |XX|
|\\| |//| |XX| |\\| |  | |\\| |  | |//| |//|
|  |+|  |=|  | |  |+|  |=|  | |  |+|  |=|  |
|//| |\\| |XX| |//| |  | |//| |  | |\\| |\\|
|//| |\\| |XX| |//| |\\| |XX| |//| |\\| |XX|
---- ---- ---- ---- ---- ---- ---- ---- ----
\\ = не может писать; // = не может читать
XX = нет доступа; \ + / = X

    Работа Biba  также  содержала  две  других  политики   целостности,
политику  "нижней метки" (low water mark),  которая предусматривает для
выхода всегда более низкую целостность по сравнению с любым  вводом;  и
"кольцевую" политику,  в которой пользователи не могут вызывать то, что
они  могут  прочитать.  Прежняя  политика  стремится   перемещать   всю
информацию на более низкие уровни целостности, тогда как новая пытается
различать,  что  не  может  быть  выполнено  при  помощи  универсальной
информационной интерпретации.

    Подобно тому,  как  системы,  основанные  на  модели Bell-LaPadula,
стремятся вызывать всю информацию,  чтобы перемещаться на более высокие
уровни  безопасности,  всегда  увеличивая  уровень,  чтобы добраться до
пользователя самого верхнего уровня,  модель Biba стремится  перемещать
всю  информацию  на  более  низкие уровни целостности,  всегда уменьшая
целостность результатов до самой низкой доступной целостности. Мы также
знаем,  что  точное  решение проблемы системной целостности - NP-полная
(подобно тому, как ее "двойник" - NP-неполная). (*2*)

    Наиболее благонадежный программист - (по  определению) программист,
который может писать программы для большинства пользователей. Для того,
чтобы поддерживать политику Bell-LaPadula, высокоуровневые пользователи
не   могут   писать   программы,   используемые  более  низкоуровневыми
пользователями.  Это означает,  что наиболее благонадежные программисты
должны  находиться  на  самом  низком уровне безопасности.  Это кажется
противоречивым.  Когда мы смешиваем модели Biba и Bell-LaPadula,  то мы
находим, что результирующий изоляционизм защищает нас от вирусов, но не
разрешает пользователю писать программы,  которые могли бы использованы
для  всей  системы.  Подобно  тому,  как  мы  допускаем  шифрование или
расшифровывание данных,  чтобы перемещать их с  более  высоких  уровней
безопасности  на  более  низкие,  мы  должны быть способны использовать
тестирование и верификацию  программ,  чтобы  перемещать  их  с  низких
уровней целостности на более высокие.

    Другой часто  используемой политикой разделения системы на закрытые
подмножества  является  политика  категорий,  применяемая  в   типичных
военных приложениях. Эта политика разделяет пользователей на категории,
и  каждый  пользователь  может  иметь  доступ  только   к   информации,
необходимой   для   выполнения   прямых   обязанностей.   Если   каждый
пользователь в строгой системе категорий имеет доступ  только  к  одной
категории,  то  система  будет  устойчива  к вирусной атаке,  поскольку
категории изолированы.  К несчастью,  в реальных системах  пользователи
могут иметь одновременный доступ к нескольким категориям. В этом случае
инфекция  может  распространяться  через  границы  категории   на   все
транзитивное замыкание информационного потока.

                           Потоковые Модели

    В политиках,  которые не разделяют системы на транзитивно замкнутые
подмножества, тоже возможно ограничить распространение вируса. Политика
'дистанции   потока'  реализует  метрику  расстояния  для  слежения  за
расстоянием (за количеством границ),  которое преодалевает  информация.
Правила:  расстояние выходной информации является максимумом расстояний
входной информации;  расстояние разделяемой  информации  -  на  единицу
больше,  чем  расстояние  той  же  самой  информации перед разделением.
Защита  обеспечивается  установкой  порога,  при  превышении   которого
информация становится непригодной. Таким образом, файл с расстоянием 8,
доступный процессу с расстоянием 2,  увеличивает расстояние процесса до
9,  и весь последующий выход будет характеризоваться на по крайней мере
этим расстоянием.

    В качестве  примера  рассмотрим  поток,  допускающий  информацию  в
соответствии  с  метрической  системой  расстояний и порогом 1,  причем
каждый пользователь (A-E) способен  связаться  только  с  2  ближайшими
соседями.  Обратите внимание,  что информация,  порождаемая в C,  может
переместиться только к пользователю B или к пользователю D, но не может
транзитом перейти к A или E, даже при участии B и D.

Правила:

  D(выход) = max(D(вход))
  D(разделяемый вход)=1+D(неразделяемый вход)
  Информация доступна, тогда и только тогда, если D < const

  A     B     C     D     E
 +-+   +-+   +-+   +-+   +-+
 |X|---|1|---|0|---|1|---|X|
 +-+   +-+   +-+   +-+   +-+

Метрика с Порогом 1.

    Политика "список потоков" поддерживает список  всех  пользователей,
которые взаимодействуют с каждым объектом.  Вот правила, которые нужны,
чтобы  поддерживать  этот  список;  список  выходных  потоков  является
объединением списков потоков всех входов (включая пользователя, который
порождает  это  действие).  Защита  приобретает   форму   произвольного
логического   выражения   в   списках   потоков,   которое   определяет
доступность. Это - та же общая политика, и она может быть использована,
чтобы    представлять   любую   из   вышеуказанных   политик,   выбирая
соответствующие логические выражения.

    Следующая иллюстрация  показывает  пример   системы,   использующей
списки  потоков,  осуществляя различные ограничения (упомянутые как A и
B) для разных пользователей (в  строке,колонке  1,3  и  2,5).  Обратите
внимание, что хотя информации позволено распространяться до 1,5, она не
может действительно оказаться там, поскольку нет пути из ее источника в
1,3.   Так   как   в   метрической  системе  расстояний  транзитивность
информационного потока не сохраняется, так что даже если бы информация,
помеченная как B, была бы способна достичь 2,3, она все равно не смогла
бы распространиться дальше.

Правила:

  F(выход)=Объединение(F(входы))
Информация доступна тогда и только тогда, если B(F)=1

   1     2     3     4     5     6
  +-+   +-+   +-+   +-+   +-+   +-+
1 |A|---|A|---|A|---| |---|A|---|B|
  +-+   +-+   +-+   +-+   +-+   +-+
   |     |     |     |     |     |
  +-+   +-+   +-+   +-+   +-+   +-+
2 | |---| |---||---| |---|B|---|B|
  +-+   +-+   +-+   +-+   +-+   +-+
   |     |     |     |     |     |
  +-+   +-+   +-+   +-+   +-+   +-+
3 |B|---|B|---|B|---|B|---|B|---|B|
  +-+   +-+   +-+   +-+   +-+   +-+

                    Пример системы списков потоков

    Рассматриваемый пример   использует   довольно  простую  логическую
функцию, но в целом, доступность может быть определена при помощи очень
сложных условий.  Например,  пользователю могло бы быть позволено иметь
доступ только к информации,  созданной парами пользователей (B и C) или
(B и D),  но запрещено к той, которая создана отдельными пользователями
B, C, или D.

    Это может быть использовано, чтобы осуществлять проверку информации
B прежде,  чем C или D могут переслать ее на A. Система списков потоков
может также быть использована, чтобы реализовывать модели Biba и модели
расстояний. Например, модель расстояний может реализовываться следующим
образом:    @центр[ИЛИ    (пользователи    <=    расстояние    1)     И
НЕ(ИЛИ(пользователи > расстояние 1))].

    В системе  с  неограниченными  информационными  путями ограниченная
транзитивность может быть эффективной,  если пользователи не используют
все  доступные  пути,  но всегда имеется прямой путь между любыми двумя
пользователями,  и в этом случае всегда имеется  возможность  инфекции.
Например,  в  системе  с  транзитивностью,  ограниченной расстоянием 1,
безопасно разделять информацию между любыми пользователями,  которым Вы
доверяете,  без  необходимости беспокоиться о том,  что какой-нибудь из
этих пользователей неправомерно доверяет другому пользователю.

                      Ограниченная интерпретация

    Ограничения общности  интерпретации   менее   ограничительны,   чем
интерпретация  первого  порядка,  и  в этом случае способность заражать
остается  открытым  вопросом,  поскольку   инфицирование   зависит   от
разрешенных функций. Для инфицирования необходимы определенные функции.
Для этого требуется способность к записи,  но  ведь  и  любая  полезная
программа  должна уметь продуцировать выходные данные.  Возможно,  надо
определить набор операций,  которые не допускают инфицирования  даже  в
общем случае разделения и транзитивности,  но неизвестно, действительно
ли такой набор включает не фиксированные функции первого порядка.

    Например, система с единственной  функцией  "показать  файл"  может
только   отображать   содержимое   файла   пользователю,   и  не  может
модифицировать никакие файлы.  В фиксированной базе данных или почтовой
системе это может найти практическое применение, но ни в коем случае не
в среде разработки.  Во многих случаях электронная почта -  достаточное
средство  связи,  и  пока  система  электронной почты связана с другими
приложениями так,  что никакая информация не может быть передана  между
ними,    за   исключением   скрытого   канала   непосредственно   через
пользователя,  такая схема может быть использована, чтобы защищаться от
инфекции.

    Хотя никакая  фиксированная  схема  интерпретации не может заразить
сама себя,  схема  интерпретации  более  высоких  порядков  может  быть
использована, чтобы заражать программы, интерепретируемые в этой схеме.
Например, компьютерный микрокод может быть фиксирован, но машинный код,
который  интерпретируется  этим микрокодом,  может инфицировать.  LISP,
APL,  и Basic - вот примеры фиксированных схем  интерпретации,  которые
могут   интерпретировать   любую   информацию.   С  их  способностью  к
интерпретации в общем возможно написать  программу  на  любом  из  этих
языков,  которая  заражала бы программы на любом другом из них,  или на
всех сразу.

    В системах  с  ограниченной  интерпретацией   инфекции   не   могут
распространяться  дальше,  чем  в универсальных системах интерпретации,
поскольку  каждая  функция  ограниченной  системы  должна  также   быть
способна  выполняться  в универсальной системе.  Предыдущие результаты,
следовательно, позволяют оценить верхние границы распространения вируса
в системах с ограниченной интерпретацией.

                          Проблемы точности

    Хотя изоляционизм  и ограниченная транзитивность предлагают решение
проблемы инфицирования,  они не идеальные в том смысле,  что разделение
ресурсов и данных обычно считается полезным свойством.  Из этих политик
только изоляционизм может быть точно осуществлен на практике, поскольку
трассировка  информационных  потоков  потребовала  бы  NP-полных затрат
времени,  а маркировка  тпотребовало  бы  много  рабочего  пространства
[Denning82]. Это оставляет нам возможность использовать только неточные
методы.  Проблема неточных методов в том,  что они стремятся  приводить
системы к изоляционизму.  Дело в том, что они используют консервативную
оценку эффектов для предотвращения потенциального ущерба. В философском
смысле лучше быть безопасным, чем разочарованным.

    Проблема в том, что когда информация несправедливо рассматривается,
как  недоступная  для  чтения  конкретным  пользователем,  то   система
становится менее пригодной для этого пользователя. Это - форма отказа в
обслуживании в процессе доступа к информации,  к который доступ  должен
быть запрещен. Такая система всегда стремится делать себя менее и менее
пригодной для разделения ресурсов и данных  вплоть  до  того,  что  или
становится полностью изолированной, или достигает точки равновесия, где
все оценки точны. Если такая точка равновесия существовала бы, то у нас
была  бы точная система для этой точки равновесия.  Поскольку мы знаем,
что любая точная точка устойчивости означает изоляционизм, то требуется
решение   NP-полной  проблемы,  а  любое  не-NP-полное  решение  должно
приводить к изоляционизму.

                            Итоги и Выводы

    Следующая таблица    объединяет    пределы,    установленные    для
распространения  вирусов только что изученными методами защиты.  Термин
"Unknown" использован для указания того,  что  особенности  конкрентных
систем известны,  но нет никакой теории,  чтобы предсказать ограничения
для этих категорий.

                     Пределы вирусной инфекции

          Общая интерпретация         Ограниченная интерпретацию

           огранич.     общ.               огранич.      общ.

--------|-----------|-----------|       |-----------|-----------|
 общ.   |неогранич. | неогранич.|       |неизвестн. |неизвестный|
--------|-----------|-----------|       |-----------|-----------|
огранич.|произвольн.| замыкание |       |произвольн.| замыкание |
--------|-----------|-----------|       |-----------|-----------|

                     ЛЕЧЕНИЕ КОМПЬЮТЕРНЫХ ВИРУСОВ

    Поскольку предотвращение   компьютерных   вирусов    может    стать
необходимым  в  условиях  обширного  разделения  доступа  к программным
объектам, то биологическая аналогия приводит нас к возможности лечения,
как  средства  защиты.  Лечение  в  биологических  системах  зависит от
способности обнаружить вирус и возможности уничтожить  его.  Аналогично
дело обстоит и для компьютерных вирусов.  Здесь мы изучим потенциальные
возможности по обнаружению и удалению компьютерных вирусов.

                          Обнаружение Вирусов

    Для того,  чтобы  определять,  что  данная  программа  P   является
вирусом,  необходимо установить,  что P заражает другие программы.  Это
неразрешимо,  поскольку P могла бы бы содержать решающую процедуру D  и
заражать  другие  программы  тогда  и  только тогда,  когда D придет вк
выводу,  что P -  не  вирус.  Мы  будем  считать,  что  нам  необходима
программа,  которая  однозначно  различает  вирус  внутри  любой другой
программы,  изучая ее поведение. Чтобы продемонстрировать невозможность
существования   таких   программ,   в   следующем   примере   с   целью
запрограммировать V, мы используем гипотетическую решающую процедуру D,
которая  возвращает  "истину"  тогда и только тогда,  когда ее аргумент
является вирусом,

program contradictory-virus:=

{...

main-program:=

 {if ~D(contradictory-virus) then
    {infect-executable;
    if trigger-pulled then do-damage;
    }

 goto next;

 }
}

                      Неоднозначность вируса "CV"

    Модифицируя основную  программу  V,  мы  гарантировали,  что   если
процедура  D  проверяет  CV  на  соответствие  вирусу,  то  CV не будет
заражать другие программы и,  таким образом, не будет являться вирусом.
Если  же D определяет,  что CV - не вирус,  то CV будет заражать другие
программы   и,   таким   образом,   будет    вирусом.    Следовательно,
гипотетическая   решающая   процедура  D  противоречит  самой  себе,  и
однозначное определение понятия "вирус" невозможно.

                            Эволюция вируса

    В наших экспериментах некоторые вирусы требовали менее  4000 байтов
для  выполнения  на  универсальном  компьютере.  Поскольку  мы могли бы
написать программу,  которая чередует  свою  деятельность:  то  она  не
останавливается,   то  завершается  в  течение  конечного  времени;  то
работает как вирус,  то безобидна,  -  в  общем,  количество  возможных
модификаций  одного  такого  вируса  иожет  быть очень большим.  В этом
примере эволюционирующего вируса EV мы допускаем  модификацию  V  таким
образом,   что  случайные  операторы  вставляются  между  любыми  двумя
обязательными операторами. (*6*)

program evolutionary-virus:=

{...

subroutine print-random-statement:=

 {
 print random-variable-name, " = ", random-variable-name;
 loop:if random-bit = 0 then
    {print random-operator, random-variable-name;
    goto loop;}
 print semicolon;
 }

subroutine copy-virus-with-random-insertions:=

 {
 loop: copy evolutionary-virus to virus till semicolon-found;
 if random-bit = 1 then print-random-statement;
 if ~end-of-input-file goto loop;
 }

main-program:=

 {
 copy-virus-with-random-insertions;
 infect-executable;
 if trigger-pulled do-damage;
 goto next;
 }

next:
}

                      Эволюционирующий Вирус "EV"

    В общем,  доказательство эквивалентности двух модификаций  одной  и
той  же программы P (это P1 и P2) невозможно,  поскольку любая решающая
процедура  D,  способная  обнаруживать   их   эквивалентность,   должна
ознакомиться   и   с   P1,  и  с  P2.  Если  с  ее  помощью  обнаружена
эквивалентность,  то они будут выполнять  различные  действия;  а  если
обнаруживается  различие,  то они будут действовать одинаково,  и таким
образом  опять   станут  эквивалентными.   Это   поясняется   следующей
модификацией  программы  EV,  в которой решающая процедура D возвращает
"истину" тогда и только тогда,  когда две  программы,  поданные  на  ее
вход, эквиалентны.

program undecidable-evolutionary-virus:=

{...

subroutine copy-with-undecidable-assertion:=

 {
 copy undecidable-evolutionary-virus to file till line-starts-with-zzz;
 if file = P1 then print "if D(P1,P2) then print 1;";
 if file = P2 then print "if D(P1,P2) then print 0;";
 copy undecidable-evolutionary-virus to file till end-of-input-file;
 }

main-program:=

 {
 if random-bit = 0 then file = P1 otherwise file = P2;
 copy-with-undecidable-assertion;
 zzz:
 infect-executable;
 if trigger-pulled do-damage;
 goto next;
 }

next:
}

             Невозможность доказательства эквивалентности
                       модификаций вируса "UEV".

    Программа UEV "перерождется" в один из двух типов программ:  P1 или
P2. Если тип программы равен P1, то значение "zzz" станет:

    if D(P1,P2) then print 1;

в то же время, если программный тип есть P2, то "zzz" примет вид:

    if D(P1,P2) then print 0.

    Обе модификации  вызывают  решающую  процедуру  D,  чтобы   решить,
действительно   ли   они   эквиалентны?   Если  D  сочтет,  что  они  -
эквивалентны,  тогда P1 напечатает 1,  тогда как P2 напечатает 0,  и  D
будет противоречить самой себе.  Если D укажет, что они различны, то не
будет напечатано ничего. Пока они эквивалентны, D будет противоречивой.
Следовательно,  гипотетическая  решающая  процедура  D  противоречива в
своей основе, и точное определение эквивалентности этих двух программ -
невозможно.

    Если P1  и  P2 - модификации одной и той же программы,  то проблема
доказательства их эквивалентности неразрешима,  и если они обе являются
вирусами,  то неразрешимо и доказательство их вирусности. Программа UEV
также демонстрирует,  что две  различные  модификации  могут  обе  быть
вирусами. Модификации являются эквивалентами с точки зрения их вирусных
эффектов, но могут иметь разные проявления.

    Альтернатива обнаружению по внешнему  виду  -  это  обнаружение  по
поведению.   Вирус,   будучи   внедрен   в   программу,  имитирует  для
пользователя выполнение запрошенных пользователем системных сервисов, в
то  время  как  сам он при этом законно пользуется законными сервисами.
Вследствие этого вопрос обнаружения по поведению сводится к возможности
определить,  какое использование системных сервисов законно,  а какое -
нет, и это позволит отличить вирус.

    Пример "законного" вируса - компилятор,  который  компилирует  свою
новую  версию,  и  фактически  является вирусом в соответствии с данным
выше определением.  Он в эом случае - тоже программа,  которая заражает
другую  программу,  модифицируя ее таким образом,  чтобы включить в нее
возможно видоизмененную версию себя.  Поскольку  свойство  "вирусности"
принадлежит   большинству   компиляторов,   то   каждое   использование
компилятора является потенциальной вирусной атакой. Вирусная активность
компилятора  может быть отключена или возобновлена конкретными входными
данными,  и,  таким образом для того,  чтобы обнаружить  эту  ситуацию,
нужно  быть  способным  обнаруживать вирус по внешнему виду.  Поскольку
однозначное  обнаружение  по  поведению  в  этом  случае   зависит   от
однозначного обнаружения содержимого входных данных, и поскольку мы уже
показали,  что обнаружение по внешнему виду неоднозначно,  то из  этого
следует, что точное обнаружение по поведению также невозможно.

                     Ограниченная вирусная защита

    Ограниченная форма   вируса   разработана   [Thompson84]   в  форме
специальной версии компилятора с языка C,  который может  обнаруживать,
что  на входе у него имеется исходный текст программы проверки паролей,
и и  добавлять  Троянского  коня,  который  обеспечивает  автору  обход
проверки. Таким образом автор мог бы иметь доступ к любой системе Unix,
снабженной этим компилятором. Кроме того, компилятор может обнаруживать
компиляцию  новых  версий  самого  мебя  и заражать их тем же Троянским
конем.  Действительно ли такой вирус существует, неизвестно (хотя ходят
слухи,   что  Агентство  Национальной  Безопасности  имеет  ее  рабочую
версию).

    Как контрмеру,   мы  можем  разработать  новую  программу  проверки
паролей (и компилятор C),  достаточно отличные от первоначальных, чтобы
определить  их  эквивалентность  было очень трудно.  (*7*) Если "лучший
искусственный интеллект" не способен обнаружить их  эквивалентность  на
текущий  момент времени,  и компилятор выполняет свою задачу достаточно
быстро,  то было бы разумным предоложить,  что  вирус  тоже  не  сможет
обнаружить  эквивалентность,  и следовательно,  не сможет размножаться.
Если точный способ обнаружения известен, то, вероятно, это будет совсем
просто сделать.

    Хотя мы  показали,  что  в   общем   случае   обнаруживать   вирусы
невозможно,  на  самом деле любой конкретный вирус может быть обнаружен
конкретной схемой обнаружения.  Например,  вирус V мог  бы  быть  легко
обнаружен детекторами по первой первой строке программы "1234567". Если
окажется,  что  программа  заражена,  она   не   будет   запущена,   и,
следовательно,  не  сможет распространиться.  Следующая программа может
быть использована вместо обычного системного загрузчика,  и  она  будет
отказываться выполнять программы, зараженные вирусом V:

program new-run-command:=

{
 file = name-of-program-to-be-executed;
 if first-line-of-file = 1234567 then
 {
 print "the program has a virus";
 exit;
 }

otherwise run file;

}

                         Защита от вируса "PV"

    Аналогично, любая конкретная схема обнаружения может  быть обойдена
конкретным   вирусом.  Так  например,  если  нападающий  знал  бы,  что
пользователь использовал программу PV как  защиту  от  вирусной  атаки,
вирус  V мог бы легко быть заменен вирусом V',  в котором первая строка
была бы "123456" вместо "1234567".  Могут быть изучены и более  сложные
вирусы  и  защитные  схемы.  Становится  совсем  очевидной  аналогия со
старинной ковбойской поговоркой:  "нет такой лошади,  на которой нельзя
было бы прокатиться,  но и нет такого человека, которого нельзя было бы
сбросить".  Никакая инфекция не может существовать без того,  чтобы  не
быть обнаруженой, и не может существовать никакой механизм обнаружения,
который не мог бы быть сам инфицирован.

    Этот результат  приводит  к  идее,  что   могло   бы   существовать
равновесие  между вирусами и защитами,  так что конкретный вирус мог бы
поразить лишь часть систем,  тогда как данная  схема  защиты  могла  бы
защищать  лишь  против  конкретного  подмножества вирусов.  Если каждый
пользователь  и  злоумышленник  использовали  бы  идентичные  защиты  и
вирусы,  то  существовали  бы  совершенный  вирус и совершенная защита.
Имело бы смысл как с точки зрения нападающего,  так и  с  точки  зрения
защищающегося, - иметь набор (возможно неполный) вирусов и защит.

    При условии, что вирусы и схемы защиты не развивались бы, это могло
бы привести к некоторым фиксированным  множествам  немногих  "выживших"
вирусов и защит,  но поскольку программы пишутся, чтобы развиваться, то
выжили  бы  программа,  которую   трудно   атаковать,   и   практически
необнаружимый вирус.  Так как эволюция все-таки происходит,  равновесие
постоянно нарушается,  и результат становится неясным  даже  при  самых
простых  обстоятельствах.  Эта  ситуация  имеет  очень много аналогий в
теориях биологической эволюции [Dawkins78],  и  хорошо  укладывается  в
генетические теории болезней. Аналогично, распространение вирусов между
системами  могло  бы  быть  хорошо  проанализировано  с  использованием
математических  моделей,  разработанных  для  исследования инфекционных
болезней [Baily57].

    Поскольку мы  не  можем однозначно обнаружить вирус,  то остаемся с
проблемой определения потенциально незаконного использования при помощи
однозначных   и  легко  реализуемых  методов.  Мы  можем  пожелать  для
множества программ способность доказать,  что они не являются вирусами,
и  даже  пропускать  некоторые  вирусы  для  того,  чтобы  обнаруживать
основную массу вирусов.  Если  такое  событие  происходит  сравнительно
редко в "нормальных" условиях, то о нем можно получить достаточно много
информации, и мы можем определить, по какой причине оно произошло. Если
доступно  следящее оборудование,  то могут быть собраны списки потоков,
которые прослеживают всех  пользователей,  обратившихся  к  конкретному
файлу.  Пользователи,  которые  появляются во многих списках,  могли бы
считаться подозрительным.  Присутствие во многих списках могло бы  быть
хорошим указателем на вирус.

    Это средство  моло  бы быть ценным,  если бы сервисы,  используемые
вирусами, редко использовались бы другими программами, но на самом деле
имеется  несколько  проблем.  Если  условия,  при  которых возбуждается
вирусная тревога,  известны нападающему,  то может быть  сделан  вирус,
работающий  вне  рамок  этих  условий.  Интеллектуальная следящая схема
могла  бы  приспосабливаться  так,  что  условия  не  моли   бы   легко
определяться  нападающим.  Хотя  эта  "игра" может легко прокручиваться
взад и вперед, частота опасных запросов может оказаться слишком низкой,
чтобы замедлить распространение необнаруженного вируса, не конфликтуя с
законным использованием сервисов.

    Было изучено  несколько  систем  на  наличие  в  них   способностей
обнаруживать  вирусную  атаку.  Удивительно,  но ни одна из этих систем
даже  не  сохраняла  список  программ,  запускающих  другие  программы.
Трассировка  подобного  типа почти несомненно должна быть использована,
если есть необходимость обнаружить даже простейшую вирусную атаку.

    Если вирус  уже  имплантирован,  он  не  может  быть  легко  удален
полностью.   Если   система  продолжает  работать  во  время  удаления,
программа может быть бы инфицирована повторно. Это означает бесконечную
погоню   за   собственным   хвостом.   Без   некоторого  ограничения  в
возможностях,  удаление вероятно  будет  невозможным,  если  программа,
выполняющая  удаление,  медленнее,  чем  процесс размножения удаляемого
вируса.  Даже в случаях,  когда удаление медленнее, чем вирус, возможно
позволять большинству активных процессов выполняться в течение удаления
без опаски еще более замедлить процесс  удаления.  Например,  можно  бы
изолировать пользователя или подмножество пользователей и лечить их, не
запрещая обмен с другими пользователями.

    В общих чертах,  точное удаление зависит  от  точного  обнаружения,
поскольку  без  точного  обнаружения  невозможно  должно  узнать точно,
следует ли удалять  данный  объект.  В  отдельных  случаях  может  быть
возможным,   чтобы   выполнять   удаление  с  использованием  неточного
алгоритма.  Например,  каждый файл,  созданный после определенной даты,
мог  быть  просто  удален  для  того,  чтобы  уничтожить  любой  вирус,
стартовавший после этой даты.

    Единственное, что смущает, это существование шанса, что вирус может
быть сгенерирован спонтанно. Это сильно связано с вопросом, как долго N
обезьян должны стучать по  N  клавиатурам,  чтобы  написать  вирус  без
посторонней помощи.

                 ЭКСПЕРИМЕНТЫ С КОМПЬЮТЕРНЫМИ ВИРУСАМИ

    Для того,  чтобы продемонстрировать возможности  вирусной  атаки  и
степень угрозы, было выполнено несколько экспериментов. В каждом случае
эксперименты были выполнены с ведома и согласия администраторов систем.
После  выполнения  экспериментов все следы были тщательно аннулированы.
Критически важно,  что эти эксперименты не были основаны на оплошностях
реализации,   но   только   на   фундаментальных   недостатках  политик
безопасности.

                             Первый Вирус

    3 ноября 1983 года был представлен эксперимент  с  первым  вирусом,
специально  подготовленный  для  доклада  на  еженедельном  семинаре по
компьютерной  безопасности.  На  этом  семинаре  сначала  автором  была
рассмотрена  концепция,  а  термин "вирус" был продуман Леном Адлеманом
(Len  Adleman).  (*8*)  После  8  часов  экспертной  работы  в   сильно
загруженной  системе VAX 11/750 под управлением Unix,  первый вирус был
завершен и подготовлен для демонстрации. В течение недели было получено
разрешение   на   проведение  экспериментов,  и  5  экспериментов  были
выполнены.  10  ноября  вирус  был  продемонстрирован  на  семинаре  по
безопасности.

    Исходная инфекция была имплантирована в vd,  - в программу, которая
отображает   файловые   структуры   Unix   наглядно   и   предоставляет
пользователям через системный информационный  бюллетень.  Поскольку  vd
была новой программой в системе,  никакие характеристики исполнения или
другие детали известны  не  были.  Вирус  был  имплантирован  в  начало
программы  так,  чтобы  он  исполнялся  перед  выполнением любых других
операций.

    Для того, чтобы держать атаку под контролем, были приняты несколько
мер предосторожности.  Все инфицирования выполнялись вручную, и никакой
ущерб нанесен  не  был,  только  выводились  сообщения.  Была  включена
трассировка,    чтобы    гарантировать    для    вируса   невозможность
распространяться незаметно,  управление доступом  было  использовано  в
процессе инфицирования,  а код,  необходимый для атаки,  был заключен в
сегментах,  каждый из котрых был закодирован и защищен  таким  образом,
чтобы предохранять незаконное использование.

    Во время каждой из пяти атак все системные права были предоставлены
нападающему в течение часа.  Самое короткое время было около 5 минут, а
среднее время составляло около 30 минут.  Даже те, кто знали, что атака
будет  происходить,  были  заражены.  В  каждом   случае   файлы   были
подвергнуты  дезинфекции после эксперимента,  чтобы гарантировать,  что
никакая секретность пользователя  не  будет  нарушена.  Ожидалось,  что
атака  будет  иметь  успех,  но  удивительным  было короткое время,  за
которое все это произошло. Кроме того, вирус сам по себе был достаточно
быстрым  (около  1/2  секунды),  так  что  что  задержки  в  выполнении
зараженных программ были незаметны.

    Как только  результаты экспериментов были объявлены, администраторы
сообщали,  что  никакие   дальнейшие   эксперименты   по   компьютерной
безопасности  не  должны  больше  проводиться в их системе.  (*9*) Этот
запрет распространялся  даже  на  запланированное  формирование  трасс,
которое позволило бы проследить потенциальные вирусы, и на эксперименты
по  увеличению  пароля,  которые   могли   бы   потенциально   улучшить
безопасность.  Типичной  являлась  именно подобная явная реакция страха
вместо того,  чтобы решать технические проблемы технически, также часто
выбирались решения, связанные с изменением политик безопасности.

    После того,  как успешные эксперименты  были  выполнены  в  системе
Unix, стало абсолютно явным, что те же методы должны работать во многих
других системах. Конкретно, эксперименты были запланированы для системы
Tops-20,  системы VMS, системы VM/370, и для сети, содержащий некоторые
эти системы.  В процессе переговоров  с  администраторами,  возможность
была  продемонстрирована посредством разработки прототипов и испытаний.
Атака  прототипа  для  системы   Tops-20   была   разработана   опытным
пользователем Tops-20 в течение 6 часов,  пользователем-новичком VM/370
с    помощью    опытного    программиста    через    30    часов,     и
пользователем-новичком  VMS без посторонней помощи через 20 часов.  Эти
программы демонстрировали способность  находить  файлы,  которые  нужно
заражать, заражали их и преодалевали пользовательские ограничения.

    После нескольких месяцев согласований и административных изменений,
эксперименты  не  были  разрешены.  Офицер  безопасности  находился   в
постоянной оппозиции к экспериментам, и отказывался рассматривать любые
предложения.  Особенно интересно  то,  что  ему  предложили  пригласить
системных программистов и специалистов по безопасности, чтобы наблюдать
за всеми аспектами экспериментов.  Кроме того, системные администраторы
отказывались   предоставлять   версии  регистрационных  логов,  которые
предполагалось  использовать  для  оффлайнового  анализа  потенциальной
вирусной   унрозы,   и   не   соглашались  добавлять  (силами  тамошних
программистов) дополнительную трассировку  системных  процессов,  чтобы
при их помощи обнаруживать вирусную атаку. Хотя эта работа не выглядела
опасной,  требовала небольших времени,  денег и усилий,  тем  не  менее
администраторы были несклонны разрешать исследования. Оказалось, что их
реакция была такой же, как и реакция страха администраторов Unix.

            Системы, основанные на политике Bell-LaPadula

    В марте 1984 г.  начались переговоры по выполнению экспериментов на
системе,  основанной на политике Bell-LaPadula [Bell73] и работавшей на
платформе  Univac  1108.  Эксперимент  был  рассчитан  в  принципе   на
несколько   часов,   но   потребовал   нескольких  месяцев  для  своего
завершения.  В июле  1984  г.  был  выделен  двухнедельный  период  для
экспериментирования. Цель этого эксперимента заключалась в демонстрации
возможности вируса поразить систему,  безопасность которой основана  на
политике Bell-LaPadula.

    Из-за чрезвычайно  ограниченного  времени  на  разработку (26 часов
работы пользователя,  который никогда  ранее  не  использовал  1108,  с
помощью  программиста,  который  не  использовал 1108 в течение 5 лет),
множество вопросов реализации  были  проигнорированы.  Конкретно,  были
проигнорированы   вопросы   временной  производительности  атаки  и  ее
масштабов.  В результате,  каждая инфекция требовала около  20  секунд,
хотя  на  самом  деле  это  могло быть легко сделано в течение секунды.
Следы вируса были оставлены в системе, хотя они могли бы быть устранены
в  значительной  степени  с  небольшими  усилиями.  Вместо того,  чтобы
заражать множество файлов сразу,  заражался  только  один  файл.  Такой
подход   допускал   распространение   вируса,  которое  можно  было  бы
обнаружить,  не включая при этом  в  процесс  много  пользователей  или
программ.  Вследствие мер предосторожности, система была использована в
выделенном режиме с только одним системным  диском,  одним  терминалом,
одним принтером,  а учетные записи были предназначены исключительно для
эксперимента.

    После 18-часового сеанса связи вирус для 1108 выполнил  свою первую
инфекцию.   Хост   обеспечил  довольно  полный  набор  пользовательской
документации,  доступ к системе  и  помощь  компетентного  пользователя
системы.  После  26  часов  экспериментов  вирус  был продемонстрирован
группе из 10 людей,  включая администраторов,  программистов и офицеров
безопасности.     Вирус     демонстрировал    способность    пересекать
пользовательские ограничения и  перемещаться  с  более  низкого  уровня
безопасности на более высокий.  Кроме того,  и это должно быть отмечено
особо, в этот процесс не были включены никакие специальные повреждающие
действия, но модель Bell-LaPadula вполне законно обеспечила возможность
этого.

    В общем,  выполнить атаку была не трудно. Код для вируса состоял из
5 строк сборочного кода, около 200 строк кода на языке Fortran, и около
50  строк  командных  файлов.  Оценено,  что   компетентный   системный
программист  мог  бы  написать  значительно  лучший вирус примерно за 2
недели.  Кроме того,  как только становится понятной  природа  вирусной
атаки,    легко    разработать   ее   специфический   вариант.   Каждый
присутствующий программист был убежден,  что они мог бы создать  лучший
вирус  за то же время.  (Это похоже на правду,  поскольку нападающий не
имел предварительного опыта работы на 1108).

                             Оборудование

    В начале августа 1984 г. было получено разрешение оснастить систему
VAX Unix средствами,  предназначенными для измерения разделения доступа
и анализа вирусного распространения.  Данные на этот  раз  были  совсем
ограничены,  но  позволили  обратить  внимание  на  новые  направления.
Оказалось,  что степень разделения доступа варьируется  существенно  от
системы  к  системе,  и  для того,  чтобы в этом убедиться,  необходимо
предварительно переоборудовать множество систем.  Небольшое  количество
пользователей  обладают  большими правами по разделению доступа,  можно
было   бы   существенно   ограничить   вирус,   защитив   именно   этих
пользователей. Защита нескольких "особо общительных" индивидуумов могла
бы также замедлить биологические болезни.  Следящее  оборудование  было
консервативным в том смысле,  что инфекция могла бы случиться и без его
участия, так что скорость атаки получилась нереально медленной.

    В результате применения в системе  такого  рода  оборудования  было
определено  множество  "особо  общительных" пользователей.  Присутствие
некоторых из них в этом списке удивило главного администратора системы.
Количество  пользователей  с административными правами оказалось весьма
высоким,  и если любой из них оказывался  заражен,  то  и  вся  система
заражалась  в пределах часа.  Предложенные довольно простые процедурные
изменения замедляли скорость  этой  атаки  на  несколько  порядков,  не
уменьшая при этом функциональных возможностей.

                         Итоги распространения

         система 1                         система 2

 класс|  ##  |распр.| время|     класс|  ##  |распр.| время|
----------------------------    ----------------------------
|  S  |  3   |  22  |   0  |    |  S  |  5   |  160 |   1  |
|  A  |  1   |   1  |   0  |    |  A  |  7   |   78 | 120  |
|  U  |  4   |   5  |  18  |    |  U  |  7   |   24 | 600  |

    Рассмотрены две   системы  с  тремя  классами  пользователей  (S  -
система, A - системный администратор, U - пользователь). '##' указывает
количество пользователей в каждой категории, "распр." (распространение)
является средним количеством пользователей,  на  которых  вирус  должен
распространяться,  а "время" является средним временем, использованным,
чтобы заразить их после входа в систему,  округленное в большую сторону
в ближайшую минуту. "Среднее время" вводит в заблуждение, поскольку как
только  инфекция  достигает   root-а   на   Unix,   то   вирусу   сразу
предоставляется полный доступ.  Если это случается,  то требуется время
порядка одной минуты, поскольку с этого момента ограничивающим фактором
скорости распространения становится собственно время инфицирования. Это
совпадает с  предыдущими  экспериментальными  результатами,  в  которых
использовался реальный вирус.

    Пользователи, которые  не  участвовали  в разделении доступа,  были
проигнорированы в этих подсчетах,  но другие  эксперименты  показывают,
что  любой  пользователь  может участвовать в разделении доступа,  имея
доступ  к  системному  информационному  бюллетеню.   Детальный   анализ
продемонстрировал,  что  системные  администраторы  стремятся пробовать
новые программы,  как  только  они  появляются.  Это  дает  возможность
обычому   пользователю  заразить  системные  файлы  в  течение  минуты.
Системные  администраторы  использовали  свои  учетные  записи  запуска
программ  других  пользователей и сохраненя часто выполняемых системных
файлов,   также   некоторые   обычные    пользователи    имели    часто
использовавшиеся   файлы.  Эти  условия  делают  вирусную  атаку  очень
быстрой.  Было немедленно предложено использование  раздельных  учетных
записей  для системных администраторов в процессе нормальной работы,  а
также систематическое перемещение (после  проверки)  часто  исполняемых
программ в системную область.

                          Другие эксперименты

    Аналогичные эксперименты   были  проведены  в  ряде  систем,  чтобы
продемонстрировать возможность выполнения вирусов во  многих  системах.
Простые  вирусы были написаны для VAX VMS и VAX Unix на соответствующих
командных языках,  и ни одна программа не потребовала для своей  работы
более  10  строк  на  командном  языке.  Вирус  для  Unix  независим от
компьютера  на  котором  он  выполняется,  и,  следовательно,  способен
работать под IDRIS,  VENIX и в других UNIX-системах.  Вирус, написанный
на Бэйсике и состоящий из 100 строк, был реализован для Radio Shack TRS
-80,  IBM PC и нескольких других машин с расширениями языка Basic. Хотя
все это были низкоуровневые  вирусы,  который  обнаруживаются  довольно
легко  создателем любой подобной программы,  все-таки это редко бывает,
что рабочая программа изучается своим создателем после  того,  как  она
запущена.  Во всех этих случаях вирусы написаны аким образом,  чтобы по
трассам их распространения в соответствующих операционных системах было
невозможно определить источника вируса,  даже если сам вирус обнаружен.
Поскольку вирусы для UNIX и вирусы,  написанные на  Бэйсике,  могли  бы
легко распространяться через гетерогенную сеть, они рассматриваются как
особо опасные.

    И на этот раз мы опять не смогли получить разрешение  на наблюдение
или  эксперименты  в  любой  из  систем,  для  которых  эти вирусы были
написаны.  Результаты,  полученные для этих систем,  основаны  в  очень
простых  примерах и не могут отражать их общее поведение в системах при
обычном использовании.

                            Итоговые выводы

    Следующая таблица объединяет результаты экспериментов  на настоящий
момент. По горизонтали идут три системы (Unix, Bell-LaPadula и следящее
оборудование), тогда как по вертикали идет указывает производительность
(время   программирования   и  инфицирования,  количество  строк  кода,
количество   выполненных   экспериментов,   минимальное,   среднее    и
максимальное  времена  владения)  где  "время  владения"  -  это время,
которое требуется нападающему для владения  ресурсами,  чтобы  внедрить
вирус.

                              Итоги атак

                | Unix-C|  B-L  | Instr |Unix-sh|  VMS  | Basic |
                -------------------------------------------------
        Time    | 8 hrs |18 hrs |  N/A  | 15min | 30min | 4 hrs |
                -------------------------------------------------
        Inf t   |.5 sec |20 sec |  N/A  | 2 sec | 2 sec | 10 sec|
                -------------------------------------------------
        Code    | 200 l | 260 l |  N/A  |  7 l  |  9 l  | 100 l |
                -------------------------------------------------
        Trials  |  5    |  N/A  |  N/A  |  N/A  |  N/A  |  N/A  |
                -------------------------------------------------
        Min t   | 5 min |  N/A  |30 sec |  N/A  |  N/A  |  N/A  |
                -------------------------------------------------
        Avg t   |30 min |  N/A  |30 min |  N/A  |  N/A  |  N/A  |
                -------------------------------------------------
        Max t   |60 min |  N/A  |48 hrs |  N/A  |  N/A  |  N/A  |
                -------------------------------------------------

    Оказалось, что  вирусная  атака  может  быть  легко  разработана за
короткое  время,  может  оставлять  мало  следов  в  самых  современных
системах,   эффективна   против   современных   политик   безопасности,
применяемых для многоуровневого использования,  и требует  минимального
опыта для своего осуществления.  Потенциальная угроза вирусов серьезна,
они  могут  распространиться  очень  быстро  по  компьютерной  системе.
Оказывается,  что они могут распространятья через компьютерные сети так
же,  как  они  распространяются  по  компьютерам  и,   таким   образом,
представляют  собой  обширную  и  актуальную угрозу для многих реальных
систем.

    Проблемы с  правилами,  которые  запрещают эксперименты с системами
безопасености,  понятны;  лишая пользователей способности продолжать их
работу,   тем   самым  провоцируются  незаконные  атаки;  и  если  один
пользователь сумел запустить атаку,  не используя  системные  дыры  или
специальные  знания,  то  и  другие пользователи также будут способными
сделать это.  Просто предупреждая пользователей, чтобы они не запускали
атаку,  невозможно  достичь цели;  пользователи,  которым доверяют,  не
будут запускать атаку (*10*); но нельзя доверять пользователям, которые
могут  нанести  вред,  так  что законная работа окажется заблокирована.
Перспектива,  что каждая допущенная атака  уменьшает  безопасность,  по
мнению автора - ошибка. Идея использовать атаки, чтобы изучать проблемы
даже  потребовала  участия  государственной  политики  для  обеспечения
надежности   систем  [Klein83]  [Kaplan82].  Будет  более  рациональным
использовать  открытый  и  управляемый  эксперимент  как   ресурс   для
увеличения безопасности.

               ОКОНЧАТЕЛЬНЫЕ ВЫВОДЫ И ДАЛЬНЕЙШИЕ ПЛАНЫ

    Короче говоря,  абсолютная  защита  может  легко  быть   достигнута
применением  абсолютного  изоляционизма,  но  это  обычно  неприемлемое
решение.  Другие формы защиты,  как кажется,  связаны с  использованием
чрезвычайно  сложных  и/или  ресурсоемких  аналитических  методов,  или
неточных решений, которые делают такие системы все менее пригодными.

    Оказалось, что  предотвращение  вирусных  атак  включает   законные
ограничительные   действия,   тогда   как   лечение  может  потребовать
существенных нарушений принятых законов и  правил.  Точное  обнаружение
является  неразрешимыми,  тем не менее статистические методы могут быть
использованы, чтобы ограничить необнаруженное распространение вируса по
скорости  или количеству.  Поведение типичного пользователя должно быть
хорошо изучено для того,  чтобы использовать статистические  методы,  и
это  поведение  может  изменяться  от системы до системы.  Ограниченные
формы обнаружения и  предотвращения  могли  бы  быть  использованы  для
ограниченной защиты из вирусов.

    Продемонстрировано, что       потенциально      вирус      способен
распространяться в любой системе, которая допускает разделение доступа.
Каждая универсальная система,  используемая в настоящее время,  открыта
для по крайней мере ограниченной вирусной атаки.  Во многих  "надежных"
системах  вирусы  стремятся  распространяться  при  помощи "ненадежных"
пользователей.  Эксперименты показывают жизнеспособность вирусной атаки
и   указывают,   что  вирусы  распространяют  быстро  и  легко  в  ряде
операционных систем. Дальнейшие эксперименты все еще впереди.

    Настоящие результаты  не  специфичны  для  какой-нибудь  конкретной
операционной   системы   или   специфической  версии,  но  основаны  на
фундаментальных  свойствах  систем.  Более  важно,  что  они   отражают
реалистичные предположения о системах,  используемых в настоящее время.
Далее,  почти  каждая  "безопасная"  система,  разрабатываемая  сейчас,
основана  на  политике  Bell-LaPadula  или  табличных политиках,  и эта
работа  ясно  продемонстрировала,  что  эти  модели  недостаточны   для
предохранения  от  вирусной  атаки.  Вирус по существу доказывает,  что
управление целостностью  должно  считаться  существенной  частью  любой
безопасной операционной системы.

    Упомянем несколько пока еще нерешенных проблем,  касающихся вирусов
и мер антивирусного противодействия.

Это:

Проблемы неразрешимости обнаружения
Обнаружение вируса по внешнему виду
Обнаружение вируса по поведению
Обнаружение эволюций известного вируса
Обнаружение переключающего механизма по внешнему виду
Обнаружение переключающего механизма по поведению
Обнаружение эволюционирующего переключающего механизма
Обнаружение вирусного детектора по внешнему виду
Обнаружение вирусного детектора по поведению
Обнаружение эволюционирующего вирусного детектора

    Несколько потенциальных  контрмер были изучены более-менее глубоко,
и ни одна  из  них  не  является  идеальным  решением.  В  этой  статье
предлагались некоторые методы, которые могли бы обеспечить ограниченную
вирусную  защиту,  но  применимость  их   на   текущий   момент   также
ограниченна.  Чтобы  полностью  обезопасить себя против вирусной атаки,
система должна защититься от поступающего информационного потока, тогда
как,   чтобы   защититься  против  утечки  информации,  система  должна
защититься против исходящего информационного потока. Также определенный
информационный  поток  должен  обеспечивать работу систем с разделением
доступа.  Основной вывод этой статьи,  что цели  разделения  доступа  в
универсальной  многоуровневой  системе  могут прямо противоречить целям
вирусной безопасности,  что  делает  их  примирение  и  сосуществование
невозможными.

    Наиболее важное   в   данном  исследовании  -  влияние  вирусов  на
компьютерные сети.  Прежде всего интересно,  как быстро  вирус  мог  бы
распространиться на большинство компьютеров в мире.  Это делается через
упрощенные   математические    модели    и    исследования    вирусного
распространения  в  "типичных"  компьютерных сетях.  Последствия работы
вируса в безопасной сети  также  вызывает  большой  интерес.  Поскольку
вирус  приводит  нас  к  вере,  что  как целостность так и безопасность
должны поддерживаться в  системе  для  того,  чтобы  предохраняться  от
вирусной  атаки,  сеть должна также поддерживать оба критерия для того,
чтобы допускать многоуровневое разделение доступа  между  компьютерами.
Это  приводит  к  необходимости  введения  существенных  ограничений на
функции этих сетей.

    Были разработаны примеры  эволюционирующих  программ  для  создания
множества  модификаций  конкретной программы.  Простой эволюционирующий
вирус уже разработан, и для него сейча разрабатывается эволюционирующий
антивирус.  Механизм  списка потоков для Unix будет осуществлен,  когда
необходимые  аппаратные  средства  будут  доступны,  и  ожидается,  что
следящие   за  сетями  средства  появятся  после  получения  средств  и
ассигнований.  Статистические   методы   обнаружения,   основанные   на
результатах  работы  таких  средств - также планируется разработать,  а
набор принципов и правил для уменьшения вирусной угрозы уже разработан.

                             Благодарности

    Вследствие специфической природы большинства  этих  исследований  и
экспериментов,  имеется  множество  людей,  которых  я  просто не смогу
отблагодарить.  Вместо того,  чтобы умолчать о  таких  людях,  я  решил
просто назвать их имена. Len и David снабдили существенной поддержкой и
при исследованиях,  и при написании статьи,  и без них я бы не добрался
до этого места. John, Frank, Connie, Chris, Peter, Terry, Dick, Jerome,
Mike,  Marv,  Steve, Lou, Steve, Andy и Loraine совали свои носы во все
аспекты   не   менее,  чем  помогали  при  выполнении  экспериментов  и
публикации результатов, чем и поддерживали работу. Martin, John, Magdy,
Xi-an,  Satish,  Chris, Steve, JR, Jay, Bill, Fadi, Irv, Saul и Frank в
основном помалкивали,  но их  терпение  и  дружеское  участие  являются
неоценимыми.   Alice,   John,   Mel,   Ann   и  Ed  обеспечили  большую
безопасность, чем АНБ для всех нас.

=======================================================================

                        КОММЕНТАРИИ ПЕРЕВОДЧИКА

Примечание 1.

    "Машина Тьюринга" - формальная математическая  модель, используемая
в  теории алгоритмов.  Представляет собой бесконечную ленту с ячейками,
пронумерованными  целыми  индексами.  Каждая  ячейка  содержит  символ,
принадлежащий  некоему  алфавиту (в том числе и символ "пусто").  Кроме
того,  над  лентой   перемещается   программно-управляемая   "головка",
способная  читать и записывать находящиеся в ячейках символы. Программа
для "машины Тьюринга" представляет собой таблицу команд,  зависящих  от
текущего   символа   и   текущего   состояния  машины.  Функциональными
эквивалентами  "машины  Тьюринга",  разработанной  в   1936   году   А.
Тьюрингом, являются "машина Поста" и "конечные цепи Маркова".

Примечание 2.

    Понятие "NP-полноты"   используется   для  описания  вычислительной
сложности алгоритмов.  В рамках теории алгоритмов рассматриваются:
    1) P  -  класс алгоритмов,  выполняющихся за "полиномиальное" время
(т.е.  за время,  рассматриваемое в  смысле  количества  шагов  "машины
Тьюринга"  и  описываемое  полиномиальной  функцией  от размера входных
данных);
    2) NP  -  класс  алгоритмов,  включающих  себя некоторую (возможно,
неформальную) процедуру,  позволяющую сразу выбрать вариант "ответа"  и
доказать его правильность/неправильность при помощи алгоритма класса P.
    Строго не доказано,  но общепризнано,  что |P|<|NP|.  Для  описания
подмножества экстремально сложных алгоритмов, принадлежащих к NP, но не
принадлежащих к P, используется термин "NP-полные".

Примечание 3.

    "Транзитивное замыкание"  (по  к/л  отношению)  -  понятие   теории
множеств. Это подмножество всех элементов множества, находящихся в в к/
л оределенном отношении друг с другом либо сразу  непосредственно, либо
через  другие  элементы,  находищиеся  друг с другом в непосредственном
отношении.

Примечание 4.

    Критику тезиса о "сжимающем вирусе" см.  в статье Весселина Бончева
"Действительно ли хорошие  компьютерные  вирусы  по  прежнему  являются
плохой   идеей".

Примечание 5.

    Политика безопасности   -  формальная  модель,  включающая  в  себя
определенную  систему  правил  и  призванная  обеспечить   "надежность"
информационых   систем.   В  рамках  этих  моделей  пассивные  "объекты
доступа" подвергаются со стороны активных "объектов  доступа"  каким-то
действиям  в  соответствии  с определенными "методами доступа" (чтение,
запись,  исполнение и т.п.),  а  разрешение/заперещение  этих  действий
производится "монитором  безопасности".  В  общем  случае  все политики
безопасности можно разделить на две большие группы:
    1) дискреционные, основанные  на  системах   разрешений/запрещений,
определенных для каждой тройки <"субъект","объект","метод">;
    2) мандатные, основанные  на  присвоении  каждому   "объекту"   или
"субъекту" определенной "метки безопасности" и на разрешении/запрещении
конкретного действия путем сравнения этих меток.
    Часть современных  политик содержат в себе черты как первой,  так и
второй групп.

Примечание 6.

    Любопытно, что  из  контекста  статьи  вытекает  понятие "эволюции"
вируса гораздо более широкое,  чем  тривиальный  вирусный  полиморфизм,
приведенный автором в качестве примера.

-----------------------------------------------------------------------
    Перевод и примечания (с) Климентьев К.Е., 1997-98, 2004
