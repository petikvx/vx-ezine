/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
					Позиционно-независимый код на HLL
					Загрузка DLL из памяти
/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
	Добрый вечер.

	Писать вирусы на ассемблере - жуткая шиза, иногда появляются черти перед 
глазами и звон в ушах. Вместо этого хочется создавать новые вирусы быстро и 
качественно. Поэтому встает вопрос о вирусах на Си, Делфи и даже 
бейсике как о более простом способе создания вирусов. Правда обычно эти твари
лишены главного достоинства ассемблерных вирей - позиционной независимости кода.
Именно эта фишка позволяет вирусам на асме без особых проблем внедряться в любой
чужеродный код. 
	Написание позиционно-независимого кода на Си превращается в войну с ком-
пилятором. Вариантов tyt несколько:
1) Изгаляться с макросами. Все глобальные преременные собрать в структуру,
адреса вызовов WinAPI собрать в массив. Инициализированные данные реализовать 
через макросы. Результат зависит от компилятора. У меня, например, код скомпили-
ровался на BСС и не прошел на LCC и MSVC.
2) Писать основу вируса на асме и делать вызовы процедур на HLL. В параметрах 
должны быть -- таблица API и таблица глобальных переменных. Некошерно.
3) Правка таблицы импорта заражаемой программы. Для этого заражаемую программу
надо фактически пересобирать заново.
4)
	К счастью, корпорация Microsoft предусмотрела отличное решение проблемы. 
Речь идет о таблицах перемещений в DLL. Итак, мы пишем полноценный модуль DLL 
на любом высокоуровневом языке и затем вставляем его в вирус. Как выяснилось, 
загружать DLL можно прямо из памяти. 
	Загрузчик приведен в файле loader.cpp. Он был написан по материалам статьи
из MSDN "Inside Win 2000". Область памяти воспринимается как DLL. Сначала
загрузчик пытается выделить область памяти начиная с imagebase, затем в случае 
неудачи -- в любом другом месте. Секции записываются по своим RVA, производится
перенастройка адресов, заполнение таблицы импортов с загрузкой импортируемых 
DLL. Потом устанавливаются защиты для секций и вызывается DllMain. Все. Теперь 
мы имеем загруженную DLL, не зарегистрированную в системе. От других DLL она 
отличается тем, что не для нее не работает GetProcAddress, FreeLibrary и неко-
торые другие вызовы. У меня получалось загрузить второй экземпляр kernel32 =)
Упакованные UPX и .NET DLL тоже идут на ура.
	Применять это можно в плагинных вирусах, при добавлении worm-компонента в
обычный вирус... Вобщем, охуительная вещь!

Вызов:
	push offset GetProcAddress
	push offset LoadLibraryA
	push offset VirtualFree
	push offset VirtualProtect
	push offset VirtualAlloc
	push offset dll_in_memory
	call dllload
	add esp, 6*4

...
dll_in_memory:
include your_dll.inc
include dllload.inc



/whale                                           Мы работаем под угрозой жизни
                                                 http://vx.netlux.org/~whale
/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
make this staff
	makeinc	
	dll2inc kkldll.dll kkldll.inc		
	mki sample
