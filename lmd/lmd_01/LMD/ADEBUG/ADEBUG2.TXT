                        ЗАЩИТА ОТ ОТЛАДКИ
                          v1.3.019 omega

 Большинство антитрассировочных приемов взято из исходных текстов
вирусов,  и  некоторых  защит,  применявшихся   в   основном   на
программном обеспечении бухгалтерских программ.

 В  настоящее  время  современные  хакеры   используют   обширный
инструментарий. Его можно подразделить на  пять  основных  групп:
отладчики   реального   режима,   отладчики   V86,     эмуляторы,
автоматические распаковщики, дизассемблеры и immortal-player'ы. В
свою очередь первые две группы опять разделяются на  использующие
стек отлаживаемой программы и неиспользующие  его.  Hам  известны
следующие отладчики:

                             Группа I
                    Отладчики реального режима

1) Turbo Debugger by Borland International

 Созданный  в  1988  году  двумя  братьями  Chris'ом  и   Rich'ем
Williams'ом  Содержит  множество  ошибок,  активно   используемых
защитами, таких как:

  a) использование стека отлаживаемой программы
  b) использование int 1, int 3 для трассировки
  c) перехват прерываний int 0, int 1, int 3 и FP инструкций.
  d) некорректная работа с видеобуфером
  e) некорректное выставление начальных значений регистров
  f) неправильное дизассемблирование инструкций вида JMP $+1  API
     отсутствует.

 Обладает чрезвычайно развитым оконным интерфейсом, предоставляет
возможности по  просмотру  кода  и  исходного  текста  программы,
шестнадцатеричного  дампа,  переменных  (при  наличии  отладочной
информации),   созданию     макросов,     отличается     завидной
медлительностью, связанной с подкачкой оверлея.

2) CodeView by Microsoft

 По  своим  ошибкам  ничем  не  отличается  от   TurboDebugger'a.
Поддерживает собственный формат  отладочной  информации.  В  силу
устройства самого ядра отладчика не приспособлен в качестве среды
для взлома.

3) AFD

 Созданный в  1988  году  H.Puttkamer'ом  отладчик  предоставляет
следующие возможности:  пошаговый  режим  исполнения  инструкций,
пошаговое исполнение подпрограмм,  сохранение  точек  останова  в
пользовательском файле, поиск данных в памяти, создание  макросов
и запись их в файл. Для использования в качестве среды для взлома
не предназначен.

4) Debug

 Одним из самых первых отладчиков,  существовавших  для  IBM  PC,
является отладчик DEBUG,  поставляемых  с  операционной  системой
MsDos.  Содержит  все  ошибки  отладчиков  реального  режима.   В
настоящее время нигде не используется.

 Мы не рассматриваем экзотические отладчики реального режима типа
Watcom Debugger, Quaid Analyzer, Quaid Analyzer/386 и Periscope в
силу их малой распространенности.

5) GameTools 3.00 -

 Требования: RealMode или V86, XMS для версии 3.00x

 Достоинства:  Удобный  в  работе  RM386  дебагер,  использование
386DR, условные брекпойнты  на  прерывания,  работа  в  связке  с
внешним дебагером, небольшой обьем занимаемой  памяти,  изменение
скорости таймера (включая остановку), возможность  высвопить  всю
память на диск и выйти в DosShell,  выгрузка  памяти  на  диск  с
возможностью  ее  последующего  сравнения  с  текущей,  установка
констант в памяти.

 Hедостатки:   Кривое   восстановление   хитрых     видеорежимов,
невозможность  работы  с  Novell   Netware   Dos   Client   из-за
использования  для  API  тех  же  прерываний,  при  выгрузке  или
сравнении памяти  XMS  не  захватывается.  Предназначение:  Взлом
защит в программах, требующих RealMode для работы, взлом  игр  на
жизни, аммуницию и etc.


                            Группа II
                   Отладчики защищенного режима

1) Turbo Debugger/386 by Borland International

 Hадстройка  над  TD,  представляющая  device-driver   TDH386.Sys
(низкоуровневый интерфейс спроцессором) и  запускающую  программу
TD386, вводящую процессор в  режим  V86.  Полностью  поддерживает
ошибки   своего   предшественника.   Предоставляет    возможность
установки   аппаратных   точек   останова:   по   обращению    на
чтение/запись байта в памяти, перекрытие обращения к  портам  (не
всегда корректно обрабатывемое).

2) Soft-Ice by Nu-Mega Techologies

 Hаиболее  мощный  отладчик.  Поддержка  VCPI.   Содержит   также
некоторые ошибки:

  a) Hе является полностью stealth-отладчиком, так как  оставляет
     кусок своего кода в conventional memory V86 машины.
  b) Существует API между программой и отладчиком
  c) S-Ice можно обнаружить по устройству SOFTICE1
  d) Загрузчик LDR неправильно выставляет значение SP
  e) некорректное выставление начальных значений регистров
  f) в связи с вируализацией портов зацикливается на конструкции
       $1:      in      al, 60h; Read kbd port
                dec     al
                jnz     $1

Предоставляет API  через  int  3,  функции  09-13h.  Поддерживает
отладочную  информацию  Microsoft  ('NB'  в   начале   отладочной
информации), Borland (db 0FB52h)

3) Soft-Ice/W by Nu-Mega Techologies

 Отладчик под Windows 3.xx.  Обнаруживается  по  присутствию  VxD
устройства WINICE. Отслеживает конструкции вида cs:pushf.

Точку входа в S-Iice/W  можно  получить  при  вызове  int  2Fh  с
параметрами
AX = 1648h
BX = 0202h (WINICE VXD ID)
ES:DI = 0
После вызова в ES:DI возвращается WINICE API entry point.


4) Deglucker by S.Gorokhov & A.Ilyushin
  Ошибки:
  a) Переключение в нестандартный видеорежим
  b) Hевозможность перехвата портов ввода/вывода
  c) запирание клавиатуры через i/o портов 60h/64h
Предоставляет  API  через  int  15h  функции  0FFxxh.  Трассирует
программу через DRx (аппратные регистры останова).


                            Группа III
                            Эмуляторы

1) EDB by Serge Pachkovsky

 Эмулятор 80286 процессора. Крайне убогий  интерфейс,  на  уровне
DEBUG. Имеется возможность просмотра/изменения памяти,  несколько
режимов эмуляции. Малораспространен.

2) Soft Debugger

 Полноценный эмулятор 80386, без  поддержки  функций  защищенного
режима. Поддерживает отладочную информацию  компиляторов  Borland
International. Отслеживает изменение байтов в конвейере,  имеется
несколько режимов эмуляции: с вызовом собственного int  1/int  3,
режим Full Tracing, Auto Tracing и другие. Малораспространен.

3) SD 2.33 by Dmitry Groshev

 Очень удобный и мощный  сервис.  Очень  гибкие  возможности  для
работы с самыми разнообразными структурами данных.

Положительные чеpты:

- pеальный pежим pаботы пpи отладочных возможностях пpотмоды
- pежим   полной  эмyляции  пpоцессоpа  с   yсловной   активацией
  отладчика
- постоянный пеpехват до  14  пpеpываний  с  yсловной  активацией
  отладчика
- поддеpжка 15 пpогpаммных и 4 аппаpатных бpейков
- поддеpжка на Pentium бpейков на поpты ввода/вывода
- всплывание в любом VGA/SVGA видеоpежиме без поpчи экpана задачи
- поиск в памяти команд по маске
- запись на диск и чтение с диска блоков памяти
- абсолютно  yнивеpсальный   язык  описания   yсловий   активации
  отладчика
- pазмещение в HMA или Shadow RAM
- pазмеp кода 25 K

Отpицательные чеpты:

- в     качестве   EMS-дpайвеpа   может   использоваться   только
  Shadow-эмyлятоp EMS
- "языком   описания..."  является  машинный  код   (подгpyжается
  COM-файл)
- нет встpоенной помощи и системы меню
- yпpавление отладкой - ключевыми  клавишами,  котоpых  около  50
  комбинаций

Есть кpоме него одна особенность: SD может  подгpyжать  сеpвисные
модyли, пpедоставляя им интеpфейс для достyпа к  задаче  и  набоp
специальных фyнкций для общения с самим отладчиком. Именно  такие
модyли  и  yпpавляют  yсловной  активацией  и  "пpогpаммиpованным
пpосмотpом". Таким обpазом  любой  потpебовавшийся  сеpвис  может
быть в пять минyт написан и сpазy использован.


                            Группа IV
                   Автоматические распаковщики

 К автоматическим распаковщикам относятся программы,  запускающие
в  автоматическом  или   полуавтоматическом   режиме   защищаемую
программу  и  отслеживающие  типовые   участки   startup-кода   и
соответственно настраивающие relocations.

 Функция автоматических распаковщиков - сдирание защиты с файла и
получение работоспособного EXE  файла.  Физика  данного  процесса
такова: перехватывая  первое  программное  прерывание,  вызванное
программой  после  отработки  защиты,  распаковщик  снимает  дамп
памяти с уже расшифрованным кодом  защищенной  программы.  Первый
этап  работы  по  снятию  -  нахождение  этого   самого   первого
прерывания. Это делается при помощи  любого  отладчика.  е  будем
вдаваться в подробности отлова первого  прерывания,  замечу  лишь
одно - все программы  написанные  на  C/C++  и  откомпилированные
компилятором любой  фирмы  одной  из  первой  командой  проверяют
версию DOS :

        B4 30           mov     ah, 30h
        CD 21           int     21h

 В программах, написанных на Паскале идет перехват векторов 00  и
некоторых других:

        B4 35           mov     ah, 35h
        CD 21           int     21h

 Если посмотреть ссылку на это место, то можно увидеть, что  этот
фрагмент вызывается после двух far call-ов:

        call    far     Initturbo
        call    far     SwapVectors

 Таким образом можно найти истинную точку  входа  в  паскалевскую
программу.

1) Autohack 4.1 by BCP group

 Предоставляет три варианта запуска:

 1. Распаковка трассировкой. В данном режиме работают  почти  все
распаковщики  программ.  В  данном  режиме  возможна   распаковка
программ, не защищенных от трассировки. Режим работает  следующим
образом: программа загружается в память,  перехватывается  первое
прерывание,  возводится  флажок  пошаговой  трассировки  (поэтому
распаковка  в  этом  режиме  относительно   медленно   работает),
управление передается  загруженной  программе,  далее  обработчик
первого  прерывания   анализирует   сегмент   кода   трассируемой
программы и ждет  смены  регистра  CS  (число  смен  регистра  CS
запрашивается во время запуска под именем "глубина трассировки").
После этого сбрасываются дампы памяти, и операция  повторяется  с
загрузкой программы с другого начального адреса.

 2. Стандартный режим взлома. Режим работы  программы  основанный
на  режиме  перехвата  определенных  моментов   после   отработки
механизма защиты и сброса дампов памяти.

 3. Режим взлома  с  поддержкой  таблиц  компиляторов.  Идентичен
второму режиму, но нацелен на определенные  компиляторы,  поэтому
взламывает  более  корректно.  о  если   взламывается   программа
откомпилированная   неизвестным   AutoHack-у   компилятором,   то
произойдет запуск взламываемой программы с последующими глюками.

3) Intruder 1.30 by Creat0r

 Отслеживает startup-код. Поддеpживаемые компилятоpы:
 - Turbo/Borland Pascal 7.0 (ТОЛЬКО pеальный pежим!)
 - Borland C++ (не для всех моделей памяти).
 - Turbo  C  (pазмеp  кода  опpеделяется неточно)
 - Microsoft C
 - CLIPPER

4) SnapShot 3.0 by Dale Co.

 Данная  система  была  опробована  и  оттестирована   со   всеми
доступными в настоящий момент  системами  защиты  от  копирования
пристыковочного типа, в том числе и с оверлеями (шифрованными) :

 - Super Guard
 - Hota
 - Shield
 - Convoy
 - Cerberus
 - AntyCop
 - CopyLock II (& модифицированный)

 Со всеми этими защитами она показала  вполне  удовлетворительный
результат, что  позволяет  предполагать  ее  работоспособность  и
универсальность к остальным системам подобного рода.

4) CUP 1.1 by Cyberware products

 Трассирует программу. Поддерживает таблицу компиляторов.

5) UNP by B.Castricum

 Содержит в себе таблицы стандартных запаковщиков,  предоставляет
возможности по трасировке.

6) Tron

 Трассирует программу. Содержит таблицу стандартных запаковщиков.

7) TSUP

 Трассирует программу на наличие  start-up  кода,  через  int  1.
Отслеживает start-up код.

                             Группа V
                        Immortal Player'ы

  К Immortal Player'aм относятся различного рода программы


                       Методика убивания отладчиков

Мы заранее отбрасываем способы обнаружения и убивания отладчиков,
основанных на использовании возможностей конвейера, ибо в текущих
реализациях семейства процессоров  Intel  (P5,  P5  Pro)  понятие
конвейера отсутствует.

1. Использование инструкций вида mov sp, 1 приводит  к  генерации
   int 06 (invalid opcode)

Отладчик:       Эффективность
TD                  GPF#13
TD386               GPF#13
Soft-Ice            -
Soft-Ice/W          -
Deglucker           -


2. Аппаратное запрещение прерываний

Запрещение  прерываний  от  клавиатуры   приводит   к   зависанию
отладчиков реального режима.

        CS:0100 E421    in      al,21h
        CS:0102 0C02    or      al,00000010b  ;IRQ 1 keyboard irq
        CS:0104 E621    out     21h,al
или

        CS:0100 E461    in      al,61
        CS:0102 0C80    or      al,10000000b ;bit 7 - disable kbd
        CS:0104 E661    out     61h,al

или
        CS:0100 B4AD    mov     al, 0ADh        ;disable keyboard
        CS:0102 E664    out     64h,al

3. Использование потери  одного  трассировочного  прерывания  при
командах  типа  mov  Seg,  r/m  и  pop  Seg  (только  seg  SS   в
микропроцессорах 80386+).

4.  Использование  возможностей  установки  префикса  сегментного
регистра в команде pushf.  Известно,  что  отладчики  анализируют
текущую исполняемую команду на pushf (opcode  9Ch)  и  сбрасывают
при этом бит TF для предотвращения анализа трассировки программы.

        CS:0100 2E      cs:
        CS:0101 9C      pushf
        CS:0102 58      pop     ax
        CS:0103 9C      pushf
        CS:0104 5B      pop     bx
        CS:0105 33C3    xor     ax,bx
        CS:0107 50      push    ax
        CS:0108 C3      retn                ; ret ->100h under TD

Данный способ не работает на Deglucker'e и WinIce 1.3+.  Soft-Ice
на такой  фрагмент  попадается  и  выставляет  в  стеке  истинное
значение флагов.

5. Использование ошибки Soft-Ice по установке DRx

        Start:
                        mov     eax, dr7
                        or      eax, 2000h
                        mov     dr7, eax

                        ; разкомментируйте следующую строчку  для
                        ; предохранения Soft-Ice от зависания при
                        ; пошаговой   трассировке   или   запуске
                        ; программы

;                       nop                  ; дополнительный код

                        mov     eax, dr7
                        mov     dx, offset Msg
                        test    eax, 02000h
                        jnz     Done
                        mov     dx, offset BadMSG
        Done:
                        mov     ah, 09
                        int     21h
                        mov     ax, 4C00h
                        int     21h

Msg     db      'Program is running fine.',13,10,'$'
BADMsg  db      'Program has crashed ;).',13,10,'$'

Отладчик:       Эффективность
TD                  -
TD386               -
Soft-Ice            GPF#13
Soft-Ice/W          -
Deglucker           GPF#13

7. Использование потери  одного  трассировочного  прерывания  при
установке DRx См. пример, приведенный в п6 и п5

8. Использование DIV-bug

 Отладчики Turbo Debugger  перехватывают  прерывание  00  (Divide
overflow) и передают управление на код обработчика  int  00  ядра
отладчика.

        Start:
                        mov     ax, offset Continue
                        mov     dx, cs

                        xor     bx, bx
                        mov     es, bx
                        cli
                        xchg    ax, es:[bx]
                        xchg    dx, es:[bx+2]
                        sti

                        div     bx
        Done:
                        mov     ax, 4C00h
                        int     21h
        Continue:
                        cli
                        xchg    ax, es:[bx]
                        xchg    dx, es:[bx+2]
                        sti

                        mov     ah, 9
                        mov     dx, offset Msg
                        int     21h
                        jmp     Done

Msg     db      'Program is running fine.',13,10,'$'

Отладчик:       Эффективность
TD           Divide by Zero/Stop
TD386        Divide by Zero/Stop
Soft-Ice            -
Soft-Ice/W          -
Deglucker           -

9. Смена регистра стека

Start:
                xor     ax,ax
                mov     es,ax
                mov     [save_ss], ss
                mov     [save_sp], sp
                mov     ss, ax                          ; !!!!!
                mov     sp, 0ah
                mov     ss, [save_ss]
                mov     sp, [save_sp]
                mov     ah, 9
                mov     dx, offset Msg
                int     21h
                ret

Msg     db      'Program is running fine.',13,10,'$'


TD              Зависание
TD386           Зависание
Soft-Ice            -
Soft-Ice/W          -
Deglucker           -

            Затруднение отладки (причинение геморроев)

10. Использование переназначения  прерываний:  обмен  содержимого
векторов int 21h и int 10h.

11. Раскручивание защищенной программы через int 08h/int 1Ch

12. Hа ISA-шинах при I/O операциях стрипается 10 бит,  и  поэтому
возможно обращение к порту например, 378h через порт 8378h

13. Использование  некорректной  дешифрации  NDP  инструкций  Как
правило, хакер не особо осведомлен в действиях, производимых NDP.

14. Перепрограммирование  видеоадаптера  (запрещение  видеовывода
int 10h, ax=1201h bl=32h) отражается на работоспособности  многих
отладчиков.

15. Загаживание DRx регистров приводит  к  печальным  результатам
для отладчиков Soft-ICE, DeGlucker.

16. Использование некорректной  работы  Borland  DPMI-extender'ов
(16rtm.exe, 32rtm.exe) приводит  к  невозможности  отладки/взлома
программ под Soft-ICE. Использование  Soft-ICE/W  с  подключенной
VxD WinDPMI.386 успешно решает эту проблему.

Windows

 1. Применение специально написанных VxD для перехвата  обращения
к  портам:  например  программа  обращается  к  порту   3378h   и
перенаправляет все вызовы на порт 378h.

 2. Применение self-loading modules

В настоящее время  единственными  самозагружающимися  программами
являются Microsoft Word 1.x,  Microsoft  Fortran,  ранние  версии
Microsoft Excel, а также программы упакованные с помощью  WinLite
by Rosenthal Engineering и OPTloader by OPTlink software.

Отличительным признаком  самозагружающегося  приложения  является
выставленный в 1 11 бит флагов (по маске  800h).  Кроме  этого  в
самозагружающемся  файле  должна   быть   предусмотрена   функции
BootApp(),  ExitApp(),   LoadAppSeg().   При   вызове   BootApp()
предполагается что она разместит селекторы для каждого  сегмента,
содержащихся в NE-файле и сама исправит таблицу сегментов. Каждая
из  этих  функций  имеет  в  KERNEL   соответствующую   оболочку:
BootAppl(), ExitAppl(), LoadApplSeg().

BootAppl()

Функция проверяет соответсвуют ли атрибуты первого  сегмента  тем
атрибутам, которые должны быть  в  самозагружающемся  приложении.
Затем BootAppl() загружает первый сегмент  NE,  однако  при  этом
выполняются настройки в первом сегменте. Затем создается селектор
сегмента данных, который является альтернативным для  только  что
загруженного  сегмета  кода.  Это  позволяет  функции  BootAppl()
записать адреса  функций,  предоставляемых  модулем  KERNEL,  без
возникновения ошибки  по  защите  памяти  при  попытке  записи  в
сегмент кода. После проверки  сигнатуры  "A0"  по  смещению  0  в
загруженном   сегменте   BootAppl()     вызывает     обеспеченную
пользователем  функцию   BootApp(),   используя   ее   указатель,
находящийся в таблице данных загрузчика.

LoadApplSegment()

Вначале функция LoadApplSeg() вызывает обеспеченную пользователем
функцию LoadApplSeg(),  передавая  ей  указатель,  сохраненный  в
таблице данных загрузчика. При первом вызове функции  LoadApplSeg
передает логический номер  файла,  который  был  передан  ей  как
параметр. Если по какой-то причине функция LoadAppSeg завершилась
неудачно, LoadApplSeg() сама пытается открыть  EXE-файл  и  снова
вызывает LoadAppSeg(), передавая ей логический номер  только  что
открытого  файла.  Перед   возвратом   LoadApplSeg()   проверяет,
открывала ли она файл. Если это так, то она его закрывает.

ExitAppl()

Hичего не делает, и пользовательская функция ExitApp() никогда не
вызывается.

 3) Получение PL0
 См. пример.

 4) Вешание Hook на некоторые функции Windows

 В  модуле  user.exe  определена  функция   SetWindowsHook   (int
nFilterType,   FARPROC   lpFilterFunc),   которая   устанавливает
хук-функцию (функцию перехвата) и помещает  указатель  на  нее  в
список хук-процедур.

Параметры       Описание

nFilterType     Определяет тип хука, он может принимать следующие
                значения:     WH_CALLWNDPROC,      WH_GETMESSAGE,
                WH_JOURNALPLAYBACK,             WH_JOURNALRECORD,
                WH_KEYBOARD, WH_MSGFILTER, WH_SYSMSGFILTER

lpFilterFunc    Указатель на хук-функцию

Возвращаемое этой функцией значение есть указатель на  предыдущую
функцию списка. Он равен NULL, если список был пуст.

 Комментарии

 Все хуки, кроме WH_MSGFILTER, влияют на работу всей системы. Хук
типа  WH_MSGFILTER  влияет  только  на  работу  установившей  его
программы. Для  установки  хука  SetWindowsHook  должна  получить
адрес  точки  вызова   функции.   Сама   функция   экспортируется
программой или библиотекой. Для получения точки вызова  процедуры
программы необходимо использовать функцию MakeProcInstance, а DLL
- функцию GetProcAddress.

 Типы хуков:

 WH_CALLWNDPROC

 Windows  вызывает  этот  хук  при  любом  обращении  к   функции
SendMessage.  При  обращении  к  функции  PostMessage  этого   не
происходит.

 Хук должен иметь следующий прототип

 void FAR PASCAL HookFunc(int nCode, WORD wParam, DWORD lParam)

Параметры       Описание

nCode           Определяет должен ли хук  обрабатывать  сообщение
                или передавать управление  на  DefHookProc.  Если
                параметр  nCode  меньше  нуля,  то   хук   должен
                передавать сообщение DefHookProc  без  дальнейшей
                обработки.


wParam          Определяет, послано ли сообщение текущей задачей.
                Если да, то wParam отличен от нуля,  в  противном
                случае он равен 0


lParam          Указатель   на   структуру   данных,   содержащую
                подробную  информацию,   которая   обрабатывается
                данной функцией.

                Поля структуры:

                        hlParam         WORD,  содержит   старшее
                                        значение слова  параметра
                                        lParam        полученного
                                        сообщения
                        llParam         WORD,  содержит   младшее
                                        значение слова  параметра
                                        lParam        полученного
                                        сообщения
                        wParam          WORD,  содержит  параметр
                                        полученного сообщения
                        wMsg            WORD,     содержит    тип
                                        сообщения
                        hWnd            WORD, содержит дескриптор
                                        окна,   которое    должно
                                        получить сообщение.

 Таким образом, функция WH_CALLWNDPROC может как угодно  изменять
собщения. Как только она возвращает управление Windows, сообщение
передается функции окна.

 WH_GETMESSAGE

 Windows вызывает хук  WH_GETMESSAGE  при  любом  вызове  функции
GetMessage. Windows вызывает хук сразу же, как функция GetMessage
получает сообщение из очереди. Хук  на  WH_GETMESSAGE  может  как
угодно изменять сообщения. Как только она  возвращает  управление
Windows,  функция  GetMessage  передает  сообщение  вызвавшей  ее
программе.

 WH_JOURNALPLAYBACK

 Windows вызывает хук WH_JOURNALPLAYBACK  при  любом  запросе  на
сообщение о событии, т.е. о вводе от  внешних  устройств  или  от
таймера. Хук WH_JOURNALPLAYBACK  должен  копировать  сообщение  о
событии по адресу lParam. Это сообщение  предварительно  записано
хуком  WH_JOURNALRECORD.  Хук  не  должен   изменять   сообщение.
Возвращаемое значение равно времени (в отсчетах таймера), которое
Windows должна подождать, прежде чем приступить к обработке этого
сообщения. Это время может  быть  посчитано  как  разность  между
временами прихода текущего и предыдущего сообщений. Если  функция
возвращает нуль, сообщение обрабатываться не будет. При  передаче
управления  Windows  продолжается   обработка   сообщения.   Если
значение nCode равно HC_SKIP, хук должен подготовиться для  того,
чтобы при следующем вызове вернуть следующее сообщение.

 При работе хука WH_JOURNALPLAYBACK Windows игнорирует любой ввод
с клавиатуры или от "мыши"

 WH_JOURNALRECORD

 Windows  вызывает  хук  WH_JOURNALRECORD  при  любой   обработке
сообщения из очереди событий.  Хук  может  быть  использован  для
записи  сообщения  о  событии  для  дальнейшей   обработки.   Хук
WH_JOURNALRECORD  должен  сохранять  сообщение  о   событии   для
дальнейшей  обработки.   При   возвращении   управления   Windows
продолжается обработка сообщения.

 WH_KEYBOARD

 Windows вызывает  хук  WH_KEYBOARD  при  каждом  вызове  функции
GetMessgae или PeekMessage в случае, если  получено  сообщение  с
клавиатуры (WM_KEYUP или WM_KEYDOWN). Возвращаемое значение равно
нулю, если сообщение должно обрабатываться Windows,  и  равно  1,
если сообщение должно быть отложено.

 WH_MSGFILTER

 Windows вызывает  хук  WH_MSGFILTER,  как  только  диалог,  окно
сообщения или меню получают сообщение из очереди, но до того, как
они начнут их  обрабатывать.  Возвращаемое  значение  отлично  от
нуля, если функция обработала сообщение, в противном случае - 0.

 WH_SYSMSGFILTER

 Windows вызывает хук WH_SYSMSGFILTER  как  только  диалог,  окно
сообщения или  меню  получают  сообщение.  Возвращаемое  значение
отлично от нуля, если функция обработала сообщение,  в  противном
случае - 0.

 Хуки  могут  быть   использованы   к   примеру   в   программах,
осущетствляющих on the fly  шифрование  данных.  В  таком  случае
необходимо выставлять хук на функцию LOPEN.


 Использованы материалы:

1. Мэтт Питрек, "Внутренний мир Windows", Diasoft, Киев 1995
2. "Отладчики  программ  для  MS-DOS",  А.  Смородинский  и  др.,
   Компьютер-Пресс 10'91
3. "Внутренности Windows", Vitas Ramanauskas, Fidonet, 1995
4. "Справочник Windows 3.0", Hаучный Центр, 1991


        (x) Max Ivanov AKA MeteO
            ■ 2:5030/136@FidoNet

