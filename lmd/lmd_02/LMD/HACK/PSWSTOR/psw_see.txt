┌──┌─┐┌──
──┘├─┘──┘ Presents
┐  ┌┐┐┌─┤ VMag, Issue 2, 1 June 1998
└─┘┘ ┘└─┘ ──────────────────────────

   Выуживание пользовательских паролей в сетях Novell 3.x и выше.
   --------------------------------------------------------------

1. Введение.

	В  данной  статье  я  познакомлю  вас  с  несложным   приемом,
позволяющим  с	помощью  небольшой  специально	написанной   программы
узнавать пароли пользователей  сетей Novell 3.x  и выше. Сразу	скажу,
что авторство этой  идеи вряд ли  принадлежит мне, тем	более, что сам
смысл ее лежит	на самой поверхности.  Отмечу лишь, что  реализованный
мной   алгоритм   представляется   наиболее   надежным	 и  удобным  в
эксплуатации,  хотя,  несомненно,  возможны  и	в той или иной степени
лучшие	способы  реализации  последнего  применительно	к   конкретным
условиям "эксплуатации" данного метода...


2. Программа PasswordStorer.

	В данной программе я  реализовал описываемый ниже способ.  Так
в чем же его  смысл?.. Дело в том,  что для входа в  сеть пользователь
использует программу LOGIN.EXE. При запуске программа выдает на  экран
след. запросы:

Enter your login name:
Enter your password:

        Причем, если при ответе  на первый запрос считывание  символов
с  клавиатуры  производится  с  эхом  (т.е.  символы  отображаются  на
экране), то во втором - нет. Это позволяет скрыть выш пароль от  чужих
глаз,  с  вожделением  и  надеждой  сверлящих взглядом ваш дисплей. ;)
Следовательно,  метод  "сграбливания"  экрана  для  подсмотра   пароля
изначально   неприменим.    Хорошо,   рассмотрим   тогда   возможность
выуживания пароля  непосредственно из  сетевого пакета,  посылаемого с
рабочей станции, выполняющей LOGIN, на  сервер:  возможно ли на  этом,
самом низком уровне узнать пароль? Дело в том, что пароль,  посылаемый
на сервер,  шифруется.   Причем шифруется  по DES-алгоритму  с потерей
данных  по  маске,  специально  запрашиваемой  программой  LOGIN перед
запросом пароля.   Все это  верно для  Novell 3.x  и 4.x  при работе в
режиме эмуляции  bindery. Собственно,  данный алгоритм  шифровки и был
введен для исключения подобного "отлова" паролей в пакетах, идущих  на
сервер. Хмм... Неужели нет  больше никаких вариантов?.. Есть.   Причем
все  очень  просто.   Нужно  отслеживать  запуск  программы  LOGIN   и
сохранять все символы, вводимые с  клавиатуры во время ее работы.   Но
возникает проблема:   а что, если  пользователь будет использовать  ее
аналог  с  другим  именем  или  просто  переименует  ее в LGIN?  Тогда
алгоритм определения  запуска по  имени не  сработает. :(  Так что же,
нет вариантов? Есть. Помните,  ведь LOGIN запрашивает у  сервера перед
получением пароля маску шифровки. Так что нам стОит отслеживать  вызов
этой функции и _после_ этого сохрянять вводимые с клавиатуры  символы,
т.е. пароль?.. Вот так и работает программа PasswordStorer.


3. Алгоритм.

        К  указанному  пользователем  файлу  в  формате  COM  или  EXE
дописывается   закодированная   подпрограмма-сборщик   паролей.    Для
затруднения  обнаружения  подпрограммы-сборщика,  последняя  шифруется
полиморфным  генератором   SMEG  (Simulated   Metamorphic   Encryption
Generator  by  Black  Baron).  В  теле подпрограммы сохраняется путь к
файлу,  в  котором  будет  производится  сохранение  паролей  и   имен
пользователей, входящих в сеть. При  запуске такого COM или EXE  файла
происходит инсталляция подпрограммы-сборщика  в память компьютера  (по
возможности,   в   область   UMB).    Причем   резидентный   блок   не
обнаруживается в меню просмотра карты памяти Volkov Commander или  Dos
Navigator.  Производится  поиск  файла,  в  котором  будут сохраняться
пароли, а при его  отсутсвии, он создается заново.  Затем производится
перехват  прерывания  Int  21h  (DOS  сервис),  производится настройка
регистров     и     управление     передается     оригинальному   коду
программы-родителя. Обработчик Int 21h выполняет следующие операции:

- перехват  DOS  fn  4b00h  (загрузить  и выполнить)  используется для
  анализа имени запускаемого файла.  В случае, если имя файла  *NET?.*
  (emsnetx, xmsnetx, netx, bnetx,  neta и т.д.) или  *VLM.* (vlm.exe),
  т.е.   запускается сетевой  драйвер, осуществляющий  работу с  сетью
  через  сервис  Int  21h,   то  мы  перед  запуском   восстанавливаем
  оригинальное   значение   вектора   Int   21h,   а   после  -  снова
  перехватываем. Тем  самым достигается  достаточно корректная  работа
  перехватчика  паролей  даже  в  том  случае,  если он был загружен в
  память до загрузки в нее драйверов работы с сетью.

- перехват  DOS fn  F217h (сетевой  мультиплексор). В  этом случае  мы
  анализируем в буфере  номер вызываемой подфункции,  и если он  равен
  18h  (login  object  encrypted),  то  считаем,  что  работает LOGIN,
  сохраняем  в  закодированном  виде  имя  пользователя,  под  которым
  делается  LOGIN  (оно  также  передается  в  буфере) и возводим флаг
  обработки DOS fn 8.  Формат вызова данной функции таков:

  AX=F217h
  CX=length of request buffer
  DX=length of reply buffer
  DS:SI=request buffer
  ES:DI=reply buffer

  request buffer:
  dw	  ?		;длина последующих данных
  db	  18h		;номер функции (login object encrypted)
  db	  8 dup (?)	;закодированный по полученному ключу объект
  dw	  ?		;тип объекта (1 - user) в формате big-endian
  db	  ?		;длина имени объекта
  db      ? dup (?)     ;имя объекта
                        ;(т.е. в нашем случае имя пользователя)

  Дело в том, что на  самом деле данная функция вызывается  дважды при
  процедуре входа в сеть.

        1) LOGIN  получает  ID  запрашиваемого   объекта  (т.е.  имени
  пользователя, пытающегося выполнить  LOGIN) формат регистров  вызова
  тот же.

  request buffer:
  dw	  ?		;длина последующих данных
  db	  35h		;номер функции (get bindery object ID)
  dw	  ?		;тип объекта (1 - user) в формате big-endian
  db	  ?		;длина имени объекта
  db      ? dup (?)     ;имя объекта
                        ;(т.е. в нашем случае имя пользователя)

  reply buffer:
  dd	  ?		;ID объекта
  dw	  ?		;тип объекта
  db	  ? dup (?)	;имя объекта


        2) LOGIN запрашивает у сервера 8-байтовый ключ  преобразования
  пароля формат регистров вызова тот же.

  request buffer:
  dw	  ?		;длина последующих данных
  db	  17h		;номер функции (get encryption key)

  reply buffer:
  db	8 dup (?)	;запрошенный ключ преобразования

        3) LOGIN  шифрует  ID  объекта  по  DES-подобному  алгоритму с
  использованием  полученного  ключа  преобразования  и  после   этого
  вызывает  вышеприведенную  функцию  18h  (login  object encrypted) c
  тем, чтобы попытаться выполнить вход  в сеть, в случае, если  пароль
  у данного пользователя не  установлен (null). Следует отметить,  что
  проверка null-пароля на сервере не отражается в лог-файлах и,  кроме
  того,  отсутствует  задержка  ответа   сервера  в  случае,  если   у
  пользовател все-таки имеется пароль.

        4) В  большинстве  случаев  п.3  отработает  с ошибкой, т.е. у
  пользователя присутствует  пароль. В  этом случае  LOGIN выводит  на
  экран:

  Enter your password:

  и читает пароль через функцию DOS 8 (character input without  echo),
  обрабатывая  нажатие  клавиш  "backspace"  (для  удаления считанного
  символа) и завершая считывание по нажатию "enter".

        5) После  этого  LOGIN  повторяет пп.1-3, используя  введенный
  пользователем пароль.  В случае  неудачной попытки,  LOGIN завершает
  выполнение с установленным кодом возврата. В противном случае  (если
  вход в сеть был произведен удачно) код возврата равен нулю.

- перехват  DOS  fn  8  (get  character without echo). Данная  функция
  обрабатывается  только  в  промежутке  между  вызовом  "login object
  encrypted"  и   нажатием  на   клавишу  "enter"   либо   завершением
  программы. Эта  функция вызывается  программой LOGIN  при считавании
  пароля, тем  самым мы  посимвольно сохраняем  пароль, кодируя каждый
  символ.    Мы  обрабатываем   также  нажатие   клавиши   "backspace"
  (затираем  предыдущий  сохраненный  символ).   По  нажатию   клавиши
  "enter" мы  прекращаем сохранение  символов пароля  в буфере (пароль
  введен).

- перехват DOS fn 4ch (exit  of program). Смотрим, сохранен ли был  во
  время сеанса работы завершаемой  программы пароль (т.е.   выполнялся
  ли LOGIN), если да и код  завершения программы равен 0, т.е. вход  в
  сеть был выполнен успешно, то  открываем для записи файл, в  который
  мы  пишем   пароли,  и   дописываем  к   его	концу	закодированный
  LOGINAME\PASSWORD.

	Данный	файл  можно  будет  затем  прочитать,  дешифровав  его
программой PswView.Com.   Вот и  все, как  видим все  _очень_  просто.
Достаточно подвесить подпрограмму-сборщик  на любой файл,  выполняемый
из autoexec.bat, и пароли всех	пользователей, входящих в сеть с  этой
рабочей станции  у вас	в кармане.  ;) Другой  вопрос: а  нужны ли они
вам?..	;)  А  программу  PasswordStorer,  равно  как  и многие другие
небольшие утилиты/краки вы можете  найти в авторских пакетах  Bashut и
Niceut (2Scout: надеюсь, что на рекламу это все-таки не тянет... ;)


4. Проблемы.

        У описанного  выше алгоритма,  как и  следовало ожидать,  есть
недостатки.   И  надежная  его  работа  обеспечивается  лишь  в случае
выполнения следующих условий:

- программа-сборщик  инсталлирована в  память после  драйвера сетевого
  DOS-сервиса (shell),  либо перед  ним, но  в этом  случае он  должен
  иметь одно из стандартных имен (?net?,vlm).

- программа-сборщик  должна  инсталлироваться  в  память  до программ,
  осуществляющих  перехват  Int  21h  во  время своей работы (например
  Volkov  Commander),  если  перед  входом  в  сеть  данная  программа
  выгружается из памяти

- выполнение входа в сеть осуществляется стандартной программой  LOGIN
  или же по 100%-совместимому алгоритму.

  В этом случае можете считать, что пароли - ваши... ;)


Специально для LMD, Psychomancer // SPS.
		    ■ 2:454/5.9@FidoNet
