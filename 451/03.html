<HTML>

<head>
<title>451 Virus Magazine issue #1 : LDIZX v 1.01</title>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
</head>
<BODY BGCOLOR="#6A8080" TEXT="#FFFFFF">
<LINK REL=STYLESHEET type="text/css" href="451.css">

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr width=800px bgcolor="FFFFFF">
<td  height=2px>
</td>
</tr>
<tr width=800px>
<td  height=20px>
	<table>
	<tr>
		<td width=70px>
		<div id="logo_hs1">451</div>
		<div id="logo_hs2">451</div>
		</td>

		<td width=250>
		<div id="alt_hs">virus magazine, issue #1</div>
		</td>

		<td width=400>
		<center>
		<a href="#ldizx1">Функции<a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<a href="#ldizx2">Структуры/Флаги<a>
		</center>
		</td>

		<td width=50>
		<a href="index.html">index<a>
		</td>

	<tr>
	</table>

</td>
</tr>
<tr width=800px bgcolor="FFFFFF">
<td  height=2px>
</td>
</tr>
</table>

<center>
<br>
<div class="headx">LDIZX <br>v 1.01</div>
</center>

<pre>                             
 Дизассемблер является примером того,что сразу написать непросто .В процессе 
 работы с ним появляются новые потребности в чем-либо,которые не были 
 актуальными вчера, и приходится модифицировать дизассемблер для своих нужд 
 снова.Завтра ,может,понадобится еще более гибкая система - и история 
 повторится вновь.

 Как можно понять LDIZX - дизассемблирующий движок и является продуктом такой 
 вот невостребованности.

 Основные характеристики :

   * Достаточно полная информация ,получаемая на выходе для анализа/сборки 
     команды.
   * Использование в качестве только лишь дизассемблера длин	
   * Не содержит данных/абсолютных смещений
   * Использован универсальный C call т.е. может быть включен в какой-нибудь
     HLL
   * Обрабатывает int 20h (0CD20h) как 6-ти байтную команду, т.е. как VxDcall
     (win32-ориентация).Если необходимо перенести его куда-нибудь еще ,то это 
     достигается изменением 1-5 строк в исходнике.
</pre>
<a name="ldizx1"><div class="parx">Описание функций</div></a>

<pre>
 Т.к. использован C call,то тут дано описание ф-ций на C , хотя это просто 
 способ передачи параметров процедуре.

 Для работы движка необходимы таблицы. Процедура их распаковки:
 <b>

 ldizx_init  ( VOID* TablePtr 		// Килобайтный буфер для таблиц
	     );

 </b>
 После выполнения этой процедуры в память по адресу TablePtr распаковываются
 таблицы движка,которые используются при дизассемлировании.

 Главная функция (собственно дизассемблирующая код):
 <b>
 ldizx       ( VOID* InPtr,		// Поинтер на входной код
               CMD*  OutPtr,            // Поинтер на структуру CMD
               VOID* TablePtr           // Поинтер на распакованые таблицы
	      ) 	
 </b>
 После выполнения данной процедуры структура ,заданная вторым параметром 
 заполняется исходя из команды ,которая дизассемблируется.На выходе LDIZX
 передает длину команды в EAX либо FFFFFFFFh в случае ошибки. 

 Если при дизассемблировании не требуется информация о команде ,кроме ее 
 длины, то в качестве второго параметра передается 0 и LDIZX возвращает лишь
 длину команды в EAX.

 Процедура ассемблирования структуры cmd в команду не включена, т.к. почти
 всегда требуется специфичное конструирование команды или, наоборот, очень 
 простое и лучше писать ассемблирование отдельно.

</pre>
<a name="ldizx2"><div class="parx">Структуры и флаги</div></a>

<pre>
 Вторым параметром в движок передается поинтер на структуру CMD ,в которую
 после выполнения главной процедуры, записывается информация о команде.Ее 
 формат представлен ниже:
 <b>
 typedef  struct {

                BYTE		lc_size;	// длина команды
                BYTE		lc_psize;	// длина префиксов

                DWORD		lc_flags;	// флаги
                BYTE		lc_tttn;	// tttn

                BYTE		lc_sib;		// sib
                BYTE		lc_modrm;	// modrm

		BYTE		lc_reg;		// reg
                BYTE		lc_mod;		// mod
                BYTE		lc_ro;		// r/o

                BYTE		lc_rm;		// r/m

                BYTE		lc_base;	// base
                BYTE		lc_index;	// index
                BYTE		lc_scale;	// scale

                DWORD		lc_offset;	// смещение

                BYTE		lc_operand[6];  // операнд

                BYTE		lc_soffset;	// длина смещения
                BYTE		lc_soperand;	// длина операнда

		BYTE		lc_mask1;	// маска
		BYTE		lc_mask2;       //
		} cmd;

 </b>
 Содержание полей lc_sib,lc_modrm,lc_rm,lc_ro,lc_base,lc_index,lc_scale думаю 
 понятно из их названия , замечу ,что поле mod дано сдвинутым на 6 бит влево 
 т.к. его часто с целью восстановления команды так сдвигают и было бы разумно 
 его таким оставить,каким оно есть в команде (т.е. занимающем 6-й и 7-й биты)

 Операнд является 6-ти байтовым с учетом таких команд, как JMP FAR/CALL FAR,
 где есть и селектор и смещение,поэтому он пишется в порядке следования его 
 байтов в команде.Т.е. необходимо при обращении к полю lc_operand учитывать
 размер операнда ,содержащийся в поле lc_soperand.

 tttn имеет смысл в командах условного выполнения (JCC/SETCC и т.д.), для них
 это поле содержит условие выполнения команды.

 На lc_reg стоит смотреть только тогда,когда команда не имеет modr/m и 
 работает с регистром.Содержание этого поля и определяет использованный 
 регистр.

 Длина префиксов дана с целью выявления нестандартных команд,в которых по 
 нескольку одинаковых префиксов.

 В полях lc_mask1 и lc_mask2 содержится маска команды.Причем она дается в 
 полном виде включая 0F,если этот префикс у команды есть.Это поле полезно,
 когда надо найти определенную команду по ее маске.Т.е. движок сам определит 
 маску команды и занесет ее в эти поля.

 Наиболее важную информацию о команде содержат флаги (lc_flags),в зависимости 
 от их содержания трактуются большинство полей в структуре CMD, поэтому 
 следует прежде всего смотреть на флаги,а уже только потом на содержание 
 полей.

</pre>

<center>
<table width=750 border=1 cellpadding=0 cellspacing=0>
<td>
<tr><td width=200>LF_PCS</td>
    <td width=100>0x00000001</td>
    <td width=350>Присутствует префикс CS</td></tr>
<tr><td width=200>LF_PDS</td>
    <td width=100>0x00000002</td>
    <td width=350>Присутствует префикс DS</td></tr>
<tr><td width=200>LF_PES</td>
    <td width=100>0x00000004</td>
    <td width=350>Присутствует префикс ES</td></tr>
<tr><td width=200>LF_PSS</td>
    <td width=100>0x00000008</td>
    <td width=350>Присутствует префикс SS</td></tr>
<tr><td width=200>LF_PFS</td>
    <td width=100>0x00000010</td>
    <td width=350>Присутствует префикс FS</td></tr>
<tr><td width=200>LF_PGS</td>
    <td width=100>0x00000020</td>
    <td width=350>Присутствует префикс GS</td></tr>
<tr><td width=200>LF_POP</td>
    <td width=100>0x00000040</td>
    <td width=350>Присутствует префикс замены разрядности операнда</td></tr>
<tr><td width=200>LF_POF</td>
    <td width=100>0x00000080</td>
    <td width=350>Присутствует префикс замены разрядности адреса</td></tr>
<tr><td width=200>LF_PLOCK</td>
    <td width=100>0x00000100</td>
    <td width=350>Присутствует префикс LOCK</td></tr>
<tr><td width=200>LF_PREPZ</td>
    <td width=100>0x00000200</td>
    <td width=350>Присутствует префикс REPZ</td></tr>
<tr><td width=200>LF_PREPNZ</td>
    <td width=100>0x00000400</td>
    <td width=350>Присутствует префикс REPNZ</td></tr>
<tr><td width=200>LF_MODRM</td>   
    <td width=100>0x80000000</td>
    <td width=350>Присутствует modr/m</td></tr>
<tr><td width=200>LF_SIB</td>   
    <td width=100>0x40000000</td>
    <td width=350>Присутствует sib</td></tr>
<tr><td width=200>LF_OFFSET</td>   
    <td width=100>0x20000000</td>
    <td width=350>Присутствует смещение</td></tr>
<tr><td width=200>LF_OPERAND</td>   
    <td width=100>0x10000000</td>
    <td width=350>Присутствует операнд</td></tr>
<tr><td width=200>LF_REG</td>   
    <td width=100>0x08000000</td>
    <td width=350>Присутствует reg (команда без modr/m)</td></tr>
<tr><td width=200>LF_REG1</td>   
    <td width=100>0x04000000</td>
    <td width=350>R/m является регистром и имеет смысл</td></tr>
<tr><td width=200>LF_REG2</td>   
    <td width=100>0x02000000</td>
    <td width=350>R/o является регистром и имеет смысл</td></tr>
<tr><td width=200>LF_BASE</td>   
    <td width=100>0x01000000</td>
    <td width=350>База в sib присутствует и имеет значение</td></tr>
<tr><td width=200>LF_BASE</td>   
    <td width=100>0x00800000</td>
    <td width=350>Индекс в sib присутствует и имеет значение</td></tr>
<tr><td width=200>LF_MEM</td>   
    <td width=100>0x00400000</td>
    <td width=350>Команда работает с памятью (т.е. mod <> 11b )</td></tr>
<tr><td width=200>LF_TTTN</td>   
    <td width=100>0x00200000</td>
    <td width=350>Присутствует tttn</td></tr>
<tr><td width=200>LF_RAW</td>   
    <td width=100>0x00100000</td>
    <td width=350>cmd не содержит полной информации</td></tr>
<tr><td width=200>LF_D</td>   
    <td width=100>0x00008000</td>
    <td width=350>В опкоде присутствует d</td></tr>
<tr><td width=200>LF_S</td>   
    <td width=100>0x00004000</td>
    <td width=350>В опкоде присутствует s</td></tr>
<tr><td width=200>LF_SDV</td>   
    <td width=100>0x00002000</td>
    <td width=350>s либо d равен 1 (в зависимосити от флагов LF_S и LF_S)</td></tr>
<tr><td width=200>LF_W</td>   
    <td width=100>0x00001000</td>
    <td width=350>В опкоде присутствует w</td></tr>
<tr><td width=200>LF_WV</td>   
    <td width=100>0x00000800</td>
    <td width=350>w равен 1</td></tr>
</td>
</table>
</center>

 <pre>
 Флаги LF_REG1,LF_REG2,LF_BASE,LF_INDEX показывают ,что r/m,r/o,base и index
 соответственно являются регистрами.Т.е. это значит ,что их необходимо 
 трактовать как регистры .Это сделано для того , чтобы отделить команды ,не 
 использующие эти поля как регистры.При прямой адресации команды типа :

	mov [12345678h],edx

 Имеют в r/m 101b т.е.регистр ebp и по идее должна быть использована 
 косвенная адресация, но по логике работы команды нет никакого регистра т.к. 
 это особенность строения команд. Тоже самое и с базой, индексом.В r/o может 
 быть и не регистр ,а уточняющий операцию код.Поэтому и введены эти флаги.
</pre>




</pre>
</body>
</HTML>