<HTML>

<head>
<title>451 Virus Magazine issue #1 : DTRASH v 1.0</title>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
</head>
<BODY BGCOLOR="#6A8080" TEXT="#FFFFFF">
<LINK REL=STYLESHEET type="text/css" href="451.css">
<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr width=800px bgcolor="FFFFFF">
<td  height=2px>
</td>
</tr>
<tr width=800px>
<td  height=20px>
	<table>
	<tr>
		<td width=70px>
		<div id="logo_hs1">451</div>
		<div id="logo_hs2">451</div>
		</td>

		<td width=250>
		<div id="alt_hs">virus magazine, issue #1</div>
		</td>

		<td width=400>
		</td>

		<td width=50>
		<a href="index.html">index<a>
		</td>

	<tr>
	</table>

</td>
</tr>
<tr width=800px bgcolor="FFFFFF">
<td  height=2px>
</td>
</tr>
</table>

<center>
<br>
<div class="headx">DTRASH v 1.00<br>Data-Trash Generator</div>
</center>

<pre>                             
 DTRASH является генератором мусора с использованием данных. Принцип его 
 действия таков, что на вход ему подается список адресов, которые можно 
 использовать, флаги, буфер и др., а на выходе имеется команда в буфере и ее 
 длина. Всего движок способен генерировать около 30-40 команд различных 
 опкодов,если не считать модификаций одних и тех же команд типа rcl reg,1 и 
 rcl reg,im.Помимо обращений к памяти используются общие регистры и операнды.

 Главная процедура (тут использован C call):
 <b>
 DWORD 	Dtrash( VOID* DataTable,		// указатель на адреса
         DWORD DataCnt,				// их количество
         VOID* TrashTable,			// указатель на таблицу,
						// необходимую генератору.
         VOID* OutBufer,			// выходной буфер
         DWORD Flags,                           // флаги
         DWORD* Seed,                           // указатель на seed
         DWORD *(RND(DWORD* SEED,DWORD Range))	// указатель на процедуру ГСЧ
	);
</b>	
 Как выходной параметр генератор возвращает в EAX длину полученной команды.

 Список адресов (адреса) представляет собой массив структур:
<b>
	typedef	struct{
			DWORD	getd_dRVA
			DWORD	getd_cRVA
			DWORD	getd_cSize
			DWORD	getd_cdType
			} node;
</b> 
 Где вторе и третье поля игнорируются, а используются лишь getd_RVA, 
 содержащее RVA данных и getd_cdType- размер данных во втором байте и тип 
 обращения к ним - в первом. Сам список может быть получен путем анализа 
 обращения программы к данным, но стоит помнить, что при генерировании команд 
 на запись следует учесть размер данных т.к. не факт, что там данные 
 выровнены, т.е. используются какая-то величина (чаше dword) вместо байтов и 
 слов и все переменные на границе этой величины, да так, что программа и не 
 "знает" об этом. Но и если выровнены,то неизвестно на какую границу ;)

 Генератор использует свою таблицу для работы. Ее можно включать как данные в 
 код, другими словами - включать ее инклудник,либо же,что более универсально,
 использовать процедуру,которая распакует таблицы (где-то 300 байт) в буфер:
<b>
 VOID	trash_init(
			VOID* Ptr			// указатель на буфер
		  )
</b>
 После этого можно передать адрес буфера в главную процедуру и вызвать ее.

 Для задания параметров генерирования мусора используются флаги:
</pre>
 <center>
 <table cellspacing=0 cellpadding=0 border=1>

 <tr>
 <td width=200>DTF_READ</td>
 <td width=200>0000000000000000b</td>
 <td width=300>генерировать команды на чтение</td>
 </tr>

 <tr>
 <td width=200>DTF_WRITE</td>
 <td width=200>0000000000000001b</td>
 <td width=300>генерировать команды на запись</td>
 </tr>

 <tr>
 <td width=200>DTF_MFLAGS</td>
 <td width=200>0000000000000010b</td>
 <td width=300>использовать флаги мусором?</td>
 </tr>

 <tr>
 <td width=200>DTF_EAX</td>
 <td width=200>0000000100000000b</td>
 <td width=300>использовать AL/AX/EAX</td>
 </tr>
  	 	 
 <tr>
 <td width=200>DTF_ECX</td>
 <td width=200>0000001000000000b</td>
 <td width=300>использовать CL/CX/ECX</td>
 </tr>
	 
 <tr>
 <td width=200>DTF_EDX</td>
 <td width=200>0000010000000000b</td>
 <td width=300>использовать DL/DX/EDX</td>
 </tr>

 <tr>
 <td width=200>DTF_EBX</td>
 <td width=200>0000100000000000b</td>
 <td width=300>использовать BL/BX/EBX</td>
 </tr>

 <tr>
 <td width=200>DTF_ESP</td>
 <td width=200>0001000000000000b</td>
 <td width=300>использовать AH/SP/ESP</td>
 </tr>
          	 
 <tr>
 <td width=200>DTF_EBP</td>
 <td width=200>0010000000000000b</td>
 <td width=300>использовать CH/BP/EBP</td>
 </tr>
                 
 <tr>
 <td width=200>DTF_ESI</td>
 <td width=200>0100000000000000b</td>
 <td width=300>использовать DH/SI/ESI</td>
 </tr>
                 
 <tr>
 <td width=200>DTF_EDI</td>
 <td width=200>1000000000000000b</td>
 <td width=300>использовать BH/DI/EDI</td>
 </tr>
                 
 <tr>
 <td width=200>DTF_ALL</td>
 <td width=200>1111111100000000b</td>
 <td width=300>использовать все регистры</td>
 </tr>
                 
 </table><br>
 </center>
<pre>
 Использованные регистры зависят и от размера входных данных. Так при размере
 данных в 1 байт и включенном флаге DTF_EAX будет использоваться лишь AL ,но 
 при включении флага DTF_ESP ,будет еще генерироваться и AH. Тоже касается и 
 остальных однобайтовых регистров.
 Если размер данных - 4 байта, то к ним может использоваться обращение как к 
 1/2/4 байтовой переменной.

</pre>
</body>
</html>
