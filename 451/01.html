<HTML>
<head>
<title>451 Virus Magazine issue #1 : GETD v 1.0</title>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
</head>
<BODY BGCOLOR="#6A8080" TEXT=#FFFFFF>
<LINK REL=STYLESHEET type="text/css" href="451.css">

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr width=800px bgcolor="FFFFFF">
<td  height=2px>
</td>
</tr>
<tr width=800px>
<td  height=20px>
	<table>
	<tr>
		<td width=70px>
		<div id="logo_hs1">451</div>
		<div id="logo_hs2">451</div>
		</td>

		<td width=250>
		<div id="alt_hs">virus magazine, issue #1</div>
		</td>

		<td width=400>
		</td>

		<td width=50>
		<a href="index.html">index<a>
		</td>

	<tr>
	</table>

</td>
</tr>
<tr width=800px bgcolor="FFFFFF">
<td  height=2px>
</td>
</tr>
</table>

<center>
<br>
<div class="headx">Использование данных в вирусах<br>
<b>GETD v 1.0</b></div>
</center>


<pre>                             

 В последнее время развитие пермутации достигло достаточно больших успехов-
 теперь можно без проблем "разобрать" код вируса/программы на что-то подобное 
 исходнику, хотя и в более приятном для обработки виде. Затем модифицировать 
 его путем мутации, внесения мусора, генерации ложных ветвей, перемешиванием 
 кода и других приемов. После этого "исходник" снова ассемблируется и 
 полученный код уже имеет совершенно иную сигнатуру.

 С точки зрения эвристика, определяющего принадлежность некого кода к 
 какому-то определенному пермутатору (движку), важно просмотреть полученные 
 на входе команды и после этого отбрасывать варианты движков, не содержащие 
 их. Данное действие дает прирост в скорости детектирования,а, следовательно,
 и сканирования. А т.к. уже сейчас количество записей в базах антивирусов 
 стремительно растет, то такой критерий при покупке антивируса, как скорость 
 сканирования будет только укреплять свои позиции. Хотя все это сугубо 
 субъективно, поскольку  вычислительная способность компьютеров тоже растет.
 Ну да к хуям это.

 Практика показала, что наиболее узкими местами пермутационного движка 
 является мутирующая часть. Она достаточно сложна в реализации т.к. для 
 идеального мутирования (т.е. мутирования почти ВСЕХ команд) необходимо знать 
 всю структуру программы, а это уже повлечет за собой полный реверсинг и 
 эмуляцию. Мало того, необходимо написание кода, мутирующего отдельно каждую 
 команду, потому как каждая оная имеет свои особенности, что повышает размеры 
 движка и вируса вцелом.

 Следующим идет генератор мусора. Его проще реализовать по нескольким 
 причинам:

   1] Изначальной подгонкой кода под генератор, т.е. с известным образом 
      действия кода.	

   2] Исследование кода на использование данных/флагов/регистров и 
      последующая генерация кода.

 Во втором случае необходим полный анализ действия кода. Скорее всего, будет 
 использоваться некая часть 1-го варианта.

 Что же самое главное в генераторе мусора? Конечно же, набор генерируемых 
 команд и количество вариантов каждой команды. Мусорные команды главным 
 образом работают с регистрами и стеком, даже используя адресацию, они 
 являются вариантами команд работы с регистрами. Часто это команда LEA,из-за 
 ее действия на флаги, т.е. полное их отсутствие ;) :

	lea ebx,[ebx+0]

 Но вернемся к эмулятору-эвристику, хотя он был вполне заслуженно отправлен в 
 место, где его по-настоящему оценят :). С его точки зрения эти команды легко 
 отбросить. Во-первых, они не изменяют содержимое регистров/флагов, если же 
 это не так, то команды фильтруют по маске и "отбрасывают" текущие варианты 
 генераторов, которые могут их создать, ускоряя тем самым сканирование, 
 поднимая "скоростной престиж" самого эвристика.
 
 Причина в том, что каждый генератор характеризуется статичным набором 
 поддерживаемых команд, которые он и генерирует. Для усложнения фильтрации 
 команд может использоваться метод, о котором тут будет написано.
 <center>
 <div class="parx">ДАННЫЕ</div>
 </center>
 Каждая серьезная программа использует данные: байты,ворды,дворды, массивы... 
 Так вот логично предположить, что эти самые "дворды" после загрузки 
 программы в память имеют свой адрес, чтобы программа сама могла обращаться к 
 ним. Так почему бы ни воспользоваться ими в вирусе ? Т.е. можно на ссылаться 
 на данные инфицированной программы, как посредством чтения, так и 
 посредством записи. Этот метод позволяет генерировать команды, обращающиеся 
 к абсолютной памяти. Что это дает?
 
  * Команды обращаются к памяти, т.е. их труднее отфильтровать,как мусор т.к.
    обращение может идти на чтение/запись.
  * Использование данных программы в пермутирующих вирусах для хранения их 
    структур и прочего. (Наверное, один из способов способный облегчить 
    написание пермутирующих вирусов).
  * Более общий вид кода вируса, "на глаз" похожий на код программы. :)
 <center>
 <div class="parx">GETD</div>
 </center>
 Для нахождения данных, к которым обращается программа, был написан GETD.
 На вход подается поинтер на считанный уже PE-файл, на выходе - поинтер на
 таблицу данных. Чтобы получить данные, использующиеся программой, по идее 
 необходимо:

   * проверить файл на валидность (очень общее понятие;)
   * разобрать фиксапы
   * проверить их на отношение к импорту и коду
   * дизассемблировать код с точки входа с целью выявления адресов команд,
     которые обращаются к данным, и размера самих данных (1/2/4).

 Исходя из полученных результатов, формируется таблица, содержащая записи,
 состоящие из адреса данных, адреса команды, размера команды, размера данных 
 и тип обращения (чтение/запись):
 <b>
 getd_node	struc
		getd_dRVA	dd	?
		getd_cRVA	dd	?
		getd_cSize	dd	?
		getd_cdType     dd	?
		ends
 </b>
 В последнем поле первый байт равен типу обращения (чтение - 0 /запись -1 ), 
 второй - размеру данных.

 Первым двордом в таблице указывается количество элементов, затем идет сама 
 таблица.

 Как побочный результат формируется таблица регионов памяти, т.е. подряд 
 располагающихся данных. Она следует сразу за таблицей данных и имеет 
 элементами вот такие структуры:
 <b>
 getd_reg_node	struc
		getd_regionRVA	dd	?	; RVA региона
		getd_regionCnt	dd	?       ; количество 4-байтных блоков
		ends
 </b>
 Данную табличку удобно использовать для организации мусорных команд, 
 работающих с цепочечными командами : movs,scas,stos,cmps,lods,
 использующих префиксы повторения. 

 Общая стуктура выходной таблицы показана ниже:
 
       -------------------------------------------
 0000:  размер таблицы #1 N
       -------------------------------------------
 ...     элементы

 ...     .....
	
       ------------------------------------------- 
 N*16:  размер таблицы #2 M
       -------------------------------------------
 ...     элементы

 ...     .....

       -------------------------------------------
 
 В случае ошибки ,GETD вместо поинтера на таблицы ,возвращает 0.
 <center>
 <div class="parx">КАК ЭТО ИСПОЛЬЗОВАТЬ?</div>
 </center>
 Применений этому может и много, но я вижу пока только 3 - генераторы
 мусора, мутаторы и данные в пермутирующих вирусах. Хотелось бы еще немного 
 остановиться на генераторе мусора, который должен использовать этот принцип.

 Допустим, что движок отработал и выплюнул пару сотен адресов, которые 
 отфильтровались и были переданы генератору мусора. Если хочется использовать
 запись в данные,что наиболее вероятно, то надо либо запоминать их предыдущие 
 значения, а затем восстанавливать, что есть бессмысленно, либо реверсить всю 
 программу на предмет обнаружения блоков с командами обращения к данным на 
 запись. Но реверсить это не единственный выход, можно просто найти элемент с 
 записью в данные, адрес данных передается генератору мусора, и он использует 
 только его. Далее на эту команду ставится CALL/JMP/PUSH/RET на точку входа в 
 вирус или что-то еще, с сохранением оригинальных байтов программы, т.е. 
 получается еще и UEP.

 Другой вариант - сплайсинг ExitProcess на импортах или же просто записью
 перехода на свой код прямо в программу, что тоже не всегда подходит. Либо же 
 перезапуск процесса, но для этого потребуется лоадер, не имеющий обращения к 
 данным и уже содержащий изрядный кусок вируса (отчасти процедуры импорта), 
 что ослабит декриптор на предмет детектирования.

 Далее, если вирус является полностью непермутирующим (пермутируется лишь
 декриптор), то ничего больше не надо. Иначе дело обстоит в т.к. называемых 
 full-moph'ах: при инфицировании из нового экземпляра, данные, используемые
 в этом экземпляре перейдут к следующему и тот при запуске ебанется на них.
 Поэтому надо просто, при рекомпиляции команд в пермутаторе, отбрасывать 
 команды с адресом большим imagebase. Это эвристик или исследующий программу 
 не знает про то, какие адреса мы используем и используем ли вообще, но мы-то 
 знаем, нам можно, причем все ;).Но следует чуть поизвращать исходник вируса,
 чтобы он не обращался напрямую в память, а то вместе с мусором слетят и 
 вирусные команды, что тоже нехорошо, хотя это зависит и от его алгоритма.
 
 Не помешает также полное убивание мусора обращающегося к данным на некотором 
 этапе, чтобы снова усложнить детектирование, но делать это надо редко и,
 естественно, рандомно.

  А еще можно... а много чего еще можно.


</pre>
</body>
</html>