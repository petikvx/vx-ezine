<HTML>

<head>
<title>451 Virus Magazine issue #1 : UEP imlementation - DEE v 1.32</title>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
</head>

<BODY BGCOLOR="#6A8080" TEXT="#FFFFFF">
<LINK REL=STYLESHEET type="text/css" href="451.css">

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr width=800px bgcolor="FFFFFF">
<td  height=2px>
</td>
</tr>
<tr width=800px>
<td  height=20px>
	<table>
	<tr>
		<td width=70px>
		<div id="logo_hs1">451</div>
		<div id="logo_hs2">451</div>
		</td>

		<td width=250>
		<div id="alt_hs">virus magazine, issue #1</div>
		</td>

		<td width=400>
		</td>

		<td width=50>
		<a href="index.html">index<a>
		</td>

	<tr>
	</table>

</td>
</tr>
<tr width=800px bgcolor="FFFFFF">
<td  height=2px>
</td>
</tr>
</table>


<center><br><div class="headx">Dirty Entrypoint Engine
<br>DEE v 1.32<br></div>
</center>

<pre>


 Движок DEE является вариацией на тему UEP. Данная технология подразумевает 
 "врезание" в случайное место кода программы какой-то команды, обычно 
 перехода на тело вируса.Такая техника позволяет претендовать на 
 неизлечимость вируса, но реально может только усложнить его детектирование. 
 Допустим, что UEP реализует замену команды по случайному адресу в программе 
 на  что-либо  иное вариант - замена на jmp/call в вирус), но необходимо, 
 чтобы длина "врезанной" команды была меньше, либо равной исходной т.к. в 
 противном случае “врезанная” команда может испортить последующую за ней.

 Нахождение адресов для замены может быть реализовано различными 
 способами, но основные направления - релокейшены и частичный реверсинг, 
 движок DEE реализует второе.

 DEE ничего не заменяет - пусть заменяют другие, а его дело найти команды по 
 требуемым признакам и вернуть в качестве результата адрес в исходном буфере,
 случайно выбранной из найденных, команды, удовлетворяющей поиску.
 </pre>

 <a name="dee1"><div class="parx">Формат вызова</div><a>
 <pre>
 <b>
 DWORD DEE ( 
		VOID* 	code_param,             // буфер с кодом
		DVORD 	cnt,			// количество просматриваемых 
						// байт

		VOID*	*MALLOC	(       	// "аллокатор" памяти
			DWORD	cnt		// количество байт
				),

		VOID* 	FREE	(		// "релизер" памяти
			VOID	bufer		// поинтер на буфер
				),

		DWORD* 	RND	(		// ГСЧ
			DWORD*	seed,           // поинтер на инициализатор
			DWORD	range		// предел
				),
		DWORD* 	seed,			// поинтер на инициализатор 
		                                // ГСЧ 

		DWORD* 	dasm	(               // дизассемблер
			VOID*	ibuf,           // входной буфер
			DWORD	reserved,	// не используется
			VOID*	tables		// поинтер на таблицы
				),		

		VOID* 	dasm_tables,		// поинтер на таблицы 
						// дизассемблера

		DWORD	flags			// флаги
          );
 </b>
 Для вызова используется C call, т.е. параметры передаются в обратном порядке 
 и функция не очищает стек.

 Результат выполнения - адрес команды в буфере возвращается в EAX ,при ошибке 
 возвращаемое значение равно FFFFFFFFh.

 Флаги могут быть следующими:


 DEE_CMD5	00000001	искать помимо CALL все команды, размером >= 5
				байт

 DEE_LINKS	00000002 	использовать переходы по JMP'ам.

 </pre>
 <a name="dee2"><div class="parx">Алгоритм работы</div></a>

 <pre>
 Действия движка заключаются в нахождении CALL'ов, как вариант (с заданием 
 соответствующих флагов) - поиск команд, длина которых больше либо равна 
 5 байтам.

 Это осуществляется посредством последовательного дизасма буфера с помощью 
 внешнего дизассемблера. Затем движок берет рандомом любой из найденных 
 адресов и как ответ функции возвращает этот адрес. Т.к. в DEE передается 
 адрес буфера, то на выходе отдается абсолютный адрес команды в буфере, а не 
 ее RVA относительно буфера. Это кажется более универсальным.

 В процессе работы движок использует память, и количество требуемых байт 
 составляет cnt*4*2. Для достаточно большой программы это может быть много и 
 есть вероятность нехватки памяти, в таком случае DEE вернет на выходе 
 FFFFFFFF, теперь стоит уменьшить сnt ,тем самым ограничив количество 
 просматриваемых байт, и повторить все снова, а потом, в случае ошибки, еще 
 раз и так пока не заебет.
 
 С включенным флагом LINKS при встрече относительного JMP'а,дизассемблирование
 продолжается по адресу, куда он указывает. В таком случае, следует грузить 
 кодовую секцию в буфер полностью, а лучше весь имадж с имитацией загруженных 
 секций, т.к. могут быть и файлы с кодом в данных, хотя это и маловероятно. 
 Иначе есть риск выйти за пределы буфера. 
 Для того ,чтобы совершить нахождние команды ,котороая вероятнее всего 
 запустится при старте программы ,при встрече всяких там RET'ов ,абсолютных
 переходов и пр. поиск команд прекращается и команда выбирается из найденных
 до этого.Как показала практика это несколько понижает процент заражения,при
 котором вирус не запускается.



 Вот вроде бы и все.

	 Unseek & grow!
</pre>
</html>

