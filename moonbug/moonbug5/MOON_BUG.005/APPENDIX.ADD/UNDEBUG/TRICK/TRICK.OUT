

                            Анти Отладочные Хитрости

                                   Создано:

                                  Inbar Raz

                 Помощь Eden Shochat и Yossi Gottlieb

                               Номер Версии 5

  Современные анти отладочные хитрости разбиты на две категории:

  1. Профилактические действия;
  2. Самомодифицирующийся код.

  Большинство отладочных хитростей, на сегодня, используются внутри
вирусов, для того, чтобы избежать дизассемблирования вируса, как он
включается в файлы.
Другая большая часть анти отладочных хитростей находится в программах
защиты, они используют это для того, чтобы сделать вскрытие защиты
более трудным.

1. Профилактические действия:
----------------------

  Профилактические действия - это в основном действия, которые программа
делает для того, чтобы пользователь был не в состоянии дизассемблировать
код и прослеживает это при выполнении.

1.1. Блокирование Прерывания:

       Блокирование Прерывания - вероятно наиболее общая форма
     анти-отладочных хитростей. Она может быть сделана различными путями:

   1.1.1. Аппаратное маскирование прерываний:

            Для того, чтобы избежать трассировки кода, обычно блокируют
            прерывание через 8259 Контроллера Прерываний, адресуемый I/O,
            чтобы перенести 21h. 8259 Контроллер Прерывания управляют IRQ
            строками. Это означает, что любой IRQ между 0 и 7 мj;tn быть
            заблокирован этим действием. Бит 0 - IRQ0, бит 1 - IRQ1 и т.п..
            Поскольку IRQ1 - клавиатурное прерывание, Вы можете заблокировать
            клавиатуру от отладчика, умеющего шунтировать это.

          Пример:

            CS:0100 E421           IN     AL,21
            CS:0102 0C02           OR     AL,02
            CS:0104 E621           OUT    21,AL

            Точно так же, как уведомление стороны, клавиатура может
          также быть заблокирована внушительным Программируемым
          Периферийным Интерфейсом (PPI), порт 61h.

          Пример:

          CS:0100 E461           IN     AL,61
          CS:0102 0C80           OR     AL,80
          CS:0104 E661           OUT    61,AL

   1.1.2. Программное маскирование прерываний:

            Это - совсем легкая форма анти-отладочной хитрости. Все Вы
          должны сделать простую замену используемых векторов отладочных
          прерываний, или любые другие прерывания, которые Вы не будете
          использовать или предполагать их появления. Не забывайте
          восстанавливать исходные векторы, когда Вы завершите работу.
          Это - совет, чтобы использовать ручное изменение вектора, как
          показано ниже, а не, чтобы изменить это используя прерывание
          21h обслуживания 25h, поскольку любой отладчик, который
          получать право контроля прерывания 21h может заменить ваш
          вектор с отладчиком. Пример показывает выключение прерывания
          03h - контрольное прерывание.

          Пример:

          CS:0100 EB04           JMP    0106
          CS:0102 0000           ADD    [BX+SI],AL
          CS:0104 0000           ADD    [BX+SI],AL
          CS:0106 31C0           XOR    AX,AX
          CS:0108 8EC0           MOV    ES,AX
          CS:010A 268B1E0C00     MOV    BX,ES:[000C]
          CS:010F 891E0201       MOV    [0102],BX
          CS:0113 268B1E0E00     MOV    BX,ES:[000E]
          CS:0118 891E0401       MOV    [0104],BX
          CS:011C 26C7064C000000 MOV    Word Ptr ES:[000C],0000
          CS:0123 26C7064E000000 MOV    Word Ptr ES:[000E],0000

   1.1.3. Векторная обработка

             Этот метод включает обработку векторов прерывания, главным
          образом для соответствующей активизации алгоритма. Такое
          действие сможет использоваться, чтобы декодировать  код (смотри
          также 2.1), использующий данных загруженное ON векторы. Ofcourse,
          В течение нормальной операции программы, векторы 01h и 03h не
          используется, так что если Вы не пытаетесь отлаживать такую
          программу, онf работает отлично.

          Пример:

          CS:0100 31C0           XOR    AX,AX
          CS:0102 8ED0           MOV    SS,AX
          CS:0104 BC0E00         MOV    SP,000E
          CS:0107 2E8B0E3412     MOV    CX,CS:[1234]
          CS:010C 50             PUSH   AX
          CS:010D 31C8           XOR    AX,CX
          CS:010F 21C5           AND    BP,AX
          CS:0111 58             POP    AX
          CS:0112 E2F8           LOOP   010C

   1.1.4. Прервите замену

            Это - в самом деле гадкая хитрость, и она должна использоваться
            ТОЛЬКО если Вы - СОВЕРШЕННО уверены, что вашим программам нужно
            больше отлаживая. Что Вам Следует сделать - копия векторов
            некоторых прерываний, которые Вы будете использовать, говорить
            16h и 21h, на векторах прерывания 01h и 03h, это не появляется в
            течение нормальной операции программы.
          Если пользователь хочет отладить программу, он должен найти
          каждый захваченный INT 01, и заменять это с подходящей INT
          инструкцией. Эта хитрость - очень эффективная если,
          используется вместе с тем, что INT 3 инструкция имеет ОДИН
          БАЙТОВЫЙ код операции - 0CCh, который не может быть изменен в
          любое другое прерывание.

          Пример:

          CS:0100 FA             CLI
          CS:0101 31C0           XOR    AX,AX
          CS:0103 8EC0           MOV    ES,AX
          CS:0105 26A18400       MOV    AX,ES:[0084]
          CS:0109 26A30400       MOV    ES:[0004],AX
          CS:010D 26A18600       MOV    AX,ES:[0086]
          CS:0111 26A30600       MOV    ES:[0006],AX
          CS:0115 B44C           MOV    AH,4C
          CS:0117 CD01           INT    01

1.2. Часы Времени:

       Это может быть менее общим методом, но это - используется против
     отладчиков, которые блокируют все прерывания кроме времени, которое
     программа выполняется, как например, Borland Turbo Debuger. Этот
     метод просто хранит величину счетчика часов, корректируемую
     прерыванием 08h, и ожидания в бесконечном цикле до тех пор, пока
     изменения величины. Другой пример -, когда Вы маскируете прерывание
     по таймеру ОПЕРАЦИЕЙ OR величина IN из порта 21h с 01h и затем,
     он возвращает, таким образом блокирует IRQ0 - Прерывание По Таймеру.
     Имейте В Виду, что этот метод - используется только против ВЫПОЛНЕНИЯ
     ДЕЙСТВИЙ, не TRACE/PROCEED им.

     Пример:

     CS:0100 2BC0           SUB    AX,AX
     CS:0102 FB             STI
     CS:0103 8ED8           MOV    DS,AX
     CS:0105 8A266C04       MOV    AH,[046C]
     CS:0109 A06C04         MOV    AL,[046C]
     CS:010C 3AC4           CMP    AL,AH
     CS:010E 74F9           JZ     0109

1.3. Одурачивать отладчик:

       Это - очень хорошая техника, это работает особенно и только на те
     кто Отладчик Turbo использования или его тип. Что Вам Следует
     сделать - init перескакивание на середину инструкции, поскольку
     реальный адрес действительно содержит другой код операции. Если Вы
     работаете с отладчиком нормального шага как например, Debug или
     SymDeb, он не будет работать поскольку отладчик перескочит на
     точный адрес перехода, и не в начало инструкции в ближайшем адресе,
     подобно Turbo Debuger.

     Пример:

     CS:0100 E421           IN     AL,21
     CS:0102 B0FF           MOV    AL,FF
     CS:0104 EB02           JMP    0108
     CS:0106 C606E62100     MOV    Byte Ptr [21E6],00
     CS:010B CD20           INT    20

     Проследите За этим:

     CS:0108 E621           OUT    21,AL

     Уведомление:

       Эта хитрость НЕ производит прогон программы в ЛЮБОМ отладчике.
     Его только использование - чтобы пытаться обманывать пользователя
     в мышление другого кода операции используется, пока другой
     действительно выполнен.

1.4. Проверьте ЦЕНТРАЛЬНЫЕ Флаги:

       Это - хорошая хитрость, эффективная против почти любого отладчика
       реального режима.
     Что Вам Следует сделать - просто набор флагов следа с где-нибудь в
     вашей программе, и проверке для его позже. Если он был включен,
     отладчик выполняется в фоне...

     Пример:

     CS:0100 9C             PUSHF
     CS:0101 58             POP    AX
     CS:0102 25FFFE         AND    AX,FEFF
     CS:0105 50             PUSH   AX
     CS:0106 9D             POPF

     В середине программы:

     CS:1523 9C             PUSHF
     CS:1524 58             POP    AX
     CS:1525 250001         AND    AX,0100
     CS:1528 7402           JZ     152C
     CS:152A CD20           INT    20

1.5. Вызов отладчика останавливает выполнение:

       Это - техника, которая вызывает отладчик останавливает выполнение
     определенной программы. Что Вы Должны сделать -, чтобы установить
     некоторые INT 3 инструкции через код, произвольно места, и любой
     отладчик, пытающийся выполнять остановит там. Наилучшим образом
     если использовано внутри цикла, как он выполнится несколько раз.

     Пример:

     CS:0100 B96402         MOV    CX,0264
     CS:0103 BE1001         MOV    SI,0110
     CS:0106 AC             LODSB
     CS:0107 CC             INT    3
     CS:0108 98             CBW
     CS:0109 01C3           ADD    BX,AX
     CS:010B E2F9           LOOP   0106

1.6. Остановите компьютер, использующий стек:

       Эта хитрость базируется на том, что отладчиках обычно не
     использовать пространство стека своего собственного, но довольно
     пространства стека программы пользователя. Установкой стека в
     позицию в середине кода, которая НЕ использует стек
     непосредственно, любой отладчик, который будет пытаться
     прослеживать код перезапишет некоторый код его собственным стеком
     (главным образом прерывание адресов возврата). Снова, CLI и STI
     будет в порядке, и не показаны для того, чтобы пример только. Они
     должны быть включены, или Вы рискуете, зависеть ваш компьютер независимо
     отладчик устанавливается или нет.

     Пример:

     CS:0100 8CD0           MOV    AX,SS
     CS:0102 89E3           MOV    BX,SP
     CS:0104 0E             PUSH   CS
     CS:0105 17             POP    SS
     CS:0106 BC0B01         MOV    SP,010B
     CS:0109 90             NOP
     CS:010A 90             NOP
     CS:010B EB02           JMP    010F
     CS:010D 90             NOP
     CS:010E 90             NOP
     CS:010F 89DC           MOV    SP,BX
     CS:0111 8ED0           MOV    SS,AX

1.7. Остановите TD386 V8086 режим:

       Это - хороший способ, чтобы одурачивать Turbo Отладчик V8086
       модуля (TD386). Базируется На То, что TD386 не использовать INT
     00h, чтобы обнаружить деление на нуль (или превышение регистра
     после деления, которое рассмотрено процессором так же как это имеет
     место деления на нуль). Когда TD386 обнаруживает дефект деления, он
     аварийно завершает, сообщает о неисправном делении.
     В реальном режиме (даже под регулярным отладчиком), инструкция
     неисправного ДЕЛЕНИЯ вызовет INT 00h, называемый. Следовательно,
     указывая INT 00h в следующей инструкции, восстановит с неисправного
     ДЕЛЕНИЯ.

     Примечание: Очень важно восстанавливать INT 00h's вектор. В
     противном случае, следующий вызов на INT 00h вызовет машину
     зависать.

     Пример:

     CS:0100 31C0          XOR     AX,AX
     CS:0102 8ED8          MOV     DS,AX
     CS:0104 C70600001201  MOV     WORD PTR [0000],0112
     CS:010A 8C0E0200      MOV     [0002],CS
     CS:010E B400          MOV     AH,00
     CS:0110 F6F4          DIV     AH
     CS:0112 B8004C        MOV     AX,4C00
     CS:0115 CD21          INT     21

1.8. Остановите любой V8086 процесс:

       Другой способ беспорядка TD386 одурачивать это в исключение.
     К несчастью, это исключение также будет генерироваться под любой
     другой программой, выполняющей в V8086 режиме. Исключение -
     исключение #13, и его переданное прерывание - INT 0Dh - 13d. Идея -
     очень подобна делению нулевой хитростью: Причина исключения, когда
     исключительное прерывание указывает на где-нибудь в программном
     коде. Он всегда будет работать, когда машина выполняется в реальном
     режиме, но никогда под V8086 режимом.

     Примечание: Очень важно восстанавливать исходные векторы прерывания.
     В противном случае, следующее исключение зависнет машина.

     Пример:

     CS:0100 31C0          XOR     AX,AX
     CS:0102 8ED8          MOV     DS,AX
     CS:0104 C70634001301  MOV     WORD PTR [0034],0113
     CS:010A 8C0E3600      MOV     [0036],CS
     CS:010E 833EFFFF00    CMP     WORD PTR [FFFF],+00
     CS:0113 B8004C        MOV     AX,4C00
     CS:0116 CD21          INT     21

2. Самомодифицирующийся код:
-----------------------

2.1. Encryptive/decryptive Алгоритм:

       Первая категория - просто код, это было закодировано, и было
     добавлено программа расшифровка. Хитрость здесь - это, когда
     отладчик устанавливает контрольную точку, он просто устанавливает
     код операции CCh (INT 03h) в желаемый адрес, и один раз это
     прерывание выполняется, отладчик восстанавливает контроль вещей.
     Если Вы пытаетесь устанавливать контрольную точку ПОСЛЕ алгоритма
     расшифровка, что - обычно необходимое, Вы закончитесь установкой
     кода операции CCh на месте где decryptive действия берутся,
     следовательно теряются ваш подлинник CCh в пользу все, что выдачи
     алгоритма расшифровка.
     Следующий пример извлекался из вируса Haifa. Если Вы пытаетесь
     устанавливать контрольную точку в адресе CS:0110, Вы никогда не
     достигнете этот адрес, поскольку нет способа, чтобы узнать какое
     будет следствием изменения. Имейте В Виду, что если Вы хотите
     сделать трассировку даже труднее, вам следует начать с расшифровка
     кода из его КОНЦА, так что требуется целая операция до тех пор,
     пока код операции следуя программе расшифровка не декодируется.

     Пример:

     CS:0100 BB7109         MOV    BX,0971
     CS:0103 BE1001         MOV    DI,0110
     CS:0106 91             XCHG   AX,CX
     CS:0107 91             XCHG   AX,CX
     CS:0108 2E803597       XOR    Byte Ptr CS:[DI],97
     CS:010C 47             INC    DI
     CS:010D 4B             DEC    BX
     CS:010E 75F6           JNZ    0106
     CS:0110 07             POP    ES
     CS:0111 07             POP    ES

2.2. Самомодифицирующийся код:

   2.2.1. Простая само-модификация:

            Этот метод поддерживает то же правило как метод шифрование:
          Измените код операции перед его использованием. В следующем
          примере, мы изменяем insruction, следующий вызову, и
          следовательно, если Вы пытаетесь прослеживать целый вызов
          ('P'/Отладка или F8/Turbo Отладчик), Вы не достигнете цели,
          поскольку отладчик установит его CCh в смещении 103h, но,
          когда программа выполняется, он перезаписывает позицию 103h.

          Пример:

          CS:0100 E80400         CALL   0107
          CS:0103 CD20           INT    20
          CS:0105 CD21           INT    21
          CS:0107 C7060301B44C   MOV    Word Ptr [0103],4CB4
          CS:010D C3             RET

          Проследите За этом:

          CS:0103 B44C           MOV    AH,4C

   2.2.2. Выполнение Строки (само-декодирование):

            Это - пример само-трассировки самомодифицирующегося кода,
          иногда названный 'выполнением строки'. был Представлен Serge
          Pachkovsky. Это - бит мудреный в реализации, но, в отличие от
          все другие techiniques упомянутое в этом документе, это -
          сравнительно resistive в различные защиты векторной таблицы.
          Короче говоря, он дает в результате декодируемые инструкции
          один в времени, таким образом никогда, подвергающий длинных
          кодовых фрагментов на analisys. Я проиллюстрирую это с
          следующим (через-упрощенное) кодовый пример:


          XOR     AX, AX
          MOV     ES, AX
          MOV     WORD PTR ES:[4*1+0],OFFSET TRACER
          MOV     WORD PTR ES:[4*1+2],CS
          MOV     BP, SP
          PUSHF
          XOR     BYTE PTR [BP-1], 1
          POPF
          MOV     AX, 4C00H          ; Это не будет прослеживаться!
          DB      3 DUP ( 98H )
          DB      C5H, 21H

   СЛЕДЯЩЕЕ УСТРОЙСТВО:

          PUSH    BP
          MOV     BP, SP
          MOV     BP, WORD PTR [BP+2]
          XOR     BYTE PTR CS:[BP-1], 8
          XOR     BYTE PTR CS:[BP+0], 8
          POP     BP
          IRET

===============================================================================
Комментарии:

Для того, чтобы сохранить строки текста программы, Я не включал CLI/STI
пару перед любым векторным изменением. Тем не менее, это - совет, чтобы
сделать эту пару перед ЛЮБЫМ ручным векторным изменением, поскольку если
любое прерывание появляется в середине ваших операций, машина могла бы
зависнуть.

Извинение:

В предшествующих версиях этой статьи, ложного примера, как отмечено
Serge Pachkovksy, был послан. Это было 2.2.2 -, манипулирующим PIQ.
Apperantly Посланный источник не будет работать под любыми
 обстоятельствами. На возврате, Serge представил ', выполняющий Строки'
техники.

Благодаря:

Eden Shochat, 2:401/100 И
  Yossi
Gottlieb,
2:401/100.3

для подсказки меня трансляция этого списка.

Другие подтверждения:

Matt Pritchard, 80XXX Эхо

Serge Pachkovsky, Распространило Узел (2:5000/19.19)

===============================================================================
Любые комментарии, предложения, идеи и коррекции охотно будут
приниматься.

Автор может быть достигнут на одном из следующих путей:

Inbar Raz, 2:401/100.1 {fidonet} Inbar Raz, 2:403/100.42 {fidonet}
nyvirus@weizmann.weizmann.ac.il {Межсетевой}
uunet!m2xenix!puddle!2!403!100.42!Inbar.Raz {UUCP}
Inbar.Raz@p1.f100.n401.z2.fidonet.org {internet<>FIDO вентиль}
Inbar.Raz@p42.f100.n403.z2.fidonet.org {internet<>FIDO вентиль}

