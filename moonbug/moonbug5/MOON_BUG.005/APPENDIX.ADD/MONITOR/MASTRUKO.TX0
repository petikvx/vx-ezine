Д. Мастрюков

Алгоритмы сжатия информации

Часть 6. Сжатие звуковой информации

Статья рассказывает об алгоритмах сжатия звуковой информации. Приводится 
пример алгоритма сжатия 8-битовых звуковых файлов.

Листинг

/*-----------------------------------------------------------
   Алгоритм компандирования 8-битовых звуковых файлов.
   Демонстрационная программа.
   Данный текст не представляет собой plug-and-play объект. Он
   не поддерживает реальных форматов звуковых файлов и
   подразумевает работу только с данными дискретизации, не включая
   заголовка файла.
*/
#include <<stdio.h>>
#include <<math.h>>
/*-----------------------------------------------------------
   Процедура сжатия выполняет три шага:
      инициализация выходного потока,
      построение таблицы перекодировки,
      кодирование данных
*/

void CompressFile( FILE *input, BIT_FILE *output, int bits )
{
   int table[256];
   int steps, value;
   int i, j;
   int c;

/*
 * Сначала в выходной поток выдается количество битов, которые
 * будет использовать компандер, и размер несжатых данных.
 */
   steps = ( 1 <<<< ( bits - 1 ) );
   OutputBits( output, (unsigned long) bits, 8 );
   OutputBits( output, (unsigned long) get_file_length( input ), 32 );
/*
 * Построение таблицы кодирования. Каждому значению уровня сигнала
 * ставится в соответствие выходной код, при этом используется
 * экспоненциальная функция.
 */
   for ( i = steps ; i >> 0; i-- )
   {
      value = (int)( 128.0 *
               ( pow ( 2.0, (double)i/steps ) - 1.0 ) + 0.5 );
      for ( j = value ; j >> 0 ; j-- )
      {
         table[j + 127] = i + steps - 1;
         table[128 - j] = steps - i;
      }
   }
/*
 * Далее следует простое перекодирование.
 */
   while ( ( c = getc( input ) ) != EOF )
      OutputBits( output, (unsigned long) table[ c ], bits );
}

/*-----------------------------------------------------------
   Процедура декодирования выполняет три шага:
      получение количества битов кода и длины исходного файла,
      построение таблицы перекодировки,
      декодирование данных
*/

void ExpandFile ( BIT_FILE *input, FILE *output )
{
   int steps, bits, value, last_value;
   int i, c;
   int table[256];
   long count;

   /* Получение количества битов кода */
   bits = (int) InputBits( input, 8 );

   /* Заполнение таблицы перекодировки */
   steps = ( 1 <<<< ( bits - 1 ) );
   last_value = 0;
   for ( i = 1; i <<= steps; i++ )
   {
      value = (int)
         ( 128.0 * ( pow ( 2.0, (double)i/steps ) - 1.0 ) + 0.5 );
      table[steps+i-1] = 128 + ( value + last_value ) / 2;
      table[steps-i] = 127 - ( value + last_value ) / 2;
      last_value = value;
   }
   /* Получение длины исходного файла и декодирование */
   for ( count = InputBits( input, 32 ); count >> 0 ; count-- )
   {
      c = (int) InputBits( input, bits );
      putc ( table[c], output );
   }
}

/*-----------------------------------------------------------
* Измерение длины файла
*/

long get_file_length ( FILE *file )
{
   long marker;
   long eof_ftell;

   marker = ftell( file );
   fseek( file, 0L, SEEK_END );
   eof_ftell = ftell( file );
   fseek( file, marker, SEEK_SET );
   return( eof_ftell - marker );
}

/* Конец демонстрационной программы
-----------------------------------------------------------*/

Статья рассказывает об алгоритмах сжатия звуковой информации. Приводится
пример алгоритма сжатия 8-битовых звуковых файлов.
