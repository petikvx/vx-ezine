program Stringek_Kodolasa;

function XORRORString(const S: String; XORByte, RORBit: Byte): String; Assembler;
asm
  push es {Elmenti az ES regisztert a Stack-ben}
  push ds {Elmenti az DS regisztert a Stack-ben}
  push di {Elmenti az DI regisztert a Stack-ben}
  push si {Elmenti az SI regisztert a Stack-ben}
  lds  si, S       {Betîlti a DS, SI regiszterp†rba az S String mem¢ria c°mÇt}
  les  di, @Result {Betîlti a ES, DI regiszterp†rba az @Result String mem¢ria c°mÇt
                     ebben a - @Result - v†ltoz¢ban ad¢dik vissza a fÅggvÇny visszatÇrÇse}

  xor  ch, ch      {kinull†zza a CH regisztert. (olyan mint: mov ch, 00h)         }
  mov  cl, Byte Ptr ds:[si] {Betîlti a CL regiszterbe az S String hossz†t, S[0]-t }
  mov  bx, cx               {Elmenti az S String hossz†t BX reg.ben, a kÇsìbbiekre}
  cld        {a REP MOVSB 'm†sol¢ mñvelet'-hez be†ll°tja a Direction flag-ot.     }
  inc  cl    {Nîveli a CL reg.t, mert a REP MOVSB-vel †tm†soljuk a ES:DI c°mre              }
             { DS:SI-n kezdìdì S String-et. ês azÇrt nîveltÅk eggyel a CL-t, mert nem csak a}
  rep  movsb { a String x db. karakterÇt m†soljuk †t, hanem a String hossz†t is. S[0]-t is !}
  dec  di    {Csîkkenti DI reg.t, mert a REP MOVSB a m†sol†s vÇgÇn, az eredeti ES:DI-t a String
               vÇgÇre - Length(S)+1 - †ll°totta Pascal-osan °gy: ES:=Seg(S); DI:=Ofs(S)+Length(S)+1;}
  mov  ch, XORByte {CH reg.be tîlti azt a sz†mot amivel XOR-ozni fogunk}
  mov  cl, RORBit  {CL reg.be tîlti azt a sz†mot amennyi bit-tel jobbra forgatjuk a String karakterÇt}
@Codeing:          {ide ugrik vissza a k¢dol†s sor†n az algoritmus}
  xor  Byte Ptr es:[di], ch {1: meg-XOR-ozza az ES:DI-n lÇvì karaktert CH-val (XORByte-tal)}
  xor  Byte Ptr es:[di], bl {2: meg-XOR-ozza az ES:DI-n lÇvì karaktert BL-lel a String-ben lÇvì poz°ci¢val}
  ror  Byte Ptr es:[di], cl {3: ROR-olja az ES:DI-n lÇvì karaktert CL bit-tel - jobbra -   }
  dec  di {Csîkkenti a DI-t, Çs BL-t eggyel, mert a String-ben visszafelÇ csin†ljuk a k¢dol†st, valahogy  }
  dec  bl { °gy: BL:=Length(S); S[BL]:=k¢dolt(S[BL]); (formakÇplet, nem utas°t†s !)        }
  cmp  bl, 00h  {Vizsg†lat: elÇrtÅk -e a String elejÇt ? Azaz a BL a kezdeti - BL:=Length(S) - ÇrtÇkÇt    }
  jne  @Codeing { a k¢dodl†s sor†n csîkkentve elÇrtÅk -e a 0-t ?            }
  pop  si {Kiemeli a Stack-bìl az SI regisztert, amint az elejÇn lementettÅk}
  pop  di {Kiemeli a Stack-bìl az DI regisztert, amint az elejÇn lementettÅk}
  pop  ds {Kiemeli a Stack-bìl az DS regisztert, amint az elejÇn lementettÅk}
  pop  es {Kiemeli a Stack-bìl az ES regisztert, amint az elejÇn lementettÅk}
end;

function RORXORString(const S: String; XORByte, RORBit: Byte): String; Assembler;
asm
  push es {Elmenti az ES regisztert a Stack-ben}
  push ds {Elmenti az DS regisztert a Stack-ben}
  push di {Elmenti az DI regisztert a Stack-ben}
  push si {Elmenti az SI regisztert a Stack-ben}
  lds  si, S       {Betîlti a DS, SI regiszterp†rba az S String mem¢ria c°mÇt}
  les  di, @Result {Betîlti a ES, DI regiszterp†rba az @Result String mem¢ria c°mÇt
                     ebben a - @Result - v†ltoz¢ban ad¢dik vissza a fÅggvÇny visszatÇrÇse}

  xor  ch, ch      {kinull†zza a CH regisztert. (olyan mint: mov ch, 00h)         }
  mov  cl, Byte Ptr ds:[si] {Betîlti a CL regiszterbe az S String hossz†t, S[0]-t }
  mov  bx, cx               {Elmenti az S String hossz†t BX reg.ben, a kÇsìbbiekre}
  cld        {a REP MOVSB 'm†sol¢ mñvelet'-hez be†ll°tja a Direction flag-ot.     }
  inc  cl    {Nîveli a CL reg.t, mert a REP MOVSB-vel †tm†soljuk a ES:DI c°mre              }
             { DS:SI-n kezdìdì S String-et. ês azÇrt nîveltÅk eggyel a CL-t, mert nem csak a}
  rep  movsb { a String x db. karakterÇt m†soljuk †t, hanem a String hossz†t is. S[0]-t is !}
  dec  di    {Csîkkenti DI reg.t, mert a REP MOVSB a m†sol†s vÇgÇn, az eredeti ES:DI-t a String
               vÇgÇre - Length(S)+1 - †ll°totta Pascal-osan °gy: ES:=Seg(S); DI:=Ofs(S)+Length(S)+1;}
  mov  ch, XORByte {CH reg.be tîlti azt a sz†mot amivel XOR-ozni fogunk}
  mov  cl, RORBit  {CL reg.be tîlti azt a sz†mot amennyi bit-tel jobbra forgatjuk a String karakterÇt}
@Codeing:          {ide ugrik vissza a k¢dol†s sor†n az algoritmus}
  ror  Byte Ptr es:[di], cl {3: ROR-olja az ES:DI-n lÇvì karaktert CL bit-tel - jobbra -   }
  xor  Byte Ptr es:[di], bl {2: meg-XOR-ozza az ES:DI-n lÇvì karaktert BL-lel a String-ben lÇvì poz°ci¢val}
  xor  Byte Ptr es:[di], ch {1: meg-XOR-ozza az ES:DI-n lÇvì karaktert CH-val (XORByte-tal)}
  dec  di {Csîkkenti a DI-t, Çs BL-t eggyel, mert a String-ben visszafelÇ csin†ljuk a k¢dol†st, valahogy  }
  dec  bl { °gy: BL:=Length(S); S[BL]:=k¢dolt(S[BL]); (formakÇplet, nem utas°t†s !)        }
  cmp  bl, 00h  {Vizsg†lat: elÇrtÅk -e a String elejÇt ? Azaz a BL a kezdeti - BL:=Length(S) - ÇrtÇkÇt    }
  jne  @Codeing { a k¢dodl†s sor†n csîkkentve elÇrtÅk -e a 0-t ?            }
  pop  si {Kiemeli a Stack-bìl az SI regisztert, amint az elejÇn lementettÅk}
  pop  di {Kiemeli a Stack-bìl az DI regisztert, amint az elejÇn lementettÅk}
  pop  ds {Kiemeli a Stack-bìl az DS regisztert, amint az elejÇn lementettÅk}
  pop  es {Kiemeli a Stack-bìl az ES regisztert, amint az elejÇn lementettÅk}
end;

function ROLXORString(const S: String; XORByte, ROLBit: Byte): String; Assembler;
asm
  push es {Elmenti az ES regisztert a Stack-ben}
  push ds {Elmenti az DS regisztert a Stack-ben}
  push di {Elmenti az DI regisztert a Stack-ben}
  push si {Elmenti az SI regisztert a Stack-ben}
  lds  si, S       {Betîlti a DS, SI regiszterp†rba az S String mem¢ria c°mÇt}
  les  di, @Result {Betîlti a ES, DI regiszterp†rba az @Result String mem¢ria c°mÇt
                     ebben a - @Result - v†ltoz¢ban ad¢dik vissza a fÅggvÇny visszatÇrÇse}

  xor  ch, ch      {kinull†zza a CH regisztert. (olyan mint: mov ch, 00h)         }
  mov  cl, Byte Ptr ds:[si] {Betîlti a CL regiszterbe az S String hossz†t, S[0]-t }
  mov  bx, cx               {Elmenti az S String hossz†t BX reg.ben, a kÇsìbbiekre}
  cld        {a REP MOVSB 'm†sol¢ mñvelet'-hez be†ll°tja a Direction flag-ot.     }
  inc  cl    {Nîveli a CL reg.t, mert a REP MOVSB-vel †tm†soljuk a ES:DI c°mre              }
             { DS:SI-n kezdìdì S String-et. ês azÇrt nîveltÅk eggyel a CL-t, mert nem csak a}
  rep  movsb { a String x db. karakterÇt m†soljuk †t, hanem a String hossz†t is. S[0]-t is !}
  dec  di    {Csîkkenti DI reg.t, mert a REP MOVSB a m†sol†s vÇgÇn, az eredeti ES:DI-t a String
               vÇgÇre - Length(S)+1 - †ll°totta Pascal-osan °gy: ES:=Seg(S); DI:=Ofs(S)+Length(S)+1;}
  mov  ch, XORByte {CH reg.be tîlti azt a sz†mot amivel XOR-ozni fogunk}
  mov  cl, ROLBit  {CL reg.be tîlti azt a sz†mot amennyi bit-tel jobbra forgatjuk a String karakterÇt}
@Codeing:          {ide ugrik vissza a k¢dol†s sor†n az algoritmus}
  rol  Byte Ptr es:[di], cl {3: ROL-olja az ES:DI-n lÇvì karaktert CL bit-tel - jobbra -   }
  xor  Byte Ptr es:[di], bl {2: meg-XOR-ozza az ES:DI-n lÇvì karaktert BL-lel a String-ben lÇvì poz°ci¢val}
  xor  Byte Ptr es:[di], ch {1: meg-XOR-ozza az ES:DI-n lÇvì karaktert CH-val (XORByte-tal)}
  dec  di {Csîkkenti a DI-t, Çs BL-t eggyel, mert a String-ben visszafelÇ csin†ljuk a k¢dol†st, valahogy  }
  dec  bl { °gy: BL:=Length(S); S[BL]:=k¢dolt(S[BL]); (formakÇplet, nem utas°t†s !)        }
  cmp  bl, 00h  {Vizsg†lat: elÇrtÅk -e a String elejÇt ? Azaz a BL a kezdeti - BL:=Length(S) - ÇrtÇkÇt    }
  jne  @Codeing { a k¢dodl†s sor†n csîkkentve elÇrtÅk -e a 0-t ?            }
  pop  si {Kiemeli a Stack-bìl az SI regisztert, amint az elejÇn lementettÅk}
  pop  di {Kiemeli a Stack-bìl az DI regisztert, amint az elejÇn lementettÅk}
  pop  ds {Kiemeli a Stack-bìl az DS regisztert, amint az elejÇn lementettÅk}
  pop  es {Kiemeli a Stack-bìl az ES regisztert, amint az elejÇn lementettÅk}
end;

var S: String;
BEGIN
  S:='Black Cat k¢dol¢ algoritmus !';
  S:=XORRORString(S, 144, 3);  {Bek¢doljuk az S String-et, XOR-ozzuk 144-gyel,
}  WriteLn(S);
 {                               Çs jobbra forgatjuk 3 bit-tel}
  S:=RORXORString(S, 144, 8-3);{Ez m†r a visszak¢dol†s, a function-ben elìszîr
   ROR-oljuk 8-3 bittel, °gy visszapîrdÅl az eredetibe a Byte-t, majd XORozzuk
   144-gyel.}
  WriteLn(S);
  S:='Black Cat k¢dol¢ algoritmus !';
  S:=XORRORString(S, 144, 3);  {Bek¢doljuk az S String-et, XOR-ozzuk 144-gyel,
                                Çs jobbra forgatjuk 3 bit-tel}
  WriteLn(S);


  {Itt saj†t programunkban azt csin†lunk a lek¢dolt String-gel amit akarunk
   le/fel/szÇt/îssze/oda/vissza mentjÅk file-ba, EXE-be ford°tjuk stb.}


  S:=ROLXORString(S, 144, 3);  {Ez m†r a visszak¢dol†s, a function-ben elìszîr
   ROL-oljuk 3 bittel, °gy visszapîrdÅl az eredetibe a Byte-t, majd XORozzuk
   144-gyel.}
  WriteLn(S);
END.
(*Ha a csak a 'fejlett' XOR-ol†st haszn†ljuk akkor mindegy, hogy elìszîr a
 XORByte-tal, vagy az indexxel XOR-ozunk. Teh†t a ugyanazt a function-t
 haszn†lhatjuk a be ill. visszak¢dol†sra.
 A fenti XORRORString Pascal-os megfelelìje:

********************************Pascal-os forma******************************
{$G+}
function  RORByte(B, Value: Byte): Byte; Assembler;
asm
  mov  al, B
  mov  cl, Value
  ror  al, cl
end;

function  ROLByte(B, Value: Byte): Byte; Assembler;
asm
  mov  al, B
  mov  cl, Value
  rol  al, cl
end;

function XORRORString(S: String; XORByte, RORBit: Byte): String;
var i: Byte;
begin
  for i:=1 to Length(S) do
    S[i]:=Chr( RORByte( ( Ord(S[i]) XOR XORByte XOR i ), RORBit ));
  XORRORString:=S;
end;

function RORXORString(S: String; XORByte, RORBit: Byte): String;
var i: Byte;
begin
  for i:=1 to Length(S) do
    S[i]:=Chr( RORByte( Ord(S[i]), RORBit) XOR XORByte XOR i );
  RORXORString:=S;
end;

function ROLXORString(S: String; XORByte, ROLBit: Byte): String;
var i: Byte;
begin
  for i:=1 to Length(S) do
    S[i]:=Chr( ROLByte( Ord(S[i]), ROLBit) XOR XORByte XOR i );
  ROLXORString:=S;
end;

var S: String;
BEGIN
  S:='Black Cat k¢dol¢ algoritmus !';
  S:=XORRORString(S, 144, 3);  {Bek¢doljuk az S String-et, XOR-ozzuk 144-gyel,
                                Çs jobbra forgatjuk 3 bit-tel}
  S:=RORXORString(S, 144, 8-3);{Ez m†r a visszak¢dol†s, a function-ben elìszîr
   ROR-oljuk 8-3 bittel, °gy visszapîrdÅl az eredetibe a Byte-t, majd XORozzuk
   144-gyel.}
  WriteLn(S);
  S:='Black Cat k¢dol¢ algoritmus !';
  S:=XORRORString(S, 144, 3);  {Bek¢doljuk az S String-et, XOR-ozzuk 144-gyel,
                                Çs jobbra forgatjuk 3 bit-tel}
  S:=ROLXORString(S, 144, 3);  {Ez m†r a visszak¢dol†s, a function-ben elìszîr
   ROL-oljuk 3 bittel, °gy visszapîrdÅl az eredetibe a Byte-t, majd XORozzuk
   144-gyel.}
  WriteLn(S);
END.
***********************************vÇge**************************************



EgyÇb k¢dol†sok:

********************************ASCIIPushString******************************
{A karakter ASCII k¢dj†hoz ad egy sz†mot ...}
function  ASCIIPushString(StrToPush: String; NumWithPush: Integer): String;
var i: Byte;
begin
  if NumWithPush >  255 then NumWithPush:=NumWithPush Div 256;
  if NumWithPush < -255 then NumWithPush:=NumWithPush Div 256;
  for i:=1 to Length(StrToPush) do
    StrToPush[i]:= Chr(Ord(StrToPush[i]) + NumWithPush);
  ASCIIPushString:=StrToPush;
end;

var S: String;
BEGIN
  S:='PC-X User';
  S:=ASCIIPushString(S, 3);
  S:=ASCIIPushString(S, -3);
  WriteLn(S);
END.
***********************************vÇge**************************************



********************************XORExtended String***************************
{A 'fejlettebb' XOR-ol†s, assembly-ben.}
function XORExtendedString(const S: String; XORByte: Byte): String; Assembler;
asm
  push es {Elmenti az ES regisztert a Stack-ben}
  push ds {Elmenti az DS regisztert a Stack-ben}
  push di {Elmenti az DI regisztert a Stack-ben}
  push si {Elmenti az SI regisztert a Stack-ben}
  lds  si, S       {Betîlti a DS, SI regiszterp†rba az S String mem¢ria c°mÇt}
  les  di, @Result {Betîlti a ES, DI regiszterp†rba az @Result String mem¢ria c°mÇt
                     ebben a - @Result - v†ltoz¢ban ad¢dik vissza a fÅggvÇny visszatÇrÇse}

  xor  ch, ch      {kinull†zza a CH regisztert. (olyan mint: mov ch, 00h)         }
  mov  cl, Byte Ptr ds:[si] {Betîlti a CL regiszterbe az S String hossz†t, S[0]-t }
  mov  bx, cx               {Elmenti az S String hossz†t BX reg.ben, a kÇsìbbiekre}
  cld        {a REP MOVSB 'm†sol¢ mñvelet'-hez be†ll°tja a Direction flag-ot.     }
  inc  cl    {Nîveli a CL reg.t, mert a REP MOVSB-vel †tm†soljuk a ES:DI c°mre              }
             { DS:SI-n kezdìdì S String-et. ês azÇrt nîveltÅk eggyel a CL-t, mert nem csak a}
  rep  movsb { a String x db. karakterÇt m†soljuk †t, hanem a String hossz†t is. S[0]-t is !}
  dec  di    {Csîkkenti DI reg.t, mert a REP MOVSB a m†sol†s vÇgÇn, az eredeti ES:DI-t a String
               vÇgÇre - Length(S)+1 - †ll°totta Pascal-osan °gy: ES:=Seg(S); DI:=Ofs(S)+Length(S)+1;}
  mov  ch, XORByte {CH reg.be tîlti azt a sz†mot amivel XOR-ozni fogunk}
@Codeing:          {ide ugrik vissza a k¢dol†s sor†n az algoritmus}
  xor  Byte Ptr es:[di], ch {meg-XOR-ozza az ES:DI-n lÇvì karaktert CH-val (XORByte-tal)}
  xor  Byte Ptr es:[di], bl {meg-XOR-ozza az ES:DI-n lÇvì karaktert BL-lel a String-ben lÇvì poz°ci¢val}
  dec  di {Csîkkenti a DI-t, Çs BL-t eggyel, mert a String-ben visszafelÇ csin†ljuk a k¢dol†st, valahogy  }
  dec  bl { °gy: BL:=Length(S); S[BL]:=k¢dolt(S[BL]); (formakÇplet, nem utas°t†s !)        }
  cmp  bl, 00h  {Vizsg†lat: elÇrtÅk -e a String elejÇt ? Azaz a BL a kezdeti - BL:=Length(S) - ÇrtÇkÇt    }
  jne  @Codeing { a k¢dodl†s sor†n csîkkentve elÇrtÅk -e a 0-t ?            }
  pop  si {Kiemeli a Stack-bìl az SI regisztert, amint az elejÇn lementettÅk}
  pop  di {Kiemeli a Stack-bìl az DI regisztert, amint az elejÇn lementettÅk}
  pop  ds {Kiemeli a Stack-bìl az DS regisztert, amint az elejÇn lementettÅk}
  pop  es {Kiemeli a Stack-bìl az ES regisztert, amint az elejÇn lementettÅk}
end;

var S: String;
BEGIN
  S:='PC-X User';
  S:=XORExtendedString(S, 144);
  S:=XORExtendedString(S, 144);
  WriteLn(S);
END.
***********************************vÇge**************************************




****************************A k¢dol†s haszn†lata prg.ben*********************
function XORExtendedString(const S: String; XORByte: Byte): String; Assembler;
asm
  push es {Elmenti az ES regisztert a Stack-ben}
  push ds {Elmenti az DS regisztert a Stack-ben}
  push di {Elmenti az DI regisztert a Stack-ben}
  push si {Elmenti az SI regisztert a Stack-ben}
  lds  si, S       {Betîlti a DS, SI regiszterp†rba az S String mem¢ria c°mÇt}
  les  di, @Result {Betîlti a ES, DI regiszterp†rba az @Result String mem¢ria c°mÇt
                     ebben a - @Result - v†ltoz¢ban ad¢dik vissza a fÅggvÇny visszatÇrÇse}

  xor  ch, ch      {kinull†zza a CH regisztert. (olyan mint: mov ch, 00h)         }
  mov  cl, Byte Ptr ds:[si] {Betîlti a CL regiszterbe az S String hossz†t, S[0]-t }
  mov  bx, cx               {Elmenti az S String hossz†t BX reg.ben, a kÇsìbbiekre}
  cld        {a REP MOVSB 'm†sol¢ mñvelet'-hez be†ll°tja a Direction flag-ot.     }
  inc  cl    {Nîveli a CL reg.t, mert a REP MOVSB-vel †tm†soljuk a ES:DI c°mre              }
             { DS:SI-n kezdìdì S String-et. ês azÇrt nîveltÅk eggyel a CL-t, mert nem csak a}
  rep  movsb { a String x db. karakterÇt m†soljuk †t, hanem a String hossz†t is. S[0]-t is !}
  dec  di    {Csîkkenti DI reg.t, mert a REP MOVSB a m†sol†s vÇgÇn, az eredeti ES:DI-t a String
               vÇgÇre - Length(S)+1 - †ll°totta Pascal-osan °gy: ES:=Seg(S); DI:=Ofs(S)+Length(S)+1;}
  mov  ch, XORByte {CH reg.be tîlti azt a sz†mot amivel XOR-ozni fogunk}
@Codeing:          {ide ugrik vissza a k¢dol†s sor†n az algoritmus}
  xor  Byte Ptr es:[di], ch {meg-XOR-ozza az ES:DI-n lÇvì karaktert CH-val (XORByte-tal)}
  xor  Byte Ptr es:[di], bl {meg-XOR-ozza az ES:DI-n lÇvì karaktert BL-lel a String-ben lÇvì poz°ci¢val}
  dec  di {Csîkkenti a DI-t, Çs BL-t eggyel, mert a String-ben visszafelÇ csin†ljuk a k¢dol†st, valahogy  }
  dec  bl { °gy: BL:=Length(S); S[BL]:=k¢dolt(S[BL]); (formakÇplet, nem utas°t†s !)        }
  cmp  bl, 00h  {Vizsg†lat: elÇrtÅk -e a String elejÇt ? Azaz a BL a kezdeti - BL:=Length(S) - ÇrtÇkÇt    }
  jne  @Codeing { a k¢dodl†s sor†n csîkkentve elÇrtÅk -e a 0-t ?            }
  pop  si {Kiemeli a Stack-bìl az SI regisztert, amint az elejÇn lementettÅk}
  pop  di {Kiemeli a Stack-bìl az DI regisztert, amint az elejÇn lementettÅk}
  pop  ds {Kiemeli a Stack-bìl az DS regisztert, amint az elejÇn lementettÅk}
  pop  es {Kiemeli a Stack-bìl az ES regisztert, amint az elejÇn lementettÅk}
end;

var S: String;
BEGIN
  S:='Ÿ◊¡◊¿⁄“ÀπÒ9¯ÚÚ=†‡Ó‰Î˜ÔÛÂ¸˘´≠';
  WriteLn(XORExtendedString(S, 144));
END.
***********************************vÇge**************************************

*********************************Elìzìhîz************************************
{Hogyan rakjuk programunkba ezt: S:='Ÿ◊¡◊¿⁄“ÀπÒ9¯ÚÚ=†‡Ó‰Î˜ÔÛÂ¸˘´≠'; ?}

function XORExtendedString(const S: String; XORByte: Byte): String; Assembler;
asm
  push es {Elmenti az ES regisztert a Stack-ben}
  push ds {Elmenti az DS regisztert a Stack-ben}
  push di {Elmenti az DI regisztert a Stack-ben}
  push si {Elmenti az SI regisztert a Stack-ben}
  lds  si, S       {Betîlti a DS, SI regiszterp†rba az S String mem¢ria c°mÇt}
  les  di, @Result {Betîlti a ES, DI regiszterp†rba az @Result String mem¢ria c°mÇt
                     ebben a - @Result - v†ltoz¢ban ad¢dik vissza a fÅggvÇny visszatÇrÇse}

  xor  ch, ch      {kinull†zza a CH regisztert. (olyan mint: mov ch, 00h)         }
  mov  cl, Byte Ptr ds:[si] {Betîlti a CL regiszterbe az S String hossz†t, S[0]-t }
  mov  bx, cx               {Elmenti az S String hossz†t BX reg.ben, a kÇsìbbiekre}
  cld        {a REP MOVSB 'm†sol¢ mñvelet'-hez be†ll°tja a Direction flag-ot.     }
  inc  cl    {Nîveli a CL reg.t, mert a REP MOVSB-vel †tm†soljuk a ES:DI c°mre              }
             { DS:SI-n kezdìdì S String-et. ês azÇrt nîveltÅk eggyel a CL-t, mert nem csak a}
  rep  movsb { a String x db. karakterÇt m†soljuk †t, hanem a String hossz†t is. S[0]-t is !}
  dec  di    {Csîkkenti DI reg.t, mert a REP MOVSB a m†sol†s vÇgÇn, az eredeti ES:DI-t a String
               vÇgÇre - Length(S)+1 - †ll°totta Pascal-osan °gy: ES:=Seg(S); DI:=Ofs(S)+Length(S)+1;}
  mov  ch, XORByte {CH reg.be tîlti azt a sz†mot amivel XOR-ozni fogunk}
@Codeing:          {ide ugrik vissza a k¢dol†s sor†n az algoritmus}
  xor  Byte Ptr es:[di], ch {meg-XOR-ozza az ES:DI-n lÇvì karaktert CH-val (XORByte-tal)}
  xor  Byte Ptr es:[di], bl {meg-XOR-ozza az ES:DI-n lÇvì karaktert BL-lel a String-ben lÇvì poz°ci¢val}
  dec  di {Csîkkenti a DI-t, Çs BL-t eggyel, mert a String-ben visszafelÇ csin†ljuk a k¢dol†st, valahogy  }
  dec  bl { °gy: BL:=Length(S); S[BL]:=k¢dolt(S[BL]); (formakÇplet, nem utas°t†s !)        }
  cmp  bl, 00h  {Vizsg†lat: elÇrtÅk -e a String elejÇt ? Azaz a BL a kezdeti - BL:=Length(S) - ÇrtÇkÇt    }
  jne  @Codeing { a k¢dodl†s sor†n csîkkentve elÇrtÅk -e a 0-t ?            }
  pop  si {Kiemeli a Stack-bìl az SI regisztert, amint az elejÇn lementettÅk}
  pop  di {Kiemeli a Stack-bìl az DI regisztert, amint az elejÇn lementettÅk}
  pop  ds {Kiemeli a Stack-bìl az DS regisztert, amint az elejÇn lementettÅk}
  pop  es {Kiemeli a Stack-bìl az ES regisztert, amint az elejÇn lementettÅk}
end;

var
  S: String;
  T: Text;
BEGIN
  Assign(T, 'KODOLT.pas');
  Rewrite(T);
  S:='K¢DOLAND¢ STRING';
  WriteLn(T, XORExtendedString(S, 144));
  Close(T);
END.
{Majd nyissuk meg a 'kodolt.pas' file-t F3-mal, Çs rakjuk az S:=''; idÇzìjelei
 kîzÇ, az ezt megelìzì programba !}
{FIGYELEM HA A K¢DOLT String ' jelet tartalmaz akkor az S String idÇzìjelei
 kîzÇ °gy °rjuk S:='kodoltrizsa''idezojel'; !!!}
***********************************vÇge**************************************
*)