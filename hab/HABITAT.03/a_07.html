<HTML><HEAD>
<TITLE>HABITAT ZINE/ISSUE #3/JUNE 2002 [articles][kernel32]</TITLE>

<STYLE type=text/css>
BODY {
	FONT-SIZE: 8pt; BACKGROUND: #2c468d; COLOR: #c0c0c0; FONT-FAMILY: "verdana"
}
A:link {
	COLOR: #c0c0c0; TEXT-DECORATION: none;FONT-SIZE: 8pt;
}
A:visited {
	COLOR: #c0c0c0; TEXT-DECORATION: none;FONT-SIZE: 8pt;
}
A:active {
	COLOR: #24bdff; TEXT-DECORATION: none;FONT-SIZE: 8pt;
}
A:hover {
	FONT-SIZE: 8pt; COLOR: #d2e9f9; TEXT-DECORATION: none; font-syle: "verdana"
}
P  {
        FONT-SIZE: 8pt; BACKGROUND: #2c468d; COLOR: #c0c0c0; FONT-FAMILY: "verdana"
   }
P.code{
        FONT-SIZE: 11pt; BACKGROUND: #2c468d; COLOR: #c0c0c0; FONT-FAMILY: "courier"
   }
H1 {
	FONT-SIZE: 22pt; COLOR: silver; FONT-FAMILY: "Times New Roman"; TEXT-ALIGN: center
}
H3 {
	FONT-SIZE: 14pt; COLOR: silver; FONT-FAMILY: courier; 
}
H4 {
	FONT-SIZE: 12pt; COLOR: silver; FONT-FAMILY: courier; 
}
I {
	COLOR: silver
}
B {
	FONT-WEIGHT: normal; COLOR: silver;FONT-SIZE: 8pt;
}
LI {
	FONT-WEIGHT: bold; MARGIN-LEFT: 3pt; COLOR: silver
}
CITE {
	FONT-WEIGHT: bold; FONT-SIZE: 16pt; COLOR: silver; FONT-FAMILY: "Times New Roman"
}
STRONG {
	FONT-WEIGHT: bold; COLOR: silver
}
</STYLE>

</HEAD>
<BODY topmargin=0 leftmargin=0>

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD>
			<IMG SRC="images/habmenu_01.gif" WIDTH=110 HEIGHT=79></TD>
		<TD>
			<IMG SRC="images/habmenu_02.gif" WIDTH=68 HEIGHT=79></TD>
		<TD>
			<IMG SRC="images/habmenu_03.gif" WIDTH=71 HEIGHT=79></TD>
		<TD>
			<IMG SRC="images/habmenu_04.gif" WIDTH=84 HEIGHT=79></TD>
		<TD>
			<IMG SRC="images/habmenu_05.gif" WIDTH=167 HEIGHT=79></TD>
	</TR>
	<TR>
		<TD><a href="hb_content.html"><IMG border=0 SRC="images/habmenu_06.gif" WIDTH=110 HEIGHT=21></a></TD>
		<TD><a href="hb_content.html#virus"><IMG border=0 SRC="images/habmenu_07.gif" WIDTH=68 HEIGHT=21></a></TD>
		<TD><a href="hb_content.html#article"><IMG border=0 SRC="images/habmenu_08.gif" WIDTH=71 HEIGHT=21></a></TD>
		<TD><a href="hb_content.html#rubric"><IMG border=0 SRC="images/habmenu_09.gif" WIDTH=84 HEIGHT=21></a></TD>
		<TD>
			<IMG SRC="images/habmenu_10.gif" WIDTH=167 HEIGHT=21></TD>
	</TR>
</TABLE>
<table width=500 cellspacing=0 cellpadding=10>
<tr><td align=left valign=top width=500>
<h3>Кратчайший путь нахождения адреса KERNEL32</h3>
<p align=justify>
Оригинальный текст: Billy Belcebu/DDT<br>
Перевод:            NeKr0!           <br> 
<br>   
 
 Simplest way for get KERNEL32 base address    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   Billy Belcebг/DDT
<br>
<br>
 Хм, как вы поняли я люблю писать маленькие и эффективные туториалы (кроме
 моего VWGs), и вот пред вами еще один. Это на мой взгляд простейший (в идее
 и реализации) путь для получения адреса KERNEL32.DLL. Я проводил тестирование
 на своем компьютере, на Win98 и WinNT4-SP3, и это работало также хорошо, как
 и моя процедура поиска таблицы импортов. Как всегда, как и со всеми моими 
 знаниями, я должен за свою идею Super'у (perdon por  llamarte tanto, ya se
 ke soy un puto pesao ;). Хрм... Oкей, oкей, я пошел :)
<br>
 Как вы знаете, когда мы выполняем приложение, код "вызывается" из части кода
 KERNEL32 (т.e., типа KERNEL делает CALL в наш код) и, если вы помните, когда
 сделан call, адрес возврата находится в стеке (это кусок памяти на котрый
 указывает ESP). Давайте взглянем на пример по теме:
</p>
<img src="images/cuthere.gif">
<pre>

        .586p                           ; Ну... просто ради прикола.
        .model  flat                    ; Hehehe я люблю 32 bit фишки ;)

        .data                           ; Некоторые данные 
					; (для нужд TASM32/TLINK32)
        
        db      00h

        .code

 start:
        mov     eax,[esp]               ; Теперь в EAX должно быть BFF8XXXXh 
					; (если система w9X)
        ret                             ; Способ завершить процесс ;)
 end    start
</pre>
<img src="images/cuthere.gif">
<p align=justify>
Вроде просто. Мы имеем в EAX число приблизительноравное BFF8XXXX (XXXX это
ненужные циферки, потому что нет нужды знать их точно, не надоедайте мне с
такими простыми вещами, как эта ;). Win32 платформы обычно все вырывнивают на
границу страницы, мы можем искать заголовок KERNEL'а на любой странице, он
просто находится в начале страницы, и мы с легкостью можем это проверить. И
когда мы найдем заголовок PE мы будем знать адрес KERNEL32. Хрмм, предел для
поиска мы могли бы установить в 50h страниц. Хехе, не беспокойтесь. Пример 
последует ;)
</p>
<img src="images/cuthere.gif">
<pre>

        .586p
        .model  flat
        .data

extrn   ExitProcess:PROC

                db      0

kernel          equ     0BFF70000h
imagebase       equ     000400000h
limit           equ     (50000h/1000h)

 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;
 ; Бесполезные и несущественные данные :)                                   ;
 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;

        .code

test:       
        call    delta
delta:
        pop     ebp
        sub     ebp,offset delta

        mov     esi,[esp]
        and     esi,0FFFFF000h                  ; AND ESI,-1000
        call    GetK32

        push    00000000h
        call    ExitProcess

 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;
 ; Блин, я предполагаю что ты немного умеешь кодить на ASMе, еще я предпола-;
 ; гаю что ты знаешь, что первый блок инструкций - для получения смещения,  ;
 ; (не нужно в этом примере, но всеравно мне нравиться делать это похожим на;
 ; вирусный код). Второй блок - это как раз то, что нас интересует. Мы имеем;
 ; в ESI адрес, откуда "вызвано" наше приложение, этот адрес указывает нам  ;
 ; ESP (если мы конечно не трогали стек после загрузки программы). Вторая   ;
 ; команда, AND, для выравния адреса, с которого нас вызвали, на границу    ;
 ; страницы. Мы вызовем нашу процедурку, и после этого завершим процесс ;)  ;
 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;

GetK32:

__1:    cmp     byte ptr [ebp+K32_Limit],00h
        jz      WeFailed

        cmp     word ptr [esi],"ZM"
        jz      CheckPE

__2:    sub     esi,1000h
        dec     byte ptr [ebp+K32_Limit]
        jmp     __1

 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;
 ; Первым делом мы проверим не превысили ли мы предел наших 50 страниц.После;
 ; После этого мы проверим начало страницы на предмет сигнатуры MZ (как это ;
 ; должно быть), если она там - проверим на предмет PE заголовка. Если ниче-;
 ; го не совпало - вычитаем из адреса 1 страницу (1000h байт, 4096d байт),  ;
 ; уменьшим значение предела для поиска страниц и поищем снова...           ;
 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;

CheckPE:
        mov     edi,[esi+3Ch]
        add     edi,esi
        cmp     dword ptr [edi],"EP"
        jz      WeGotK32
        jmp     __2
WeFailed:
        stc
WeGotK32:
        xchg    eax,esi
        ret

K32_Limit       dw      limit

 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;
 ; Мы взяли число по смещению 3Ch из MZ заголовка (указывающий RVA адрес где;
 ; начинается PE заголовок), мы устаканили его с адресом страницы, и если по;
 ; этому смещению стоят буковки PE, я думаю мы его нашли... неужели мы его  ;
 ; нашли! ;)                                                                ;
 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;

end     test
</pre>
<img src="images/cuthere.gif">
<p align=justify><br>
Рекомендация: я тестировал этот метод и он не создавл мне проблем в системах
Win98 и WinNT4 с SP3, но, т.к. я не знаю что может где-нибудь случиться, я
рекомендую вам использовать SEH чтобы избежать возможных Page Fault'ов
(и сопутствующих им "синих экранов").
<br><br>
Я не намерен больше тратить свое время на этот простой туториал. Увидимся.
<br><br>
Billy Belcebг,
mass killer and ass kicker.
<br><br>
© Nekr0!
<br><br>
</p>
</BODY>
</HTML>