
▐█ █▐▀█▄▐▀█ ▀▐▀▀▌▀█▄▐▀▀▌    ▄▄▄█▀█
 █ █▐  █▐▄█▌█▐  ▄  █▐       █▄▄▄▄    ▄       Сокеты и Винда
 █▄█▐▄▄█▐  █▐▐  █▄▄█▐       ▀   ▀█  
▐█ █▐▄ █▐▄██▐▐▄ █▄ █▐▄      ▀█▄▄█▀   ▀       (c) NeKr0!
==============================================================================

   Сейчас вирус без функции работы с сетью уже и не вирус. А еще лучше если
в нем есть BackDoor... Сразу в мозгу возникают картины тысяч подчиненных
компутеров, DDOS и прочее мировое  господство :)
   И так, поскольку у меня Win98, то я и писал под нее. Вы спросите - "Что
такое сокет?" и я отвечу вам "RTFM" ибо текст не об этом.
   Для использования сокета в вашей проге, сперва нужно проинициализировать
библиотеку сокетов. Делается это так:
        push offset WSA_Struc    <---- Указатель на структуру WSAData,
                                       которая будет заполнена после вызова
                                       функции.
        push 101h                <---- Требуемая версия (1.1)
        call WSAStartup          <---- Собственно сам вызов

   Структуру WSAData вам знать не обязательно, только ее размер,
но все же вот она:
       WSAdata struc
         wVersion dw 0
         wHighVersion dw 0
         szDescription db 257 dup (0)
         szSystemStatus db 129 dup (0)
         iMaxSockets dw 0
         iMaxUdpDg dw 0
         lpVendorInfo dd 0
       WSAdata ENDS    = 398 байт

   После этого, надо описать сокет:
        push IPPROTO_TCP          <---- Тип протокола
        push SOCK_STREAM          <---- Способ соединения
        push AF_INET              <---- Для интернет сокетов
        call socket

   IPPROTO_TCP использует соединение типа SOCKET_STREAM, функция возвращает
в eax хендл созданного сокета или -1, если ошибка.
   Далее этот сокет нужно подключить к определенному адресу, этот адрес опи-
сывается в структуре sockaddr_in
 sockaddr_in struc
   sin_family dw 0         <---- Тип связи (в нашем случае должно быть
                                 AF_INET)
   sin_port dw 0           <---- Порт на который коннектится (запись в
                                 специальном формате, как его получить -
                                 см. далее)
   sin_addr dd 0           <---- Адрес куда коннектиться (как получить -
                                 см. далее)
   sin_zero db 8 dup (0)   <---- Зарезервированно
 sockaddr_in ENDS

   И подключаем сокет:
     
        push 16                  <---- Размер структуры
        push offset sock_struc   <---- Указатель на структуру
        push socket_handle       <---- Хендл сокета
        call connect

   Все, если нет ошибки, то мы подключены. Теперь мы можем слать и принимать
данные посредством функций send и recv.

        push 0                  <---- Так надо
        push buffer_size        <---- Размер буфера
        push offset buffer      <---- Указатель на буфер
        push socket_handle      <---- Хендл сокета
        call send / call recv         запись/чтение

   Получить номер порта:
        push Port               <---- Ваше число (номер порта)
        callx htons
   В ax (!) возратится переделанный номер

   Получить интернет адрес:
        push offset myaddr      <---- Указатель на строку с адресом
                                      типа 192.168.1.2
        callx inet_addr
   В eax вернется переработанный адрес


   Тут начинается часть вторая ;) Как же быть серверу?

   Серверу не надо соединяться с каким-то адресом, к нему сами все приходят,
ему надо лишь открыть порт на прослушку ну и слушать его :)
   Для этого нужно забиндить предварительно созданный сокет (эта ф-ция похо-
жа на ф-цию connect):

        push 16                  <---- Размер структуры
        push offset sock_struc   <---- Указатель на структуру
        push socket_handle       <---- Хендл сокета
        call bind

   И поставить его в режим прослушки:

	push 15			<---- Размер очереди на соединение
	push socket_handle	<---- Хендл сокета
	callx listen

   Теперь принимаем соединения:

	push 0
	push 0
	push socket_handle
	callx accept           

   Функция возвращает хендл соединения, с которым нам предстоит работать. Этот
хендл нужно запомнить в структуре 

       fd_set struc
         count dd 0              <---- Кол-во проверяемых сокетов
         sock_h dd 0             <---- Хендл соединения
       fd_set ends

   Теперь в цикле остается ждать, пока в сокете не появятся какие-то данные.
Проверяется наличие данных в сокете фуекцией select, 

	push offset timeval      <---- Структура TTL
	push 0			
	push 0
	push offset fd_set       
	push 10h                 <---- Это значение может быть любым ;)
	call select

        timeval struc        <---- Типа время жизни пакета
          sec dd 0
          usec dd 0
        timeval ends

   Тут есть одна заморочка: после каждого вызова select обнуляется поле
fd_set.count, и надо его выставлять в ручную. Функция возвращает в eax коды:
  -1   -случилась ошибка, надо закрыть сокет
   1   -что-то пришло, это можно прочитать
   0   -ничего не случилось

   Ну и в конце, завершаем работу с сокетами:

          call WSACleanup

   Вот вроде и все с технической частью.

   В архиве вы можете найти образец программы. Она состоит из 2х частей:
   Серверная часть открывает соединение на 666 порту и ждет соединения.
             соединение идет по определенному протоколу.
   Клиентская часть соединяется на указанный адрес к порту 666 и посылает
             сообщение.

   В нутри программы вы увидите мою реализацию моего протокола ;) , который
правда пока еще умеет только передовать сообщения, но .....
сделать свой протокол - ЭЛЕМЕНТАРНО!!!!


P.S.: Тут остались не рассмотренны такие вещи как асинхронные сокеты, а это
      я вам скажу ВЕЩЬ ;) 
      Дерзайте.


(c) NeKr0! 2002