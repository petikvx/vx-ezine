
▐█ █▐▀█▄▐▀█ ▀▐▀▀▌▀█▄▐▀▀▌    ▄▄▄█▀█
 █ █▐  █▐▄█▌█▐  ▄  █▐       █▄▄▄▄    ▄     Добавление секции в PE executable
 █▄█▐▄▄█▐  █▐▐  █▄▄█▐       ▀   ▀█  
▐█ █▐▄ █▐▄██▐▐▄ █▄ █▐▄      ▀█▄▄█▀   ▀     (c) by somebody
==============================================================================

 Хехе, как вы уже догадались, в этой статье пойдёт речь о том, как добавить к PE
 экзэшнику ещё одну секцию -- теперь догадайтесь зачем :-)

 Но  перед  тем, как  непосредственно рассказать  о  добавлении  оной, позвольте
 немножечко попиздить на тему  "PE проги, и шо это ваще такое",  а потом к делу.
 Кому всё это вовсе не надо, можете сразу глядеть сорец. Поехали...


 Итак, PE формат исполняемых файлов в ОС Windows используется везде, где можно и
 не нужно,  был придуман  лучшими умами  Micro$ofta, которым  и пришла  в голову
 мысль спиздить его (формат  в смысле) с *nix  систем. Именно поэтому, в  разных
 PE-шниках для разных версий ОС творится хуй знает что и где (взять хотя бы  тот
 факт,  что  загрузчику  насрать  на  то,  что  виртуальную  длину  секции можно
 занулить). И  всё глюки, оставленные микросорцами :) приходится разгребать  нам
 -- вирусмэйкерам (наша служба и опасна и трудна...).

 Так вот, всем известно, что проги в формате PE в памяти, НЕ СООТВЕСТВУЮТ своему
 образу на диске. Например, экзешник для DOS'а загружается в память КАК ЕСТЬ  --
 то есть, если побайтно эмулировть его работу (не загружая его в память), то все
 смещения и переходы  будут указывать в нужное место. Для PE это не так, но  всё
 по порядку...

 PE  программа грузится  в память  вместе со  всеми заголовками.  Рассмотрим  её
 структуру на диске:

                +-------------------+
                |старый MZ заголовок|
                |===================|
                |новый  PE заголовок|
                |===================|
                |  таблица секций   |
                |===================|
                |..секции в порядке.|
                |...перечисления....|
                |....в.таблице......|
                |===================|
                |   всё остальное   |
                +-------------------+

 примечание: наиболее полное описание PE формата вы можете посмотреть в доке  от
             Hard Wisdom'а, я рассмотрю лишь те его части, что будут нам полезны

 Вот. Старый MZ заголовок нужен для двух вещей: проверки на экзэшность (первые 2
 байта должны быть MZ или ZM), и для заглушки, в случае запуска PE из под DOS'а.
 Дворд (двойное слово = 4 байта) по смещению  +3Ch в MZ заголовке есть  смещение
 до нового PE заголовка.  Это первое, что мы должны получить. Первый дворд  в PE
 заголовке есть сигнатура 'PE,0,0', и  если она отсутствует (мы это  проверяем),
 то значит прога вовсе не PE и делать нам там нечего!

        Теперь немного терминологии:

 VA (Virtual Address) -- есть абсолютный адрес чего-либо в памяти. Например:  VA
 = 0x77E80000, адрес загрузки kernel32.dll в ОС Windows 2000.

 RVA  (Relative  Virtual  Address)  --  есть  адрес,  базированный  на  какой-то
 константе. То есть: VA = RVA + const, где const - это то, на чём RVA базирован.

 Выравнивание (Align) -- округление  числа до определённой константы.  Например:
 число 15  выровненное на  8 будет  равно 16.  Наикратчайший способ выравнивания
 предложил Z0MBiE (align_const степень двойки!):

        mov     eax, align_const        ;то, на что выравниваем
        dec     eax
        add     num_to_align, eax       ;то, что выравниваем
        not     eax
        and     num_to_align, eax

 Image Base (dword, со  смещением в PE заголовке  +34h) -- VA адрес  загрузки PE
 проги. Tlink , по умолчанию, устанавливает  это  значение равным  400000h. Если
 программу  не  удаётся  загрузить  по  указанному  Image  Base,  то   загрузчик
 использует специальные секции .reloc и .fixup для того, чтобы перенастроить все
 VA адреса в программе. Но PE проги , в основном, используют RVA адреса, которые
 базируются  на  Image Base, и  поэтому это не  страшно  :-) Значение Image Base
 выровнено на границу 64 Кб (10000h).

 PE файл разбит на секции. Для  чего? Причин много (например, для хранения  доп.
 каталогов импорта или отладочной информации)  -- скажем так: для удобства  ( но
 это уж кому как :). Информация  о всех секциях проги хранится в  ТАБЛИЦЕ СЕКЦИЙ
 (последовательность записей  о всех  секциях программы,  одна запись называется
 Object Entry).  Таблица следует  СРАЗУ за  PE заголовком,  размер которого, как
 правило равен F8h, но поскольку Must Die is Must Die, в PE заголовке есть  word
 со смещением +14h, который хранит длину заголовка минус 18h. Итак, по  смещению
 от PE заголовка,  равному ([word по  +14h] - 18h),  лежит первая запись  Object
 Entry. Её размер (как и любой следующей) всегда равен 28h (формат смотри у Hard
 Wisdom'а).

 Теперь вернёмся к самому первому вопросу, который был поставлен в этой доке  --
 почему образ  PE  программы  в памяти, не соответствует  оному на диске.  Чтобы
 лучше понять это, компилим TASM'ом следующую прогу:

 ===================================[cut here]==================================
 ;       lame.asm
 .586
 .model flat, stdcall

        extrn MessageBoxA:proc
        extrn ExitProcess:proc

 .data
        d_capt  db 'W0W!',0
        d_text  db 'Windoze -- rulz :-)',0

 .code
        lame_start:
        push    40h
        push    offset d_capt
        push    offset d_text
        push    0
        call    MessageBoxA

        push    0
        call    ExitProcess
        end     lame_start
 ===================================[cut here]==================================

 Далее запускаем HIEW (или, что у вас там) и делаем её дамп. Что вы  видете? Дай
 угадаю -- хуйню :-). Правильно, это исполняемый код в перемешку с данными.  Вот
 дамп PE заголовка этой программы:

 ===================================[cut here]==================================
 00000000:  4D 5A 50 00-02 00 00 00-04 00 0F 00-FF FF 00 00  MZP               
 00000010:  B8 00 00 00-00 00 00 00-40 00 1A 00-00 00 00 00  ╕       @         
 00000020:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 00000030:  00 00 00 00-00 00 00 00-00 00 00 00-00 01 00 00                    
 00000040:  BA 10 00 0E-1F B4 09 CD-21 B8 01 4C-CD 21 90 90  ║    ┤ ═!╕ L═!РР  
 00000050:  54 68 69 73-20 70 72 6F-67 72 61 6D-20 6D 75 73  This program mus  
 00000060:  74 20 62 65-20 72 75 6E-20 75 6E 64-65 72 20 57  t be run under W  
 00000070:  69 6E 33 32-0D 0A 24 37-00 00 00 00-00 00 00 00  in32  $7          
 00000080:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 00000090:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000000A0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000000B0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000000C0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000000D0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000000E0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000000F0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 00000100:  50 45 00 00-4C 01 04 00-62 2D 02 0C-00 00 00 00  PE  L   b-        
 00000110:  00 00 00 00-E0 00 8E 81-0B 01 02 19-00 02 00 00      р ОБ          
 00000120:  00 06 00 00-00 00 00 00-00 10 00 00-00 10 00 00                    
 00000130:  00 20 00 00-00 00 40 00-00 10 00 00-00 02 00 00        @           
 00000140:  01 00 00 00-00 00 00 00-03 00 0A 00-00 00 00 00                    
 00000150:  00 50 00 00-00 04 00 00-00 00 00 00-02 00 00 00   P                
 00000160:  00 00 10 00-00 20 00 00-00 00 10 00-00 10 00 00                    
 00000170:  00 00 00 00-10 00 00 00-00 00 00 00-00 00 00 00                    
 00000180:  00 30 00 00-90 00 00 00-00 00 00 00-00 00 00 00   0  Р             
 00000190:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000001A0:  00 40 00 00-14 00 00 00-00 00 00 00-00 00 00 00   @                
 000001B0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000001C0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000001D0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000001E0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000001F0:  00 00 00 00-00 00 00 00-43 4F 44 45-00 00 00 00          CODE      
 00000200:  00 10 00 00-00 10 00 00-00 02 00 00-00 06 00 00                    
 00000210:  00 00 00 00-00 00 00 00-00 00 00 00-20 00 00 60                 `  
 00000220:  44 41 54 41-00 00 00 00-00 10 00 00-00 20 00 00  DATA              
 00000230:  00 02 00 00-00 08 00 00-00 00 00 00-00 00 00 00                    
 00000240:  00 00 00 00-40 00 00 C0-2E 69 64 61-74 61 00 00      @  └.idata    
 00000250:  00 10 00 00-00 30 00 00-00 02 00 00-00 0A 00 00       0            
 00000260:  00 00 00 00-00 00 00 00-00 00 00 00-40 00 00 C0              @  └  
 00000270:  2E 72 65 6C-6F 63 00 00-00 10 00 00-00 40 00 00  .reloc       @    
 00000280:  00 02 00 00-00 0C 00 00-00 00 00 00-00 00 00 00                    
 00000290:  00 00 00 00-40 00 00 50-00 00 00 00-00 00 00 00      @  P          
 000002A0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000002B0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000002C0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 000002D0:  00 00 00 00-00 00 00 00-00 00 00 00-00 00 00 00                    
 ===================================[cut here]==================================

 Вот именно  со слова  'CODE' и  начинается таблица  секций. В  ней находятся  4
 элемента: секции 'CODE', 'DATA', '.idata' и '.reloc'. Наша цель, позаботиться о
 том, чтобы в ней появился ПЯТЫЙ ЭЛЕМЕНТ (фильм смотрели? :-).

        Теперь самый важный момент -- внимание!

 Если вы сделали дамп, то увидите за PE заголовком приблизительно 300h нулей. Мы
 подошли к  <выравниванию объектов  в файле>.  Все ОБЪЕКТЫ  в PE  файле подлежат
 выравниванию на диске. Это делает  линкер на этапе компиляции. Этот  факт можно
 понимать ещё  и как  УПАКОВКУ объектов  в файле.  Будем понимать под объектами:
 заголовок (MZ  + PE  + таблица  секций), секции  PE файла,  каталоги импорта  \
 экспорта,  и  так далее...  Я  уже говорил,  что  такое выравнивание  --  то же
 применимо  и  к  объектам  PE  файла,  они  выравниваются  нулями  (0h),   т.е.
 дополняются ими до какой то определённой константы. Грубо говоря КАЖДЫЙ  объект
 будет иметь размер кратный этой  константе, независимо от того, сколько  кода \
 данных он  содержит. Эта  константа называется  file align,  и определена  в PE
 заголовке  (dword, со  смещением +3Ch).  Нули, которыми  выравниваются объекты,
 называются  АЛИГНМЕНТОМ  (т.е. эти  300h  нулей  за  PE  заголовком, и есть его
 алигнмент).

 Зачем производится  выравнивание (упаковка)  объектов? Это  можно легко понять,
 если учесть, что само значение file align кратно 512 (200h) -- размеру  сектора
 на диске.  Т.е. если  размер объекта  равен 60h,  то при  выравнивании он будет
 дополнен нулями до размера 200h, и разместится в одном секторе. Если же  размер
 объекта будет равен 220h, то он займёт уже 2 сектора (400h). Удобно, не  правда
 ли? Есть ещё одна причина такого  удобства -- она связанна с загрузкой  файла в
 память...

 Но это не ответ на наш вопрос! Почему в памяти образ файла выглядит по другому?
 Связанно  это опять таки  с удобством  :-) Если  на винчестере  объекты удобнее
 всего хранить  секторами, то  в память  их удобнее  всего отображать СТРАНИЦАМИ
 (размер страницы равен 4096 = 1000h).  Это и есть выравнивание файла в  памяти.
 Константа, на   которую происходит  выравнивание объектов  в памяти  называется
 object align -- она хранится в PE заголовке (dword, по смещению +38h), и кратна
 размеру страницы памяти 4096 (1000h).
 Пусть file align  = 200h, а  object align =  1000h. Тогда: если  размер объекта
 равен 60h, на диске он займёт 200h, а в памяти 1000h. Если размер объекта равен
 220h, на диске он займёт 400h, и в памяти 1000h.

 Размер станицы равен размеру 5 секторов, поэтому факты выравнивания объектов  в
 памяти и в файле могут следовать один из другого.

 Резюмируем -- размер  минимального объекта (скажем  1 байт) ВСЕГДА  будет равен
 file align байт  в файле и  object align байт  в памяти. Выравнивание  объектов
 производится  нулями, в  файле  -  линкером, на  этапе  компиляции, в  памяти -
 загрузчиком, на этапе загрузки.


 Вернёмся к секциям PE файла. Как уже было сказано -- они являются объектами  PE
 файла. На каждую секцию  проги отводится одна  Object Entry в PE заголовке,  их
 количество описано в поле Num of Objects PE заголовка (word, по смещению +06h).
 Вот структура, отражающая формат Object Entry:

 oe_struc                struc
 oe_name                 db      8 dup (?) ;имя секции
 oe_virtsize             dd      ?         ;виртуальная длина секции
 oe_virtrva              dd      ?         ;смещение секции в памяти (RVA)
 oe_physsize             dd      ?         ;физическая длина секции
 oe_physoffs             dd      ?         ;смещение секции в файле
 oe_xxx                  dd      ?         ;зарезервированно для OBJ файла
                         dd      ?         ;в экзешниике значения
                         dd      ?         ;не имеет
 oe_flags                dd      ?         ;флаги секции

                 ; длина Object Entry ВСЕГДА равна 28h
 oe_struc                ends

 1) Имя секции  -- это просто  имя :-) оно  может быть любым,  длина ограниченна
 восьмью байтами,  остаток (если  есть) заполняется  нулями. Это  те самые слова
 "CODE', 'DATA' и т.д., что мы видели в дампе.

 2) Физическая длина секции  -- это  то, сколько секция занимает на диске. Может
 содержать   не   выровненную   длину   (линкер   просто   запихал   сюда  длину
 откомпилированного кода), так  что перед тем, как выполнять какие либо расчёты,
 необходимо  это  значение выровнять.  В  этом  поле  указанно  количество байт,
 которое загрузчик будет считывать в память.

 3) Виртуальная длина секции -- это то, сколько секция будет занимать в  памяти,
 с  учтём  неинициализированных  данных  в  её   конце.  Определяется  как сумма
 физической длины  с длиной  неинициализированных данных.  Так же  может быть не
 выровнена.

 4) Смещение  секции в  файле --  смещение, по  которому лежит  секция на диске.
 Исходя из того, что линкер выравнивает секции, смещение кратно file align.

 5) RVA секции в памяти -- это вычисленное линкером значение, по которому секция
 будет загружена  в память.  Исходя из  выравнивания секций   в памяти, значение
 кратно object align.

 Значения смещений в файле, и в памяти выровнены всегда  --  т.е. секция  должна
 начинаться на границе сектора - на диске, и страницы - в памяти.

 6) Флаги секции -- это число, определяющие её свойства, такие как разрешение на
 запись в неё и т.д.

 Процесс загрузки секции PE в память выглядит приблизительно так:

 Загрузчик, предварительно считав общий  заголовок в память, анализирует  Object
 Entry  секции.  Берёт  из неё  RVA  секции,  и грузит  в  память  по этому  RVA
 oe_physsize байт, которые читает по смещению oe_physoffs. Затем забивает нулями
 область до  oe_virtsize, отводя  таким образом  память для неинициализированных
 данных. Далее, он  забивает нулями область  памяти, до границы   кратной object
 align -- выравнивает  секцию в памяти.  Теперь понятно, почему  в Object  Entry
 могут  храниться  не  выровненные длины  секции  --  например нахуя  загрузчику
 грузить  лишние  нули с  диска  (алигнмент секции),  если  он всё  равно  будет
 забивать ими  память  (нахуя  мне без  хуя --  если с  хуем дохуя :-)? Загрузив
 секцию, он переходит к следующей Object Entry...

 Рассмотрим возможные соотношения между НЕ ВЫРОВНЕННЫМИ длинами секции:

 1)  физическая  длина  равна  виртуальной  --  это  значит,  что  в  секции нет
 неинициализированных данных.

 2)  физическая длина  меньше виртуальной  -- значит,  что  неинициализированные
 данные присутствуют.

 3)  физическая длина  больше виртуальной  -- это  значит, что  мы нарвались  на
 ЕБАНУТЫЙ  линкер   :-).  На   самом  деле,   если  в   секции  ТОЧНО  не  будет
 неинициализированных данных,  то со  значением виртуальной  длины можно  делать
 всё, что хочешь  -- хоть занулить  её нахуй. В  этом случае загрузчик  поступит
 так:  загрузит кол-во  байт по  физической длине  секции,  затем  глянет на  её
 виртуальную длину -- увидит,  что она меньше физической, или вообще равна нулю,
 и...  просто забьет нулями память до границы object align. Запомните, мы всегда
 должны поступать так же, как и загрузчик -- в этом случае мы примем виртуальную
 длину равной физической.

 Но перед  тем, как  добавить  ещё  одну секцию  в PE  файл, нужно  поработать с
 его последней секцией. Здесь мы можем столкнуться с некоторыми проблемами:

 1) секция на диске может быть не выровнена;

 Выше говорилось,  что линкер  выравнивает секцию  на диске  нулями, до размера,
 кратного file align.  Это ОБЯЗАТЕЛЬНО для  всех секций файла,  кроме последней.
 Причин может быть несколько:

        а) нам опять попался ебанутый (ленивый) линкер;
        б) файл  заражён другим  вирусом, который заражает  PE увеличивая  длину
           последней секции, и естественно её выравнивать не будет;
        в) кто угодно, может удалить лишние нули из последней секции;
        г) что нибудь ещё...

 Почему это стало проблемой для нас? Потому, что выровнена ли секция на диске по
 file align или нет, её смещение (как и  любой другой) по file align должно быть
 выровнено всегда (секция должна начинаться на границе сектора)!

 Есть два способа решения этой проблемы:
        а) выровнять секцию до file align нулями самостоятельно;
        б) не заражать такие файлы (так можно решить любую проблему :-);

 В пользу того, что такой файл трогать не следует говорит то, что он может  быть
 заражён другим вирусом, и двойное заражение может порушить файл...

 2) секция может иметь оверлей;

 Оверлей -- это участок кода \ данных, который не загружается в память вместе  с
 программой.  Обычно  присутствует  в последней  секции,  но  теоретически можно
 сделать и в другой. Но для нас важно лишь его присутствие в последней секции  -
 -  такие файлы  мы заражать  не будем  :-( <Смещение  оверлея> вычисляется  как
 <смещение  последней  секции>  плюс   её  <физическая  длина>.  <Длина оверлея>
 равна <длине файла>  минус <смещение оверлея>.  Оверлеи применяются например  в
 SFX архивах: представьте себе SFX размером 300 Мб, с вашим объёмом памяти в 128
 Мб :-) Из этого файла в память  загрузится около 300 Кб. Так  же оверлеи  могут
 содержать  отладочную  информацию...

 Из всего выше сказанного, следует, что оверлейные проги таким методом  заразить
 нельзя. В Windows NT и выше, таких файлов большинство...

 3) файл может иметь алигнмент;

 Выше говорилось, что алигнмент есть последствие выравнивания объектов (нули). В
 данном случае в роли объекта выступает сам PE файл. Файловый алигнмент нигде не
 учитывается, и ни на что не влияет. Файловый алигнмент -- это  образ, состоящий
 из нулей, которым выравнивается файл до определённого размера , например  Tlink
 выравнивает файл до размера кратного 1000h (4096 байт). Зачем  --  спросите вы,
 увеличивать длину файла, добавляя в него лишние нули? А хуй его знает -- отвечу
 я...  Главное не перепутать файловый алигнмент с  алигнменом секции.  Для этого
 прогой TDUMP (из комплекта TASM) сделайте дамп lame.exe. Вот что вы увидите:

        Длина файла                             1000h
        Смещение последней секции (.reloc)       C00h
        Физ. длина последней секции              200h

 Вычислим длину файла по Object Entry последней секции: её смещение + физ. длина
 = C00h + 200h =  E00h. Но длина файла равна  1000h? Куда делись ещё 200h  байт?
 Это и есть ФАЙЛОВЫЙ АЛИГНМЕНТ.

 А сама проблема вот в чём: вирус не заразит этот файл, так как обнаружит в  нём
 оверлей со смещением E00h и длиной 200h. А ведь файловый алигнмент ни на что не
 влияет, и его спокойно можно затереть.


 Что же  делать? Как  отличить оверлей  от  алигнмента?  Как ни странно все  три
 проблемы  имеют  одно общее  решение.  Я опирался  на  следующие факты:  обычно
 оверлей  по  file align не  выравнивается (зачем?), а  при наличии  алигнмента,
 ДЛИНА  ФАЙЛА кратна  file align.  То есть: достаточно всего на всего  выровнять
 реальную (по функции  FindFile) ДЛИНУ ФАЙЛА  на file align, и сравнить её  с не
 выровненной длиной. Получим вот что:

        а) не выровненная длина меньше выровненной -- это значит,  что последняя
        секция файла не выровнена по file align (проблема №1);
        б) не выровненная  длина больше  выровненной -- это значит,  что  секция
        имеет оверлей (проблема №2);
        в) не выровненная  длина равна  выровненной -- значит,  что либо всё Ok,
        либо файл содержит алигнмент (проблема №3);



                 Вот алгоритм добавления секции к PE executable:

 1) перейти к концу таблицы объектов -- туда, где будет новая Object Entry нашей
 секции.  Считать в  буфер 28h байт (размер  Object Entry),  и проверить  их  на
 отсутствие каких либо данных (они там могут быть!) -- все байты в буфере должны
 быть равны 0h.

 2) перейти на  28h байт назад  -- к  Object  Entry последней секции.  Проверить
 секцию:  на  повторное  заражение, оверлейность  \  не  выравненность, сравнить
 физическую  и  виртуальную длину  секции  -- уравнять  их,  если вторая  больше
 первой.

 3)  выровнять  значения  физической  и  виртуальной длины  секции (длин вируса)
 соответственно по file align и  object  align.  Вычислить смещения нашей  новой
 секции в файле, и в памяти:

 смещение новой секции , в файле, будет равно сумме  <смещения последней секции>
 с её <выровненной физической длинной>.
 аналогично:  смещение  новой  секции , в памяти, будет  равно  сумме  <смещения
 последней секции> с её <выровненной виртуальной длинной>.

 Полученные данные сохранить.

 4) подготовить в памяти новую Object Entry, следующим образом:

 oe_struc                struc
 oe_name                 db      [здесь поместить имя <= 8 байт]
 oe_virtsize             dd      [вирт. длина вируса]
 oe_virtrva              dd      [полученное вирт. смещение секции]
 oe_physsize             dd      [физ. длина вируса]
 oe_physoffs             dd      [полученное физ. смещение секции]
 oe_xxx                  dd      [сюда можно]
                         dd      [поставить]
                         dd      [метку заражения]
 oe_flags                dd      [установить равным C0000040h]
 oe_struc                ends

 и записать её сразу после Object Entry (!) последней секции.

 5) передвинутся по  смещению новой секции.  Создать пустую выровненную  секцию,
 записав нули в файл (по выровненной физ. длине вируса).

 6) настроить вирус и записать его в новую секцию.

 7) обновить PE заголовок:

 увеличить значение Num of Objects на 1 (мы добавили ещё одну секцию!);
 увеличить поле Image Size (dword, со  смещением +50h),  которое является суммой
 виртуальных длин ВСЕХ ОБЪЕКТОВ PE файла, на выровненную виртуальную длину новой
 секции;
 плюс обновления, требуемые вирусом (установка новой точки входа, и т.д.);


                                      * * *
