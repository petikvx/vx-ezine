
▐█ █▐▀█▄▐▀█ ▀▐▀▀▌▀█▄▐▀▀▌    ▄▄▄█▀█
 █ █▐  █▐▄█▌█▐  ▄  █▐       █▄▄▄▄    ▄     Взлом UltraEdit
 █▄█▐▄▄█▐  █▐▐  █▄▄█▐       ▀   ▀█  
▐█ █▐▄ █▐▄██▐▐▄ █▄ █▐▄      ▀█▄▄█▀   ▀     (c) somebody
==============================================================================

                             Взлом Ultra Edit v 9.2+
                             ~~~~~~~~~~~~~~~~~~~~~~~

 Ultra  Edit  --  рулёзный текстовый  редактор,  с  подсветкой синтаксиса,  хекс
 редактор, и ещё много клёвых фич.

 До этого я юзал  восьмую версию, и на  днях скачал с ftp.ultraedit.com,  версию
 9.2+.  Поиски  кряка  успехом  не   увенчались,  максимум  что  я  нашёл,   это
 "UltraEdit32 v9.10 Keymaker by Egis/CORE".

 Осмотрев  прогу,  выясняется схема  её  регистрации: при  вводе  user name'а  и
 серийника -- никаких вычислений не производится, а всё это дело  обрабатывается
 (шифруется, и  ещё х.з.  что), и  скидывается в  файл UEDIT32.REG,  затем прога
 перезапускается.  Врубив  тулзу  FILEMON (регистрирует  обращения к  файлам), я
 увидел,  что прога  перед загрузкой,  открывает \  закрывает  около  40 файлов.
 UEDIT32.REG в  этом списке  один из  последних, а  это значит,  что с бряком на
 CreateFileA  может крыша  поехать. Подумав:  "да ну  её нахуй"  --  копаться  в
 бинарнике 1,8 Mb дизасмом, я  стал пробовать старые кейгены. Кейген  для версии
 9.1 подошёл. Прога  перезапустилась, и заработала  (в окне About  строки "Thank
 you for supporting Shareware")!  Представляете моё лицо, когда  перезапустив её
 ещё раз,  прога жёстко  (триал кончился  за день  :) потребовала  рег. инфы? Не
 слабо охуевши, я посмотрел и увидел, что она СНЕСЛА файл UEDIT32.REG -- в проге
 имелась какая то хитрая наёбка. Зарегив её ещё раз, и перезапустив два раза,  я
 уже  своими  глазами  увидел,  как  из  её  диры  улетает, ко  всем  хуям, файл
 UEDIT32.REG.

 Значит, это была хитрая наёбка  -- деволоперы предусмотрели ввод фэйковой  рег.
 инфы. Очевидно, было три пути решения проблемы:

        1) написать собственный кейген, заточенный под версию 9.2;
        2) разобраться, почему прога регится, а рег. файл удаляет;
        3) уебать процедуру удаления файла;

 Но ведь, если старый  кейген работает,  и в  окне About  всё ништяк,  нахуя его
 переписывать?  Разбираться  с причиной  взъёба  тоже в  падлу.  Пойдём по  пути
 наименьшего сопротивления.

 Поставим  в Soft-Ice  "bpx DeleteFileA"  и закроем  прогу, которая  только  что
 нормально работала (второй  перезапуск). Попав в  айс, жмём F12  (PRET), и чуть
 выше видим такой код:

 001B: 004046498	push    dword ptr [ebp-10]
 001B: 00404649B	call    [Kernel32!DeleteFileA]
 001B: 0040464A1        ....    ................        ; <= мы здесь

 Как мы  знаем, у  функции DeleteFileA  один параметр  -- это  указатель на  имя
 файла. Стало  быть этот  параметр, указатель  на файл "UEDIT32.REG". Вот  он --
 наш злопиздец. Ну что ж, отроем Hiew, перейдём по адресу  .004046498, и  забъём
 всё, до .0040464A0 включительно, nop'ами  (код = 90h). Теперь всё  работает как
 надо :-)

 После  всего этого,  я написал  кряк, скрестив  чужой кейген  с моим  маленьким
 патчем.
                                      * * *
===================================[cut here]===================================
COMMENT`

 Вот исходник кряка для UltraEdit v9.2+ -- гибрид чужого кейгена, с моим патчем.
 Прогу можно взять здесь -- ftp://ultraedit.com/uedit32.zip. Нихуя особого он не
 делает, просто запускает кейген или патч.

 Компилять MASM'ом.

        (c) somebody 2002
`

.586
.model flat, stdcall
option casemap :none

        ; INCLUDEZ:
        include         c:\masm32\include\windows.inc
        include         c:\masm32\include\user32.inc
        include         c:\masm32\include\kernel32.inc
        include         c:\masm32\include\masm32.inc
        include         c:\masm32\include\comdlg32.inc
        includelib      c:\masm32\lib\user32.lib
        includelib      c:\masm32\lib\kernel32.lib
        includelib      c:\masm32\lib\masm32.lib
        includelib      c:\masm32\lib\comdlg32.lib

        ; PROTOTYPEZ:
        WndProc         PROTO :DWORD,:DWORD,:DWORD,:DWORD

        ; EQUZ:
        IDR_ICON        equ 200                         ;ID ресурсов
        IDB_GENERATE    equ 1000
        IDB_PATCH       equ 1001
        MAX_SIZE        equ 206
        file_size       equ 1961984                     ;длина файла (для проверки!)
        PATCH_OFFSET    equ 46498h                      ;смещение, где патчить
        PATCH_BYTES     equ 9                           ;сколько впатчивать

.data
        ;Для диалоговых окон:
        c_success       db "Enjoy!",0
        t_success       db "Programm cracked successfully!",13,10
                        db "Enjoy the crack version.",0
        c_eaccess       db "Access to file is closed!",0
        t_eaccess       db "Error in open file process!",13,10
                        db "Check what file dont uses by another process.",0
        c_esize         db "Error!",0
        t_esize         db "File have wrong size!",13,10
                        db "Check programm version - it must be 9.2+",0
        c_ekg           db "Error!",0
        t_ekg           db "Cant open file KG.DAT in current directory.",13,10
                        db "Check it, i really need it ;-)",0

        bytes           db 9 dup (90h)                  ;байты, что впатчивать
        dlgTitle        db "Crack for UltraEdit v9.2+, (c) Sliver",0
        dlgname         db "CRACKDLG",0
        ofn             OPENFILENAME <>                 ;структура OPEN FILE NAME
        processInfo     PROCESS_INFORMATION <>          ;структура информации о процессе
        FilterString    db "UltraEdit executable",0,"UEDIT32.EXE",0,0
        keygen          db "KG.DAT",0                   ;файл кейгена

.data?
        b_count         dd ?                            ;счётчик байт (для ReadFile)
        hWnd            HWND ?                          ;хендл окна,
        hFile           HANDLE ?                        ;файла,
        hInstance       HINSTANCE ?                     ;проги,
        hIconImage      HANDLE ?                        ;иконки,
        hIcon           HANDLE ?                        ;--//--
        ExitCode        dd ?                            ;код выхода (для процесса кейгена)
        file            db MAX_SIZE dup(?)              ;под имя файла

.code

start:

        invoke  GetModuleHandle, NULL                   ;взять хендл проги
        mov     hInstance, eax
        invoke  DialogBoxParam, hInstance, offset dlgname, NULL, ADDR WndProc, NULL
        invoke  ExitProcess, eax                        ;на выход...

WndProc         proc hWin   :DWORD, uMsg :DWORD, wParam :DWORD, lParam :DWORD
        LOCAL   startInfo:STARTUPINFO                   ;структура StartUpInfo

        .IF uMsg == WM_INITDIALOG
                ;инициализируем окно:
                mov     eax, hWin                       ;хендл у окна, тот же,
                mov     hWnd, eax                       ;что и у проги

                ;инициализируем структуру ofn:
                mov     ofn.lStructSize, sizeof ofn
                push    hWnd
                pop     ofn.hWndOwner                   ;хендл окна-предка
                push    hInstance
                pop     ofn.hInstance                   ;хенд проги
                mov     ofn.lpstrFilter, offset FilterString
                mov     ofn.lpstrFile, offset file      ;буфер, для имени файла
                mov     ofn.nMaxFile, MAX_SIZE

                invoke  SendMessage, hWin, WM_SETTEXT, 0, offset dlgTitle

                ;загрузить, и показать иконку:
                invoke  LoadIcon, hInstance, IDR_ICON
                mov     hIcon, eax
                invoke  SendMessage, hWin, WM_SETICON, 1, hIcon

        .ELSEIF uMsg == WM_COMMAND
                .IF wParam == IDB_GENERATE
                        ;юзер вызвал кейген...
                        .IF processInfo.hProcess!=0
                                ;закрыть процесс, если он был запущенн
                                invoke  CloseHandle, processInfo.hProcess
                                mov     processInfo.hProcess, 0
                        .ENDIF
                        ;заполнить StartUpInfo, и создать процесс
                        invoke  GetStartupInfo, ADDR startInfo
                        invoke  CreateProcess, offset keygen, NULL, NULL, NULL, FALSE,\
                                NORMAL_PRIORITY_CLASS, NULL, NULL, ADDR startInfo, \
                                ADDR processInfo
                        .IF eax == FALSE
                                invoke  MessageBox, NULL, offset t_ekg, offset c_ekg, \
                                        MB_OK or MB_ICONERROR
                        .ENDIF
                        invoke  CloseHandle, processInfo.hThread

                .ELSEIF wParam == IDB_PATCH
                        ;будем патчить UltraEdit
                        call    Terminate               ;вырубить кейген

                        ;вызвать окно "Open File"
                        mov     ofn.Flags, OFN_FILEMUSTEXIST or OFN_PATHMUSTEXIST or\
                                OFN_EXPLORER or OFN_LONGNAMES or OFN_HIDEREADONLY
                        invoke  GetOpenFileName, ADDR ofn
                        test    eax, eax
                        jz      Exit_Patch

                        ;проверить, та ли версия проги, что нам нужна
                        invoke  filesize, offset file
                        cmp     eax, file_size
                        jnz     wrong_size

                        ;открыть файл на чтение\запись
                        invoke  CreateFile, offset file, GENERIC_READ or GENERIC_WRITE, \
                                FILE_SHARE_READ, NULL, OPEN_EXISTING, \
                                FILE_ATTRIBUTE_ARCHIVE or FILE_ATTRIBUTE_NORMAL, NULL
                        cmp     eax, -1
                        jz      access_error
                        mov     hFile, eax

                        ;поставить указатель, записать байты, и закрыть его нах
                        invoke  SetFilePointer, hFile, PATCH_OFFSET, NULL, FILE_BEGIN
                        invoke  WriteFile, hFile, offset bytes, PATCH_BYTES, offset b_count, NULL
                        invoke  CloseHandle, hFile

                        ;радостная мессага, и на выход...
                        invoke  MessageBox, hWnd, offset t_success, offset c_success, \
                                MB_OK or MB_ICONINFORMATION
                        jmp     Got_Out

                wrong_size:
                        invoke  MessageBox, hWnd, offset t_esize, offset c_esize, \
                                MB_OK or MB_ICONERROR
                        jmp     Exit_Patch

                access_error:
                        invoke  MessageBox, hWnd, offset t_eaccess, offset c_eaccess, \
                                MB_OK or MB_ICONERROR

                Exit_Patch:
                .ENDIF

        .ELSEIF uMsg == WM_CLOSE
                ;уходим...
         Got_Out:
                call    Terminate                       ;вырубить кейген
                invoke  EndDialog, hWin, NULL           ;снять окно

        .ENDIF
        xor     eax, eax
        ret
WndProc         endp

Terminate       proc
        ;процедура закрытия процесса кейгена

        invoke  GetExitCodeProcess, processInfo.hProcess, offset ExitCode

        .IF ExitCode == STILL_ACTIVE                    ;снять процесс, если он активен
                invoke  TerminateProcess, processInfo.hProcess, NULL
        .ENDIF

        invoke  CloseHandle, processInfo.hProcess       ;закрыть его хендл
        mov     processInfo.hProcess, 0

        ret
Terminate       endp

end     start
===================================[cut here]===================================
