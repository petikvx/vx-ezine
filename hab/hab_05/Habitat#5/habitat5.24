
▐█ █▐▀█▄▐▀█ ▀▐▀▀▌▀█▄▐▀▀▌    ▄▄▄█▀█
 █ █▐  █▐▄█▌█▐  ▄  █▐       █▄▄▄▄    ▄      Занимательные числа
 █▄█▐▄▄█▐  █▐▐  █▄▄█▐       ▀   ▀█  
▐█ █▐▄ █▐▄██▐▐▄ █▄ █▐▄      ▀█▄▄█▀   ▀      (c) ecr
==============================================================================

/*
    Идея:
    Берём единицу (1), ну и начинаем её прибавлять к себе, короче:
     1
     2
     3
    ...
    10
    11
    12
    13
    ...
    Затем делаем то же самое с двойкой (2):
     2
     4
     6
     8
    10
    12
    14
    16
    ...
    И так далее  с остальными цифрами  десятичной системы (кроме  0). Дальше
    смотрим на  последнюю цифру  каждого столбика  и видим  что она,  цифра,
    образует последовательности (периоды).  Ставим все столбики  рядом, если
    всё правильно, то имеем такую картину:

                   1  2  3  4  5  6  7  8  9
                   2  4  6  8  0  2  4  6  8
                   3  6  9  2  5  8  1  4  7
                   4  8  2  6  0  4  8  2  6
                   5  0  5  0  5  0  5  0  5
                   6  2  8  4  0  6  2  8  4
                   7  4  1  8  5  2  9  6  3
                   8  6  4  2  0  8  6  4  2
                   9  8  7  6  5  4  3  2  1

            
    То есть  периоды идут  в обоих  направлениях, как  ни крути.  И вот  что
    сильно бросается  в глаза,  так это  то, что  периоды чисел,  стоящих на
    противоположних сторонах  от центра  (которым является  пятёрка), строго
    противоположны друг другу. Поясню: в столбце 3 числа идут вниз в порядке
    обратном порядку  чисел, стоящих  в столбце  7. А  вот пятёрка  является
    центром, ведь у нас всего  девять цифр. Тут у кого-то  возникнет вопрос:
    Ну  и нахуя  надо было  тратить время  на ЭТО??  Так вот,  теперь  самое
    главное: Это справедливо для ЛЮБОЙ системы счисления, и чем она  больше,
    тем  интереснее рисунок,  который образуют  числа (должен отметить,  что
    я взял десятичную систему как базу, таким образом в матрице с основанием
    11 будет присутствовать ЦИФРА 10).
    Внимание!!!   Сделайте консоль  больших размеров  (~ 300х300,  это чтоб
    строки не переносились)  и  запустите пример с БОЛЬШИМ  числом, например
    128 (layer=1). Дальше понимайте как хотите.       
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int *mtx(int dim, int *array);
int *mtx2(int dim, int *array);
int *mtx3(int dim, int k, int *array);  // !!!!! здесь 3 аргумента

int realshit[1000][1000];

void main()
{
    int *shit = &realshit[0][0];
    int i, j, b, num;
    int layer;
    char buffie[256];
    printf("Radix: ");
    gets(buffie);
    b = atoi(buffie);
    printf("Layer: ");
    gets(buffie);
    layer = atoi(buffie);
    if((mtx3(b, layer, shit)) == NULL) exit(0);
    printf("*** Matrix based on %d:\n", b);
    for(i=0;i<=((b-2)*3);i++) printf("-");
    printf("\n");
    for(i=0;i<(b-1);i++)
    {
        for(j=0;j<(b-1);j++) 
        {
            num = shit[i*(b-1) + j];
            printf("%3d", num);
        }
        printf("\n");
    }
    for(i=0;i<=((b-2)*3);i++) printf("-");
    printf("\n");
}

//-------------------------------------------------------------------------------
/*
    Сей бред представляет собой не что иное как УПРОЩЕННЫЙ АЛГОРИТМ  ДЕЛЕНИЯ
    В СТОЛБИК: за счет деления на последнюю цифру в некой системе  счисления
    (F для шестнадцатеричной,  9 для десятичной  итд) мы оперируем  довольно
    малыми числами  (ну, если  конечно не  брать базу  больше предела  int).
    Кстати, тут местами теряется единица, то есть  некоторые противоположные
    цифры отличаются ровно  на 1. Но  тем не менее  это не портит  картинку.
    ОЧЕНЬ КРИВО, но как ни странно работает, не трогаю ничего больше
    так как я заебался отлаживать.
    
    ПОЯСНЕНИЕ:
    Можете не вникать в алгоритм, это совсем не нужно. Это была самая первая
    реализация.  Всё  заключалось  в делении  111111111  (девяти  единиц) на
    девять, затем 222222222 на девять итд:

    111111111 / 9 = 12345679  \           1 2 3 4 5 6 7 9
    222222222 / 9 = 24691358   \          2 4 6 9 1 3 5 8
    333333333 / 9 = 37037037    \         3 7 0 3 7 0 3 7
    444444444 / 9 = 49382716     \____    4 9 3 8 2 7 1 6
    555555555 / 9 = 61728395     /        6 1 7 2 8 3 9 5
    666666666 / 9 = 74074074    /         7 4 0 7 4 0 7 4
    777777777 / 9 = 86419753   /          8 6 4 1 9 7 5 3
    888888888 / 9 = 98765432  /           9 8 7 6 5 4 3 2

    Число 999999999 мы не берём, так как результат очевиден == 111111111.
    Обратите внимание, что числа делятся нацело на девять.
    Попытаюсь сформулировать:
    Возьмём систему счисления b. Для записи чисел используются цифры от 1 до
    b-1 и 0. Тогда числа представленные как 
    {x / x = n*(b^(0) + b^(1) + b^(2) + ... + b^(b-2)) && n Э [1;b-2]}
    будут делиться на b-1 без остатка и результат составит нашу матрицу.
*/
int *mtx(int dim, int *array)
{
    const unsigned int max_dec=10;  //не надо этого здесь, не будет запятой
    unsigned limit;        //последняя цифра системы
    unsigned pos;        //позиция в делимом
    unsigned row;        //строка матрицы
    unsigned col;        //столбец матрицы (он же - цифра)
    unsigned num;        //рабочиее число
    unsigned mod;        //остаток при поразрядном делении

    if(dim < 3) return NULL;   //если нас хотят наебать
    limit = dim - 1;
    for(row = 1; row < limit; row++)  //для каждого числа системы
    {
        pos = 1;    //макс. выводимых цифер
        num = row;  //цифра-номер строки
        col = 0;
        while(pos <= (limit + max_dec))  //движемся по номеру слева направо
        {
            if(num < limit) //если текущее число меньше делителя
            {
                num = num * dim + row;  //приписали номер слева
                if((col != 0) && (num < limit))  //если не первая цифра результата, то пишем 0
                {
                    array[(row - 1) * (dim - 2) + col++] = 0;
                    pos++;  //следующий разряд
                }                
                continue;
            }
            pos++;  //следующий разряд
            array[(row - 1) * (dim - 2) + col++] = num / limit;  //записать рез.и продвинуть указатель
            if(((mod = num % limit) == 0) && (pos >= limit)) break;  //если остаток=0 и все цифры поделены, то стоп
            num = mod;  //а теперь делимое равно остатку от предыдущего деления
        }
    }
    return array;
}

//-------------------------------------------------------------------------------
/*
    А  здесь  я  допёр,  что   не  надо  ничего  делить,  всё   равно  числа
    распределятся по матрице с  одинаковой частотой, поэтому просто  берутся
    периоды последней цифры последовательностей.
    Кстати, эта схема уравновешена со всех сторон.
*/
int *mtx2(int dim, int *array)
{
    int i, j, base=dim, n;
    for(i=1;i<=(base-1);i++)
    {
        n=i;
        for(j=1;j<=(base-1);j++) 
            array[(i-1)*(base-1)+j-1] = (n*j) % base;
    }
    return array;
}
//-------------------------------------------------------------------------------
/*
    Это та  же самая  матрица, только  мы еще  смотрим и  плоскость или срез
    куба, образованного добавлением еще одного измерения к матрице, то  есть
    теперь:
    1 2 3 4 5 6 7 8 9
    растёт не только вниз, но и "внутрь".
*/
int *mtx3(int dim, int k, int *array)
{
    int i, j, base=dim;

    for(i=1;i<=(base-1);i++)
        for(j=1;j<=(base-1);j++) 
            array[(i-1)*(base-1)+j-1] = ( ( (i * k) % base ) * j ) % base;
    return array;
}
