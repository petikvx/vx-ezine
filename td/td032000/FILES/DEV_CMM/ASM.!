Небольшое введение в асм i8086,для тех кто его не знает.

 P.S. С помощью этой статейке вы программить на асм'е не будете,но будете
	представлять что такое регистры,как работает проц и тп.

 P.S.S. Для большего понимания,вы должны знать что такое шестнадцатеричная
	система. :) Это когда в одной "десятке" не десять значений а 16.
	Таблица символов:0123456789ABCDEF
	Обозначение:	Си	=	0x????
			Pascal	=	$????
			ASM	=	????h
		где ???? - некоторое 16ричное число
	Примеры:	10h	=	16
			 7h	=	 7
			0Ah	=	10

 И так. У процессора есть 8 регистров (представляйте это как переменные длиной
16 бит - слово (word)). Они называются AX,BX,CX,DX,SI,DI,BP,SP.
 Этим регистрам можно присваивать что угодно,складывать,умножать и тп.
 Есть память. В ней можем хранить переменные которые не помещаются в 
 регистрах и тп. Обращатся к ячейке памяти можно как напрямую указав адрес
(16 битный) так и через регистры.
 Отлично. Сколько значений может принять переменная размером в слово ? 
65536 значений. Значит максимальное количество ячеек - 65536. А даже во всех
XT'шках стояло как минимум 256k. Как же тогда получить доступ к памяти за
пределом 65k ? Вот и придумали инженеры iNTEL сегментацию памяти(а может и у
кого-то содрали ?). У i8086 (и выше) есть четыре дополнительных регистра
ES,DS,SS и CS. В данных регистрах нельзя делать никаких арифметических операций-
только присваивание и чтение. Вся аддресация в i8086 идет просто - берется
значение сегментного регистра,умножается на 16 и добавляется к получившемуся
числу смещение ячейки. Записывается это так Сегмент:Смещение.
 Пример:
	1. Есть ячейка 10h от начала памяти. Логично что ее смещение = 16 :)
	Так вот к ней можно обратится двумя способами:
		0:16		-	Сегмент 0,смещение 16
	или	1:0		-	Сегмент 1,смещение 0
		Умножив 1 на 16 и добавив 0 мы получим туже самую ячейку (16).
	2. Есть ячейка 10001h от начала памяти. Ее смещение 65536
	Для обращения к ней мы должны установить сегментный регистр так,
	что-бы с помощью смещения можно было "достать" до данной ячейки.
	Естесвенно 0:10001h не покатит,так как смещение не влезет в 16 бит.
	Делаем просто: делим (в уме естественно :) смещение на 16 и целая
	часть от деления идет в сегментный регистр,а остаток в смещение.
	Вот и получили:
		1000h:1
 Если отнять от сегмента n(некоторое число) и добавить к смещению n*16
 и если n*16 не превышает 65536,то получившийся аддрес тоже указывает
 на эту-же ячейку... Пример: 1000h:1 = 0FFFh:17
 Сегмент (эти 16 байт) так-же называют параграфом. Дальше вместо употребления
слово "ячейка" я буду говорить "по адресу".

 Есть такой регистр,называется он IP. К нему нельзя обратится напрямую. Он
выполняет самую значительную роль среди всех регистров - хранит смещение
текущей выполняемй комманды. А сегментный регистр СS (его можно только читать)
хранит текущий сегмент в котором выполняется код.

С памятья разобрались. Движимся к стеку. Вероятно все слышали что это такое.
Так что-же это такое на самом деле: есть сегментный регистр SS и регистр SP.
SS:SP указывают куда-то (чаще всего на свободную область памяти). Естественно
мы можем сохранить что-то по адресу SS:SP,а потом это от туда взять. Стек
работает по принципу FILO - First In,Last Out (первый зашел,последним вышел)
или LIFO - Last In,Fist Out :),кому как больше нравится.
Есть такие две комманды: push и pop. Собственно они являются основными 
коммандами по работе со стеком. У них может быть различный параметр (но только
один) - регистр,некая переменная в памяти и тп. Когда вы что-то сохраняете в
стеке с помощью PUSH,то по смещению SS:SP ложится то значение,которое
хотели сохранить и SP уменьшается на размер сохраняемого значения. Тоесть при 
следующем PUSH ваше старое значение сохранится. Отлично. Делаем POP - SP 
увеличивается на размер переменной,и берется значение по адресу SS:SP. 
Следовательно возвращается значение которое было занесено в стек. 
	Примеры: (Во всех примерах SP = 20)
	1.

		mov ax,1234h	; AX = 1234h
		push ax		; Заносит в стек AX (1234h). SP = 18
		pop  bx		; Берем из стека число и ложим его в BX. SP = 20
				; В результате BX = 1234h


	2.	

		push ax		; Заносим в стек AX. SP = 18
		push bx		; Заносим в стек BX. SP = 16
		pop  ax		; Берем из стека AX. SP = 18
		pop  bx		; Берем из стека BX. SP = 20
		 Что-же делает этот кусочек ? Просто меняет местами значения
		 AX и BX.

Вот и со стеком разобрались. Возвращаемся к CS и IP. Естественно,что можно 
сделать,если в программе нет ветвлений ? У i8086 есть около двадцати комманд
которые изменяют (косвенно) значение IP. Вспоминаем Basic(кто его еще помнит).
Была там такая комманда Goto. С помощью нее можно было перепрыгивать ненужный
нам код и тп. Так вот сделана она по подобию комманды процессора Jmp. 
(от слова Jump). У Jmp один аргумент - аддрес прыжка. Когда выполняется
данная комманда,процессор берет аддрес и присваеват IP взятому значению.
	Пример:
		; Предположим что IP = 0
		jmp 1234h
		; Тепер IP = 1234h
 Естественно все несовсем так,но если уж совсем надо асм учить,ищите книгу
(хоть 86 года) или ищите в сети более подробные мануалы.
 Снова вспоминаем Бейсик. Были так такие комманды GoSub и Return. Сделаны они
опять по подобию ASM'a,только в ASM'e они называются Call и Ret.
 Как и для Jmp,Call принимает один параметр - аддрес назначения. Когда 
вызывается Call,в стек заносится смещение следующей(!) после Call комманды и
IP делается равным заданному смещению. Ret же,берет из стека аддрес(величину)
и прыгает по взятому смещению,следовательно управление продолжается сразу
за коммнадой Call.
 Пример:

1. Пример как работает Call/Ret
    Смещение	Код				Стек
	0	Call 1234h			??
		.....		; Тут продолжение кода
	1234h	ret				3 ??
; Размер комманды Call 3 байта - 1 байт код и 2 байта смещение
	3	...				??

2. Псевдо Call
    Смещение	Код				Стек
	0	mov ax,7			??	; AX = 7
	3	push ax				??	; Сохраним в стеке AX
	4	jmp 1234h			7 ??	; Прыгаем на 1234h
		...
	1234h	ret				7 ??
; Ret берет со стека одное 16-битное число и прыгает по взятому значению
; Так как мы положили 7,то и IP станет = 7
	7	...					; Продолжение

3. Стандартный трюк получения своего смещения в памяти
	Предположим есть .com файл,и вирус дописываемся к нему в конец. У него
 есть некоторые данные,к которым он должен обращатся (они внутри вируса).
 Все отлично,но с разной жертвой местоположение данных будет менятся...Что-же
 делать ? Все просто:
	Call GetOfs		; Делаем Call на GetOfs
GetOfs:				; Так обозначаются метки в ASM исходниках
	pop  bp			; Возьмем смещение следующей комманды после Call
	sub  bp,offset GetOf	; Отнимем от BP смещение на данную комманду.
 В результате мы получим в BP число,которое является нашим смещением от начала
сегмента. Собственно нам больше ничего и не надо. 
 Разумеется есть меж-сегментные прыжки и тп,но все остальное уже сами...

P.S. Извините за грамматику :)

Deviator/HAZARD.
