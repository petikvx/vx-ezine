<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<base target="_self">
</head>

<body topmargin="0" leftmargin="0" bgcolor="#E7BE7B" link="#CC0000" vlink="#993300" alink="#FF9900">

<Table border="0" cellPadding="0" cellSpacing="0" width="100%">
        <Tr>
                <Td valign="top" height="33">
                        <Img src="../images/index_08.gif" width="6" height="33"></Td>
                <Td width="100%" background="../images/index_09.gif" valign="top" height="33">
            <img border="0" src="../images/kolesiko.gif" align="absmiddle" width="21" height="33"><font face="Arial" size="2"><b>
RSA для программиста
            </b> - 13:10 - <i>by z0mbie</i></font>
            </font></Td>
                <Td valign="top" height="33">
                        <Img src="../images/index_10.gif" width="10" height="33"></Td>
     </Tr>
     <Tr>
                <Td background="../images/index_17.gif">
            &nbsp;</Td>
                <Td width="100%" bgcolor="#E7BE7B">
            <font face="Courier" size="3">
<pre>
<h3 align=center>Введение</h3>

<p>Существует огромное количество реализаций алгоритма RSA, и еще больше
 написано на эту тему книг, описаний и статей.
 Так что в информации, приведенной здесь, нет ничего нового,
 а уж представлена она в гарантированно худшем виде, чем где-либо еще.
 Основное достоинство этого текста в том, что написан он для тех,
 кто хочет сочетать все возможности качественной криптосистемы
 с простотой ее реализации в своих собственных системных,
 а не в чужих прикладных программах.</p>

<h3 align=center>Алгоритм, в самых общих чертах</h3>

<p>Алгоритм из тех, что с открытым и секретным ключом.</p>

<p>То есть зашифровать сообщение может каждый, у кого есть открытый ключ,
 а расшифровать - только тот, у кого секретный.</p>

<p>Подписать сообщение может только владелец секретного ключа,
 а проверить подпись - владелец открытого.</p>

<p>Получить секретный ключ из открытого - можно,
 но при сегодняшних математических методах и аппаратных средствах,
 на решение этой задачи потребуется абсолютно
 неприемлемое время (много лет).</p>

<h3 align=center>Шифровка/расшифровка (теория)</h3>

<p>Основная фича в том, что алгоритм оперирует "большими" числами,
 то есть числами, состоящими из сотен бит.</p>

<p>Открытый ключ (public key) -- это числа e и m.
 (e от слова encrypt, шифровка)</p>

<p>Секретный ключ (secret key) -- числа d и m.
 (d от слова decrypt, расшифровка)</p>

<p>(иногда пишут {e,m} и {d,m} - на самом деле это ничего не значит)</p>

<p>Числа m и d - большие.
 Число e - маленькое, часто принимается равным 3, 9, 17, и т.п.
 Как видите, число m - одно и то же в обоих ключах (известно всем),
 а число e, зная m и d, обычно может быть легко найдено.
 Исходя из этого логично было бы считать m открытым ключом, а d секретным,
 но, так уж принято.</p>

<p>Согласно RSA, большое число x (причем x &lt; m)
 зашифровывается в y так:</p>
<br>y = (x ^ e) % m,
<br>а расшифровывается обратно так:
<br>x = (y ^ d) % m

<p>Здесь ^ означает возведение в степень,
 а % -- остаток от деления, иначе называемый модуль.
 (не путайте этот модуль с абсолютным значением, оно здесь
 вообще нигде использоваться не будет)
 Часто модуль записывается так: a = b (mod m).
 Читается как "а равно b по модулю m".
 Значок % используется в Си, 'x mod y' в Паскале,
 а 'x = y (mod m)' во всякой литературе.
 Например: 10 mod 3 = 1.</p>

<p>Но вернемся к шифровке.
 Откуда берется x -- понятно и ежу, это же и есть ваше исходное сообщение,
 только представленное в виде большого числа.
 А нахождение чисел m,d и e называется "генерация ключей".</p>

<h3 align=center>Генерация ключей (теория)</h3>

<p>Для генерации ключей можно использовать старое доброе досовское PGP 2.6.x
 с параметрами '-kg -d'. Сгенеренные числа m/d/e будут выданы на экран.
 Если вы твердо решили написать свою реализацию RSA, то лучше,
 оставив генератор ключей на потом, сразу приступайте к
 шифровке/расшифровке (подпрограмма modexp).</p>

<p>Итак, генерации RSA-ключей (чисел m/d/e) заключается в следующем:</p>

<ul>
<li>Найти большие простые числа p и q,
   длина произведения (сумма длин) которых (в битах)
   равна длине искомого RSA-ключа.
   Простые -- значит не имеющие делителей кроме единицы,
   например 7, 11, 23.
   Обычно длины p и q принимаются одинаковыми - например по 128 бит для
   256-битного ключа.
   Хотя есть и модификации алгоритма с существенно разными длинами p/q.</li>

<li>Число m принимается равным m = p * q</li>

<li>Выбирается число e, взаимно простое с произведением (p-1)*(q-1).
    Взаимно простое -- значит не имеющее общих делителей, кроме единицы.
     Так как числа p и q - простые, а значит - нечетные (ибо не делятся на 2),
   то (p-1)*(q-1) -- число четное, и, соответственно, e будет нечетным.
   При этом e не может быть равно 1, ибо тогда шифровка не имеет смысла,
   так что минимально допустимое е равно 3.
   <br>Обычно выбирают некоторое начальное e,
   и пробуют e, e+2, e+4, e+6 и т.п., до тех пор, пока
   числа e и (p-1)*(q-1) не окажутся взаимно простыми.
   Записывается это условие так:
   GCD(e, (p-1)*(q-1)) = 1,
   что равносильно
   GCD(e, p-1)=1 и GCD(e, q-1)=1.
   Здесь GCD (Greatest Common Divisor)
   есть не что иное как НОД (Наибольший Общий Делитель).</li>

<li>Число d вычисляется такое, что (e * d) mod ((p-1)*(q-1)) = 1.
    <br>Другими словами, d = modinv(e, (p-1)*(q-1)),
   <br>где modinv (modular inverse) -- специальная хитрая функция.</li>
</ul>

<p>Собственно на этом генерация ключей кончается.</p>

<p>Вникнув в алгоритм, можно видеть, что именно числа p и q
 и составляют самую секретную фишку. Вы скажете: но ведь m=p*q публикуется?
 Да. Именно в эффективном алгоритме разложения m на p и q и состоит хак.</p>

<h3 align=center>Более быстрая расшифровка</h3>

<p>Обычно расшифровку x = (y ^ d) % m заменяют чуть более сложным,
 но и более быстрым алгоритмом:</p>
<pre><font color=#000055>
 u = modinv(p, q)                -- u,dp,dq -- могут быть вычислены заранее,
 dp = d % (p-1)                  -- при генерации ключей
 dq = d % (q-1)                  --

 a = ((x % p) ^ dp) % p
 b = ((x % q) ^ dq) % q
 if (b &lt; a) b += q
 y = a + p * (((b - a) * u) % q) -- CRT (Chinese Remainder Theorem)
</font></pre>

<p>Почему алгоритм более быстрый?
-- потому, что оперировать приходится более короткими числами,
и в результате производится меньше операций.
Хотя, признаюсь, используя этот метод у меня получилось увеличить скорость
всего на 10% на C++.</p>

<h3 align=center>шифровка/расшифровка</h3>

<p>Прежде всего заметим, что большие числа у нас будут храниться в обычном
интелевском формате (младший бит/байт/... сначала).</p>

<h3 align=center>modexp()</h3>

<p>Теперь рассмотрим вопрос о возведении большого числа в степень:
<br>y = (x ^ e) mod m.
<br>Такая процедура обычно называется modexp.</p>

<p>Совершенно ясно, что показатель степени может быть очень большой,
и никто не собирается выполнять соответствующее количество умножений.
Вместо этого мы воспользуемся следующей формулой:
<br>x^(a + b) = x^a * x^b
<br>То есть будем рассматривать число e как степени двойки:
<br>пусть e = 32+8+1, тогда x^e = x^32 * x^8 * x^1.
<br>Кроме того, очевидно следующее:
<br>(a*b) % m = (a * (b % m)) % m = ((a % m) * b) % m = ((a % m) * (b % m)) % m
<br>Поэтому (x^(32+8+1)) % m может быть вычислено как
<br>(x^32 * ((x^8 * ((x^1) % m)) % m)) % m
<br>Откуда брать x^i (i-ю степень x) ? - в цикле умножать число x само на себя.
В результате алгоритм нашей подпрограммы будет выглядеть так:</p>

<pre><font color=#000055>
 y = 1                         -- результат, (x ^ e) % m
 i = 0                         -- номер текущего бита в показателе степени e
 t = x                         -- временная переменная, t = (x ^ i) % m
 while (1)                     -- повторять всегда, выход по break
 {
     if (e.getbit[i] == 1)     -- если i-й бит числа e установлен в 1
     {
         y = (y * t) % m       -- умножим результат на t = x ^ i
     }
     i = i + 1                 -- следующий бит
     if (i &gt; maxbit(e)) break  -- от 0 и до старшего бита e
     t = (t * x) % m           -- t = t * x, вычисляем следующую степень x^i
 }
</font></pre>

<p>Как видно, все, что делает процедура modexp() -- это вызывает процедуру
 modmult() -- выполняющую c = (a * b) % m -- N раз,
 где N&nbsp;=&nbsp;e.общее_число_бит&nbsp;+&nbsp;e.число_единичных_бит&nbsp;-&nbsp;1.</p>

<h3 align=center>modmult() - вариант 1</h3>

<p>Теперь рассмотрим процедуру modmult():
<br>c = (a * b) % m
<br>По аналогии с modexp()-ом, разложим b на степени двойки, т.е. воспользуемся формулой
<br>a * b = a * (... + b.bit[3]&lt;&lt;3 + b.bit[2]&lt;&lt;2 + b.bit[1]&lt;&lt;1 + b.bit[0]&lt;&lt;0),
<br>здесь &lt;&lt; означает shl, двоичный сдвиг влево, т.е. x &lt;&lt; y = x * (2^y)
<br>Кроме того, ясно, что:
<br>(a+b) % m = (a + (b % m)) % m = ((a % m) + b) % m = ((a % m) + (b % m)) % m
<br>Таким образом для b=32+8+1, (a * b) % m будет вычислено как
<br>((a&lt;&lt;5)%m + ((a&lt;&lt;3)%m + ((((a&lt;&lt;0)%m) % m)) % m)) % m
<br>Текущее значение a&lt;&lt;i вычисляется в цикле, последовательным сдвигом на 1.</p>
<pre><font color=#000055>
 c = 0                         -- результат, (a * b) % m
 i = 0                         -- номер текущего бита в множителе b
 t = a                         -- временная переменная, t = (x &lt;&lt; i) % m
 while (1)
 {
     if (b.getbit[b] == 1)     -- если i-й бит числа b установлен в 1
     {
//       с = (c + t) % m       -- добавим t = x &lt;&lt; i
         с = c + t             -- + t
         if (c &gt;= m) c = c - m -- % m
     }
     i = i + 1                 -- следующий бит
     if (i &gt; maxbit(b)) break  -- от 0 и до старшего бита множителя b
//   t = (t &lt;&lt; 1) % m          -- t=t*2, вычисляем следующую степень a&lt;&lt;i
     t = t &lt;&lt; 1                -- &lt;&lt; 1
     if (t &gt;= m) t = t - m     -- % m
 }
</font></pre>

<p>Вычисление модуля производится последовательным вычитанием m из c, каждый
 раз когда число с становится больше m. Это становится возможным из-за того,
 что длина числа c каждый раз увеличивается не больше чем на 1 бит
 (а значение - в 2 раза), и избавляет от необходимости выполнять нахождение
 остатка от деления после умножения.</p>

<h3 align=center>modmult() - вариант 2</h3>

<p>Здесь предлагается другой вариант, умножение столбиком.
 Такая процедура будет работать намного быстрее за счет встроенной в x86
 32-битной команды MUL.
 Кроме того, что в отличие от предыдущей процедуры потребуется в 32 раза
 меньше операций (т.к. оперируем двордами, а не битами),
 насколько я слышал, в x86 процессор заложен еще и так называемый алгоритм
 быстрого окончания, то есть умножение старших нулевых битов
 множимого/множителя не происходит.
 Практика показала, что этот вариант modmultа быстрее в 2 раза.</p>

<p>Вот как выглядит алгоритм умножения столбиком для двух больших чисел:
<br>c = (a * b) % m</p>

<p>1. Собственно умножение "столбиком": t = a * b
    Очевидно, что разрядность числа t (число бит) будет равно сумме бит
    чисел a и b, то есть при одинаковой длине последних, длина t будет
    вдвое больше.</p>
<pre><font color=#000055>
 t = 0                         -- произведение
 for i = 0 to maxdword(a)      -- от 0 и до последнего дворда множимого
 for j = 0 to maxdword(b)      -- от 0 и до последнего дворда множителя
 {
//   ...:t[i+j+2]:t[i+j+1]:t[i+j] += a[i] * b[j]
     EDX:EAX = a[i] * b[j]     -- умножение командой MUL
     k = i + j                 -- позиция с которой добавлять к произведению
     t[k  ] = t[k  ] + EAX
     t[k+1] = t[k+1] + EDX + CF
     while (CF)                -- добавляем, пока перенос
     {
         t[k+2] = t[k+2] + CF
         k = k + 1
     }
 }
</font></pre>

<p>2. вычисление остатка от деления</p>

<p>Это, конечно, плохо, но придется.
 Итак, сейчас мы имеем t = a * b, и надо посчитать c = t % m.</p>

<p>Вот алгоритм:</p>
<pre><font color=#000055>
 c = 0                         -- результат
 for i = maxbit(t) to 0        -- от старшего бита к младшему
 {
     c = c &lt;&lt; 1                -- сдвиг влево на 1 бит, shl
     c = c | t.getbit[i]       -- | значит OR, копируем i-й бит t в 0й бит c
     if (c &gt;= m) c = c - m     -- % m
 }
</font></pre>

<p>Идея алгоритма в том, что мы последовательно вычитаем из c
 m&lt;&lt;maxbit(t), ..., m&lt;&lt;i, ..., m&lt;&lt;2, m&lt;&lt;1, m</p>

<h3 align=center>сложение, вычитание, сравнение</h3>

<p>Эти операции над большими числами релизуются достаточно просто:</p>

<pre><font color=#000055>
 ; input: ESI=big a
 ;        EDI=big b
 ;        ECX=length in DWORDs
 ; output:CF
 ; action:b = b + a

 bn_add:       clc                     ; CF=0
 __cycle:      lodsd
               adc     eax, [edi]
               stosd
               loop    __cycle
               retn

 ; input: ESI=big a
 ;        EDI=big b
 ;        ECX=length in DWORDs
 ; output:CF
 ; action:b = b - a

 bn_sub:       clc                     ; CF=0
 __cycle:      lodsd
               sbb     [edi], eax
               lea     edi, [edi+4]
               loop    __cycle
               retn

 ; input: ESI=big a
 ;        EDI=big b
 ;        ECX=length in DWORDs
 ; output:CF==1 (jb) -- a &lt; b
 ;        ZF==1 (jz) -- a = b
 ;        CF==0 (ja) -- a &gt; b

 bn_cmp:
 __cycle:      mov     eax, [esi+ecx*4-4]
               cmp     eax, [edi+ecx*4-4]
               loopnz  __cycle
 __exit:       retn
</font></pre>

<h3 align=center>Генерация ключей: нахождение больших простых чисел p и q</h3>

<p>Заполняем число случайными значениями, и проверяем,
 является ли оно простым.
 Если не является, то увеличиваем число и проверяем еще раз.
 И так до тех пор, пока не задымит процессор.</p>

<p>Используется здесь такая оптимизация:
 начальное число выбирается нечетным, и затем увеличивается не на 1, а на 2.
 Это делается для того, чтобы заранее выбросить все четные
 (и соответственно, составные) числа.</p>

<p>Как узнать, является ли текущее число простым?</p>

<p>Есть два способа: быстрый, но ненадежный и медленный, но надежный.
 Используются оба.</p>

<p>Способ первый. "решето" (sieve).
 Используется, чтобы отсеять большинство составных чисел
 (т.е. не являющихся простыми).</p>

<p>Идея в следующем: делим тестируемое число p на сотню первых простых
 чисел. Если делится (остаток от деления равен нулю) - число составное.</p>

<p>На самом деле, конечно, никто не будет постоянно делить большое число
 на сотню простых, это очень долго.
 Поэтому производится следующая оптимизация:
 составляется таблица остатков remainder[] от деления начального значения
 тестируемого числа p на нашу сотню простых чисел prime[].
 Затем, при поиске простого числа, вместе с самим числом p увеличивается
 некоторое дельта-значение pdelta.
 И при поиске остатка от деления p на i-е простое число prime[i] вместо
 p в качестве делимого берется сумма pdelta+remainder[i].
 То есть, используется равенство
 <br>p % prime[i] = (pdelta + remainder[i]) % prime[i].
 <br>Следует это из уже рассмотренного выше правила:
 <br>(a + b) % m = (a + (b % m)) % m
 <br>Выигрыш в скорости получается за счет того, что в первом случае мы делили
 большое число на регистр, а теперь делим регистр на регистр.</p>

<p>Способ второй.
 Сюда подаются на проверку только числа, прошедшие предыдущую проверку.
 Используется так называемая теорема Ферма:
 для любого a, если (a ^ (p-1)) % p != 1, то x - число составное.
 В качестве a обычно пробуют числа 2,3,5,7.
 Как видим, здесь просто вызывается описанная раньше процедура modexp().</p>

<h3 align=center>Вычисление GCD</h3>

<p>Итак, вот мы сгенерили простые числа p и q.</p>

<p>Теперь перебираем e = 3,5,7,9,... пока GCD(e, (p-1)*(q-1)) не окажется
 равным единице.
 (можно начинать с любого другого значения числа e, обычно тройка используется
 из соображений максимальной скорости)</p>

<p>Как посчитать GCD(x,y)? - используя так называемый алгоритм Евклида</p>

<pre><font color=#000055>
 while (1)
 {
   if (y == 0) return x
   x = x % y
   if (x == 0) return y
   y = y % x
 }
</font></pre>

<p>Поскольку число x - большое, а y - обычный дворд, оптимизируем
 алгоритм так: первый раз считаем остаток от деления большого числа
 на дворд, а затем уже оперируем только двордами.
 Вычисление остатка от деления
 приведено в описании процедуры modmult() - 2.</p>

<h3 align=center>Вычисление modinv() (modular inverse)</h3>

<p>Процедура modinv(a,m) возвращает такое i (0&lt;i&lt;m), что (i*a) mod m = 1.
 Число a должно быть 0&lt;a&lt;m.</p>

<p>Вот ее алгоритм из исходников PGP 2.6.x: (genprime.c)</p>

<pre><font color=#000055>
 g[0] = m
 g[1] = a
 v[0] = 0
 v[1] = 1
 i = 1
 while (g[i] != 0)
 {
     g[i+1] = g[i-1] % g[i]
     y      = g[i-1] / g[i]
     t      = y * v(i)
     v[i+1] = v[i-1]
     v[i-1] = v[i-1] - t
     i      = i + 1
 }
 x = v[i-1]
 if (x &lt; 0) x = x + m
 return x
</font></pre>

<p>А вот алгоритм из каких-то других исходников:</p>

<pre><font color=#000055>
 b = m
 c = a
 i = 0
 j = 1
 while (c != 0)
 {
   x = b / c
   y = b % с
   b = c
   c = y
   y = j
   j = i - j * x
   i = y
 }
 if (i &lt; 0) i += m;
 return i
</font></pre>

<p>Если присмотреться, то можно понять, что обе процедуры по сути одинаковые.</p>

<p>Что все это значит, я пока не представляю. Какая-то хуйня.
 Хотя на ассемблер в конце концов переписалось и заработало ;-)</p>

<h3 align=center>Деление больших чисел</h3>

<p>В подпрограмме modinv() явно используется деление больших чисел.
 Как считать остаток от деления уже было показано, а теперь приведем
 процедуру считающую и частное и остаток вместе.</p>

<pre><font color=#000055>
 d = 0                         -- частное, d = x / y
 c = 0                         -- остаток от деления, c = x % y
 for i = maxbit(x) to 0        -- от старшего бита к младшему
 {
     d = d &lt;&lt; 1                -- сдвиг влево на 1 бит, shl
     c = c &lt;&lt; 1                -- сдвиг влево на 1 бит, shl
     c = c | x.bit[i]          -- | значит OR, копируем i-й бит x в 0й бит c
     if (c &gt;= y)
     {
         c = c - y             -- % y
         d = d | 1             -- вычли y из c, добавим 1 к d
     }
 }
</font></pre>

<h3 align=center>Еще что-нибудь про ассемблер</h3>

<p>Удобно оперировать битами в больших числах командами BT/BTS/BTR/BTC.
 Выглядит это так:</p>

<pre><font color=#000055>
 ebx = указатель на большое число в памяти
 ecx = номер бита

 bt  [ebx], ecx -- копировать бит в CF
 bts [ebx], ecx -- копировать бит в CF, затем установить бит (--&gt;1)
 btr [ebx], ecx -- копировать бит в CF, затем очистить бит (--&gt;0)
 btc [ebx], ecx -- копировать бит в CF, затем инвертировать бит
</font></pre>

<p>То же самое, но из обычных команд:</p>

<pre><font color=#000055>
 mov edx, ecx
 shr edx, 3
 and cl, 111b
 mov al, 1
 shl al, cl
 test [ebx+edx], al -- jz bit0, jnz bit1
 xor  [ebx+edx], al -- инвертировать бит
 or   [ebx+edx], al -- установить бит (--&gt;1)
 not  al
 and  [ebx+edx], al -- очистить (--&gt;0)
</font></pre>

<h3 align=center>сдвиг большого числа влево (x shl 1, x * 2)</h3>

<pre><font color=#000055>
 ; input: EDI=bignumber
 ;        ECX=length in DWORDs
 ; output:CF
 ; action:x = x shl 1

 bn_shl1:
 bn_sub:       clc                     ; CF=0
 __cycle:      rcl     dword ptr [edi], 1
               lea     edi, [edi+4]
               loop    __cycle
               retn
</font></pre>

<h3 align=center>Как происходит реальная шифровка</h3>

<p>В случае, когда длина сообщения подлежащего шифровке больше длины RSA-ключа
(длины числа m, в битах), сообщение разбивается на соответствующие блоки:
для каждого блока (числа x) должно соблюдаться условие x < m.
Можно например посчитать длину числа m в байтах и длину блоков принимать
на байт меньше, и т.п.</p>

<p>В этом случае может использоваться такая схема: посредством RSA шифруется только
первый блок (так как это относительно долго), а все последующие блоки
шифруются каким-нибудь более быстрым алгоритмом, но так, чтобы результат
расшифровки этих блоков зависел от расшифрованного первого блока.

<p>Можно, например, при помощи RSA шифровать некое начальное значение
хэш-буфера, а затем, последовательно изменяя этот буфер, шифровать им
собственно сообщение.</p>

<p>Перед шифровкой алгоритмом RSA данные рекомендуется зашифровывать с
использованием случайного элемента, по причине low-exponent attack.</p>

<h3 align=center>low-exponent attack</h3>

<p>Пусть некоторое сообщение x посылается e получателям, так, что
открытые ключи каждого из них {e,n1}, {e,n2}, {e,n3}, ...
<br>Хак заключается в восстановлении исходного сообщения, зная e
открытых ключей и e зашифрованных сообщений.</p>

<p>Пусть e = 3, x -- исходное сообщение, y1,y2,y3 -- зашифрованные сообщения,
n1,n2,n3 -- модули открытых ключей.
Тогда x^3 может быть найдено следующим образом:</p>

<pre><font color=#000055>
#define CRT(c1,c2,n1,n2)  (c1+n1*((modinv(n1,n2)*(c2-c1))%n2))

  x3 = CRT(CRT(y1,y2,n1,n2),y3,n1*n2,n3);
</font></pre>

<p>Вычисление кубического корня из большого числа осуществляется простейшим
бинарным поиском:</p>

<pre><font color=#000055>
  x = 1;
  for (t = x3; t > 1; t = t / 2)
  {
    if (x*x*x < x3) x += t; else
    if (x*x*x > x3) x -= t; else break;
  }
</font></pre>

<p>Дабы такой атаки не происходило, часть сообщения x при каждой шифровке
выбирается случайным образом.</p>

<h3 align=center>В помощь изучающим исходники на английском</h3>

<p>Рекомендуются исходники от <a href="http://www.pgpi.com" target="_blank">PGP</a>. Там все понятно и с комментариями.</p>

<p>
<table border=0 width=100% cellspacing=0 cellpadding=0>
<tr><td>dividend</td>              <td>-- делимое</td></tr>
<tr><td>divisor</td>               <td>-- делитель</td></tr>
<tr><td>quotient</td>              <td>-- частное</td></tr>
<tr><td>remainder</td>             <td>-- остаток</td></tr>
<tr><td>multiplicand</td>          <td>-- множимое</td></tr>
<tr><td>multiplier</td>            <td>-- множитель</td></tr>
<tr><td>product</td>               <td>-- произведение</td></tr>
<tr><td>to raise to a power</td>   <td>-- возводить в степень</td></tr>
<tr><td>base</td>                  <td>-- основание (степени)</td></tr>
<tr><td>exponent</td>              <td>-- показатель (степени)</td></tr>
<tr><td>module, modulus</td>       <td>-- модуль. здесь - то же что и remainder</td></tr>
<tr><td>prime, prime number</td>   <td>-- простое число</td></tr>
<tr><td>sieve</td>                 <td>-- решето (мат. метод нахождения простых чисел)</td></tr>
<tr><td>Fermat's theorem</td>      <td>-- теорема Ферма: (a^(p-1))%p=1, если p-простое</td></tr>
</table>
</p>
<center>
 <a href="../files/rsa4.zip">rsa4.zip</a> - примеры к  статье.
</center>
</pre>
</font>
</Td>
                <Td background="../images/index_19.gif">
            &nbsp;</Td>
        </Tr>
        <Tr>
                <Td>
                        <Img src="../images/index_44.gif" width="6" height="9"></Td>
                <Td background="../images/index_45.gif" height="9">
            <img border="0" src="../images/spacer.gif" width="9" height="9"></Td>
                <Td>
                        <Img src="../images/index_46.gif" width="10" height="9"></Td>
        </Tr>
</Table>
<br>

</Table>
&nbsp;

</body>

</html>
