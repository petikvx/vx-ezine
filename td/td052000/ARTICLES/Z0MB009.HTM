<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
</head>

<body bgcolor="#B1B1B1" text="#000000" topmargin="0"
leftmargin="3">

<p><STYLE> </p>

<p>INPUT { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt
}</p>

<p>SELECT { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE:
8pt } </p>

<p>OPTION { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE:
8pt } </p>

<p>TEXTAREA { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE:
8pt } </p>

<p>FORM { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt
} <br>
BODY { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt } <br>
P { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt }
TABLE { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt
}TR { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt } TD
{ FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 10pt
}TEXTAREA { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE:
8pt } A { COLOR: #005500; TEXT-DECORATION: none }A:hover {
TEXT-DECORATION: underline } A:link { TE  XT-DECORATION: none
}A:visited { }text:unknown { FONT-SIZE: 8pt } } </STYLE> </p>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="100%"><div align="center"><center><table
        border="0" cellpadding="0" cellspacing="0" width="100%">
            <tr>
                <td width="100%" bgcolor="#000000"img
                src="-.gif" width="1" height="1"></td>
            </tr>
            <tr>
                   <td width="100%" bgcolor="#808080"><strong>22.05.2000</strong>
                    Описание INT 2E под Win9X
 <strong>[Z0mbie]</strong></td>
            </tr>
            <tr>
                <td width="100%" bgcolor="#000000"><img
                src="-.gif" width="1" height="1"></td>
            </tr>
            <tr>
                <td width="100%"><img src="-.gif" width="1"
                height="1"></td>
            </tr>
            <tr>
                <td width="100%" bgcolor="#000000"><img
                src="-.gif" width="1" height="1"></td>
            </tr>
            <tr>
                <td width="100%">
<h2>INT 2E services (VMM/NTKERN.VxD)</h2>
<p align=center>(x) 2000 Z0MBiE<br>http://z0mbie.cjb.net</p>

<h3 align=center>Содержание</h3>

<ul>
<li><a href=#x1>Введение</a>
<li><a href=#x2>Переход в RING-0</a>
   <ul>
   <li><a href=#x2a>PsCreateSystemThread</a>
   <li><a href=#x2b>PoCallDriver</a>
   </ul>
<li><a href=#x3>Работа с памятью</a>
   <ul>
   <li><a href=#x3a>RtlCopyMemory, RtlMoveMemory</a>
   <li><a href=#x3b>READ_REGISTER_BUFFER_UCHAR/ULONG/USHORT</a>
   <li><a href=#x3c>WRITE_REGISTER_BUFFER_UCHAR/ULONG/USHORT</a>
   <li><a href=#x3d>READ_REGISTER_UCHAR/ULONG/USHORT</a>
   <li><a href=#x3e>WRITE_REGISTER_UCHAR/ULONG/USHORT</a>
   </ul>
<li><a href=#x4>Работа с портами</a>
   <ul>
   <li><a href=#x4a>READ_PORT_BUFFER_UCHAR/ULONG/USHORT</a>
   <li><a href=#x4b>WRITE_PORT_BUFFER_UCHAR/ULONG/USHORT</a>
   <li><a href=#x4c>READ_PORT_UCHAR/ULONG/USHORT</a>
   <li><a href=#x4d>WRITE_PORT_UCHAR/ULONG/USHORT</a>
   </ul>
<li><a href=#x5>Процессы и нити</a>
   <ul>
   <li><a href=#x5a>IoGetCurrentProcess, PsGetCurrentProcess</a>
   <li><a href=#x5a>KeGetCurrentThread, PsGetCurrentThread</a>
   </ul>
<li><a href=#x6>Прочие функции</a>
   <ul>
   <li><a href=#x6a>KeQuerySystemTime</a>
   </ul>
<li><a href=#x7>Комментарии</a>
</ul>

<a name=x1>
<h3 align=center>Введение</h3>

<p>Рассмотрим некую Win32-программу.
  Как известно, программа эта вызывает kernel, а kernel уже вызывает ring-0.

<p>Под Win9X VMM/VWIN32 реализует специальные сервисы для kernelа.
  Вызываются они так:

<pre>
       kernel@int21:
  015F:BFF712B9  push    ecx
                 push    eax
                 push    002A0010    ; <-- service-number
                 call    kernel@ord0
                 ret
       kernel@ord0:
  015F:BFF713D4  mov     eax, [esp+4]
                 pop     dword ptr [esp]
                 call    far cs:[BFFC9734]
                 ...
  015F:BFF79734  dd      000003C8h   ; offset
                 dw      003Bh       ; selector
                 ...
  003B:03C8      int     30h
                 ...
</pre>

<p>где service-number -- номер сервиса, например 0x002A0010 для INT 21,
  0x002A0029 для INT 31, и так далее. Надо сказать, что с номерами
  VxD-callов эти сервисы не имеют ничего общего. Найти полный список
  соответствий всяких номеров именам сервисов можно в питреке.

<p>Под WinNT ноль вызывается из кернела посредством INT 2E.

<p>Но, как выяснилось, в маздае в VMMе существует NTKERN.VXD, коий
  реализует NT-евые сервисы. Называются они типа ntoskrnl!DbkBreakPoint  и
  вызываются так же -- через INT 2E.
  И, о чудо, у такого рулезного инта DPL=3, то есть его можно вызывать
  прямо из PE файла.
  Более того, в обработчике нет никаких хитрожопых проверок - типа
  откуда пришел вызов.

<p>Дальше-интереснее. Оказывается, INT 2E активно используется
  при загрузке маздая. А во  время работы  маздай может пользовать
  функции типа ntoskrnl!NtPowerInformation.

<p>Короче говоря, можно вызывать INT 2E из PE файлов одним из следующих
  способов:

<pre>
; 1.
        mov     eax, service-number
        lea     edx, stk
        int     2Eh

stk:    dd      param1
        dd      param2
        dd      param3
        ...
; 2.
        ...
        push    param3
        push    param2
        push    param1
        mov     edx, esp
        mov     eax, service-number
        int     2Eh
        add     esp, 4*n
</pre>

<p>Как видим, при вызове INT 2E в EAX должен быть номер сервиса,
  а в EDX указатель на кадр стэка.
  Перед тем как вызвать соответствующую функцию, обработчик инта
  копирует данные из *EDX в свой стэк.

<p>Список всех номеров и имен функций лежит в <a href="ntoskrnl.inc">ntoskrnl.inc</a>

<p>Далее идут описания некоторых наиболее интересных функций INT 2E.

<a name=x2>
<h3 align=center>Переход в RING-0</h3>

<a name=x2a>
<p><big>PsCreateSystemThread</big>

<p>Тут все и так ясно. Создаем нить прямо в нуле. При выходе из нити (по RET)
она автоматически убивается ф-цией PsTerminateSystemThread.

<pre>
                        ...
                        mov     eax, i2E_PsCreateSystemThread
                        lea     edx, stk
                        int     2Eh

__cycle:                cmp     r0_finished, 1
                        jne     __cycle
                        ...

stk:                    dd      offset thread_handle ; 0 or *thread_handle
                        dd      0               ; 0 or 0x1F03FF
                        dd      0               ; 0
                        dd      0               ; 0
                        dd      0               ; 0
                        dd      offset ring0    ; thread EIP, near proc
                        dd      12345678h       ; thread-parameter

; input: [ESP+4]=EDI=thread_parameter

ring0:                  int 3
                        mov     r0_finished, 1
                        ret
</pre>

<a name=x2b>
<p><big>PoCallDriver</big>

<p>Никакими драйверами тут и не пахнет. Эта функция просто передает
управление (в нуле) туда, куда ей скажут.
Единственный минус -- ей надо уж очень по-изъебски передавать параметры.
Кадр стэка выглядит так:

<pre>
stk                     dd      offset x1
                        dd      offset x2
x1                      db      8 dup (0)
                        dd      offset x3
x2                      db      60h dup (0)
                        dd      offset x4+24h
x4                      db      18h dup (0)
x3                      db      38h dup (0)
                        dd      ring_0
</pre>

<p>А реальный код, коий я по возможности соптимизировал, такой:

<pre>
                        lea     esi, r0proc
                        call    callring0
                        ...
r0proc:                 int 3
                        ret

; subroutine: callring0
; input:      ESI=offset ring_0, proc NEAR

callring0:              pusha
                        call    @@X
                        pusha
                        call    dword ptr [ecx]
                        popa
                        ret     8
@@X:                    sub     esp, 14h
                        xor     eax, eax
                        push    eax
                        lea     edx, [esp+24h]
                        push    edx
                        sub     esp, 54h
                        lea     edx, [esp+38h]
                        push    edx
                        push    edx
                        push    esi
                        mov     edx, esp
                        push    edx
                        push    edx
                        mov     edx, esp
                        mov     al, i2E_PoCallDriver
                        int     2Eh
                        popa
                        add     esp, 88h-20h
                        popa
                        ret
</pre>

<a name=x3>
<h3 align=center>Работа с памятью</h3>

<p>Эти функции подразумевают работу с памятью через нулевое кольцо.
Это значит, что вы из третьего кольца передаете параметры, а
в нуле производятся чтение/запись памяти. Таким образом можно читать/писать
в защищенную в третьем кольце память, например в kernel.

<p>Причем для работы с памятью из нуля существует просто охуительное
количество всяких функций, включая всякие InterlockedIncrement'ы и
функции для работы со строками, юникодными и не очень.

<a name=x3a>
<p><big>RtlCopyMemory, RtlMoveMemory</big>

<p>Отличаются эти две функции тем, что RtlCopyMemory просто берет и
копирует буфера командой movs,
а RtlMoveMemory сначала анализирует esi и edi, а потом копирует буфер по
одному байту, причем начиная либо с начала либо с конца буфера.
Таким образом RtlMoveMemory корректно обработает перекрывающиеся области
esi...esi+ecx и edi...edi+ecx.

<pre>
                        mov     eax, i2E_RtlCopyMemory  ; or RtlMoveMemory
                        lea     edx, stk
                        int     2Eh
                        ...
stk:                    dd      0BFF7xxxxh      ; edi (destination)
                        dd      offset vir_code ; esi (source)
                        dd      vir_size        ; ecx (length in bytes)
</pre>

<a name=x3b>
<p><big>READ_REGISTER_BUFFER_UCHAR/ULONG/USHORT</big>

<p>Реализации команд REP MOVSB, REP MOVSD и REP MOVSW соответственно.

<pre>
                        push    ecx
                        push    edi
                        push    esi
                        mov     edx, esp
                        mov     eax, i2E_READ_REGISTER_BUFFER_ULONG
                        int     2Eh
                        add     esp, 3*4
</pre>

<a name=x3c>
<p><big>WRITE_REGISTER_BUFFER_UCHAR/ULONG/USHORT</big>

<p>Аналогично предыдущим: REP MOVSB, REP MOVSD и REP MOVSW,
НО источник и приемник поменялись местами.

<pre>
                        push    ecx
                        push    esi
                        push    edi
                        mov     edx, esp
                        mov     eax, i2E_WRITE_REGISTER_BUFFER_ULONG
                        int     2Eh
                        add     esp, 3*4
</pre>

<a name=x3d>
<p><big>READ_REGISTER_UCHAR/ULONG/USHORT</big>

<p>Считать BYTE/DWORD/WORD.
(MOV AL,[ESI], MOV EAX,[ESI] и MOV AX,[ESI])
Значение возвращается в EAX.

<pre>
                        push    esi
                        mov     edx, esp
                        mov     eax, i2E_READ_REGISTER_UCHAR
                        int     2Eh
                        add     esp, 1*4
</pre>

<a name=x3e>
<p><big>WRITE_REGISTER_UCHAR/ULONG/USHORT</big>

<p>Записать BYTE/DWORD/WORD.
(MOV [EDI],AL, MOV [EDI],EAX и MOV [EDI],AX)

<pre>
                        push    eax
                        push    edi
                        mov     edx, esp
                        mov     eax, i2E_WRITE_REGISTER_UCHAR
                        int     2Eh
                        add     esp, 2*4
</pre>

<a name=x4>
<h3 align=center>Работа с портами</h3>

<a name=x4a>
<p><big>READ_PORT_BUFFER_UCHAR/ULONG/USHORT</big>

<p>Выполнить REP INSB, REP INSD и REP INSW соответственно.

<pre>
                        push    ecx
                        push    edi
                        push    edx
                        mov     edx, esp
                        mov     eax, i2E_READ_PORT_BUFFER_ULONG
                        int     2Eh
                        add     esp, 3*4
</pre>

<a name=x4b>
<p><big>WRITE_PORT_BUFFER_UCHAR/ULONG/USHORT</big>

<p>REP OUTSB, REP OUTSD и REP OUTSW

<pre>
                        push    ecx
                        push    esi
                        push    edx
                        mov     edx, esp
                        mov     eax, i2E_WRITE_PORT_BUFFER_ULONG
                        int     2Eh
                        add     esp, 3*4
</pre>

<a name=x4c>
<p><big>READ_PORT_UCHAR/ULONG/USHORT</big>

<p>Выполнить IN AL,DX, IN EAX,DX и IN AX,DX соответственно.

<pre>
                        push    edx
                        mov     edx, esp
                        mov     eax, i2E_READ_PORT_ULONG
                        int     2Eh
                        add     esp, 1*4
</pre>

<a name=x4d>
<p><big>WRITE_PORT_UCHAR/ULONG/USHORT</big>

<p>OUT DX,AL, OUT DX,EAX и OUT DX,AX.

<pre>
                        push    eax
                        push    edx
                        mov     edx, esp
                        mov     eax, i2E_WRITE_PORT_UCHAR
                        int     2Eh
                        add     esp, 2*4
</pre>

<a name=x5>
<h3 align=center>Процессы и нити</h3>

<a name=x5a>
<p><big>IoGetCurrentProcess, PsGetCurrentProcess</big>

<p>Обе функции указывают на один и тот же обработчик. Хендл текущего
процесса возвращается в EAX.

<pre>
                        mov     eax, i2E_IoGetCurrentProcess
                        int     2Eh
</pre>

<p>Обработчик GetCurrentProcess'а изнутри реализует следующее:

<pre>
                        call    ntoskrnl!KeGetCurrentThread
                        mov     eax, [eax+4]
                        ret
</pre>

<a name=x5b>
<p><big>KeGetCurrentThread, PsGetCurrentThread</big>

<p>Опять один и тот же обработчик. Хендл текущей
нити возвращается в EAX.

<pre>
                        mov     eax, i2E_KeGetCurrentThread
                        int     2Eh
</pre>

<a name=x6>
<h3 align=center>Прочие функции</h3>

<a name=x6a>
<p><big>KeQuerySystemTime</big>

<pre>
                        push    offset systime
                        mov     edx, esp
                        mov     eax, i2E_KeQuerySystemTime
                        int     2Eh
                        add     esp, 4
                        ...
systime                 dq      ?
</pre>

<a name=x7>
<h3 align=center>Коментарии</h3>

<p>Совершенно непонятно как обстоит дело с функциями для работы с файлами.
(IoCreateFile, NtCreateFile, ZwCreateFile, ZwReadFile, ZwWriteFile,
DeviceIoControlFile, etc.)
Я слышал, есть книжка про недокументированные возможности WinNT.
Но те параметры, которые там описаны для соответствующих функций, передаются
из программы в кернел, а ведь из кернела в ноль передаются уже совсем
другие вещи, даже число параметров не совпадает. Ну а трассировать
обработчик CreateFile выясняя все его 11 хитроизъебских параметров --
как-то лениво.

<p>Существуют также функции для работы с registry.
(RtlDeleteRegistryValue, RtlQueryRegistryValues, RtlWriteRegistryValue,
IoOpenDeviceInterfaceRegistryKey, IoOpenDeviceRegistryKey,
может быть -- ZwCreateKey, ZwDeleteKey, ZwEnumerateKey, ZwEnumerateValueKey,
ZwOpenKey и т.п.)
Этих функция я не проверял, но они явно показывают на какой-то нормальный
код и могут быть вызваны.

<p>Большинство функций, для которых не указано число параметров (в
<a href="../files/ntoskrnl.zip">ntoskrnl.inc</a> написан '-'),
являются ВНУТРЕННИМИ, то есть параметры им передаются,
но не на стэке а в регистрах, и вызвать их, минуя похеривание
регистров в обработчике INT 2E нет никакой возможности.
Обычно эти функции написаны полностью маленькими буквами или
начинаются с подчеркивания, типа memmove, memset, qsort, rand, sprintf,
_except_handler2, _global_unwind2 и т.п.

<p align=center>* * *</p>

<p>см. также примеры в <a href="../files/ntoskrnl.zip">ntoskrnl.zip</a>

<p align=right>(c) 1999 Z0MBiE, <i><a href="http://z0mbie.cjb.net">z0mbie.cjb.net</a></i></p>

<a href="http://topdev.tsx.org"> Статья для журнала Top Device</a>     
               
                 </td>
            </tr>
            <tr>
                <td width="100%" bgcolor="#000000"><img
                src="-.gif" width="1" height="1"></td>
            </tr>
            <tr>
                <td width="100%"><img src="-.gif" width="1"
                height="1"></td>
            </tr>
            <tr>
                <td width="100%" bgcolor="#000000"><img
                src="-.gif" width="1" height="1"></td>
            </tr>
            <tr>
                <td>&nbsp;</td>
            </tr>
        </table>
        </center></div></td>
        <td>&nbsp;</td>
    </tr>
</table>

<p>&nbsp;</p>
</body>
</html>
