<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
</head>

<body bgcolor="#B1B1B1" text="#000000" topmargin="0"
leftmargin="3">

<p><STYLE> </p>

<p>INPUT { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt
}</p>

<p>SELECT { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE:
8pt } </p>

<p>OPTION { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE:
8pt } </p>

<p>TEXTAREA { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE:
8pt } </p>

<p>FORM { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt
} <br>
BODY { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt } <br>
P { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt }
TABLE { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt
}TR { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 8pt } TD
{ FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE: 10pt
}TEXTAREA { FONT-FAMILY: Tahoma, sans-serif, arial; FONT-SIZE:
8pt } A { COLOR: #005500; TEXT-DECORATION: none }A:hover {
TEXT-DECORATION: underline } A:link { TE  XT-DECORATION: none
}A:visited { }text:unknown { FONT-SIZE: 8pt } } </STYLE> </p>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="100%"><div align="center"><center><table
        border="0" cellpadding="0" cellspacing="0" width="100%">
            <tr>
                <td width="100%" bgcolor="#000000"img
                src="-.gif" width="1" height="1"></td>
            </tr>
            <tr>
                   <td width="100%" bgcolor="#808080"><strong>8.06.2000</strong>
                   ПОМЕХОЗАЩИЩЕННЫЕ ВИРУСЫ
 <strong>[Z0mbie]</strong></td>
            </tr>
            <tr>
                <td width="100%" bgcolor="#000000"><img
                src="-.gif" width="1" height="1"></td>
            </tr>
            <tr>
                <td width="100%"><img src="-.gif" width="1"
                height="1"></td>
            </tr>
            <tr>
                <td width="100%" bgcolor="#000000"><img
                src="-.gif" width="1" height="1"></td>
            </tr>
            <tr>
                <td width="100%">

<p>Когда    большинство   вирусов   было   бутовыми,   когда   обновлялся
 аидстестовский  вирлист,  лозинский еще не впал в маразм, а касперский еще
 только сосал не причмокивая... Жил-был вирус, и как только он не назывался
 - Doodle, Yankee, Music, и еще хрен знает как.
<p>И   была  в  том  вирусе  фича,  а  именно  -  коли  патчил  в  вирусе
 бедняга-программист  какой  байт,  так  байт этот на место возвращался. То
 есть становился обратно, как был.
<p>И  с  тех  пор мучают вирмэйкеры себя и людей, доставая их вопросами -
 как же енто он, проклятый, восстанавливается, не делая второй своей копии?
<p>Интуитивно  ясно,  что  внесение  избыточности  в информацию позволяет
 находить и восстанавливать помехи. Пример тому - избыточность естественных
 языков.  Сколько  избыточности вносить и как ее считать, можно прочитать у
 Шеннона.
<p>Мы, вирмэйкеры, люди простые, нам Шеннон ни к чему, всякие там теоремы
 мы   вообще   знать   не   желаем,  и  поэтому  требуется  простой  способ
 восстанавливать вирус после патча.
<p>Итак,  представляем  защищаемый блок данных в виде матрицы. По каждому
 столбцу  и каждой строке матрицы считаем контрольную сумму, попросту XORим
 байты один на другой.
<p>Теперь   представим,   что   изменился   один  байт.  Тогда  изменятся
 контрольные   суммы  соответствующих  столбца/строки  матрицы,  своими
 номерами указывая координаты байта.
<p>Вот и все. Максимальное количество восстанавливаемых подряд байт равно
 числу столбцов. Количество строк и столбцов выбирается как вам удобнее.
<p>Конечно, можно попросту хранить вторую копию вируса. Но ее будет легко
 пропатчить. И вообще, это уже совсем другая байка.
<p>Кстати,  судя  по  всему  похожая фишка используется в RARе для защиты
 архивов  от глюков, для -rr1 число столбцов (длина строки) соответственно 512 байт - один
 сектор.
<p>Пример.
<p>Есть <font color=#008080>данные</font>, и есть
контрольные суммы <font color=#000080>по&nbsp;строкам</font> и
<font color=#0000FF>по&nbsp;столбцам</font>, посчитанные XORом.
Пусть байт <font color=#00FFFF>74</font> (jz) изменили на <font color=#00FFFF>EB</font> (jmp).
<pre>
  до изменения:               после изменения:

  <font color=#008080>90 90 90 90 90</font>   <font color=#000080>90</font>         <font color=#008080>90 90 90 90 90</font>   <font color=#000080>90</font>
  <font color=#008080>90 <font color=#00FFFF>74</font> 12 90 90</font>   <font color=#000080>F6</font>         <font color=#008080>90 <font color=#00FFFF>EB</font> 12 90 90</font>   <font color=#800000>69</font>
  <font color=#008080>90 90 90 90 90</font>   <font color=#000080>90</font>         <font color=#008080>90 90 90 90 90</font>   <font color=#000080>90</font>
  <font color=#008080>90 90 90 90 90</font>   <font color=#000080>90</font>         <font color=#008080>90 90 90 90 90</font>   <font color=#000080>90</font>

  <font color=#0000FF>00 E4 82 00 00</font>              <font color=#0000FF>00 <font color=#FF0000>7B</font> 82 00 00</font>
</pre>
<p>В результате изменятся два байта контрольных сумм - один в суммах <font color=#800000>по&nbsp;строкам</font> и  один
в суммах <font color=#FF0000>по&nbsp;столбцам</font>.
<br>Таким образом мы узнали координаты измененного <font color=#00FFFF>байта</font> в массиве <font color=#008080>данных</font>.
<br>Как вычислить старое значение байта?
- проXORить <font color=#0000FF>старую</font> контрольную сумму на <font color=#FF0000>новую</font> и на
новое значение байта.
<pre>
<font color=#000080>F6</font> xor <font color=#800000>69</font> xor <font color=#00FFFF>EB</font> = <font color=#00FFFF>74</font>, либо
<font color=#0000FF>E4</font> xor <font color=#FF0000>7B</font> xor <font color=#00FFFF>EB</font> = <font color=#00FFFF>74</font>.
</pre>

<p>Следующую мысль выражу кратко: если и здесь не понятно, то это пиздец.</p>

<table border=0 width=100% cellspacing=1 cellpadding=0 bgcolor=#A0A0A0>
<tr><th>Пример на C++
<tr>
<td>Примечание (для тех кто не знает C):<br>
<pre>
   с++           pascal
c = d ^ e;    c := d xor e;
a ^= b;       a := a xor b;
a++;          a := a + 1;
</pre>
<tr>
<td>
<pre>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define COLS 4                    <i>// число столбцов (x)</i>
#define ROWS 4                    <i>// число строк (y)</i>

void main()
{
  unsigned char a[ROWS][COLS];    <i>// массив данных</i>

  for (int y=0; y&lt;ROWS; y++)      <i>// заполним его всякой хуйней</i>
  for (int x=0; x&lt;COLS; x++)
    a[y][x]=random(256);

  unsigned char oy[ROWS]={0};     <i>// контрольные суммы: по строкам</i>
  unsigned char ox[COLS]={0};     <i>// по столбцам</i>

  for (int y=0; y&lt;ROWS; y++)      <i>// считаем контрольные суммы</i>
  for (int x=0; x&lt;COLS; x++)
  {
    oy[y]^=a[y][x];
    ox[x]^=a[y][x];
  }

  int y = random(ROWS);           <i>// пропатчим два рандомных байта</i>
  int x = random(COLS);           <i>// (они должны быть в одной строке)</i>
  int r = random(256);
  printf("randomizing a[%i][%i]: %02X --&gt; %02X\n", y,x, a[y][x], r);
  a[y][x] = r;
  x--;
  r = random(256);
  printf("randomizing a[%i][%i]: %02X --&gt; %02X\n", y,x, a[y][x], r);
  a[y][x] = r;

  unsigned char ny[ROWS]={0};     <i>// новые контрольные суммы</i>
  unsigned char nx[COLS]={0};

  for (int y=0; y&lt;ROWS; y++)      <i>// считаем и их</i>
  for (int x=0; x&lt;COLS; x++)
  {
    ny[y]^=a[y][x];
    nx[x]^=a[y][x];
  }

  for (int y=0; y&lt;ROWS; y++)      <i>// для каждого байта данных</i>
  for (int x=0; x&lt;COLS; x++)
    <i>// если не совпадают суммы по строкам и столбцам</i>
    if ((oy[y]!=ny[y])&&(ox[x]!=nx[x]))
    {
      printf("found error in a[%i][%i]\n", y,x);
      <i>// два варианта "старых" значений байта</i>
      int v1 = oy[y]^ny[y]^a[y][x];
      int v2 = ox[x]^nx[x]^a[y][x];
      printf(v1==v2?"correcting\n":"trying to correct\n");
      printf("%02X -&gt; %02X\n", a[y][x], v2);
      <i>// в качестве восстановленного байта используем оный посчитанный
      // при помощи суммы по столбцу (v2), так как вероятность изменения
      // нескольких байт подряд (т.е. в одной строке) больше</i>
      ny[y] ^= a[y][x] ^ v2; <i>// корректируем контрольные суммы в</i>
      nx[x] ^= a[y][x] ^ v2; <i>// соответствии с восстанавливаемым байтом</i>
      a[y][x] = v2;          <i>// восстанавливаем байт</i>
    }
} <i>// main</i>
</pre>
<tr><th>Результат работы программы:
<tr><td>
<pre>
randomizing a[3][3]: 51 --> A6
randomizing a[3][2]: FC --> 11
found error in a[3][2]
trying to correct
11 -> FC
found error in a[3][3]
correcting
A6 -> 51
</pre>
</table>

<p>Может возникнуть вопрос: какими должны быть изменения, чтобы подобный
метод не смог восстановить пропатченый байт?

<p>В основном такими:

<pre>
  00 00 00 00 00   nn   Нельзя определить, какие из указанных четырех байтов
  00 A  B  00 00   **   изменились: это могут быть A и D либо B и C,
  00 C  D  00 00   **   либо любые комбинации по 3 байта, либо все 4.
  00 00 00 00 00   nn
  00 00 00 00 00   nn

  nn ** ** nn nn
</pre>

<p>То есть такая схема подсчета контрольных сумм хорошо
работает только если изменения произошли в пределах одной строки/столбца.
Поэтому строки эффективно делать длиннее столбцов.

<p>Если вас заинтересовало помехозащищенное кодирование - ищите
линейный блоковый код, коды M из N, коды Хэмминга и тому подобную хрень.

<p align=center>* * *</p>

<p align=right>(x) 2000 Z0MBiE, <i><a href="http://z0mbie.cjb.net">z0mbie.cjb.net</a></i></p>
 
<a href="http://topdev.tsx.org"> Статья для журнала Top Device</a>     
                                 </td>
            </tr>
            <tr>
                <td width="100%" bgcolor="#000000"><img
                src="-.gif" width="1" height="1"></td>
            </tr>
            <tr>
                <td width="100%"><img src="-.gif" width="1"
                height="1"></td>
            </tr>
            <tr>
                <td width="100%" bgcolor="#000000"><img
                src="-.gif" width="1" height="1"></td>
            </tr>
            <tr>
                <td>&nbsp;</td>
            </tr>
        </table>
        </center></div></td>
        <td>&nbsp;</td>
    </tr>
</table>

<p>&nbsp;</p>
</body>
</html>
