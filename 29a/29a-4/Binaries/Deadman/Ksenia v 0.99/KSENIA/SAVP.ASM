                        model   tiny
                        codeseg
                        org     100h
                        .386

 start:                 mov     ax,18ddh
                        int     21h
                        cmp     ax,0303h
                        jne     no_in_mem

                        mov     ah,9
                        lea     dx,vir_found
                        int     21h
                        int     20h

 no_in_mem:             mov     ax,3
                        int     10h
                        mov     ah,1
                        mov     ch,100000b
                        int     10h

                        push    ds 0
                        pop     ds
                        mov     word ptr ds:[24h*4],offset int24
                        mov     word ptr ds:[24h*4+2],cs
                        pop     ds
                        lea     dx,copyright
                        call    screen
                        mov     ah,3
                        mov     bh,0
                        int     10h
                        mov     cur_pos,dx

                        mov     si,81h
 up_reg_comline:        lodsb
                        cmp     al,61h
                        jb      ok_reg
                        cmp     al,7ah
                        ja      ok_reg
                        sub     al,20h
 ok_reg:                mov     byte ptr [si-1],al
                        cmp     al,0dh
                        jne     up_reg_comline

                        mov     si,81h
 ignore_space:          lodsb
                        cmp     al,0dh
                        je      help
                        cmp     al,20h
                        je      ignore_space
                        dec     si
                        mov     dx,si
                        mov     al,0dh
                        mov     di,81h
                        mov     cx,0ffffh
                        repne   scasb
                        dec     di
                        mov     byte ptr [di],0

 get_separ:             dec     di
                        cmp     byte ptr [di],'\'
                        je      set_dots
                        cmp     byte ptr [di],':'
                        je      set_dots
                        cmp     byte ptr [di],20h
                        je      get_separ
                        jmp     aaaa

 set_dots:              mov     word ptr [di+1],'.*'
                        mov     word ptr [di+3],'*'

 aaaa:                  call    collect
                        jc      report
                        push    dx
                        mov     dx,cur_pos
                        mov     ah,2
                        mov     bh,0
                        int     10h
                        pop     dx
                        dec     dx
                        call    screen
                        inc     dx
                        push    dx
                        mov     ah,3
                        mov     bh,0
                        int     10h
                        push    dx
                        lea     dx,spaces
                        call    screen
                        pop     dx
                        mov     ah,2
                        int     10h
                        pop     dx
                        call    test_infected
                        jnc     no_inf
                        call    screen
                        cmp     dx,offset virused
                        jne     no_increment
                        inc     virused_cnt
 no_increment:          mov     ah,3
                        mov     bh,0
                        int     10h
                        cmp     dh,20
                        jb      ok_pos
                        mov     ax,3
                        int     10h
                        mov     ah,1
                        mov     ch,100000b
                        int     10h
                        xor     dx,dx
 ok_pos:                mov     cur_pos,dx
 no_inf:                jmp     aaaa

 report:                push    dx
                        mov     dx,cur_pos
                        mov     bh,0
                        mov     ah,2
                        int     10h
                        lea     dx,spaces
                        call    screen
                        mov     ah,2
                        mov     bh,0
                        mov     dx,cur_pos
                        int     10h
                        pop     dx
                        movzx   eax,dx
                        lea     di,file_number
                        stc
                        call    count
                        mov     eax,virused_cnt
                        lea     di,vir_asciz
                        call    count
                        lea     dx,log
                        call    screen

                        jmp     terminate

 help:                  lea     dx,error_com_line
                        call    screen
 terminate:             mov     ax,4c00h
                        int     21h

 test_infected:         mov     ax,3d00h
                        int     21h
                        lea     dx,rerr
                        jc      quit_all
                        xchg    ax,bx
                        mov     ax,4202h
                        mov     cx,-1
                        mov     dx,-2
                        int     21h
                        mov     ah,3fh
                        mov     cx,2
                        lea     dx,two_bytes
                        int     21h
                        push    ax
                        mov     ah,3eh
                        int     21h
                        pop     ax
                        cmp     ax,2
                        clc
                        jne     quit_all
                        cmp     word ptr two_bytes,0c39dh
                        stc
                        lea     dx,virused
                        je      quit_all
                        clc
 quit_all:              ret

 two_bytes              dw      ?
                        include count.inc
                        include screen.inc
 ; --- cut here ---
; подпрограмма "collect" для нахождения файлов по заданной маске
; copyright (c) 1998-99 Deadman
; на входе: cs:dx - маска
; на выходе cs:dx - найденный файл в формате ASCIZ+'$'
; если файлов больше нет, то cf=1 и dx = количество найденных до файлов
; при повторном вызове работает как "find next"
; при отсутствии файлов (cf=1) процедура сбрасывается в режим "find first"
; портит регистры: flags, dx
; замечание: подпрограмма должна быть расположена последней, т.к. ей
; требуется место для хранения DTA вложенных подкаталогов
 collect:
          push    ax bx cx si di bp ds es  ; сохранить регистры \dx

          mov     ah,2fh                   ; получить в es:bx адрес
          int     21h                      ; текущего dta
          push    es bx                    ; сохранить его в стеке

          push    cs cs         ; установить сегментные регистры
          pop     es ds         ; ds и es на сегмент кода

          cmp     fron,0        ; первый вызов (find first)?
          jne     find_next

          mov     in_dx,dx      ; сохранить смещение маски поиска
          mov     file_cnt,0    ; total files found: 0

          mov     si,dx              ; засунуть в di адрес маски
          dec     si
 col_get_eol:                        ; ищем зиро в маске
          inc     si
          cmp     byte ptr [si],0
          jne     col_get_eol        ; нашли?

          std                   ; ищем начало голой маски (например, *.COM)
 get_mask:
          lodsb                 ; считать в al символ
          cmp     al,':'        ; разделитель? (c:...)
          je      have_got
          cmp     al,'\'        ; \...?
          je      have_got
          cmp     si,dx         ; если указана голая маска, т.е. без ":" и "\"
          jae     get_mask      ; то взять за начало оной смещение из dx
          dec     si
 have_got:
          inc     si            ; выравнивание на начало (ебаный std :-)
          inc     si
          mov     msk_pnt,si    ; сохранить смещение
          mov     cx,si         ; вычислить количество байт от начала строки
          sub     cx,dx         ; до начала маски (т.е. путь)

          lea     di,result     ; перекачать путь из юзеровского буфера в
          mov     si,dx         ; буфер результатов
          cld
          repz    movsb
          mov     res_post,di   ; сохранить смещение конца ;-) пути
 find_first:
          mov     ah,4eh        ; ищем первый файл
          jmp     $+4           ; чтоб не испахабили ah

 find_next:
          mov     ah,4fh        ; а тут ищем next
          push    ax dx         ; устанавливаем dta по адресу, указанному
          mov     ah,1ah        ; в переменной "dta_pnt"
          mov     dx,dta_pnt
          int     21h
          pop     dx ax
          mov     cx,0ffefh and (not 1000b) ; ищем все ?*:%;( кроме каталогов
          int     21h
          jc      check_dir     ; нету больше файлов -> перейти в другую
                                ; 'папку'

          mov     si,dta_pnt    ; тута качаем имя и фамилию найденного файла
          add     si,1eh        ; по адресу "res_post"

          push    si
          lodsb
          cmp     al,'.'
          jne     $-3
          lodsd
          pop   si
          cmp     eax,'SYS'
          je      good
          cmp     eax,'MOC'
          je      good
          cmp     eax,'EXE'
          jne     find_next
 good:

          mov     di,res_post
          lodsb
          stosb
          or      al,al
          jnz     $-4
          mov     al,'$'        ; состосить '$' в конце ASCIZ строки для
          stosb                 ; ее использования 9-й функцией dos
          jmp     yes_more      ; показать файл

 check_dir:
          mov     ah,4eh                ; ищем папки
          mov     si,res_post
          mov     word ptr [si],'.*'    ; (dir)\(*.*),0
          mov     word ptr [si+2],'*'
          lea     dx,result
          mov     cx,0ffffh             ; это для того, чтобы всякие hidden'ы
 check_again:                           ; не ускользнули от моего глаза
          int     21h
          jc      cd_dotdot             ; тута ниче нету -> делаем псевдо-CD
          mov     si,dta_pnt            ; иначе тестим юнит, есть ли он
          mov     ah,4fh                ; нормальная папка, или он
          cmp     byte ptr [si+1eh],'.' ; файл или (.)(..), т.е. фильтруем
          je      check_again
          test    byte ptr [si+15h],10000b
          jz      check_again

          mov     si,dta_pnt            ; нашли папку -> перекачать
          add     si,1eh                ; название в 'result'
          mov     di,res_post

          lodsb
          stosb
          or      al,al
          jnz     $-4
          mov     byte ptr [di-1],'\'   ; конец пути
          mov     ax,di
          xchg    res_post,ax
          mov     si,dta_pnt            ; сохранить указатель на конец пути
          mov     [si+43],ax            ; предыдущего уровня

          mov     si,msk_pnt     ; перекачать маску для поиска в ЭТОЙ папке
          lodsb
          stosb
          or      al,al
          jnz     $-4

          lea     dx,result      ; ищем следующие файлы, затем каталоги
          add     dta_pnt,45
          inc     dir_cnt
          jmp     find_first

 cd_dotdot:                      ; тут надо сделать псевдо CD .. для поиска
          dec     dir_cnt        ; оставшихся файлов и папок в предыдущей
          jz      no_more        ; папке
          sub     dta_pnt,45
          mov     si,dta_pnt
          mov     dx,si
          mov     ah,1ah
          int     21h
          mov     di,[si+43]
          mov     res_post,di
          mov     ah,4fh
          jmp     check_again

 yes_more:                                  ; выводим найденный файл
          inc     dword ptr file_cnt        ; количество найденных файлов
          clc
          mov     fron,1                    ; следующий вызов - find next
          lea     dx,result

 exit:    mov     bp,dx
          pop     dx ds
          pushf
          mov     ah,1ah
          int     21h
          popf
          mov     dx,bp

          pop     es ds bp di si cx bx ax
          ret

 no_more: mov     fron,0                        ; сбрасываем переменные
          mov     dta_pnt,offset dtaz
          mov     dir_cnt,1
          mov     dx,file_cnt                   ; было найдено dx файлов
          stc
          jmp     exit

 fron     db      0
 file_cnt dw      0
 dir_cnt  dw      1
 dta_pnt  dw      dtaz
 msk_pnt  dw      ?
 res_post dw      ?
 in_dx    dw      ?
          db      0ah
 result   db      100h dup (?)

; --- cut here ---


 int24:                 mov     al,3
                        iret

 vir_found              db      'Virus in memory, can''t work',0dh,0ah,24h
 copyright              db      0ah,'Speed Anti-Virus Program Copyright (C) 1998-99 Deadman',0dh,0ah,0dh,0ah,24h
 error_com_line         db      0ch,'Error in command line! Usage: SAVP <path>',0dh,0ah,24h
 log                    db      0ah,0dh,0ah,'Total files tested: '
 file_number            db      15 dup (' '),0dh,0ah
                        db      'Virused: '
 vir_asciz              db      15 dup (' '),0dh,0ah,24h
 crlf                   db      0ah,0dh,24h
 spaces                 db      0ch,100h dup (' '),24h
 virused                db      0ch,'- Virused!',0dh,0ah,24h
 rerr                   db      0ah,'- Read error!',0dh,0ah,24h
 virused_cnt            dd      0
 cur_pos                dw      ?
 dtaz:                  end     start